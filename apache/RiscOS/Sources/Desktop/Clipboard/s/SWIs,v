head	1.8;
access;
symbols
	Clipboard-0_10:1.8
	Clipboard-0_09:1.8
	Clipboard-0_08:1.7
	Clipboard-0_07:1.6
	Clipboard-0_06:1.6
	Clipboard-0_05:1.5
	Clipboard-0_04:1.4
	Clipboard-0_03:1.3
	Clipboard-0_02:1.2
	Clipboard-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2008.09.16.18.36.55;	author rool;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.13.01.41.06;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	99.02.25.10.57.30;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	99.02.22.11.58.02;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	99.02.19.11.22.07;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	99.02.12.20.01.57;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	98.11.10.18.02.09;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	98.11.10.17.28.24;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.10.17.28.24;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.8
log
@  Completed the clipboard support part of the Clipboard module.
  Drag-and-Drop support still needs to be designed and implemented.
Detail:
  The initial Clipboard module released by ROOL was in a state of flux due
  to a redesign of how the module worked. The transition to the new way
  of doing things was only done partially and needed completing to make the
  Clipboard module support the clipboard fully. The module also contained
  26-bit only code.

  - Replaced all the 26-bit code with 32-bit (not mode neutral) code.

  - Completed implementation of Clipboard_GetDataType by adding support for
    the situation where the Clipboard module doesn't own the clipboard and
    isn't proxying either. The required StateHandler_DataRequest2 has been
    implemented also.

  - Fully implemented Clipboard_Get including all the required statehandlers.
      StateHandler_DataSaveAck
      StateHandler_RAMFetch1
      StateHandler_RAMFetch2
      StateHandler_DataRequest1
      StateHandler_DataRequest2
      StateHandler_PutRequest3
      StateHandler_Paste

  - Modified CopyData routine to allow for clipboard content not being
    word-aligned and/or its length not being a multiple of four.

  - Removed all the commented out code that was left over from the initial
    implementation of the Clipboard module.

  - Added GetData to the set of test applications. It displays the clipboard
    contents if it's of type text (It's best to use short text strings). It's
    not very polished and it's better to use PutClip and GetClip to test the
    Clipboard module.

  - Added PutClip to the set of test applications. It can be used test
    SWI Clipboard_Put. Details on how can be found in its Help file.

  - Added GetClip to the set of test applications. It can be used test
    SWI Clipboard_Get. Details on how can be found in its Help file.
Admin:
  Extensively tested on Iyonix RO 5.11 both external behaviour with PutClip
  and GetClip as well as the internal behaviour of the statehandler (by using
  StrongED as the clipboard owner/requester and rigging it to fail at certain
  points during the datatransfer).

  Briefly tested on RO 4.02, seems to be OK.

  Briefly tested on RO 6.06, seems to be OK. Functionality may be different
  from 5.11 and 4.02 though due to ClipboardHolder. In particular using the
  Clipboard module as a proxy is likely to be affected.

Version 0.09. Tagged as 'Clipboard-0_09'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
;  s.SWIs - SWI handlers
;


SWIHandler ROUT
        Push    "R14"
        LDR     R12, [R12]
        LDR     R14, mytaskhandle
        CMP     R14, #0
        BLE     ClipboardNotActive
        Push    "R0, R1"
        MOV     R0, #WimpSysInfo_CurrentTask
        SWI     XWimp_ReadSysInfo
        CMP     R0, #0
        Pull    "R0, R1"
        BEQ     TaskNotActive
        CMP     R11, #(EndOfJumpTable - JumpTable)/4
        ADDLO   PC, PC, R11, LSL #2
        B       UnknownSWIError
JumpTable
        B       SWIClipboard_Put
        B       SWIClipboard_Get
        B       SWIClipboard_GetDataType
      [ DragNDrop
        B       SWIClipboard_StartDrag
        B       SWIClipboard_CatchDrop
      ]
EndOfJumpTable

UnknownSWIError
        Push    "R1-R4"
        ADR     R0, ErrorBlock_BadSWI
        MOV     R1, #0
01      ADR     R2, PollBlock
        MOV     R3, #?PollBlock
        addr    R4, Title
        SWI     XMessageTrans_ErrorLookup       ; set up error block (sets V!)
        Pull    "R1-R4, LR"                     ; get our registers back
        TEQ     PC,PC                           ; are we in 32-bit mode?
        MOVEQ   PC,LR                           ; if so, don't restore flags
        ORRNES  PC,LR,#V_bit                    ; if not, restore flags, set V

ClipboardNotActive
        Push    "R1-R4"
        ADR     R0, ErrorBlock_NotActive
        ADR     R1, MessagesBlock
        B       %BT01

TaskNotActive
        Push    "R1-R4"
        ADR     R0, ErrorBlock_NoTask
        ADR     R1, MessagesBlock
        B       %BT01

        MakeErrorBlock BadSWI
        MakeErrorBlock NotActive
        MakeErrorBlock NoTask

;-----------------------------------------------------------------
; Clipboard_Put - put data on clipboard
;
; On entry: R0 = flags
;                  bit 0 => clear clipboard
;                  bit 1 => data is translatable, so needs a PutRequest
;                  bit 2 => data type *list* is provided
;                  bit 31 => Wimp flag
;           R1 = data type, or data type list pointer
;           R2 -> data
;           R3 = data length
;           R4 -> proposed leafname
;           R5 = my_ref of Message_PutRequest, or 0 if this isn't a reply
;-----------------------------------------------------------------
SWIClipboard_Put ROUT
        Push    "R0-R9"
        TEQ     R5, #0
        BEQ     %FT01

        Debug   tmp, "response to Message_Put"

        ; SWI is part of a data transfer transaction
        MOV     R11, R5
        BL      GetActionHandle
        CMP     R11, #0         ; did we find it?
        BEQ     %FT99
        ; Acknowledge our message on behalf of the caller
        Push    "R0-R2"
        ADR     R1, PollBlock
        MOV     R0, #ms_data
        STR     R0, [R1, #ms_size]
        STR     R5, [R1, #ms_yourref]
        MOV     R0, #User_Message_Acknowledge
        LDR     R2, mytaskhandle
        SWI     XWimp_SendMessage
        Pull    "R0-R2"
        ; Jump into the transaction state handler
        MOV     R5, #-1
        BL      StateHandler
        B       %FT99

01      TST     R0, #ClipboardPut_Clear
        BLNE    FreeClipboard   ; preserves flags
        BNE     %FT99

        ; SWI is to claim the clipboard
        ; We have to be careful here so that we don't trash
        ; the existing clipboard if an error is generated!

        ; If they've been a wally and specified a list but can't translate
        ; the data, just work from the first data type in the list instead
        AND     R14, R0, #ClipboardPut_SendPutRequest :OR: ClipboardPut_DataTypeList
        TEQ     R14, #ClipboardPut_DataTypeList
        LDREQ   R1, [R1]
        BICEQ   R0, R0, #ClipboardPut_SendPutRequest :OR: ClipboardPut_DataTypeList

        ; Hold pointer arguments on the stack while we validate and relocate them
        MOV     R14, #0
        Push    "R14"           ; leafname
        Push    "R14"           ; data
        Push    "R14"           ; data type list

        MOV     R5, R0          ; we need R0 for parameter passing

        ; Copy the leafname
        MOV     R0, R4
        BL      CopyLeaf
        BVS     %FT90
        STR     R0, [SP, #4*2]

        Debug   tmp,"Leaf copied"

        ; Copy the data
        TST     R5, #ClipboardPut_SendPutRequest
        MOVNE   R0, #0
        MOVEQ   R0, R2
        BLEQ    CopyData
        BVS     %FT90
        STR     R0, [SP, #4*1]

        Debug   tmp,"Data copied"

        ; Deal with type list last (so the stack copy is 0 if an error occurs above)
        MOV     R0, R1
        TST     R5, #ClipboardPut_DataTypeList
        BLNE    CopyTypes
        BVS     %FT90
        STR     R0, [SP, #4*0]

        Debug   tmp,"File type",r0

        ; If claiming the clipboard from someone else, broadcast Message_ClaimEntity
        LDR     R0, ClipboardTask
        TEQ     R0, #0
        BNE     %FT11
        Push    "R0-R4"
        MOV     R0, #User_Message
        ADR     R1, PollBlock
        MOV     R2, #0                 	; broadcast
        MOV     R4, #0                  ; don't return my_ref
        MOV     R14, #msClaimEntity_size
        STR     R14, [R1, #ms_size]
        MOV     R14, #0
        STR     R14, [R1, #ms_yourref]
        MOV     R14, #Message_ClaimEntity
        STR     R14, [R1, #ms_action]
        MOV     R14, #msClaimEntity_ClaimClipboard
        STR     R14, [R1, #msClaimEntity_flags]
        BL      MySendMessage
        Pull    "R0-R4"
11
        ; Free the old clipboard
        BL      FreeClipboard

        ; Update clipboard information
        MOV     R0, R5                  ; get flags back into R0
        Pull    "R1, R2, R4"            ; these are now the RMA pointers
        ADR     R14, ClipboardFlags
        STMIA   R14, {R0-R4}
        MOV     R0, #WimpSysInfo_CurrentTask
        SWI     XWimp_ReadSysInfo
        STR     R0, ClipboardTask

        B       %FT99


90      ; An error has occurred
        ; R0 -> error block
        ; stack holds pointers to RMA blocks that need freeing
        MOV     R11, R0
        MOV     R0, #ModHandReason_Free
        Pull    "R2"
        TEQ     R2, #0
        SWINE   XOS_Module
        MOV     R0, #ModHandReason_Free
        Pull    "R2"
        TEQ     R2, #0
        SWINE   XOS_Module
        MOV     R0, #ModHandReason_Free
        Pull    "R2"
        TEQ     R2, #0
        SWINE   XOS_Module
        MOV     R0, R11
        SETV
        ; drop through...

99      ; Exit SWI Clipboard_Put
        STRVS   R0, [SP, #4*0]          ; if error, overwrite stacked r0
        Pull    "R0-R9, LR"             ; get our registers back
        TEQ     PC,PC                   ; are we in 32-bit mode?
        MOVEQ   PC,LR                   ; if so, exit without restoring flags
        MOVVCS  PC,LR                   ; if not and V clear, restore flags
        ORRVSS  PC,LR,#V_bit            ; if not and V set, restore flags, set V


;-----------------------------------------------------------------
; Clipboard_Get - get the clipboard's content
;
; On entry: R0 = flags
;                  bit 31 => Wimp flag
;           R1 = destination window handle
;           R2 = destination icon handle
;           R3 = destination x coordinate
;           R4 = destination y coordinate
;           R5 -> list of acceptable data types, terminated by -1
;-----------------------------------------------------------------
SWIClipboard_Get ROUT
        Push    "R0-R5"

        LDR     R14, ClipboardTask
        TEQ     R14, #0
        BEQ     %FT10
        LDR     R14, ClipboardFlags
        TST     R14, #ClipboardPut_SendPutRequest
        BNE     %FT10

        ; We're managing the clipboard - reply immediately.
        LDR     R5, ClipboardType
        MOV     R6, #-1
        BL      SendMsg_Paste
        B       %FT99

10      ; Gather information from SWI parameters.
        BL      NewAction
        BVS     %FT99
        ADD     R14, R11, #Act_Flags
        STMIA   R14, {R0-R4}
        MOV     R0, R5
        BL      CopyTypes
        BVS     %FT90
        STR     R0, [R11, #Act_List]

        ; Branch according to clipboard state
        LDR     R0, ClipboardTask
        ADR     R14, %FT90              ; set up return address
        TEQ     R0, #0

        ; We're proxying for the clipboard owner - enter State_PutRequest3.
        MOVNE   R0, #State_PutRequest3
        STRNE   R0, [R11, #Act_State]
        BNE     SendMsg_PutRequest      ; NB returns to R14 set up above

        ; We know nothing about the clipboard - enter State_DataRequest1.
        MOVEQ   R0, #State_DataRequest1
        STREQ   R0, [R11, #Act_State]
        BEQ     SendMsg_DataRequest     ; NB returns to R14 set up above

90      ; If an error has occurred delete action block
        ; R11 -> action block
        BLVS    DeleteAction            ; preserves flags
        ; drop through...

99      ; Exit SWI Clipboard_Get
        STRVS   R0, [SP, #4*0]          ; if error, overwrite stacked r0
        Pull    "R0-R5, LR"             ; get our registers back
        TEQ     PC,PC                   ; are we in 32-bit mode?
        MOVEQ   PC,LR                   ; if so, exit without restoring flags
        MOVVCS  PC,LR                   ; if not and V clear, restore flags
        ORRVSS  PC,LR,#V_bit            ; if not and V set, restore flags, set V


;-----------------------------------------------------------------
; Clipboard_GetDataType - get the clipboard's data type
;
; On entry: R0 = flags
;                  bit 31 => Wimp flag
;           R1 = destination window handle
;           R2 = destination icon handle
;           R3 = destination x coordinate
;           R4 = destination y coordinate
;           R5 -> list of acceptable data types, terminated by -1
;-----------------------------------------------------------------
SWIClipboard_GetDataType ROUT
        Push    "R0-R5"

        LDR     R14, ClipboardTask
        TEQ     R14, #0
        BEQ     %FT10
        LDR     R14, ClipboardFlags
        TST     R14, #ClipboardPut_SendPutRequest
        BNE     %FT10

        ; We're managing the clipboard - reply immediately.
        LDR     R5, ClipboardType
        BL      SendMsg_DataTypeIs
        B       %FT99

10      ; Gather information from SWI parameters.
        BL      NewAction
        BVS     %FT99
        ADD     R14, R11, #Act_Flags
        STMIA   R14, {R0-R4}
        MOV     R0, R5
        BL      CopyTypes
        BVS     %FT90
        STR     R0, [R11, #Act_List]

        ; Branch according to clipboard state
        LDR     R0, ClipboardTask
        ADR     R14, %FT90              ; set up return address
        TEQ     R0, #0

        ; We're proxying for the clipboard owner - enter State_PutRequest2.
        MOVNE   R0, #State_PutRequest2
        STRNE   R0, [R11, #Act_State]
        BNE     SendMsg_PutRequest      ; NB returns to R14 set up above

        ; We know nothing about the clipboard - enter State_DataRequest2.
        MOVEQ   R0, #State_DataRequest2
        STREQ   R0, [R11, #Act_State]
        BEQ     SendMsg_DataRequest     ; NB returns to R14 set up above

90      ; If an error has occurred delete action block
        ; R11 -> action block
        BLVS    DeleteAction            ; preserves flags
        ; drop through...

99      ; Exit SWI Clipboard_GetDataType
        STRVS   R0, [SP, #4*0]          ; if error, overwrite stacked r0
        Pull    "R0-R5, LR"             ; get our registers back
        TEQ     PC,PC                   ; are we in 32-bit mode?
        MOVEQ   PC,LR                   ; if so, exit without restoring flags
        MOVVCS  PC,LR                   ; if not and V clear, restore flags
        ORRVSS  PC,LR,#V_bit            ; if not and V set, restore flags, set V

        END
@


1.7
log
@Fixed Clipboard to build and made it 32bit.
Detail:
  Clipboard has never been 32bitted, therefore it refused to build for
  Tungsten. It's now been fixed to build. It's still not finished though.
Admin:
  Tested on RiscPC RO402. Module checked with ARMalyser.
Notes:
  Changes by James Lampard.

Version 0.08. Tagged as 'Clipboard-0_08'
@
text
@d52 5
a56 3
        SWI     XMessageTrans_ErrorLookup  ;always set V for us!
        Pull    "R1-R4, PC"
        ;ORRS    PC, R14, #V_bit
d93 2
d144 2
d154 2
d163 2
d221 6
a226 6
        STRVS   R0, [SP, #4*0]
        Pull    "R0-R9, PC"
        ;Pull    "R0-R9, PC", VC, ^
        ;ADD     SP, SP, #4*1
        ;Pull    "R1-R9, R14"
        ;ORRS    PC, R14, #V_bit
d230 1
a230 1
; Clipboard_Get - get data from clipboard
d233 6
a238 16
;             bits 0-2: notify type:
;                        0 => send message Message_ClipboardFetched
;                        1 => call a callback routine
;                             (may corrupt R0-R3, R14; preserve rest)
;                             R0=pointer to data, R1=data len, R2=data type
;                             User mode, R13->512 bytes+ of stack
;                        2-7 reserved
;                  3-30: reserved
;                  31: end operation and dispose data
;           R1 -> list of filetypes (terminated by -1), needn't be static
;           R2, R3 depends on notify type
;             0 => R2=reference
;             1 => R2=routine to call, R3=value to pass in R12
; On exit: R0, R1 preserved
;          R2, R3 depend on notify type
;             0 => R2, R3 preserved
d241 52
a292 46
;        ; Check for "end operation" first
;        TST     R0, #1:SHL:31
;        Pull    "R14", NE
;        BNE     FreeGetBuffer
;
        Push    "R0-R3"
;        ; Type must be zero at the moment
;        AND     R0, R0, #7
;        CMP     R0, #1
;        Pull    "R0-R3, PC", HI
;        BLO     %FT02
;        ; Get current task handle into R3 for notify type 0
;        Push    "R0, R1"
;        MOV     R0, #5
;        SWI     XWimp_ReadSysInfo
;        ADDVS   SP, SP, #3*4
;        Pull    "R1-R3, PC", VS
;        MOV     R3, R0
;        Pull    "R0, R1"
;        ; Note parameters
;02      ADR     R14, GetData
;        STMIA   R14, {R0, R2, R3}
;        ; Clear GetBuffer
;        LDR     R0, GetBufferAddr
;        TEQ     R0, #0
;        BLNE    FreeMem
;        ; Do _we_ have the clipboard?
;        LDR     R14, ClipboardAddr
;        TEQ     R14, #0
;        ; We have the clipboard - it's a piece of cake...
;        MOVNE   R0, #Event_SendClipboard
;        MOVNE   R1, #0
;        BNE     %FT30
;        ; We don't, so we need to get the foreground task to request it
;        ; Find how many filetypes
;        MOV     R2, R1
;        MOV     R1, #0
;05      LDR     R14, [R2, R1]
;        ADD     R1, R1, #4
;        CMP     R14, #-1
;        BNE     %BT05
;        ; Queue the event (R1=data length, R2->data (ie type list))
;        MOV     R0, #Event_FetchClipboard
;30      BL      QueueEvent
;        STRVS   R0, [SP, #CallerR0]
        Pull    "R0-R3, PC"
d308 1
d317 2
a318 17
        ADR     R14, PollBlock + msDataTypeIs_flags
        AND     R0, R0, #ClipboardGetDataType_Wimp
        STMIA   R14, {R0-R4}
        ADR     R1, PollBlock
        MOV     R0, #msDataTypeIs_size
        STR     R0, [R1, #ms_size]
        MOV     R0, #0
        STR     R0, [R1, #ms_yourref]
        LDR     R0, =Message_DataTypeIs
        STR     R0, [R1, #ms_action]
        LDR     R0, ClipboardType
        STR     R0, [R1, #msDataTypeIs_datatype]
        MOV     R0, #User_Message
        LDR     R2, [R1, #msDataTypeIs_window]
        LDR     R3, [R1, #msDataTypeIs_icon]
        MOV     R4, #0
        BL      MySendMessage
d329 1
a329 1
        STR     R0, [R11, #Act_Type]
d332 3
a334 3
        LDR     R14, ClipboardTask
        TEQ     R14, #0
        BEQ     %FT30
d336 9
a344 3
20      ; We're proxying for the clipboard owner - enter State_PutRequest2.
        MOV     R0, #State_PutRequest2
        STR     R0, [R11, #Act_State]
d346 1
a346 28
        ADR     R1, PollBlock
        MOV     R0, #msPutRequest_size
        STR     R0, [R1, #ms_size]
        MOV     R0, #0
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #Message_PutRequest
        STR     R0, [R1, #ms_action]
        LDR     R0, ClipboardFlags
        AND     R0, R0, #ClipboardPut_Wimp
        ORR     R0, R0, #msPutRequest_SendClipboard
        STR     R0, [R1, #msPutRequest_flags]
        ADD     R0, R11, #Act_Window
        LDMIA   R0, {R2-R5}
        ADD     R0, R1, #msPutRequest_window
        STMIA   R0, {R2-R5}
        LDR     R0, [R11, #Act_Type]
        STR     R0, [R1, #msPutRequest_datatypes]
        MOV     R0, #User_Message_Recorded
        LDR     R2, ClipboardTask
        ADD     R4, R11, #Act_MyRef
        BL      MySendMessage
        BVS     %FT90
        B       %FT99

30      ; We know nothing about the clipboard - enter State_DataRequest2.
        B       %FT99

90      ; An error has occurred
d348 1
a348 1
        BL      DeleteAction            ; preserves flags
d352 6
a357 7
        STRVS   R0, [SP, #4*0]
        Pull    "R0-R5, PC"
        ;Pull    "R0-R5, PC", VC, ^
        ;ADD     SP, SP, #4*1
        ;Pull    "R1-R5, R14"
        ;ORRS    PC, R14, #V_bit

@


1.6
log
@* Standardised all error blocks to use AddError/MakeErrorBlock macros
* Routines added for making "safe" copies of data blocks, data type lists
  and leafnames passed in via the various mechanisms
* SWI Clipboard_Put and Message_DataRequest handler implemented, and the
  supporting state handlers
    State_PutRequest1
    State_DataSave
    State_RAMTransmit
    State_DataLoad
* SWI Clipboard_GetDataType implemented, and the supporting handler
    State_PutRequest2
    (but not State_DataRequest2 yet)
* Now requires that the caller is an active task
* Fixed occasional data abort bug in MySendMessage
* Fixed corruption of wimp event code bug
* Implemented and added test applications

Version 0.06. Tagged as 'Clipboard-0_06'
@
text
@d52 3
a54 3
        SWI     XMessageTrans_ErrorLookup
        Pull    "R1-R4, R14"
        ORRS    PC, R14, #V_bit
d211 6
a216 4
        Pull    "R0-R9, PC", VC, ^
        ADD     SP, SP, #4*1
        Pull    "R1-R9, R14"
        ORRS    PC, R14, #V_bit
d381 6
a386 4
        Pull    "R0-R5, PC", VC, ^
        ADD     SP, SP, #4*1
        Pull    "R1-R5, R14"
        ORRS    PC, R14, #V_bit
@


1.5
log
@* Task-related initialisation moved from module init to Start routine
* State handler added, called from SWI, UserMessage, UserMessageAck handlers
* Implemented NewAction, DeleteAction, DeleteActions, FreeClipboard and
  FreeMsgQueue
* DA memory allocation adapted so as not to use max-size "-1" DAs
* RMA memory allocation functions completed to match DA functions - will now
  assemble with DA support option turned off!

Version 0.05. Tagged as 'Clipboard-0_05'
@
text
@d26 6
d47 1
a47 1
        ADR     R0, BadSWI
d57 8
a64 1
        ADR     R0, NotActiveErr
d68 3
a70 9
BadSWI
        &       &1E6
        =       "BadSWI", 0
        ALIGN

NotActiveErr
        &       0
        =       "NotActive", 0
        ALIGN
d76 9
a84 3
;           R1 -> data
;           R2 = data length
;           R3 = data type (bits 0-11), bits 12-31 mbz
d87 129
a215 43
        Push    "R0-R3, R5, R11"
  TEQ   R5, #0
  BEQ   %FT01
  BL    GetActionHandle
  TEQ   R11, #0  ; did we find it?
  Pull  "R0-R3, R5, R11, PC", EQ
  MOV   R5, #-1
  BL    StateHandler
  Pull  "R0-R3, R5, R11, PC"
01
;        MOV     R3, R3, LSL #32-12
;        MOV     R3, R3, LSR #32-12
;
;        MOV     R0, R1
;        ADD     R1, R0, R2
;        SWI     XOS_ValidateAddress
;        BCS     BadRead
;
;        LDR     R0, ClipboardAddr
;        TEQ     R0, #0
;        BLNE    FreeMem
;
;        MOV     R0, R2
;        MOV     R1, R2
;        BL      AllocMem
;        ADDVS   SP, SP, #4
;        Pull    "R1-R3, PC", VS
;
;        STR     R2, ClipboardLen
;        STR     R3, ClipboardType
;        LDR     R3, ClipboardAddr
;        STR     R0, ClipboardAddr
;
;        LDR     R1, [SP, #CallerR1]
;        BL      MemCopy
;
;        TEQ     R3, #0
;        MOVEQ   R0, #Event_ClaimClipboard
;        MOVEQ   R1, #0
;        BLEQ    QueueEvent
;        STRVS   R0, [SP, #CallerR0]
;
        Pull    "R0-R3, R5, R11, PC"
a216 17
;BadRead
;        ADR     R0, ErrorBlock_BadRead
;        MOV     R1, #0
;        ADR     R2, PollBlock
;        MOV     R3, #?PollBlock
;        Push    "R4"
;        addr    R4, Title
;        SWI     XMessageTrans_ErrorLookup
;        STRVS   R0, [SP, #4]
;        Pull    "R4"
;        Pull    "R0-R3, PC"
;
;ErrorBlock_BadRead
;        &       &410
;        =       "BadRead"
;        ALIGN
;
a286 1

d288 1
a288 1
; Clipboard_GetDataType
d290 7
a296 1
; No parameters
d298 85
a382 3
SWIClipboard_GetDataType
;        BL      FreeClipboard
        Pull    "PC"
@


1.4
log
@* Updated API to match that from the spec 1309,419/FS
* Added symbols for all flag bits in SWIs and messages
* Major reorganisation of workspace layout, primarily to facilitate multiple
  concurrent data transfer transactions - because of this, most of the
  useful functionality is currently commented out, pending updating to use
  the new structures
* Replaced "event" queue with a simple queue of ready-to-send Wimp message
  blocks - this way, event handling can be handled in the same place in the
  code, irrespective of whether we're in the foreground or background
* Reorganised finalisation code so that task and module operations are
  performed in separate routines and (mostly) in strictly the reverse order
  to at initialisation. This allows code sharing between module finalisation,
  the exit handler, the UpCall_NewApplication handler, and the task quit
  code, as well as eradicating several memory leaks in the process

Version 0.04. Tagged as 'Clipboard-0_04'
@
text
@d15 5
d30 3
a32 3
        B       SWI_Put
        B       SWI_Get
        B       SWI_GetDataType
d34 2
a35 2
        B       SWI_StartDrag
        B       SWI_CatchDrop
d73 11
a83 2
SWI_Put ROUT
        Push    "R0-R3"
d116 1
a116 18
        Pull    "R0-R3, PC"

BadRead
        ADR     R0, ErrorBlock_BadRead
        MOV     R1, #0
        ADR     R2, PollBlock
        MOV     R3, #?PollBlock
        Push    "R4"
        addr    R4, Title
        SWI     XMessageTrans_ErrorLookup
        STRVS   R0, [SP, #4]
        Pull    "R4"
        Pull    "R0-R3, PC"

ErrorBlock_BadRead
        &       &410
        =       "BadRead"
        ALIGN
d118 17
d156 1
a156 1
SWI_Get ROUT
d211 1
a211 1
SWI_GetDataType
a214 147

;;-------------------------------------------------------------------
;; QueueEvent - stick an event onto the background->foreground queue
;;      R0 = event type
;;      R1 = data length
;;      R2 -> event data
;; On exit:
;;      VS if error occured (ie no mem)
;;-------------------------------------------------------------------
;QueueEvent ROUT
;        Entry   "R0-R3"
;        MOV     R0, #ModHandReason_Claim
;        ADD     R3, R1, #EventData
;        SWI     XOS_Module
;        STRVS   R0, [SP, #CallerR0]
;        EXIT    VS
;        MOV     R0, #0
;        STR     R0, [R2, #EventNext]
;        LDR     R0, [SP, #CallerR0]
;        STR     R0, [R2, #EventType]
;        ADD     R0, R2, #EventData
;        MOV     R2, R1
;        LDR     R1, [SP, #CallerR2]
;        BL      MemCopy
;        SUB     R0, R0, #EventData
;        ADR     R1, EventQueue
;01      LDR     R14, [R1, #EventNext]
;        TEQ     R14, #0
;        MOVNE   R1, R14
;        BNE     %BT01
;        STR     R0, [R1, #EventNext]
;        EXITS
;
;JunkEvent ROUT
;        Entry   "R1, R2"
;        LDR     R1, [R0, #EventNext]
;        MOV     R2, R0
;        MOV     R0, #ModHandReason_Free
;        SWI     XOS_Module
;        MOV     R0, R1
;        EXITS

        [ UseDynamicAreas
AllocMem
        Entry   "R1-R8"
        MOV     R7, R0
        MOV     R5, R1           ; maximum size in R1
        ADR     R0, MessagesBlock
        ADR     R1, ClipboardText
        MOV     R2, #0
        SWI     XMessageTrans_Lookup
        EXIT    VS
        MOV     R8, R2           ; DA name
        MOV     R0, #0           ; Create area
        MOV     R1, #-1          ; any number will do
        ADD     R2, R7, #4        ; requested size, plus 4 for us
        MOV     R3, #-1          ; any address will do
        MOV     R4, #2_010000000 ; usual flags (cacheable, not draggable etc)
        MOV     R6, #0           ; no handler routine
        MOV     R7, #0           ; yawn (R6=0 => R7=0)
        SWI     XOS_DynamicArea
        STRVC   R1, [R3]
        ADDVC   R0, R3, #4
        EXIT

FreeMem
        Entry   "R0, R1"
        LDR     R1, [R0, #-4]
        MOV     R0, #1
        SWI     XOS_DynamicArea
        STRVS   R0, [SP, #CallerR0]
        EXIT

ExpandMemToR1
        Entry   "R0-R3"
        ; Get current size of area
        LDR     R3, [R0, #-4]
        MOV     R0, R3
        SWI     XOS_ReadDynamicArea
        STRVS   R0, [SP, #CallerR0]
        EXIT    VS
        ; Exit if we are already big enough
        LDR     R14, [SP, #CallerR1]
        ADD     R14, R14, #4              ; our workspace
        SUBS    R1, R14, R1
        EXIT    LE
        MOV     R0, R3
        SWI     XOS_ChangeDynamicArea
        STRVS   R0, [SP, #CallerR0]
        EXIT

ShrinkMemToR1
        Entry   "R0-R3"
        ; Get current size of area
        LDR     R3, [R0, #-4]
        MOV     R0, R3
        SWI     XOS_ReadDynamicArea
        STRVS   R0, [SP, #CallerR0]
        EXIT    VS
        ; Exit if we are already small enough
        LDR     R14, [SP, #CallerR1]
        ADD     R14, R14, #4              ; our workspace
        SUBS    R1, R14, R1
        EXIT    GE
        MOV     R0, R3
        SWI     XOS_ChangeDynamicArea
        STRVS   R0, [SP, #CallerR0]
        EXIT

        |

AllocMem
        Entry   "R2, R3"
        MOV     R3, R0
        MOV     R0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVC   R0, R2
        EXIT

FreeMem
        Entry   "R0, R2"
        MOV     R2, R0
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        STRVS   R0, [SP, #CallerR0]
        EXIT
        ]

FreeClipboard
        Entry   "R0"
        LDR     R0, ClipboardTask
        TEQ     R0, #0
        EXITS   EQ
        BL      FreeMem
        MOV     R0, #0
        STR     R0, ClipboardTask
        EXITS

;FreeGetBuffer
;        Entry   "R0"
;        LDR     R0, GetBufferAddr
;        TEQ     R0, #0
;        EXITS   EQ
;        BL      FreeMem
;        MOV     R0, #0
;        STR     R0, GetBufferAddr
;        EXITS
@


1.3
log
@* Makefile altered to build separate targets for RAM and ROM builds
* Makefile supports LocalRes$Path
* General tidying up of source
* Drag-and-Drop features optioned out (implementation unlikely in first release)
* R0 passed to Wimp_Initialise now a recognised value
* Ursula fast service call table added
* Now launches task when module is RMRun
* Error handler modified to have a Quit button instead of Cancel
* Debug builds append error PC to error message in error handler error box

Version 0.03. Tagged as 'Clipboard-0_03'
@
text
@d27 2
a28 1
        B       SWI_Clear
d30 2
d33 1
a34 1
SWI_StartDrag
d70 32
a101 32
        MOV     R3, R3, LSL #32-12
        MOV     R3, R3, LSR #32-12

        MOV     R0, R1
        ADD     R1, R0, R2
        SWI     XOS_ValidateAddress
        BCS     BadRead

        LDR     R0, ClipboardAddr
        TEQ     R0, #0
        BLNE    FreeMem

        MOV     R0, R2
        MOV     R1, R2
        BL      AllocMem
        ADDVS   SP, SP, #4
        Pull    "R1-R3, PC", VS

        STR     R2, ClipboardLen
        STR     R3, ClipboardType
        LDR     R3, ClipboardAddr
        STR     R0, ClipboardAddr

        LDR     R1, [SP, #CallerR1]
        BL      MemCopy

        TEQ     R3, #0
        MOVEQ   R0, #Event_ClaimClipboard
        MOVEQ   R1, #0
        BLEQ    QueueEvent
        STRVS   R0, [SP, #CallerR0]

d143 5
a147 5
        ; Check for "end operation" first
        TST     R0, #1:SHL:31
        Pull    "R14", NE
        BNE     FreeGetBuffer

d149 39
a187 39
        ; Type must be zero at the moment
        AND     R0, R0, #7
        CMP     R0, #1
        Pull    "R0-R3, PC", HI
        BLO     %FT02
        ; Get current task handle into R3 for notify type 0
        Push    "R0, R1"
        MOV     R0, #5
        SWI     XWimp_ReadSysInfo
        ADDVS   SP, SP, #3*4
        Pull    "R1-R3, PC", VS
        MOV     R3, R0
        Pull    "R0, R1"
        ; Note parameters
02      ADR     R14, GetData
        STMIA   R14, {R0, R2, R3}
        ; Clear GetBuffer
        LDR     R0, GetBufferAddr
        TEQ     R0, #0
        BLNE    FreeMem
        ; Do _we_ have the clipboard?
        LDR     R14, ClipboardAddr
        TEQ     R14, #0
        ; We have the clipboard - it's a piece of cake...
        MOVNE   R0, #Event_SendClipboard
        MOVNE   R1, #0
        BNE     %FT30
        ; We don't, so we need to get the foreground task to request it
        ; Find how many filetypes
        MOV     R2, R1
        MOV     R1, #0
05      LDR     R14, [R2, R1]
        ADD     R1, R1, #4
        CMP     R14, #-1
        BNE     %BT05
        ; Queue the event (R1=data length, R2->data (ie type list))
        MOV     R0, #Event_FetchClipboard
30      BL      QueueEvent
        STRVS   R0, [SP, #CallerR0]
d193 1
a193 1
; Clipboard_Clear - clear the clipboard, if owned
d197 2
a198 2
SWI_Clear
        BL      FreeClipboard
d202 40
a241 40
;-------------------------------------------------------------------
; QueueEvent - stick an event onto the background->foreground queue
;      R0 = event type
;      R1 = data length
;      R2 -> event data
; On exit:
;      VS if error occured (ie no mem)
;-------------------------------------------------------------------
QueueEvent ROUT
        Entry   "R0-R3"
        MOV     R0, #ModHandReason_Claim
        ADD     R3, R1, #EventData
        SWI     XOS_Module
        STRVS   R0, [SP, #CallerR0]
        EXIT    VS
        MOV     R0, #0
        STR     R0, [R2, #EventNext]
        LDR     R0, [SP, #CallerR0]
        STR     R0, [R2, #EventType]
        ADD     R0, R2, #EventData
        MOV     R2, R1
        LDR     R1, [SP, #CallerR2]
        BL      MemCopy
        SUB     R0, R0, #EventData
        ADR     R1, EventQueue
01      LDR     R14, [R1, #EventNext]
        TEQ     R14, #0
        MOVNE   R1, R14
        BNE     %BT01
        STR     R0, [R1, #EventNext]
        EXITS

JunkEvent ROUT
        Entry   "R1, R2"
        LDR     R1, [R0, #EventNext]
        MOV     R2, R0
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     R0, R1
        EXITS
d331 1
a331 1
        LDR     R0, ClipboardAddr
d336 1
a336 1
        STR     R0, ClipboardAddr
d339 9
a347 9
FreeGetBuffer
        Entry   "R0"
        LDR     R0, GetBufferAddr
        TEQ     R0, #0
        EXITS   EQ
        BL      FreeMem
        MOV     R0, #0
        STR     R0, GetBufferAddr
        EXITS
@


1.2
log
@Expanded tabs.

Version 0.01. Not tagged
@
text
@d16 4
a19 4
        Push    "LR"
        LDR     R12,[R12]
        LDR     R14,mytaskhandle
        CMPS    R14,#0
d21 2
a22 2
        CMPS    R11,#(EndOfJumpTable - JumpTable)/4
        ADDLO   PC,PC,R11,LSL #2
d33 5
a37 5
        ADR     R0,BadSWI
        MOV     R1,#0
01      ADR     R2,PollBlock
        MOV     R3,#?PollBlock
        addr    R4,Title
d39 2
a40 2
        Pull    "R1-R4,LR"
        ORRS    PC,LR,#V_bit
d43 2
a44 2
        ADR     R0,NotActiveErr
        ADR     R1,MessagesBlock
d67 2
a68 2
        MOV     R3,R3,LSL #32-12
        MOV     R3,R3,LSR #32-12
d70 2
a71 2
        MOV     R0,R1
        ADD     R1,R0,R2
d75 2
a76 2
        LDR     R0,ClipboardAddr
        TEQS    R0,#0
d79 2
a80 2
        MOV     R0,R2
        MOV     R1,R2
d82 2
a83 2
        ADDVS   SP,SP,#4
        Pull    "R1-R3,PC",VS
d85 4
a88 4
        STR     R2,ClipboardLen
        STR     R3,ClipboardType
        LDR     R3,ClipboardAddr
        STR     R0,ClipboardAddr
d90 1
a90 1
        LDR     R1,[SP,#CallerR1]
d93 3
a95 3
        TEQS    R3,#0
        MOVEQ   R0,#Event_ClaimClipboard
        MOVEQ   R1,#0
d97 1
a97 1
        STRVS   R0,[SP,#CallerR0]
d99 1
a99 1
        Pull    "R0-R3,PC"
d102 4
a105 4
        ADR     R0,ErrorBlock_BadRead
        MOV     R1,#0
        ADR     R2,PollBlock
        MOV     R3,#?PollBlock
d107 1
a107 1
        addr    R4,Title
d109 1
a109 1
        STRVS   R0,[SP,#4]
d111 1
a111 1
        Pull    "R0-R3,PC"
d125 1
a125 1
;                             (may corrupt R0-R3,R14; preserve rest)
d132 1
a132 1
;           R2,R3 depends on notify type
d135 3
a137 3
; On exit: R0,R1 preserved
;          R2,R3 depend on notify type
;             0 => R2,R3 preserved
d141 2
a142 2
        TSTS    R0,#1:SHL:31
        Pull    "LR",NE
d147 3
a149 3
        AND     R0,R0,#7
        CMPS    R0,#1
        Pull    "R0-R3,PC",HI
d152 2
a153 2
        Push    "R0,R1"
        MOV     R0,#5
d155 4
a158 4
        ADDVS   SP,SP,#3*4
        Pull    "R1-R3,PC",VS
        MOV     R3,R0
        Pull    "R0,R1"
d160 2
a161 2
02      ADR     R14,GetData
        STMIA   R14,{R0,R2,R3}
d163 2
a164 2
        LDR     R0,GetBufferAddr
        TEQS    R0,#0
d167 2
a168 2
        LDR     R14,ClipboardAddr
        TEQS    R14,#0
d170 2
a171 2
        MOVNE   R0,#Event_SendClipboard
        MOVNE   R1,#0
d175 5
a179 5
        MOV     R2,R1
        MOV     R1,#0
05      LDR     R14,[R2,R1]
        ADD     R1,R1,#4
        CMPS    R14,#-1
d182 1
a182 1
        MOV     R0,#Event_FetchClipboard
d184 2
a185 2
        STRVS   R0,[SP,#CallerR0]
        Pull    "R0-R3,PC"
d209 2
a210 2
        MOV     R0,#ModHandReason_Claim
        ADD     R3,R1,#EventData
d212 1
a212 1
        STRVS   R0,[SP,#CallerR0]
d214 7
a220 7
        MOV     R0,#0
        STR     R0,[R2,#EventNext]
        LDR     R0,[SP,#CallerR0]
        STR     R0,[R2,#EventType]
        ADD     R0,R2,#EventData
        MOV     R2,R1
        LDR     R1,[SP,#CallerR2]
d222 5
a226 5
        SUB     R0,R0,#EventData
        ADR     R1,EventQueue
01      LDR     R14,[R1,#EventNext]
        TEQS    R14,#0
        MOVNE   R1,R14
d228 1
a228 1
        STR     R0,[R1,#EventNext]
d232 4
a235 4
        Entry   "R1,R2"
        LDR     R1,[R0,#EventNext]
        MOV     R2,R0
        MOV     R0,#ModHandReason_Free
d237 1
a237 1
        MOV     R0,R1
d243 5
a247 5
        MOV     R7,R0
        MOV     R5,R1           ; maximum size in R1
        ADR     R0,MessagesBlock
        ADR     R1,ClipboardText
        MOV     R2,#0
d250 8
a257 8
        MOV     R8,R2           ; DA name
        MOV     R0,#0           ; Create area
        MOV     R1,#-1          ; any number will do
        ADD     R2,R7,#4        ; requested size, plus 4 for us
        MOV     R3,#-1          ; any address will do
        MOV     R4,#2_010000000 ; usual flags (cacheable, not draggable etc)
        MOV     R6,#0           ; no handler routine
        MOV     R7,#0           ; yawn (R6=0 => R7=0)
d259 2
a260 2
        STRVC   R1,[R3]
        ADDVC   R0,R3,#4
d264 3
a266 3
        Entry   "R0,R1"
        LDR     R1,[R0,#-4]
        MOV     R0,#1
d268 1
a268 1
        STRVS   R0,[SP,#CallerR0]
d274 2
a275 2
        LDR     R3,[R0,#-4]
        MOV     R0,R3
d277 1
a277 1
        STRVS   R0,[SP,#CallerR0]
d280 3
a282 3
        LDR     R14,[SP,#CallerR1]
        ADD     R14,R14,#4              ; our workspace
        SUBS    R1,R14,R1
d284 1
a284 1
        MOV     R0,R3
d286 1
a286 1
        STRVS   R0,[SP,#CallerR0]
d292 2
a293 2
        LDR     R3,[R0,#-4]
        MOV     R0,R3
d295 1
a295 1
        STRVS   R0,[SP,#CallerR0]
d298 3
a300 3
        LDR     R14,[SP,#CallerR1]
        ADD     R14,R14,#4              ; our workspace
        SUBS    R1,R14,R1
d302 1
a302 1
        MOV     R0,R3
d304 1
a304 1
        STRVS   R0,[SP,#CallerR0]
d310 3
a312 3
        Entry   "R2,R3"
        MOV     R3,R0
        MOV     R0,#ModHandReason_Claim
d314 1
a314 1
        MOVVC   R0,R2
d318 3
a320 3
        Entry   "R0,R2"
        MOV     R2,R0
        MOV     R0,#ModHandReason_Free
d322 1
a322 1
        STRVS   R0,[SP,#CallerR0]
d328 2
a329 2
        LDR     R0,ClipboardAddr
        TEQS    R0,#0
d332 2
a333 2
        MOV     R0,#0
        STR     R0,ClipboardAddr
d338 2
a339 2
        LDR     R0,GetBufferAddr
        TEQS    R0,#0
d342 2
a343 2
        MOV     R0,#0
        STR     R0,GetBufferAddr
@


1.1
log
@Initial revision
@
text
@d16 8
a23 8
	Push	"LR"
	LDR	R12,[R12]
	LDR	R14,mytaskhandle
	CMPS	R14,#0
	BLE	ClipboardNotActive
	CMPS	R11,#(EndOfJumpTable - JumpTable)/4
	ADDLO	PC,PC,R11,LSL #2
	B	UnknownSWIError
d25 4
a28 4
	B	SWI_Put
	B	SWI_Get
	B	SWI_Clear
	B	SWI_StartDrag
d32 9
a40 9
	Push	"R1-R4"
	ADR	R0,BadSWI
	MOV	R1,#0
01	ADR	R2,PollBlock
	MOV	R3,#?PollBlock
	addr	R4,Title
	SWI	XMessageTrans_ErrorLookup
	Pull	"R1-R4,LR"
	ORRS	PC,LR,#V_bit
d43 3
a45 3
	ADR	R0,NotActiveErr
	ADR	R1,MessagesBlock
	B	%BT01
d48 3
a50 3
	&	&1E6
	=	"BadSWI", 0
	ALIGN
d53 3
a55 3
	&	0
	=	"NotActive", 0
	ALIGN
d66 32
a97 32
	Push	"R0-R3"
	MOV	R3,R3,LSL #32-12
	MOV	R3,R3,LSR #32-12

	MOV	R0,R1
	ADD	R1,R0,R2
	SWI	XOS_ValidateAddress
	BCS	BadRead

	LDR	R0,ClipboardAddr
	TEQS	R0,#0
	BLNE	FreeMem

	MOV	R0,R2
	MOV	R1,R2
	BL	AllocMem
	ADDVS	SP,SP,#4
	Pull	"R1-R3,PC",VS

	STR	R2,ClipboardLen
	STR	R3,ClipboardType
	LDR	R3,ClipboardAddr
	STR	R0,ClipboardAddr

	LDR	R1,[SP,#CallerR1]
	BL	MemCopy

	TEQS	R3,#0
	MOVEQ	R0,#Event_ClaimClipboard
	MOVEQ	R1,#0
	BLEQ	QueueEvent
	STRVS	R0,[SP,#CallerR0]
d99 1
a99 1
	Pull	"R0-R3,PC"
d102 10
a111 10
	ADR	R0,ErrorBlock_BadRead
	MOV	R1,#0
	ADR	R2,PollBlock
	MOV	R3,#?PollBlock
	Push	"R4"
	addr	R4,Title
	SWI	XMessageTrans_ErrorLookup
	STRVS	R0,[SP,#4]
	Pull	"R4"
	Pull	"R0-R3,PC"
d114 3
a116 3
	&	&410
	=	"BadRead"
	ALIGN
d125 3
a127 3
;			      (may corrupt R0-R3,R14; preserve rest)
;			      R0=pointer to data, R1=data len, R2=data type
;			      User mode, R13->512 bytes+ of stack
d129 2
a130 2
;		   3-30: reserved
;		   31: end operation and dispose data
d140 46
a185 46
	; Check for "end operation" first
	TSTS	R0,#1:SHL:31
	Pull	"LR",NE
	BNE	FreeGetBuffer

	Push	"R0-R3"
	; Type must be zero at the moment
	AND	R0,R0,#7
	CMPS	R0,#1
	Pull	"R0-R3,PC",HI
	BLO	%FT02
	; Get current task handle into R3 for notify type 0
	Push	"R0,R1"
	MOV	R0,#5
	SWI	XWimp_ReadSysInfo
	ADDVS	SP,SP,#3*4
	Pull	"R1-R3,PC",VS
	MOV	R3,R0
	Pull	"R0,R1"
	; Note parameters
02	ADR	R14,GetData
	STMIA	R14,{R0,R2,R3}
	; Clear GetBuffer
	LDR	R0,GetBufferAddr
	TEQS	R0,#0
	BLNE	FreeMem
	; Do _we_ have the clipboard?
	LDR	R14,ClipboardAddr
	TEQS	R14,#0
	; We have the clipboard - it's a piece of cake...
	MOVNE	R0,#Event_SendClipboard
	MOVNE	R1,#0
	BNE	%FT30
	; We don't, so we need to get the foreground task to request it
	; Find how many filetypes
	MOV	R2,R1
	MOV	R1,#0
05	LDR	R14,[R2,R1]
	ADD	R1,R1,#4
	CMPS	R14,#-1
	BNE	%BT05
	; Queue the event (R1=data length, R2->data (ie type list))
	MOV	R0,#Event_FetchClipboard
30	BL	QueueEvent
	STRVS	R0,[SP,#CallerR0]
	Pull	"R0-R3,PC"
d195 2
a196 2
	BL	FreeClipboard
	Pull	"PC"
d208 22
a229 22
	Entry	"R0-R3"
	MOV	R0,#ModHandReason_Claim
	ADD	R3,R1,#EventData
	SWI	XOS_Module
	STRVS	R0,[SP,#CallerR0]
	EXIT	VS
	MOV	R0,#0
	STR	R0,[R2,#EventNext]
	LDR	R0,[SP,#CallerR0]
	STR	R0,[R2,#EventType]
	ADD	R0,R2,#EventData
	MOV	R2,R1
	LDR	R1,[SP,#CallerR2]
	BL	MemCopy
	SUB	R0,R0,#EventData
	ADR	R1,EventQueue
01	LDR	R14,[R1,#EventNext]
	TEQS	R14,#0
	MOVNE	R1,R14
	BNE	%BT01
	STR	R0,[R1,#EventNext]
	EXITS
d232 7
a238 7
	Entry	"R1,R2"
	LDR	R1,[R0,#EventNext]
	MOV	R2,R0
	MOV	R0,#ModHandReason_Free
	SWI	XOS_Module
	MOV	R0,R1
	EXITS
d240 1
a240 1
	[ UseDynamicAreas
d242 20
a261 20
	Entry	"R1-R8"
	MOV	R7,R0
	MOV	R5,R1		; maximum size in R1
	ADR	R0,MessagesBlock
	ADR	R1,ClipboardText
	MOV	R2,#0
	SWI	XMessageTrans_Lookup
	EXIT	VS
	MOV	R8,R2		; DA name
	MOV	R0,#0		; Create area
	MOV	R1,#-1		; any number will do
	ADD	R2,R7,#4	; requested size, plus 4 for us
	MOV	R3,#-1		; any address will do
	MOV	R4,#2_010000000 ; usual flags (cacheable, not draggable etc)
	MOV	R6,#0		; no handler routine
	MOV	R7,#0		; yawn (R6=0 => R7=0)
	SWI	XOS_DynamicArea
	STRVC	R1,[R3]
	ADDVC	R0,R3,#4
	EXIT
d264 6
a269 6
	Entry	"R0,R1"
	LDR	R1,[R0,#-4]
	MOV	R0,#1
	SWI	XOS_DynamicArea
	STRVS	R0,[SP,#CallerR0]
	EXIT
d272 16
a287 16
	Entry	"R0-R3"
	; Get current size of area
	LDR	R3,[R0,#-4]
	MOV	R0,R3
	SWI	XOS_ReadDynamicArea
	STRVS	R0,[SP,#CallerR0]
	EXIT	VS
	; Exit if we are already big enough
	LDR	R14,[SP,#CallerR1]
	ADD	R14,R14,#4		; our workspace
	SUBS	R1,R14,R1
	EXIT	LE
	MOV	R0,R3
	SWI	XOS_ChangeDynamicArea
	STRVS	R0,[SP,#CallerR0]
	EXIT
d290 16
a305 16
	Entry	"R0-R3"
	; Get current size of area
	LDR	R3,[R0,#-4]
	MOV	R0,R3
	SWI	XOS_ReadDynamicArea
	STRVS	R0,[SP,#CallerR0]
	EXIT	VS
	; Exit if we are already small enough
	LDR	R14,[SP,#CallerR1]
	ADD	R14,R14,#4		; our workspace
	SUBS	R1,R14,R1
	EXIT	GE
	MOV	R0,R3
	SWI	XOS_ChangeDynamicArea
	STRVS	R0,[SP,#CallerR0]
	EXIT
d307 1
a307 1
	|
d310 6
a315 6
	Entry	"R2,R3"
	MOV	R3,R0
	MOV	R0,#ModHandReason_Claim
	SWI	XOS_Module
	MOVVC	R0,R2
	EXIT
d318 7
a324 7
	Entry	"R0,R2"
	MOV	R2,R0
	MOV	R0,#ModHandReason_Free
	SWI	XOS_Module
	STRVS	R0,[SP,#CallerR0]
	EXIT
	]
d327 8
a334 8
	Entry	"R0"
	LDR	R0,ClipboardAddr
	TEQS	R0,#0
	EXITS	EQ
	BL	FreeMem
	MOV	R0,#0
	STR	R0,ClipboardAddr
	EXITS
d337 8
a344 8
	Entry	"R0"
	LDR	R0,GetBufferAddr
	TEQS	R0,#0
	EXITS	EQ
	BL	FreeMem
	MOV	R0,#0
	STR	R0,GetBufferAddr
	EXITS
d346 1
a346 1
	END
@


1.1.1.1
log
@Initial import: Kevin's original version.
@
text
@@

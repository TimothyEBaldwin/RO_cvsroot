head	1.8;
access;
symbols
	Clipboard-0_10:1.8
	Clipboard-0_09:1.8
	Clipboard-0_08:1.7
	Clipboard-0_07:1.6
	Clipboard-0_06:1.6
	Clipboard-0_05:1.5
	Clipboard-0_04:1.4
	Clipboard-0_03:1.3
	Clipboard-0_02:1.2
	Clipboard-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2008.09.16.18.36.55;	author rool;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.13.01.41.06;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	99.02.25.10.57.33;	author bavison;	state Exp;
branches;
next	1.5;

1.5
date	99.02.22.11.58.03;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	99.02.19.11.22.09;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	99.02.12.20.01.58;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	98.11.10.18.02.12;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	98.11.10.17.28.24;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.10.17.28.24;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.8
log
@  Completed the clipboard support part of the Clipboard module.
  Drag-and-Drop support still needs to be designed and implemented.
Detail:
  The initial Clipboard module released by ROOL was in a state of flux due
  to a redesign of how the module worked. The transition to the new way
  of doing things was only done partially and needed completing to make the
  Clipboard module support the clipboard fully. The module also contained
  26-bit only code.

  - Replaced all the 26-bit code with 32-bit (not mode neutral) code.

  - Completed implementation of Clipboard_GetDataType by adding support for
    the situation where the Clipboard module doesn't own the clipboard and
    isn't proxying either. The required StateHandler_DataRequest2 has been
    implemented also.

  - Fully implemented Clipboard_Get including all the required statehandlers.
      StateHandler_DataSaveAck
      StateHandler_RAMFetch1
      StateHandler_RAMFetch2
      StateHandler_DataRequest1
      StateHandler_DataRequest2
      StateHandler_PutRequest3
      StateHandler_Paste

  - Modified CopyData routine to allow for clipboard content not being
    word-aligned and/or its length not being a multiple of four.

  - Removed all the commented out code that was left over from the initial
    implementation of the Clipboard module.

  - Added GetData to the set of test applications. It displays the clipboard
    contents if it's of type text (It's best to use short text strings). It's
    not very polished and it's better to use PutClip and GetClip to test the
    Clipboard module.

  - Added PutClip to the set of test applications. It can be used test
    SWI Clipboard_Put. Details on how can be found in its Help file.

  - Added GetClip to the set of test applications. It can be used test
    SWI Clipboard_Get. Details on how can be found in its Help file.
Admin:
  Extensively tested on Iyonix RO 5.11 both external behaviour with PutClip
  and GetClip as well as the internal behaviour of the statehandler (by using
  StrongED as the clipboard owner/requester and rigging it to fail at certain
  points during the datatransfer).

  Briefly tested on RO 4.02, seems to be OK.

  Briefly tested on RO 6.06, seems to be OK. Functionality may be different
  from 5.11 and 4.02 though due to ClipboardHolder. In particular using the
  Clipboard module as a proxy is likely to be affected.

Version 0.09. Tagged as 'Clipboard-0_09'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
;  s.Task - task management
;


clipboard_text
        =       "_TaskName", 0
        ALIGN

messages_list
        &       Message_DataSave
        &       Message_DataSaveAck
        &       Message_DataLoad
        &       Message_DataLoadAck
        &       Message_RAMFetch
        &       Message_RAMTransmit
        &       Message_ClaimEntity
        &       Message_DataRequest
      [ DragNDrop
        &       Message_Dragging
        &       Message_DragClaim
      ]
        &       Message_PutRequest
        &       Message_Paste
        &       0

;-------------------------------------------------------------------------------
;
; Start - module entry point
;
;-------------------------------------------------------------------------------
Start
        LDR     R12, [R12]
        LDR     R0, mytaskhandle
        CMP     R0, #0
        ; Close down any existing task
        LDRGT   R1, TASK
        SWIGT   Wimp_CloseDown
        LDR     R2, mystack
        TEQ     R2, #0
        BNE     %FT01
        ; Claim ourselves a stack
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #UserStackSize
        SWI     OS_Module
        STR     R2, mystack
        ; Find our task name
01      ADD     R13, R2, #UserStackSize
        ADR     R0, MessagesBlock
        ADR     R1, clipboard_text
        ADR     R2, PollBlock
        MOV     R3, #?PollBlock
        SWI     MessageTrans_Lookup             ; R2->task name
        ; Initialise the Wimp
        LDR     R0, =310
        LDR     R1, TASK
        ADR     R3, messages_list
        SWI     Wimp_Initialise
        STR     R1, mytaskhandle

        Debug   tmp,"Init handle",r1
        ; Initialise other things
        MOV     R0, #0
        STR     R0, MsgQueue
        STR     R0, ClipboardTask
      [ DragNDrop
        STR     R0, DragTask
      ]
        STR     R0, Actions
        BL      InstallHandlers

        ; Enter the poll loop
PollLoop
        LDR     R0, =null_bit:OR:pollword_enable
        ADR     R1, PollBlock
        ADR     R3, MsgQueue
        SWI     Wimp_Poll
        CMP     R0, #19
        ADDLS   PC, PC, R0, LSL #2
        B       PollLoop
        B       NullReasonCode
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       UserDragBox
        B       KeyPressed
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       PollWordNonZero
        B       PollLoop
        B       PollLoop
        B       PollLoop
        B       UserMessage
        B       UserMessage
        B       UserMessageAcknowledge


;-------------------------------------------------------------------
;
; Wimp event handlers
;

NullReasonCode
UserDragBox
KeyPressed
        B       PollLoop


PollWordNonZero
        LDR     R5, MsgQueue
01      TEQ     R5, #0
        STREQ   R5, MsgQueue
        BEQ     PollLoop

        ADD     R1, R5, #MsgQ_Data              ; -> Wimp message block
        ADD     R14, R5, #MsgQ_EventCode
        LDMIA   R14, {R0, R2-R4}                ; R0, R2, R3 are Wimp_SendMessage params,
                                                ; R4 -> word to store my_ref in
        SWI     XWimp_SendMessage               ; nowhere to report error to
        LDR     R14, [R1, #ms_myref]
        TEQ     R4, #0
        STRNE   R14, [R4]

        MOV     R2, R5
        LDR     R5, [R2, #MsgQ_Next]            ; -> next message queue block, or 0
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module                      ; free the block we've just dealt with

        B       %BT01                           ; loop


UserMessage
        LDR     R5, [R1, #ms_action]
        Debug   tmp,"User Msg",r5

        TEQ     R5, #Message_Quit
        BEQ     MessageQuit

        TEQ     R5, #Message_ClaimEntity
        BEQ     MessageClaimEntity

        TEQ     R5, #Message_DataRequest
        BEQ     MessageDataRequest

        TEQ     R5, #Message_DataSave
        TEQNE   R5, #Message_DataSaveAck
        TEQNE   R5, #Message_DataLoad
        TEQNE   R5, #Message_DataLoadAck
        TEQNE   R5, #Message_RAMFetch
        TEQNE   R5, #Message_RAMTransmit
        BNE     %FT01
        LDR     R11, [R1, #ms_yourref]
        Debug   tmp, "yourref",r11
        BL      GetActionHandle
        Debug   tmp, "ActionHandle",r11
        CMP     R11, #0                         ; was an action handle found?
        BLNE    StateHandler
        SWIVS   OS_GenerateError
01
        B       PollLoop


UserMessageAcknowledge
        LDR     R5, [R1, #ms_action]
        Debug   tmp,"User Msg ack",r5

        TEQ     R5, #Message_DataSave
        TEQNE   R5, #Message_DataSaveAck
        TEQNE   R5, #Message_DataLoad
        TEQNE   R5, #Message_RAMFetch
        TEQNE   R5, #Message_RAMTransmit
        TEQNE   R5, #Message_DataRequest
        TEQNE   R5, #Message_PutRequest
        LDRNE   R14, =Message_Paste
        TEQNE   R5, R14
        BNE     %FT01
        LDR     R11, [R1, #ms_myref]
        BL      GetActionHandle
        CMP     R11, #0                         ; was an action handle found?
        BLNE    StateHandler
        SWIVS   OS_GenerateError
01
        B       PollLoop


;-------------------------------------------------------------------
;
; Wimp message handlers (excluding those involved in data transfer)
;

;
; Message_Quit - exit task
;
MessageQuit
        BL      CloseDown
        SWI     OS_Exit


;-------------------------------------------------------------------------------
;
; Message_ClaimEntity - junk our clipboard if someone else has nobbled it
;
;-------------------------------------------------------------------------------
MessageClaimEntity
        Debug   tmp,"MessageClaimEntity"
        LDR     R0, [R1, #msClaimEntity_flags]
        TST     R0, #4
        BEQ     PollLoop
        LDR     R0, [R1, #ms_taskhandle]
        LDR     R14, mytaskhandle
        Debug   tmp,"sender",r0
        Debug   tmp,"handle",r14
        TEQ     R0, R14                  ; ignore our broadcasts...
        BLNE    FreeClipboard
        B       PollLoop


;-------------------------------------------------------------------------------
;
; Message_DataRequest - someone wants the clipboard contents
;
;-------------------------------------------------------------------------------
MessageDataRequest
        Debug   tmp,"MessageDataRequest"
        LDR     R0, [R1, #ms_taskhandle]
        LDR     R14, mytaskhandle
        TEQ     R0, R14                  ; ignore our broadcasts...
        BEQ     PollLoop

        LDR     R0, [R1, #msDataRequest_flags]
        TST     R0, #msDataRequest_SendFromClipboard
        BEQ     PollLoop                 ; ignore any non-Clipboard protocol

        LDR     R0, ClipboardTask
        TEQ     R0, #0
        BEQ     PollLoop                 ; ignore it if we can't help

        ; Gather information from the DataRequest block
        BL      NewAction
        SWIVS   OS_GenerateError
        LDR     R0, [R1, #ms_taskhandle]
        STR     R0, [R11, #Act_Task]
        ADD     R0, R1, #msDataRequest_window
        LDMIA   R0, {R2-R5}
        ADD     R0, R11, #Act_Window
        STMIA   R0, {R2-R5}
        ADD     R0, R1, #msDataRequest_filetypes
        BL      CopyTypes
        SWIVS   OS_GenerateError
        STR     R0, [R11, #Act_List]
        LDR     R0, [R1, #ms_myref]
        STR     R0, [R11, #Act_DataRequestRef]

        Debug   tmp,"Check state"
        ; Branch according to clipboard state
        LDR     R0, ClipboardFlags
        TST     R0, #msPutRequest_SendPutRequest
        BNE     %FT10

        ; We hold the clipboard - enter State_DataSave
        MOV     R0, #State_DataSave
        STR     R0, [R11, #Act_State]
        LDR     R0, ClipboardAddr
        STR     R0, [R11, #Act_BufAddr]
        LDR     R0, ClipboardLen
        STR     R0, [R11, #Act_BufLen]
        MOV     R0, #1                   ; don't free clipboard!
        STR     R0, [R11, #Act_IntFlags]

        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #Message_DataSave
        STR     R0, [R1, #ms_action]
        LDR     R0, ClipboardLen
        STR     R0, [R1, #msDataTransfer_filesize]
        LDR     R0, ClipboardType
        STR     R0, [R1, #msDataTransfer_filetype]
        LDR     R0, ClipboardName
        ADD     R2, R1, #msDataTransfer_filename
01      LDRB    R14, [R0], #1
        STRB    R14, [R2], #1
        TEQ     R14, #0
        BNE     %BT01
        SUB     R0, R2, R1
        ADD     R0, R0, #3
        BIC     R0, R0, #3
        STR     R0, [R1, #ms_size]
        MOV     R0, #User_Message_Recorded
        LDR     R2, [R1, #ms_taskhandle]
        ADD     R4, R11, #Act_MyRef
        BL      MySendMessage
        SWIVS   OS_GenerateError

        Debug   tmp,"Data req done"
        B       PollLoop

10      ; We are proxying - enter State_PutRequest1
        MOV     R0, #State_PutRequest1
        STR     R0, [R11, #Act_State]

        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #User_Message_Acknowledge
        LDR     R2, [R1, #ms_taskhandle]
        MOV     R4, #0
        BL      MySendMessage            ; acknowledge the DataRequest
        SWIVS   OS_GenerateError         ; because we won't reply immediately

        MOV     R0, #Message_PutRequest
        STR     R0, [R1, #ms_action]
        MOV     R0, #0
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #msPutRequest_size
        STR     R0, [R1, #ms_size]
        LDR     R0, ClipboardFlags
        AND     R0, R0, #ClipboardPut_Wimp
        ORR     R0, R0, #msPutRequest_SendClipboard
        STR     R0, [R1, #msPutRequest_flags]
        ADD     R0, R11, #Act_Window
        LDMIA   R0, {R2-R5}
        ADD     R0, R1, #msPutRequest_window
        STMIA   R0, {R2-R5}
        LDR     R0, [R11, #Act_List]
        STR     R0, [R1, #msPutRequest_datatypes]
        MOV     R0, #User_Message_Recorded
        LDR     R2, ClipboardTask
        ADD     R4, R11, #Act_MyRef
        BL      MySendMessage
        SWIVS   OS_GenerateError

        B       PollLoop


;-------------------------------------------------------------------
;
; CloseDown - close down task, but leave module active
; Called from module finalisation, exit/upcall handlers and task exit (after Message_Quit)
; R12 and R13 must be valid
;

CloseDown
        Entry   "R0-R2"

        BL      RestoreHandlers         ; remove our error handler *first*

        BL      DeleteActions           ; free actions list

      [ DragNDrop
        BL      StopDragging            ; stop Wimp drag and free dynamic drag data
      ]

        BL      FreeClipboard           ; free clipboard and dynamic clipboard data

        BL      FreeMsgQueue            ; free message queue

        LDR     R0, mytaskhandle
        LDR     R1, TASK
        SWI     XWimp_CloseDown         ; close down task
        MOV     R0, #0
        STR     R0, mytaskhandle

        MOV     R0, #ModHandReason_Free
        LDR     R2, mystack
        SWI     XOS_Module
        MOV     R14, #0
        STR     R14, mystack            ; free task stack

        EXIT

        LTORG

        END
@


1.7
log
@Fixed Clipboard to build and made it 32bit.
Detail:
  Clipboard has never been 32bitted, therefore it refused to build for
  Tungsten. It's now been fixed to build. It's still not finished though.
Admin:
  Tested on RiscPC RO402. Module checked with ARMalyser.
Notes:
  Changes by James Lampard.

Version 0.08. Tagged as 'Clipboard-0_08'
@
text
@d41 1
a41 1
;-------------------------------------------------------------------
d45 1
a45 1

d74 2
a115 1
        LTORG
d153 1
d172 1
d174 1
d184 1
d217 2
d222 1
d224 1
d230 2
d236 2
d241 1
d243 1
d269 1
a269 1
        STR     R0, [R11, #Act_Type]
d273 1
d313 1
d342 1
a342 1
        LDR     R0, [R11, #Act_Type]
a352 272

;;
;; Message_RAMFetch - yo ho ho, lets transfer some data...
;;
;RAMFetch
;        LDR     R0, MsgState
;        TEQ     R0, #MsgState_DataSave
;        TEQNES  R0, #MsgState_RAMTransmit
;        BNE     PollLoop
;        LDR     R7, TransferCount                ; R7 = amount transferred so far
;        LDR     R6, [R1, #msRAMTransfer_length]   ; R6 = buffer size
;        LDR     R0, ClipboardLen
;        SUB     R0, R0, R7                        ; R0 = amount to go
;        CMP     R6, R0
;        MOVLS   R4, R6                           ; R4 = amount to transfer this go
;        MOVHI   R4, R0
;
;        LDR     R2, [R1, #ms_taskhandle]
;        LDR     R3, [R1, #msRAMTransfer_buffer]
;        LDR     R0, mytaskhandle
;        LDR     R1, ClipboardAddr
;        ADD     R1, R1, R7
;        SWI     Wimp_TransferBlock
;
;        ADD     R7, R7, R4
;        STR     R7, TransferCount
;
;        ADR     R1, PollBlock
;        MOV     R0, #Message_RAMTransmit
;        STR     R0, [R1, #ms_action]
;        LDR     R0, [R1, #ms_myref]
;        STR     R0, [R1, #ms_yourref]
;        STR     R4, [R1, #msRAMTransfer_length]
;
;        CMP     R4, R6
;        MOVEQ   R0, #User_Message_Recorded
;        MOVEQ   R5, #MsgState_RAMTransmit
;        MOVNE   R0, #User_Message
;        MOVNE   R5, #MsgState_None
;        LDR     R2, [R1, #ms_taskhandle]
;        SWI     Wimp_SendMessage
;        STR     R5, MsgState
;
;        B       PollLoop
;
;;
;; Message_DataSave - starting to pull in some data for someone...
;;
;DataSave
;        LDR     R0, MsgState
;        TEQ     R0, #MsgState_DataRequest
;        BNE     PollLoop
;        ; Sanity check (we set the icon to our pollblock for some reason...)
;        LDR     R0, [R1, #msDataTransfer_icon]
;        TEQ     R0, R1
;        BNE     PollLoop
;        LDR     R0, [R1, #msDataTransfer_filetype]
;        STR     R0, GetBufferType
;        LDR     R0, [R1, #msDataTransfer_filesize]
;        ; So we should hopefully get a single (non-full) transfer, allocate a bigger buffer
;        ADD     R0, R0, #4
;        ; Ensure a sensible figure between 2K and 1M
;        CMP     R0, #2*1024
;        MOVLO   R0, #2*1024
;        CMP     R0, #1024*1024
;        MOVHI   R0, #1024*1024
;        STR     R0, GetBufferLen
;        STR     R0, TransferBufLen
;        STR     R0, [R1, #msRAMTransfer_length]
;        ; Get a buffer for us
;        Push    "R1"
;        MOV     R1, #-1
;        BL      AllocMem
;        Pull    "R1"
;        BVS     PollLoop
;        STR     R0, GetBufferAddr
;        STR     R0, [R1, #msRAMTransfer_buffer]
;        MOV     R0, #28
;        STR     R0, [R1, #ms_size]
;        LDR     R0, [R1, #ms_myref]
;        STR     R0, [R1, #ms_yourref]
;        MOV     R0, #Message_RAMFetch
;        STR     R0, [R1, #ms_action]
;        MOV     R0, #User_Message_Recorded
;        LDR     R2, [R1, #ms_taskhandle]
;        SWI     Wimp_SendMessage
;        MOV     R0, #MsgState_RAMFetch
;        STR     R0, MsgState
;        B       PollLoop
;
;;
;; Message_RAMTransmit - pulling data into GetBuffer
;;
;RAMTransmit ROUT
;        LDR     R0, MsgState
;        TEQ     R0, #MsgState_RAMFetch
;        BNE     PollLoop
;        LDR     R0, [R1, #msRAMTransfer_length]
;        ; Increment transfer counter
;        LDR     R14, TransferCount
;        ADD     R14, R14, R0
;        STR     R14, TransferCount
;        ; Is the buffer full?
;        LDR     R2, TransferBufLen
;        TEQ     R2, R0
;        BNE     %FT50
;        ; Buffer is full - we need to allocate more
;        LDR     R0, GetBufferAddr
;        Push    "R1"
;        LDR     R1, GetBufferLen
;        MOV     R1, R1, LSL #1
;        BL      ExpandMemToR1
;        STRVC   R1, GetBufferLen
;        Pull    "R1"
;        BVS     %FT70
;        LDR     R14, TransferCount
;        LDR     R2, GetBufferLen
;        SUB     R0, R2, R14
;        STR     R0, TransferBufLen
;        STR     R0, [R1, #msRAMTransfer_length]
;        LDR     R2, GetBufferAddr
;        ADD     R0, R2, R14
;        STR     R0, [R1, #msRAMTransfer_buffer]
;        LDR     R0, [R1, #ms_myref]
;        STR     R0, [R1, #ms_yourref]
;        MOV     R0, #Message_RAMFetch
;        STR     R0, [R1, #ms_action]
;        MOV     R0, #User_Message_Recorded
;        LDR     R2, [R1, #ms_taskhandle]
;        SWI     Wimp_SendMessage
;        B       PollLoop
;
;        ; Buffer isn't full - we've finished!
;50      LDR     R1, TransferCount
;        LDR     R0, GetBufferAddr
;        BL      ShrinkMemToR1
;        LDR     R2, GetBufferType
;
;        BL      NotifyGetCaller
;        B       PollLoop
;
;70      BL      FreeMem
;        B       PollLoop




;;-------------------------------------------------------------------
;; Pollword handling routines. Called with
;;      R0 -> event
;;      R1 -> PollBlock
;; Can corrupt R0-R3 and PollBlock, should B ExitPollWord to return
;;-------------------------------------------------------------------
;
;;
;; Clipboard_Put has been issued and we need to broadcast Message_ClaimEntity
;;
;PW_ClaimClipboard
;        MOV     R0, #User_Message
;        ; R1=PollBlock from above
;        MOV     R2, #0
;        MOV     R14, #24
;        STR     R14, [R1, #ms_size]
;        STR     R2, [R1, #ms_yourref]
;        MOV     R14, #Message_ClaimEntity
;        STR     R14, [R1, #ms_action]
;        MOV     R14, #4
;        STR     R14, [R1, #msClaimEntity_flags]
;        SWI     Wimp_SendMessage
;        B       ExitPollWord
;
;;
;; Clipboard_Get has been issued and we need to broadcast Message_DataRequest
;;
;PW_FetchClipboard ROUT
;        ; R1=PollBlock
;        MOV     R2, #0
;        STR     R2, [R1, #ms_yourref]
;        MOV     R14, #Message_DataRequest
;        STR     R14, [R1, #ms_action]
;        STR     R2, [R1, #msDataRequest_window]
;        ; Sanity check value (just in case)
;        STR     R1, [R1, #msDataRequest_internal]
;        STR     R2, [R1, #msDataRequest_x]
;        STR     R2, [R1, #msDataRequest_y]
;        MOV     R14, #4
;        STR     R14, [R1, #msDataRequest_flags]
;        ; Copy in filetypes from event
;        ADD     R14, R0, #EventData
;        ADD     R0, R1, #msDataRequest_filetypes
;10      LDR     R3, [R14], #4
;        STR     R3, [R0], #4
;        CMP     R3, #-1
;        BNE     %BT10
;        ; Fill in the size
;        SUB     R14, R0, R1
;        STR     R14, [R1, #ms_size]
;        MOV     R0, #User_Message
;        SWI     Wimp_SendMessage
;        ; Note that we're expecting a response
;        MOV     R0, #MsgState_DataRequest
;        STR     R0, MsgState
;        MOV     R0, #0
;        STR     R0, TransferCount
;        B       ExitPollWord
;
;;
;; Clipboard_Get has been issued and we need to notify the task that we have it already!
;;
;PW_SendClipboard ROUT
;        LDR     R0, ClipboardAddr
;        LDR     R1, ClipboardLen
;        LDR     R2, ClipboardType
;        BL      NotifyGetCaller
;        B       ExitPollWord
;
;;-------------------------------------------------------------------
;; NotifyGetCaller - tell caller of Clipboard_Get that we have the
;;                   data
;;      R0 -> data
;;      R1 = data length
;;      R2 = data type
;;-------------------------------------------------------------------
;NotifyGetCaller ROUT
;        Entry   "R0-R3"
;
;        LDR     R14, GetData
;        AND     R14, R14, #7
;        ADD     PC, PC, R14, LSL #2
;        NOP
;        B       NotifyType0
;
;        ; Call a routine
;NotifyType1
;        Push    "R12"
;        LDR     R2, GetData+4
;        LDR     R12, GetData+8
;        MOV     R14, PC
;        MOV     PC, R2
;        Pull    "R12"
;        EXIT
;
;        ; Send the message
;NotifyType0
;        ADR     R1, PollBlock
;        LDR     R14, =Message_Paste
;        STR     R14, [R1, #ms_action]
;        ; Fill in reference value
;        LDR     R14, GetData+4
;        STR     R14, [R1, #ms_data]
;        ; Fill in buffer address
;        STR     R0, [R1, #ms_data+4]
;        ; Fill in length
;        LDR     R14, TransferCount
;        STR     R14, [R1, #ms_data+8]
;        ; Fill in type
;        LDR     R14, GetBufferType
;        STR     R14, [R1, #ms_data+12]
;        MOV     R14, #0
;        STR     R14, [R1, #ms_yourref]
;        MOV     R14, #28
;        STR     R14, [R1, #ms_size]
;        MOV     R0, #User_Message_Recorded
;        LDR     R2, GetData+8
;        SWI     Wimp_SendMessage
;        EXIT
;
;        END




d389 1
@


1.6
log
@* Standardised all error blocks to use AddError/MakeErrorBlock macros
* Routines added for making "safe" copies of data blocks, data type lists
  and leafnames passed in via the various mechanisms
* SWI Clipboard_Put and Message_DataRequest handler implemented, and the
  supporting state handlers
    State_PutRequest1
    State_DataSave
    State_RAMTransmit
    State_DataLoad
* SWI Clipboard_GetDataType implemented, and the supporting handler
    State_PutRequest2
    (but not State_DataRequest2 yet)
* Now requires that the caller is an active task
* Fixed occasional data abort bug in MySendMessage
* Fixed corruption of wimp event code bug
* Implemented and added test applications

Version 0.06. Tagged as 'Clipboard-0_06'
@
text
@d114 1
@


1.5
log
@* Task-related initialisation moved from module init to Start routine
* State handler added, called from SWI, UserMessage, UserMessageAck handlers
* Implemented NewAction, DeleteAction, DeleteActions, FreeClipboard and
  FreeMsgQueue
* DA memory allocation adapted so as not to use max-size "-1" DAs
* RMA memory allocation functions completed to match DA functions - will now
  assemble with DA support option turned off!

Version 0.05. Tagged as 'Clipboard-0_05'
@
text
@d129 1
d138 2
a139 1
        STR     R14, [R4]
d150 1
a150 1
        LDR     R0, [R1, #ms_action]
d152 1
a152 1
        TEQ     R0, #Message_Quit
d155 1
a155 1
        TEQ     R0, #Message_ClaimEntity
d158 9
a166 6
        TEQ     R0, #Message_DataSave
        TEQNE   R0, #Message_DataSaveAck
        TEQNE   R0, #Message_DataLoad
        TEQNE   R0, #Message_DataLoadAck
        TEQNE   R0, #Message_RAMFetch
        TEQNE   R0, #Message_RAMTransmit
d168 1
a168 1
        LDR     R5, [R1, #ms_yourref]
d170 1
a170 2
        TEQ     R11, #0                         ; was an action handle found?
        LDRNE   R5, [R1, #ms_action]
d172 1
d178 1
a178 1
        LDR     R0, [R1, #ms_action]
d180 7
a186 7
        TEQ     R0, #Message_DataSave
        TEQNE   R0, #Message_DataSaveAck
        TEQNE   R0, #Message_DataLoad
        TEQNE   R0, #Message_RAMFetch
        TEQNE   R0, #Message_RAMTransmit
        TEQNE   R0, #Message_DataRequest
        TEQNE   R0, #Message_PutRequest
d188 1
a188 1
        TEQNE   R0, R14
d190 1
a190 1
        LDR     R5, [R1, #ms_myref]
d192 1
a192 2
        TEQ     R11, #0                         ; was an action handle found?
        LDRNE   R5, [R1, #ms_action]
d194 1
a223 48
;;
;; Message_DataRequest - someone wants the clipboard contents
;;
;DataRequest
;        LDR     R0, [R1, #msDataRequest_flags]
;        TST     R0, #4
;        BEQ     PollLoop
;
;        LDR     R0, [R1, #ms_taskhandle]
;        LDR     R14, mytaskhandle
;        TEQ     R0, R14
;        BEQ     PollLoop
;
;        LDR     R0, ClipboardAddr
;        TEQ     R0, #0
;        BEQ     PollLoop
;
;        MOV     R0, #Message_DataSave
;        STR     R0, [R1, #ms_action]
;        LDR     R0, [R1, #ms_myref]
;        STR     R0, [R1, #ms_yourref]
;        LDR     R0, ClipboardLen
;        LDR     R14, ClipboardType
;        STR     R0, [R1, #msDataTransfer_filesize]
;        STR     R14, [R1, #msDataTransfer_filetype]
;        ADR     R0, MessagesBlock
;        ADD     R2, R1, #msDataTransfer_filename
;        ADR     R1, ClipboardToken
;        MOV     R3, #?PollBlock-msDataTransfer_filename
;        SWI     MessageTrans_Lookup
;        MOV     R14, #0
;        STRB    R14, [R1]
;        ADR     R1, PollBlock            ; get R1 back...
;        ADD     R0, R3, #msDataTransfer_filename+1+3
;        BIC     R0, R0, #3
;        STR     R0, [R1, #ms_size]
;        MOV     R0, #User_Message_Recorded
;        LDR     R2, [R1, #ms_taskhandle]
;        SWI     Wimp_SendMessage
;        MOV     R0, #MsgState_DataSave
;        STR     R0, MsgState
;        MOV     R0, #0
;        STR     R0, TransferCount
;        B       PollLoop
;
;ClipboardToken
;        =       "Clipboard", 0
;        ALIGN
d225 111
@


1.4
log
@* Updated API to match that from the spec 1309,419/FS
* Added symbols for all flag bits in SWIs and messages
* Major reorganisation of workspace layout, primarily to facilitate multiple
  concurrent data transfer transactions - because of this, most of the
  useful functionality is currently commented out, pending updating to use
  the new structures
* Replaced "event" queue with a simple queue of ready-to-send Wimp message
  blocks - this way, event handling can be handled in the same place in the
  code, irrespective of whether we're in the foreground or background
* Reorganised finalisation code so that task and module operations are
  performed in separate routines and (mostly) in strictly the reverse order
  to at initialisation. This allows code sharing between module finalisation,
  the exit handler, the UpCall_NewApplication handler, and the task quit
  code, as well as eradicating several memory leaks in the process

Version 0.04. Tagged as 'Clipboard-0_04'
@
text
@d15 6
a20 1
ClipboardText
d24 1
a24 1
MessagesList
d34 1
d37 2
d64 1
a64 1
        ADR     R1, ClipboardText
d71 1
a71 1
        ADR     R3, MessagesList
d74 8
d149 1
d151 18
a168 11
        BEQ     Quit
;        TEQ     R0, #Message_ClaimEntity
;        BEQ     ClaimEntity
;        TEQ     R0, #Message_DataRequest
;        BEQ     DataRequest
;        TEQ     R0, #Message_RAMFetch
;        BEQ     RAMFetch
;        TEQ     R0, #Message_RAMTransmit
;        BEQ     RAMTransmit
;        TEQ     R0, #Message_DataSave
;        BEQ     DataSave
d173 18
d199 4
a202 1
Quit
d209 1
a209 1
ClaimEntity
d551 1
a551 1
;        BL      FreeActions             ; free actions list
d559 1
a559 1
 ;       BL      FreeMsgQueue            ; free message queue
@


1.3
log
@* Makefile altered to build separate targets for RAM and ROM builds
* Makefile supports LocalRes$Path
* General tidying up of source
* Drag-and-Drop features optioned out (implementation unlikely in first release)
* R0 passed to Wimp_Initialise now a recognised value
* Ursula fast service call table added
* Now launches task when module is RMRun
* Error handler modified to have a Quit button instead of Cancel
* Debug builds append error PC to error message in error handler error box

Version 0.03. Tagged as 'Clipboard-0_03'
@
text
@d22 1
d28 3
d33 5
d72 1
a72 1
        ADR     R3, EventQueue
d77 1
a77 1
        B       PollLoop ; NullReasonCode
d84 2
a85 2
        B       PollLoop ; UserDragBox
        B       PollLoop ; KeyPressed
d96 34
a129 1
        B       PollLoop ; UserMessageAcknowledge
d135 10
a144 10
        TEQ     R0, #Message_ClaimEntity
        BEQ     ClaimEntity
        TEQ     R0, #Message_DataRequest
        BEQ     DataRequest
        TEQ     R0, #Message_RAMFetch
        BEQ     RAMFetch
        TEQ     R0, #Message_RAMTransmit
        BEQ     RAMTransmit
        TEQ     R0, #Message_DataSave
        BEQ     DataSave
d147 10
d158 1
a158 5
        LDR     R0, mytaskhandle
        LDR     R1, TASK
        SWI     Wimp_CloseDown
        MOV     R0, #0
        STR     R0, mytaskhandle
d174 314
d489 1
a489 11
; Message_DataRequest - someone wants the clipboard contents
;
DataRequest
        LDR     R0, [R1, #msDataRequest_flags]
        TST     R0, #4
        BEQ     PollLoop

        LDR     R0, [R1, #ms_taskhandle]
        LDR     R14, mytaskhandle
        TEQ     R0, R14
        BEQ     PollLoop
a490 3
        LDR     R0, ClipboardAddr
        TEQ     R0, #0
        BEQ     PollLoop
a491 27
        MOV     R0, #Message_DataSave
        STR     R0, [R1, #ms_action]
        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        LDR     R0, ClipboardLen
        LDR     R14, ClipboardType
        STR     R0, [R1, #msDataTransfer_filesize]
        STR     R14, [R1, #msDataTransfer_filetype]
        ADR     R0, MessagesBlock
        ADD     R2, R1, #msDataTransfer_filename
        ADR     R1, ClipboardToken
        MOV     R3, #?PollBlock-msDataTransfer_filename
        SWI     MessageTrans_Lookup
        MOV     R14, #0
        STRB    R14, [R1]
        ADR     R1, PollBlock            ; get R1 back...
        ADD     R0, R3, #msDataTransfer_filename+1+3
        BIC     R0, R0, #3
        STR     R0, [R1, #ms_size]
        MOV     R0, #User_Message_Recorded
        LDR     R2, [R1, #ms_taskhandle]
        SWI     Wimp_SendMessage
        MOV     R0, #MsgState_DataSave
        STR     R0, MsgState
        MOV     R0, #0
        STR     R0, TransferCount
        B       PollLoop
a492 19
ClipboardToken
        =       "Clipboard", 0
        ALIGN

;
; Message_RAMFetch - yo ho ho, lets transfer some data...
;
RAMFetch
        LDR     R0, MsgState
        TEQ     R0, #MsgState_DataSave
        TEQNES  R0, #MsgState_RAMTransmit
        BNE     PollLoop
        LDR     R7, TransferCount                ; R7 = amount transferred so far
        LDR     R6, [R1, #msRAMTransfer_length]   ; R6 = buffer size
        LDR     R0, ClipboardLen
        SUB     R0, R0, R7                        ; R0 = amount to go
        CMP     R6, R0
        MOVLS   R4, R6                           ; R4 = amount to transfer this go
        MOVHI   R4, R0
d494 6
a499 6
        LDR     R2, [R1, #ms_taskhandle]
        LDR     R3, [R1, #msRAMTransfer_buffer]
        LDR     R0, mytaskhandle
        LDR     R1, ClipboardAddr
        ADD     R1, R1, R7
        SWI     Wimp_TransferBlock
d501 2
a502 2
        ADD     R7, R7, R4
        STR     R7, TransferCount
d504 1
a504 110
        ADR     R1, PollBlock
        MOV     R0, #Message_RAMTransmit
        STR     R0, [R1, #ms_action]
        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        STR     R4, [R1, #msRAMTransfer_length]

        CMP     R4, R6
        MOVEQ   R0, #User_Message_Recorded
        MOVEQ   R5, #MsgState_RAMTransmit
        MOVNE   R0, #User_Message
        MOVNE   R5, #MsgState_None
        LDR     R2, [R1, #ms_taskhandle]
        SWI     Wimp_SendMessage
        STR     R5, MsgState

        B       PollLoop

;
; Message_DataSave - starting to pull in some data for someone...
;
DataSave
        LDR     R0, MsgState
        TEQ     R0, #MsgState_DataRequest
        BNE     PollLoop
        ; Sanity check (we set the icon to our pollblock for some reason...)
        LDR     R0, [R1, #msDataTransfer_icon]
        TEQ     R0, R1
        BNE     PollLoop
        LDR     R0, [R1, #msDataTransfer_filetype]
        STR     R0, GetBufferType
        LDR     R0, [R1, #msDataTransfer_filesize]
        ; So we should hopefully get a single (non-full) transfer, allocate a bigger buffer
        ADD     R0, R0, #4
        ; Ensure a sensible figure between 2K and 1M
        CMP     R0, #2*1024
        MOVLO   R0, #2*1024
        CMP     R0, #1024*1024
        MOVHI   R0, #1024*1024
        STR     R0, GetBufferLen
        STR     R0, TransferBufLen
        STR     R0, [R1, #msRAMTransfer_length]
        ; Get a buffer for us
        Push    "R1"
        MOV     R1, #-1
        BL      AllocMem
        Pull    "R1"
        BVS     PollLoop
        STR     R0, GetBufferAddr
        STR     R0, [R1, #msRAMTransfer_buffer]
        MOV     R0, #28
        STR     R0, [R1, #ms_size]
        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #Message_RAMFetch
        STR     R0, [R1, #ms_action]
        MOV     R0, #User_Message_Recorded
        LDR     R2, [R1, #ms_taskhandle]
        SWI     Wimp_SendMessage
        MOV     R0, #MsgState_RAMFetch
        STR     R0, MsgState
        B       PollLoop

;
; Message_RAMTransmit - pulling data into GetBuffer
;
RAMTransmit ROUT
        LDR     R0, MsgState
        TEQ     R0, #MsgState_RAMFetch
        BNE     PollLoop
        LDR     R0, [R1, #msRAMTransfer_length]
        ; Increment transfer counter
        LDR     R14, TransferCount
        ADD     R14, R14, R0
        STR     R14, TransferCount
        ; Is the buffer full?
        LDR     R2, TransferBufLen
        TEQ     R2, R0
        BNE     %FT50
        ; Buffer is full - we need to allocate more
        LDR     R0, GetBufferAddr
        Push    "R1"
        LDR     R1, GetBufferLen
        MOV     R1, R1, LSL #1
        BL      ExpandMemToR1
        STRVC   R1, GetBufferLen
        Pull    "R1"
        BVS     %FT70
        LDR     R14, TransferCount
        LDR     R2, GetBufferLen
        SUB     R0, R2, R14
        STR     R0, TransferBufLen
        STR     R0, [R1, #msRAMTransfer_length]
        LDR     R2, GetBufferAddr
        ADD     R0, R2, R14
        STR     R0, [R1, #msRAMTransfer_buffer]
        LDR     R0, [R1, #ms_myref]
        STR     R0, [R1, #ms_yourref]
        MOV     R0, #Message_RAMFetch
        STR     R0, [R1, #ms_action]
        MOV     R0, #User_Message_Recorded
        LDR     R2, [R1, #ms_taskhandle]
        SWI     Wimp_SendMessage
        B       PollLoop

        ; Buffer isn't full - we've finished!
50      LDR     R1, TransferCount
        LDR     R0, GetBufferAddr
        BL      ShrinkMemToR1
        LDR     R2, GetBufferType
d506 1
a506 2
        BL      NotifyGetCaller
        B       PollLoop
d508 3
a510 2
70      BL      FreeMem
        B       PollLoop
d512 1
d514 1
d516 3
a518 70
PollWordNonZero
        LDR     R0, EventQueue
        LDR     R14, [R0, #EventType]
        CMP     R14, #Event_FirstUnused
        ADDLO   PC, PC, R14, LSL #2
        B       %FT10
        B       PW_ClaimClipboard
        B       PW_FetchClipboard
        B       PW_SendClipboard
ExitPollWord
        LDR     R0, EventQueue
10      BL      JunkEvent
        STR     R0, EventQueue
        B       PollLoop

;-------------------------------------------------------------------
; Pollword handling routines. Called with
;      R0 -> event
;      R1 -> PollBlock
; Can corrupt R0-R3 and PollBlock, should B ExitPollWord to return
;-------------------------------------------------------------------

;
; Clipboard_Put has been issued and we need to broadcast Message_ClaimEntity
;
PW_ClaimClipboard
        MOV     R0, #User_Message
        ; R1=PollBlock from above
        MOV     R2, #0
        MOV     R14, #24
        STR     R14, [R1, #ms_size]
        STR     R2, [R1, #ms_yourref]
        MOV     R14, #Message_ClaimEntity
        STR     R14, [R1, #ms_action]
        MOV     R14, #4
        STR     R14, [R1, #msClaimEntity_flags]
        SWI     Wimp_SendMessage
        B       ExitPollWord

;
; Clipboard_Get has been issued and we need to broadcast Message_DataRequest
;
PW_FetchClipboard ROUT
        ; R1=PollBlock
        MOV     R2, #0
        STR     R2, [R1, #ms_yourref]
        MOV     R14, #Message_DataRequest
        STR     R14, [R1, #ms_action]
        STR     R2, [R1, #msDataRequest_window]
        ; Sanity check value (just in case)
        STR     R1, [R1, #msDataRequest_internal]
        STR     R2, [R1, #msDataRequest_x]
        STR     R2, [R1, #msDataRequest_y]
        MOV     R14, #4
        STR     R14, [R1, #msDataRequest_flags]
        ; Copy in filetypes from event
        ADD     R14, R0, #EventData
        ADD     R0, R1, #msDataRequest_filetypes
10      LDR     R3, [R14], #4
        STR     R3, [R0], #4
        CMP     R3, #-1
        BNE     %BT10
        ; Fill in the size
        SUB     R14, R0, R1
        STR     R14, [R1, #ms_size]
        MOV     R0, #User_Message
        SWI     Wimp_SendMessage
        ; Note that we're expecting a response
        MOV     R0, #MsgState_DataRequest
        STR     R0, MsgState
d520 1
a520 2
        STR     R0, TransferCount
        B       ExitPollWord
d522 5
a526 19
;
; Clipboard_Get has been issued and we need to notify the task that we have it already!
;
PW_SendClipboard ROUT
        LDR     R0, ClipboardAddr
        LDR     R1, ClipboardLen
        LDR     R2, ClipboardType
        BL      NotifyGetCaller
        B       ExitPollWord

;-------------------------------------------------------------------
; NotifyGetCaller - tell caller of Clipboard_Get that we have the
;                   data
;      R0 -> data
;      R1 = data length
;      R2 = data type
;-------------------------------------------------------------------
NotifyGetCaller ROUT
        Entry   "R0-R3"
a527 14
        LDR     R14, GetData
        AND     R14, R14, #7
        ADD     PC, PC, R14, LSL #2
        NOP
        B       NotifyType0

        ; Call a routine
NotifyType1
        Push    "R12"
        LDR     R2, GetData+4
        LDR     R12, GetData+8
        MOV     R14, PC
        MOV     PC, R2
        Pull    "R12"
a529 24
        ; Send the message
NotifyType0
        ADR     R1, PollBlock
        LDR     R14, =Message_ClipboardFetched
        STR     R14, [R1, #ms_action]
        ; Fill in reference value
        LDR     R14, GetData+4
        STR     R14, [R1, #ms_data]
        ; Fill in buffer address
        STR     R0, [R1, #ms_data+4]
        ; Fill in length
        LDR     R14, TransferCount
        STR     R14, [R1, #ms_data+8]
        ; Fill in type
        LDR     R14, GetBufferType
        STR     R14, [R1, #ms_data+12]
        MOV     R14, #0
        STR     R14, [R1, #ms_yourref]
        MOV     R14, #28
        STR     R14, [R1, #ms_size]
        MOV     R0, #User_Message_Recorded
        LDR     R2, GetData+8
        SWI     Wimp_SendMessage
        EXIT
@


1.2
log
@Expanded tabs.

Version 0.01. Not tagged
@
text
@a28 8
CantStart
        addr    R0,ErrorBlock_CantStartClipboard
        MOV     R1,#0
        ADR     R2,PollBlock
        MOV     R3,#?PollBlock
        addr    R4,Title
        SWI     MessageTrans_ErrorLookup

d30 8
a37 7
        ; Check we've been started properly
        LDR     R12,[R12]
        LDR     R1,mytaskhandle
        CMPS    R1,#-1
        BNE     CantStart
        LDR     R2,mystack
        TEQS    R2,#0
d40 2
a41 2
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#UserStackSize
d43 1
a43 1
        STR     R2,mystack
d45 5
a49 5
01      ADD     R13,R2,#UserStackSize
        ADR     R0,MessagesBlock
        ADR     R1,ClipboardText
        ADR     R2,PollBlock
        MOV     R3,#?PollBlock
d52 3
a54 4
        MOV     R0,#300
        ADD     R0,R0,#67
        LDR     R1,TASK
        ADR     R3,MessagesList
d56 1
a56 1
        STR     R1,mytaskhandle
d61 3
a63 4
        MOV     R0,#null_bit
        ORR     R0,R0,#pollword_enable
        ADR     R1,PollBlock
        ADR     R3,EventQueue
d65 2
a66 5
        CMPS    R0,#19
        ADDLS   PC,PC,R0,LSL #2
        B       PollLoop
        B       PollLoop
        B       PollLoop
d68 1
d75 2
d87 1
a87 1
        B       PollLoop
d90 2
a91 2
        LDR     R0,[R1,#ms_action]
        TEQS    R0,#Message_Quit
d93 1
a93 1
        TEQS    R0,#Message_ClaimEntity
d95 1
a95 1
        TEQS    R0,#Message_DataRequest
d97 1
a97 1
        TEQS    R0,#Message_RAMFetch
d99 1
a99 1
        TEQS    R0,#Message_RAMTransmit
d101 1
a101 1
        TEQS    R0,#Message_DataSave
d106 2
a107 2
        LDR     R0,mytaskhandle
        LDR     R1,TASK
d109 2
a110 2
        MOV     R0,#0
        STR     R0,mytaskhandle
d117 2
a118 2
        LDR     R0,[R1,#msClaimEntity_flags]
        TSTS    R0,#4
d120 3
a122 3
        LDR     R0,[R1,#ms_taskhandle]
        LDR     R14,mytaskhandle
        TEQS    R0,R14                  ; ignore our broadcasts...
d130 2
a131 2
        LDR     R0,[R1,#msDataRequest_flags]
        TSTS    R0,#4
d134 3
a136 3
        LDR     R0,[R1,#ms_taskhandle]
        LDR     R14,mytaskhandle
        TEQS    R0,R14
d139 2
a140 2
        LDR     R0,ClipboardAddr
        TEQS    R0,#0
d143 12
a154 12
        MOV     R0,#Message_DataSave
        STR     R0,[R1,#ms_action]
        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]
        LDR     R0,ClipboardLen
        LDR     R14,ClipboardType
        STR     R0,[R1,#msDataTransfer_filesize]
        STR     R14,[R1,#msDataTransfer_filetype]
        ADR     R0,MessagesBlock
        ADD     R2,R1,#msDataTransfer_filename
        ADR     R1,ClipboardToken
        MOV     R3,#?PollBlock-msDataTransfer_filename
d156 8
a163 8
        MOV     R14,#0
        STRB    R14,[R1]
        ADR     R1,PollBlock            ; get R1 back...
        ADD     R0,R3,#msDataTransfer_filename+1+3
        BIC     R0,R0,#3
        STR     R0,[R1,#ms_size]
        MOV     R0,#User_Message_Recorded
        LDR     R2,[R1,#ms_taskhandle]
d165 4
a168 4
        MOV     R0,#MsgState_DataSave
        STR     R0,MsgState
        MOV     R0,#0
        STR     R0,TransferCount
d179 3
a181 3
        LDR     R0,MsgState
        TEQS    R0,#MsgState_DataSave
        TEQNES  R0,#MsgState_RAMTransmit
d183 13
a195 13
        LDR     R7,TransferCount                ; R7 = amount transferred so far
        LDR     R6,[R1,#msRAMTransfer_length]   ; R6 = buffer size
        LDR     R0,ClipboardLen
        SUB     R0,R0,R7                        ; R0 = amount to go
        CMPS    R6,R0
        MOVLS   R4,R6                           ; R4 = amount to transfer this go
        MOVHI   R4,R0

        LDR     R2,[R1,#ms_taskhandle]
        LDR     R3,[R1,#msRAMTransfer_buffer]
        LDR     R0,mytaskhandle
        LDR     R1,ClipboardAddr
        ADD     R1,R1,R7
d198 2
a199 2
        ADD     R7,R7,R4
        STR     R7,TransferCount
d201 13
a213 13
        ADR     R1,PollBlock
        MOV     R0,#Message_RAMTransmit
        STR     R0,[R1,#ms_action]
        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]
        STR     R4,[R1,#msRAMTransfer_length]

        CMP     R4,R6
        MOVEQ   R0,#User_Message_Recorded
        MOVEQ   R5,#MsgState_RAMTransmit
        MOVNE   R0,#User_Message
        MOVNE   R5,#MsgState_None
        LDR     R2,[R1,#ms_taskhandle]
d215 1
a215 1
        STR     R5,MsgState
d223 2
a224 2
        LDR     R0,MsgState
        TEQS    R0,#MsgState_DataRequest
d227 2
a228 2
        LDR     R0,[R1,#msDataTransfer_icon]
        TEQS    R0,R1
d230 3
a232 3
        LDR     R0,[R1,#msDataTransfer_filetype]
        STR     R0,GetBufferType
        LDR     R0,[R1,#msDataTransfer_filesize]
d234 1
a234 1
        ADD     R0,R0,#4
d236 7
a242 7
        CMPS    R0,#2*1024
        MOVLO   R0,#2*1024
        CMPS    R0,#1024*1024
        MOVHI   R0,#1024*1024
        STR     R0,GetBufferLen
        STR     R0,TransferBufLen
        STR     R0,[R1,#msRAMTransfer_length]
d245 1
a245 1
        MOV     R1,#-1
d249 10
a258 10
        STR     R0,GetBufferAddr
        STR     R0,[R1,#msRAMTransfer_buffer]
        MOV     R0,#28
        STR     R0,[R1,#ms_size]
        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]
        MOV     R0,#Message_RAMFetch
        STR     R0,[R1,#ms_action]
        MOV     R0,#User_Message_Recorded
        LDR     R2,[R1,#ms_taskhandle]
d260 2
a261 2
        MOV     R0,#MsgState_RAMFetch
        STR     R0,MsgState
d268 2
a269 2
        LDR     R0,MsgState
        TEQS    R0,#MsgState_RAMFetch
d271 1
a271 1
        LDR     R0,[R1,#msRAMTransfer_length]
d273 3
a275 3
        LDR     R14,TransferCount
        ADD     R14,R14,R0
        STR     R14,TransferCount
d277 2
a278 2
        LDR     R2,TransferBufLen
        TEQS    R2,R0
d281 1
a281 1
        LDR     R0,GetBufferAddr
d283 2
a284 2
        LDR     R1,GetBufferLen
        MOV     R1,R1,LSL #1
d286 1
a286 1
        STRVC   R1,GetBufferLen
d289 14
a302 14
        LDR     R14,TransferCount
        LDR     R2,GetBufferLen
        SUB     R0,R2,R14
        STR     R0,TransferBufLen
        STR     R0,[R1,#msRAMTransfer_length]
        LDR     R2,GetBufferAddr
        ADD     R0,R2,R14
        STR     R0,[R1,#msRAMTransfer_buffer]
        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]
        MOV     R0,#Message_RAMFetch
        STR     R0,[R1,#ms_action]
        MOV     R0,#User_Message_Recorded
        LDR     R2,[R1,#ms_taskhandle]
d307 2
a308 2
50      LDR     R1,TransferCount
        LDR     R0,GetBufferAddr
d310 1
a310 1
        LDR     R2,GetBufferType
d321 4
a324 4
        LDR     R0,EventQueue
        LDR     R14,[R0,#EventType]
        CMPS    R14,#Event_FirstUnused
        ADDLO   PC,PC,R14,LSL #2
d330 1
a330 1
        LDR     R0,EventQueue
d332 1
a332 1
        STR     R0,EventQueue
d346 1
a346 1
        MOV     R0,#User_Message
d348 8
a355 8
        MOV     R2,#0
        MOV     R14,#24
        STR     R14,[R1,#ms_size]
        STR     R2,[R1,#ms_yourref]
        MOV     R14,#Message_ClaimEntity
        STR     R14,[R1,#ms_action]
        MOV     R14,#4
        STR     R14,[R1,#msClaimEntity_flags]
d364 5
a368 5
        MOV     R2,#0
        STR     R2,[R1,#ms_yourref]
        MOV     R14,#Message_DataRequest
        STR     R14,[R1,#ms_action]
        STR     R2,[R1,#msDataRequest_window]
d370 5
a374 5
        STR     R1,[R1,#msDataRequest_internal]
        STR     R2,[R1,#msDataRequest_x]
        STR     R2,[R1,#msDataRequest_y]
        MOV     R14,#4
        STR     R14,[R1,#msDataRequest_flags]
d376 5
a380 5
        ADD     R14,R0,#EventData
        ADD     R0,R1,#msDataRequest_filetypes
10      LDR     R3,[R14],#4
        STR     R3,[R0],#4
        CMPS    R3,#-1
d383 3
a385 3
        SUB     R14,R0,R1
        STR     R14,[R1,#ms_size]
        MOV     R0,#User_Message
d388 4
a391 4
        MOV     R0,#MsgState_DataRequest
        STR     R0,MsgState
        MOV     R0,#0
        STR     R0,TransferCount
d398 3
a400 3
        LDR     R0,ClipboardAddr
        LDR     R1,ClipboardLen
        LDR     R2,ClipboardType
d414 3
a416 3
        LDR     R14,GetData
        AND     R14,R14,#7
        ADD     PC,PC,R14,LSL #2
d423 4
a426 4
        LDR     R2,GetData+4
        LDR     R12,GetData+8
        MOV     LR,PC
        MOV     PC,R2
d432 3
a434 3
        ADR     R1,PollBlock
        LDR     R14,=Message_ClipboardFetched
        STR     R14,[R1,#ms_action]
d436 2
a437 2
        LDR     R14,GetData+4
        STR     R14,[R1,#ms_data]
d439 1
a439 1
        STR     R0,[R1,#ms_data+4]
d441 2
a442 2
        LDR     R14,TransferCount
        STR     R14,[R1,#ms_data+8]
d444 8
a451 8
        LDR     R14,GetBufferType
        STR     R14,[R1,#ms_data+12]
        MOV     R14,#0
        STR     R14,[R1,#ms_yourref]
        MOV     R14,#28
        STR     R14,[R1,#ms_size]
        MOV     R0,#User_Message_Recorded
        LDR     R2,GetData+8
@


1.1
log
@Initial revision
@
text
@d16 2
a17 2
	=	"_TaskName", 0
	ALIGN
d20 8
a27 8
	&	Message_DataSave
	&	Message_DataSaveAck
	&	Message_DataLoadAck
	&	Message_RAMFetch
	&	Message_RAMTransmit
	&	Message_ClaimEntity
	&	Message_DataRequest
	&	0
d30 6
a35 6
	addr	R0,ErrorBlock_CantStartClipboard
	MOV	R1,#0
	ADR	R2,PollBlock
	MOV	R3,#?PollBlock
	addr	R4,Title
	SWI	MessageTrans_ErrorLookup
d38 28
a65 28
	; Check we've been started properly
	LDR	R12,[R12]
	LDR	R1,mytaskhandle
	CMPS	R1,#-1
	BNE	CantStart
	LDR	R2,mystack
	TEQS	R2,#0
	BNE	%FT01
	; Claim ourselves a stack
	MOV	R0,#ModHandReason_Claim
	MOV	R3,#UserStackSize
	SWI	OS_Module
	STR	R2,mystack
	; Find our task name
01	ADD	R13,R2,#UserStackSize
	ADR	R0,MessagesBlock
	ADR	R1,ClipboardText
	ADR	R2,PollBlock
	MOV	R3,#?PollBlock
	SWI	MessageTrans_Lookup		; R2->task name
	; Initialise the Wimp
	MOV	R0,#300
	ADD	R0,R0,#67
	LDR	R1,TASK
	ADR	R3,MessagesList
	SWI	Wimp_Initialise
	STR	R1,mytaskhandle
	BL	InstallHandlers
d67 1
a67 1
	; Enter the poll loop
d69 28
a96 28
	MOV	R0,#null_bit
	ORR	R0,R0,#pollword_enable
	ADR	R1,PollBlock
	ADR	R3,EventQueue
	SWI	Wimp_Poll
	CMPS	R0,#19
	ADDLS	PC,PC,R0,LSL #2
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	PollWordNonZero
	B	PollLoop
	B	PollLoop
	B	PollLoop
	B	UserMessage
	B	UserMessage
	B	PollLoop
d99 14
a112 14
	LDR	R0,[R1,#ms_action]
	TEQS	R0,#Message_Quit
	BEQ	Quit
	TEQS	R0,#Message_ClaimEntity
	BEQ	ClaimEntity
	TEQS	R0,#Message_DataRequest
	BEQ	DataRequest
	TEQS	R0,#Message_RAMFetch
	BEQ	RAMFetch
	TEQS	R0,#Message_RAMTransmit
	BEQ	RAMTransmit
	TEQS	R0,#Message_DataSave
	BEQ	DataSave
	B	PollLoop
d115 6
a120 6
	LDR	R0,mytaskhandle
	LDR	R1,TASK
	SWI	Wimp_CloseDown
	MOV	R0,#0
	STR	R0,mytaskhandle
	SWI	OS_Exit
d126 8
a133 8
	LDR	R0,[R1,#msClaimEntity_flags]
	TSTS	R0,#4
	BEQ	PollLoop
	LDR	R0,[R1,#ms_taskhandle]
	LDR	R14,mytaskhandle
	TEQS	R0,R14			; ignore our broadcasts...
	BLNE	FreeClipboard
	B	PollLoop
d139 40
a178 40
	LDR	R0,[R1,#msDataRequest_flags]
	TSTS	R0,#4
	BEQ	PollLoop

	LDR	R0,[R1,#ms_taskhandle]
	LDR	R14,mytaskhandle
	TEQS	R0,R14
	BEQ	PollLoop

	LDR	R0,ClipboardAddr
	TEQS	R0,#0
	BEQ	PollLoop

	MOV	R0,#Message_DataSave
	STR	R0,[R1,#ms_action]
	LDR	R0,[R1,#ms_myref]
	STR	R0,[R1,#ms_yourref]
	LDR	R0,ClipboardLen
	LDR	R14,ClipboardType
	STR	R0,[R1,#msDataTransfer_filesize]
	STR	R14,[R1,#msDataTransfer_filetype]
	ADR	R0,MessagesBlock
	ADD	R2,R1,#msDataTransfer_filename
	ADR	R1,ClipboardToken
	MOV	R3,#?PollBlock-msDataTransfer_filename
	SWI	MessageTrans_Lookup
	MOV	R14,#0
	STRB	R14,[R1]
	ADR	R1,PollBlock		; get R1 back...
	ADD	R0,R3,#msDataTransfer_filename+1+3
	BIC	R0,R0,#3
	STR	R0,[R1,#ms_size]
	MOV	R0,#User_Message_Recorded
	LDR	R2,[R1,#ms_taskhandle]
	SWI	Wimp_SendMessage
	MOV	R0,#MsgState_DataSave
	STR	R0,MsgState
	MOV	R0,#0
	STR	R0,TransferCount
	B	PollLoop
d181 2
a182 2
	=	"Clipboard", 0
	ALIGN
d188 37
a224 37
	LDR	R0,MsgState
	TEQS	R0,#MsgState_DataSave
	TEQNES	R0,#MsgState_RAMTransmit
	BNE	PollLoop
	LDR	R7,TransferCount		; R7 = amount transferred so far
	LDR	R6,[R1,#msRAMTransfer_length]	; R6 = buffer size
	LDR	R0,ClipboardLen
	SUB	R0,R0,R7			; R0 = amount to go
	CMPS	R6,R0
	MOVLS	R4,R6				; R4 = amount to transfer this go
	MOVHI	R4,R0

	LDR	R2,[R1,#ms_taskhandle]
	LDR	R3,[R1,#msRAMTransfer_buffer]
	LDR	R0,mytaskhandle
	LDR	R1,ClipboardAddr
	ADD	R1,R1,R7
	SWI	Wimp_TransferBlock

	ADD	R7,R7,R4
	STR	R7,TransferCount

	ADR	R1,PollBlock
	MOV	R0,#Message_RAMTransmit
	STR	R0,[R1,#ms_action]
	LDR	R0,[R1,#ms_myref]
	STR	R0,[R1,#ms_yourref]
	STR	R4,[R1,#msRAMTransfer_length]

	CMP	R4,R6
	MOVEQ	R0,#User_Message_Recorded
	MOVEQ	R5,#MsgState_RAMTransmit
	MOVNE	R0,#User_Message
	MOVNE	R5,#MsgState_None
	LDR	R2,[R1,#ms_taskhandle]
	SWI	Wimp_SendMessage
	STR	R5,MsgState
d226 1
a226 1
	B	PollLoop
d232 40
a271 40
	LDR	R0,MsgState
	TEQS	R0,#MsgState_DataRequest
	BNE	PollLoop
	; Sanity check (we set the icon to our pollblock for some reason...)
	LDR	R0,[R1,#msDataTransfer_icon]
	TEQS	R0,R1
	BNE	PollLoop
	LDR	R0,[R1,#msDataTransfer_filetype]
	STR	R0,GetBufferType
	LDR	R0,[R1,#msDataTransfer_filesize]
	; So we should hopefully get a single (non-full) transfer, allocate a bigger buffer
	ADD	R0,R0,#4
	; Ensure a sensible figure between 2K and 1M
	CMPS	R0,#2*1024
	MOVLO	R0,#2*1024
	CMPS	R0,#1024*1024
	MOVHI	R0,#1024*1024
	STR	R0,GetBufferLen
	STR	R0,TransferBufLen
	STR	R0,[R1,#msRAMTransfer_length]
	; Get a buffer for us
	Push	"R1"
	MOV	R1,#-1
	BL	AllocMem
	Pull	"R1"
	BVS	PollLoop
	STR	R0,GetBufferAddr
	STR	R0,[R1,#msRAMTransfer_buffer]
	MOV	R0,#28
	STR	R0,[R1,#ms_size]
	LDR	R0,[R1,#ms_myref]
	STR	R0,[R1,#ms_yourref]
	MOV	R0,#Message_RAMFetch
	STR	R0,[R1,#ms_action]
	MOV	R0,#User_Message_Recorded
	LDR	R2,[R1,#ms_taskhandle]
	SWI	Wimp_SendMessage
	MOV	R0,#MsgState_RAMFetch
	STR	R0,MsgState
	B	PollLoop
d277 43
a319 43
	LDR	R0,MsgState
	TEQS	R0,#MsgState_RAMFetch
	BNE	PollLoop
	LDR	R0,[R1,#msRAMTransfer_length]
	; Increment transfer counter
	LDR	R14,TransferCount
	ADD	R14,R14,R0
	STR	R14,TransferCount
	; Is the buffer full?
	LDR	R2,TransferBufLen
	TEQS	R2,R0
	BNE	%FT50
	; Buffer is full - we need to allocate more
	LDR	R0,GetBufferAddr
	Push	"R1"
	LDR	R1,GetBufferLen
	MOV	R1,R1,LSL #1
	BL	ExpandMemToR1
	STRVC	R1,GetBufferLen
	Pull	"R1"
	BVS	%FT70
	LDR	R14,TransferCount
	LDR	R2,GetBufferLen
	SUB	R0,R2,R14
	STR	R0,TransferBufLen
	STR	R0,[R1,#msRAMTransfer_length]
	LDR	R2,GetBufferAddr
	ADD	R0,R2,R14
	STR	R0,[R1,#msRAMTransfer_buffer]
	LDR	R0,[R1,#ms_myref]
	STR	R0,[R1,#ms_yourref]
	MOV	R0,#Message_RAMFetch
	STR	R0,[R1,#ms_action]
	MOV	R0,#User_Message_Recorded
	LDR	R2,[R1,#ms_taskhandle]
	SWI	Wimp_SendMessage
	B	PollLoop

	; Buffer isn't full - we've finished!
50	LDR	R1,TransferCount
	LDR	R0,GetBufferAddr
	BL	ShrinkMemToR1
	LDR	R2,GetBufferType
d321 2
a322 2
	BL	NotifyGetCaller
	B	PollLoop
d324 2
a325 2
70	BL	FreeMem
	B	PollLoop
d330 8
a337 8
	LDR	R0,EventQueue
	LDR	R14,[R0,#EventType]
	CMPS	R14,#Event_FirstUnused
	ADDLO	PC,PC,R14,LSL #2
	B	%FT10
	B	PW_ClaimClipboard
	B	PW_FetchClipboard
	B	PW_SendClipboard
d339 4
a342 4
	LDR	R0,EventQueue
10	BL	JunkEvent
	STR	R0,EventQueue
	B	PollLoop
d355 12
a366 12
	MOV	R0,#User_Message
	; R1=PollBlock from above
	MOV	R2,#0
	MOV	R14,#24
	STR	R14,[R1,#ms_size]
	STR	R2,[R1,#ms_yourref]
	MOV	R14,#Message_ClaimEntity
	STR	R14,[R1,#ms_action]
	MOV	R14,#4
	STR	R14,[R1,#msClaimEntity_flags]
	SWI	Wimp_SendMessage
	B	ExitPollWord
d372 30
a401 30
	; R1=PollBlock
	MOV	R2,#0
	STR	R2,[R1,#ms_yourref]
	MOV	R14,#Message_DataRequest
	STR	R14,[R1,#ms_action]
	STR	R2,[R1,#msDataRequest_window]
	; Sanity check value (just in case)
	STR	R1,[R1,#msDataRequest_internal]
	STR	R2,[R1,#msDataRequest_x]
	STR	R2,[R1,#msDataRequest_y]
	MOV	R14,#4
	STR	R14,[R1,#msDataRequest_flags]
	; Copy in filetypes from event
	ADD	R14,R0,#EventData
	ADD	R0,R1,#msDataRequest_filetypes
10	LDR	R3,[R14],#4
	STR	R3,[R0],#4
	CMPS	R3,#-1
	BNE	%BT10
	; Fill in the size
	SUB	R14,R0,R1
	STR	R14,[R1,#ms_size]
	MOV	R0,#User_Message
	SWI	Wimp_SendMessage
	; Note that we're expecting a response
	MOV	R0,#MsgState_DataRequest
	STR	R0,MsgState
	MOV	R0,#0
	STR	R0,TransferCount
	B	ExitPollWord
d407 5
a411 5
	LDR	R0,ClipboardAddr
	LDR	R1,ClipboardLen
	LDR	R2,ClipboardType
	BL	NotifyGetCaller
	B	ExitPollWord
d421 1
a421 1
	Entry	"R0-R3"
d423 5
a427 5
	LDR	R14,GetData
	AND	R14,R14,#7
	ADD	PC,PC,R14,LSL #2
	NOP
	B	NotifyType0
d429 1
a429 1
	; Call a routine
d431 7
a437 7
	Push	"R12"
	LDR	R2,GetData+4
	LDR	R12,GetData+8
	MOV	LR,PC
	MOV	PC,R2
	Pull	"R12"
	EXIT
d439 1
a439 1
	; Send the message
d441 22
a462 22
	ADR	R1,PollBlock
	LDR	R14,=Message_ClipboardFetched
	STR	R14,[R1,#ms_action]
	; Fill in reference value
	LDR	R14,GetData+4
	STR	R14,[R1,#ms_data]
	; Fill in buffer address
	STR	R0,[R1,#ms_data+4]
	; Fill in length
	LDR	R14,TransferCount
	STR	R14,[R1,#ms_data+8]
	; Fill in type
	LDR	R14,GetBufferType
	STR	R14,[R1,#ms_data+12]
	MOV	R14,#0
	STR	R14,[R1,#ms_yourref]
	MOV	R14,#28
	STR	R14,[R1,#ms_size]
	MOV	R0,#User_Message_Recorded
	LDR	R2,GetData+8
	SWI	Wimp_SendMessage
	EXIT
d464 1
a464 1
	END
@


1.1.1.1
log
@Initial import: Kevin's original version.
@
text
@@

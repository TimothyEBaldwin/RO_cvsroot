head	4.19;
access;
symbols
	Manager-0_57:4.19
	Manager-0_56:4.18
	Manager-0_55:4.17
	Manager-0_54:4.16
	Manager-0_53:4.16
	Manager-0_52:4.16
	Manager-0_51:4.16
	Manager-0_50:4.16
	Manager-0_49:4.16
	Manager-0_48:4.15
	Manager-0_47:4.15
	Manager-0_46:4.14
	Manager-0_45:4.14
	Manager-0_44:4.14
	Manager-0_43:4.13
	RO_5_07:4.13
	Manager-0_42:4.13
	Manager-0_41:4.12
	Manager-0_40:4.12
	Manager-0_39:4.11
	Manager-0_38:4.10
	Manager-0_37:4.10
	dellis_autobuild_BaseSW:4.10
	Manager-0_36:4.10
	sbrodie_sedwards_16Mar2000:4.9
	dcotton_autobuild_BaseSW:4.12
	Manager-0_35:4.9
	Manager-0_34:4.8
	Manager-0_33:4.7
	Manager-0_32:4.6
	Manager-0_31:4.5
	Manager-0_30:4.4
	Manager-0_29:4.4
	Manager-0_28:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1.2.1
	Ursula_RiscPC:4.1.4.1.0.2
	Manager-0_27:4.2
	Ursula_merge:4.1.4.1
	nicke_TerrManager-0_24:4.1.7.1
	bavison_TerritoryManager-0_26:4.1.4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.19
date	2017.11.12.18.16.47;	author jlee;	state Exp;
branches;
next	4.18;
commitid	nbYj7G6x5Rdm8MeA;

4.18
date	2015.01.16.00.39.07;	author jlee;	state Exp;
branches;
next	4.17;
commitid	lrLUmP7tTRheqb6y;

4.17
date	2013.03.09.15.53.40;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	TAx7w6YFEMz6h8Hw;

4.16
date	2012.06.08.17.44.10;	author bavison;	state Exp;
branches;
next	4.15;
commitid	j0IrLQ3Zff15HV7w;

4.15
date	2012.05.28.17.45.25;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	3IFk2KVqvs8f3w6w;

4.14
date	2012.02.20.21.44.02;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	42AbPoCtGtUswWTv;

4.13
date	2002.12.12.11.15.47;	author rsprowson;	state Exp;
branches;
next	4.12;

4.12
date	2001.03.19.15.32.39;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	2001.03.01.15.17.06;	author sforrest;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.28.14.48.47;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.08.24.12.17.50;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.04.19.12.33.52;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.01.21.09.32.26;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.01.20.17.15.00;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.01.20.13.58.27;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.01.14.17.30.31;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.01.07.13.31.53;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.19.11.37.55;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.40.30;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.40.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.56.01;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.04.14.14.40.29;	author mstphens;	state Exp;
branches
	4.1.4.1.2.1;
next	;

4.1.4.1.2.1
date	98.11.20.20.09.37;	author aglover;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.45.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.00.54;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.19
log
@Re-evaluate AutoDST state when RTC is synchronised
Detail:
  s/Daylight, s/ModHead - On Service_RTCSynchronised, re-evaluate the current DST state if AutoDST is enabled. Should help ensure that the DST state remains correct whenever OS_ResyncTime is used to reset the soft RTC.
Admin:
  Tested in Iyonix ROM image


Version 0.57. Tagged as 'Manager-0_57'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.ModHead

        ENTRY

        ASSERT  (.=Module_BaseAddr)
MySWIBase       *       Module_SWISystemBase + TerritorySWI * Module_SWIChunkSize


        DCD     0
        DCD     Init           - Module_BaseAddr
        DCD     Die            - Module_BaseAddr
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Commands       - Module_BaseAddr
        DCD     MySWIBase
        DCD     Territory_SWIdecode - Module_BaseAddr
        DCD     Territory_SWInames  - Module_BaseAddr
        DCD     0
      [ international_help
        DCD     message_filename - Module_BaseAddr
      |
        DCD     0
      ]
      [ :LNOT:No32bitCode
        DCD     MyFlags        - Module_BaseAddr
      ]

Title   DCB     "TerritoryManager",0
Helpstr DCB     "Territory Mgr",9,"$Module_HelpVersion", 0
        ALIGN
      [ :LNOT:No32bitCode
MyFlags
        DCD     ModuleFlag_32bit
      ]

;-----------------------------------------------------------------------------
; Handle *Territory
; Entry:  R0-> command tail => *Territory <number>
;         R1 = number of parameters
;
Territory_Code

        Push    "LR"
        LDR     r12,[r12]

        TEQ     R1,#0                   ; just *Territory?
        BNE     %FT50                   ; [no, so we're setting it]

        ; print current territory to screen

        LDR     r0,configured_territory
        ADR     r1,scratch_buffer
        MOV     r2,#?scratch_buffer
        SWI     XTerritory_NumberToName
        LDRVS   r0,configured_territory
        SWIVS   XOS_ConvertCardinal1
        Pull    "PC",VS
        ADR     r0, scratch_buffer
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        Pull    "PC"

50
        MOV     R1,R0                   ; R1 --> string
        MOV     r0, #-1
        SWI     XTerritory_NameToNumber
        Pull    "PC",VS
        TEQ     r0, #0
        BNE     %FT10

        MOV     R0,#&C000000A           ; base 10, check terminator, <= 255
        SWI     XOS_ReadUnsigned
        Pull    "PC",VS
01
        LDRB    R14,[R1],#1             ; check that nothing else follows
        CMP     R14,#' '
        BEQ     %BT01
        MOVHI   R0,#3                   ; "Too many parameters"
        SETV    HI
        Pull    "PC",VS
        MOV     r0, r2
10
        SWI     XTerritory_Select
        Pull    "PC"

;-----------------------------------------------------------------------------
;       Handle *Territories
;
Territories_Code
        Push    "LR"


        ; Print numbers and names of loaded territories.

        LDR     r12,[r12]
        ADR     r3,territories
01
        LDR     r3,[r3,#next_ptr]
        CMP     r3,#0
        BEQ     %FT02

        LDR     r0,[r3,#t_number]
        ADR     r1,scratch_buffer
        MOV     r2,#?scratch_buffer
        SWI     XOS_ConvertCardinal4

        SWI     XOS_Write0
        SWI     XOS_WriteI+32

        LDR     r0,[r3,#t_number]
        ADR     r1,scratch_buffer
        MOV     r2,#?scratch_buffer
        SWI     XTerritory_NumberToName
        ADRVC   r0, scratch_buffer
        SWIVC   XOS_Write0
        ADRVS   r0, unused_token
        BLVS    message_write0

        SWI     XOS_NewLine

        B       %BT01

02
        CLRV
        Pull    "PC"

unused_token
        DCB     "Unused", 0
        ALIGN

;-----------------------------------------------------------------------------
; Handle *Configure Territory
; Entry:  R0=0 => print syntax message only
;         R0=1 => *Status Territory was typed - print out value
;         R0-> command tail => *Configure Territory <number>
; Exit:   if *configure, CMOS RAM configured
;
TerritoryC_Code

        Push    "r1,r12,LR"
        LDR     r12,[r12]

        CMP     r0,#1
        BEQ     printstatus
        BLO     printsyntax

        MOV     R1,R0                   ; R1 --> string
        MOV     r0, #-1
        SWI     XTerritory_NameToNumber
        Pull    "R1,R12,PC",VS
        MOVS    r2, r0
        BNE     gotterritorynumber
        MOV     R0,#&C000000A           ; base 10, check terminator, <= 255
        SWI     XOS_ReadUnsigned
        Pull    "R1,R12,PC",VS

01
        LDRB    R14,[R1],#1             ; check that nothing else follows
        CMP     R14,#' '
        BEQ     %BT01
        MOVHI   R0,#3                   ; "Too many parameters"
        SETV    HI
        Pull    "R1,R12,PC",VS
gotterritorynumber
        EOR     r2,r2,#1                ; Default is 1.

        MOV     R0,#OsByte_WriteCMOS    ; Write the CMOS RAM!
        MOV     R1,#TerritoryCMOS
        SWI     XOS_Byte

        Pull    "R1,R12,PC"

printstatus

        MOV     R0,#OsByte_ReadCMOS
        MOV     R1,#TerritoryCMOS
        SWI     XOS_Byte                        ; R2 = Configured Territory
        SUB     sp,sp,#4
        EORVC   R0,R2,#1                        ; Default is 1.
        MOVVC   R1,sp
        MOVVC   R2,#4
        SWIVC   XOS_ConvertCardinal1            ; print number
        MOVVC   r1, r0
        ADRVC   r0, status_territory_token
        BLVC    message_write0
        SWIVC   XOS_NewLine                     ; followed by NewLine
        ADD     sp,sp,#4

        Pull    "R1,R12,PC"

printsyntax

        ADR     r0,config_territory_token
        BL      message_write0
        SWIVC   XOS_NewLine

        Pull    "R1,R12,PC"

config_territory_token
        DCB     "CTSynt", 0
status_territory_token
        DCB     "CTStat", 0
        ALIGN

;-----------------------------------------------------------------------------
; Handle *Configure DST
; Entry:  R0=0 => print syntax message only
;         R0=1 => *Status DST was typed - print out value
;         R0-> command tail => *Configure DST
; Exit:   if *configure, CMOS RAM configured
;
DST_Code

        Push    "r1,r12,LR"
        LDR     r12,[r12]

        CMP     r0,#1
        BLO     print_DSTsyntax
        BEQ     print_DSTstatus

        MOV     R0,#0                           ; Manual 'on' implicitly
        MOV     R1,#DSTCMOSBit                  ; clears the auto flag
set_dst_bits
        BL      daylight_modify_cmos
        BL      daylight_switch_check
        CLRV                                    ; No errors, *STATUS DST tells
        Pull    "r1,r12,PC"                     ; what's happening

print_DSTsyntax
        ADR     r0,config_DST_token
        BL      message_write0
        SWIVC   XOS_NewLine
        Pull    "r1,r12,PC"

print_DSTstatus
        MOV     R0,#AutoDSTCMOSBit:OR:DSTCMOSBit
        MOV     R1,#0
        BL      daylight_modify_cmos

        TST     R0,#AutoDSTCMOSBit
        ADRNE   R0,st_AUTODST
        BNE     %FT10

        TST     R0,#DSTCMOSBit
        ADREQ   R0,st_NODST
        ADRNE   R0,st_DST
10
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        Pull    "r1,r12,PC"

config_DST_token DCB     "CDSTSyn",0
st_DST           DCB     "DST",0
st_NODST         DCB     "NoDST",0
st_AUTODST       DCB     "AutoDST",0
        ALIGN

;-----------------------------------------------------------------------------
; Handle *Configure AutoDST
; Entry:  R0=0 => print syntax message only  (Ignore)
;         R0=1 => *Status AutoDST was typed  (Ignore)
;         R0-> command tail => *Configure AutoDST
; Exit:   if *configure, CMOS RAM configured
;
AutoDST_Code

        Push    "r1,r12,LR"
        LDR     r12,[r12]

        CMP     r0,#1
        Pull    "r1,r12,PC",LS

        MOV     R0,#DSTCMOSBit                  ; Leave the DST bit alone and
        MOV     R1,#AutoDSTCMOSBit              ; set the auto bit
        B       set_dst_bits

;-----------------------------------------------------------------------------
; Handle *Configure NoDST
; Entry:  R0=0 => print syntax message only  (Ignore)
;         R0=1 => *Status NoDST was typed    (Ignore)
;         R0-> command tail => *Configure NoDST
; Exit:   if *configure, CMOS RAM configured
;
NoDST_Code

        Push    "r1,r12,LR"
        LDR     r12,[r12]

        CMP     r0,#1
        Pull    "r1,r12,PC",LS

        MOV     R0,#0                           ; Manual 'off' implicitly
        MOV     R1,#0                           ; clears the auto flag
        B       set_dst_bits

;-----------------------------------------------------------------------------
; Handle *Configure TimeZone
;
TimeZoneC_Code
        Push    "lr"
        LDR     r12, [r12]

        CMP     r0, #1
        BEQ     timezone_printstatus
        BLO     timezone_printsyntax
        LDRB    r3, [r0]
        CMP     r3, #'-'
        CMPNE   r3, #'+'
        MOVNE   r3, #'+'
        ADDEQ   r0, r0, #1
        MOV     r1, r0
        MOV     r2, #13
        MOV     r0, #10 + (1:SHL:29)
        SWI     XOS_ReadUnsigned
        Pull    "PC", VS
        
        MOV     r4, r2, LSL #2
        LDRB    r5, [r1], #1
        CMP     r5, #':'
        BNE     no_minutes
        ORR     r0, r0, #1:SHL:31
        MOV     r2, #59
        SWI     XOS_ReadUnsigned
        Pull    "PC", VS

        ADD     r2, r2, #3      ; Divide by 15
        ADD     r4, r4, r2, LSR #4
no_minutes
        CMP     r3, #'-'
        RSBEQ   r4, r4, #0
        MOV     r2, r4
        MOV     r0, #OsByte_WriteCMOS
        MOV     r1, #TimeZoneCMOS
        SWI     XOS_Byte

        BL      daylight_switch_check

        Pull    "PC"

timezone_printsyntax
        ADR     r0, timezone_syntax
        BL      message_write0
        B       newline_exit

timezone_printstatus
        MOVVC   r0, #OsByte_ReadCMOS
        MOVVC   r1, #TimeZoneCMOS
        SWIVC   XOS_Byte
        Pull    "PC", VS

        MOV     r0, #'+'
        MOV     r3, r2
        TST     r3, #&80
        RSBNE   r3, r3, #256
        MOVNE   r0, #'-'
        SUB     sp, sp, #8
        STRB    r0, [sp]
        MOVVC   r0, r3, LSR #2
        ADDVC   r1, sp, #1
        MOVVC   r2, #4
        SWIVC   XOS_ConvertCardinal1
        MOVVC   r0, #':'
        STRVCB  r0, [r1], #1
        ANDVC   r3, r3, #3
        RSBVC   r0, r3, r3, LSL #4
        MOVVC   r2, #4
        SWIVC   XOS_ConvertCardinal1
        ADRVC   r0, timezone_status
        MOVVC   r1, sp
        BLVC    message_write0
        ADD     sp, sp, #8
newline_exit
        SWIVC   XOS_NewLine
        Pull    "PC"

timezone_syntax
        DCB     "TZSynt", 0
timezone_status
        DCB     "TZStat", 0
        ALIGN

Commands
      [ international_help
        Command Territory,  1,0,International_Help
        Command Territories,0,0,International_Help
        Command Territory,  1,1,Status_Keyword_Flag :OR: International_Help,TerritoryC
        Command DST,        0,0,Status_Keyword_Flag :OR: International_Help
        Command NoDST,      0,0,Status_Keyword_Flag :OR: International_Help
        Command AutoDST,    0,0,Status_Keyword_Flag :OR: International_Help
        Command TimeZone,   1,1,Status_Keyword_Flag :OR: International_Help,TimeZoneC
        DCB     0

Territories_Help        DCB     "HTRMTTS",0
Territories_Syntax      DCB     "STRMTTS",0
Territory_Help          DCB     "HTRMTTY",0
Territory_Syntax        DCB     "STRMTTY",0
TerritoryC_Help         DCB     "HTRMCTY",0
TerritoryC_Syntax       DCB     "STRMCTY",0
DST_Help
NoDST_Help
AutoDST_Help
                        DCB     "HTRMCDS",0
DST_Syntax
NoDST_Syntax
AutoDST_Syntax
                        DCB     "STRMCDS",0
TimeZoneC_Help          DCB     "HTRMCTZ",0
TimeZoneC_Syntax        DCB     "STRMCTZ",0
      |
        Command Territory,  1,0,0
        Command Territories,0,0,0
        Command Territory,  1,1,Status_Keyword_Flag,TerritoryC
        Command DST,        0,0,Status_Keyword_Flag
        Command NoDST,      0,0,Status_Keyword_Flag
        Command AutoDST,    0,0,Status_Keyword_Flag
        Command TimeZone,   1,1,Status_Keyword_Flag,TimeZoneC
        DCB     0

Territories_Help
        DCB     "*Territories lists the currently loaded territory modules.", 13
Territories_Syntax
        DCB     "Syntax: *Territories", 0
Territory_Help
        DCB     "*Territory sets the current territory.", 13
        DCB     "*Territory with no parameter displays the current territory.", 13
Territory_Syntax
        DCB     "Syntax: *Territory [<Territory Number>]", 0
TerritoryC_Help
        DCB     "*Configure Territory sets the default territory for the machine.", 13
TerritoryC_Syntax
        DCB     "Syntax: *Configure Territory <Territory Number>", 0
DST_Help
NoDST_Help
AutoDST_Help
        DCB     "*Configure DST sets the clock for Daylight Saving Time,", 13
        DCB     "*Configure NoDST sets the clock for Local Standard Time,", 13
        DCB     "*Configure AutoDST leaves the computer to make the decision itself.", 13
DST_Syntax
NoDST_Syntax
AutoDST_Syntax
        DCB     "Syntax: *Configure DST | NoDST | AutoDST", 0
TimeZoneC_Help
        DCB     "*Configure TimeZone sets the time zone as an offset from UTC", 13
TimeZoneC_Syntax
        DCB     "Syntax: *Configure TimeZone [+/-]<Hours>[:<Minutes>]", 0
      ]
        ALIGN

;-----------------------------------------------------------------------------
;       Module initialisation point
;
Init
        Push    "LR"

        ; initialise Territory$Path if not already done

        ADR     r0, Path
        MOV     r2, #-1
        MOV     r3, #0
        MOV     r4, #VarType_Expanded
        SWI     XOS_ReadVarVal
        CMP     r2, #0

        ADREQ   r0, Path
        ADREQL  r1, PathDefault
        MOVEQ   r2, #?PathDefault
        MOVEQ   r3, #0
        MOVEQ   r4, #VarType_String
        SWIEQ   XOS_SetVarVal

        LDR     r2, [r12]
        CMP     r2, #0                  ; clears V
        BNE     %FT01

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =max_running_work
        SWI     XOS_Module
        Pull    "PC",VS

        STR     r2, [r12]
01
        MOV     r12, r2

        ; Clear the territories list.

        MOV     r0,#0
        STR     r0,territories

        ; Read configured territory from CMOS

        MOV     r0,#OsByte_ReadCMOS
        MOV     r1,#TerritoryCMOS
        SWI     XOS_Byte
        MOVVS   r2,#TerritoryNum_UK
        EORVC   r2,r2,#1                        ; Default is UK (1).

        STR     r2,configured_territory

        Debug   xx,"Configured territory is ",r2

        ; Important flags

        MOV     r0, #0
        STRB    r0, message_file_open
        MOV     r0, #-1
        STR     r0, tzone_index
        STRB    r0, last_dst_bits               ; Ensures a service call

        ; Read the static string 'Custom' for Territory_ReadCurrentTimeZone

        ADR     r1, CustomTZ
        ADR     r2, message_custom
        MOV     r3, #?message_custom
        BL      message_lookup
        TEQ     r0, #0
        ASSERT  (:INDEX:message_custom :MOD: 4) = 0
        ASSERT  (({PC} - CustomTZ) :MOD: 4) = 0
        LDMNEIA r1, {r3-r4}                     ; Failed to find, use
        STMNEIA r2, {r3-r4}                     ; the token itself

        ; Set a callback to issue the TerritoryManagerLoaded Service call

        ADR     r0,callback_entry
        MOV     r1,r2
        SWI     XOS_AddCallBack

        Pull    "PC"

Path            DCB     "TerritoryManager$$Path", 0
PathDefault     DCB     "Resources:$.Resources.TerrMgr.", 0
        ALIGN
CustomTZ        DCB     "Custom", 0
        ALIGN

callback_entry
        Push    "r0-r9,LR"

        MOV     R1,#Service_TerritoryManagerLoaded
        SWI     XOS_ServiceCall

        Debug   xx,"Service call issued"

        Pull    "r0-r9,PC"

;-----------------------------------------------------------------------------
;       RMKill'ing the module
;
Die
        LDR     r12, [r12]
        CMP     r12, #0
        MOVEQ   PC, LR

        Push    "lr"

        ; Cancel any pending DST switch
        
        ADRL    r0, daylight_switchover
        MOV     r1, r12
        SWI     XOS_RemoveTickerEvent

        ; Close the message file if open

        LDRB    r0, message_file_open
        CMP     r0, #0
        ADRNE   r0, message_file_block
        SWINE   XMessageTrans_CloseFile
        MOVVC   r0, #0
        STRVCB  r0, message_file_open

        ; Free all module blocks

        LDR     r2, territories
01
        CMP     r2, #0
        BEQ     %FT02
        LDR     r1, [r2,#next_ptr]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     r2, r1
        B       %BT01
02
        CLRV                             ; don't refuse to die
        Pull    "pc"              

;-----------------------------------------------------------------------------
;       Module service entry point
;
        ASSERT  Service_UKWord   < Service_UKConfig
        ASSERT  Service_UKConfig < Service_PostInit
        ASSERT  Service_PostInit < Service_RTCSynchronised
UServTab
        DCD     0                           ;flags
        DCD     UService - Module_BaseAddr
        DCD     Service_UKWord
        DCD     Service_UKConfig
        DCD     Service_PostInit
        DCD     Service_RTCSynchronised
        DCD     0
        DCD     UServTab - Module_BaseAddr  ;anchor
Service
        MOV     r0,r0                       ;magic instruction
        TEQ     r1,#Service_UKWord
        TEQNE   R1,#Service_PostInit
        TEQNE   R1,#Service_UKConfig
        MOVNE   PC,LR
UService
        LDR     R12, [R12]
        CMP     R12, #0
        MOVEQ   PC, LR

        TEQ     R1,#Service_UKWord
        BEQ     svc_UKWord

        TEQ     R1,#Service_PostInit
        BEQ     svc_PostInit

        TEQ     R1,#Service_UKConfig
        BEQ     svc_UKConfig

        TEQ     R1,#Service_RTCSynchronised
        BEQ     svc_RTCSynchronised

        MOV     PC,LR

message_filename
        DCB     "TerritoryManager:Messages",0
        ALIGN

        LTORG

;-----------------------------------------------------------------------------
; Unknown OS_Word. Is it OS_Word 15,5?
;
svc_UKWord
        TEQ     R2,#OsWord_WriteRealTimeClock   ; check it's OS_Word 15
        MOVNE   PC,LR

        LDRB    R1,[R3,#0]                      ; check subreason code
        TEQ     R1,#5
        MOVNE   R1,#Service_UKWord              
        MOVNE   PC,LR

        Push    "LR"                            ; Kernel didn't deal with
        BL      SetTimeTheHardWay               ; OS_Word 15,5 so we will.
        MOVVC   R1,#0
        Pull    "PC"

;-----------------------------------------------------------------------------
; Unknown configuration option, is it the time zone ?
;
svc_UKConfig ROUT
        CMP     R0,#0           ; No syntax to print
        MOVEQ   PC,LR

        Push    "R0-R5,LR"
        MOV     R5,#0           ; Loop over all timezones in this territory
10
        MOV     R0,#-1          ; For configured territory
        MOV     R1,R5
        LDR     R4,=ReadTimeZones_Extension
        SWI     XTerritory_ReadTimeZones
        Pull    "R0-R5,PC",VS   ; Pass on service
20
        ; Try the standard timezone
        Push    "R1"
        LDR     R1,[SP,#4]
        BL      cmp_tz_names
        Pull    "R0"
        MOVEQ   R1,#0           ; Match! NoDST and not auto
        BEQ     %FT30

        ; Try daylight saving timezone
        LDR     R1,[SP,#0]
        BL      cmp_tz_names
        MOVEQ   R1,#DSTCMOSBit  ; Match! DST and not auto
        BEQ     %FT30

        ; Loop if the extended API is supported
        TEQ     R4,#0
        ADDEQ   R5,R5,#1
        BEQ     %BT10
        Pull    "R0-R5,PC"      ; Pass on service
30
        ; Since this command has matched on the territory specific timezone
        ; name this writes the timezone CMOS too.
        ; It also sets/clears the DST flag, and turns off auto DST adjustments.
        MOV     R0,#0
        BL      daylight_modify_cmos

        MOV     R0,#-15*4       ; -15 hrs in 15 minute units
        LDR     R1,=15 * 60 * 100
40
        MUL     R3,R0,R1
        TEQ     R3,R2           ; Equalled the standard time offset in cs?
        BEQ     %FT50
        ADD     R0,R0,#1
        CMP     R0,#15*4        ; +15 hrs in 15 minute units
        BNE     %BT40
50
        MOV     R2,R0
        MOV     R1,#TimeZoneCMOS
        MOV     R0,#OsByte_WriteCMOS
        SWI     XOS_Byte        ; Write back timezone

        BL      daylight_switch_check
        
        ADD     SP,SP,#8
        MOV     R1,#0           ; Claim the service
        MOVVC   R0,#-1          ; No error
        Pull    "R2-R5,PC"

cmp_tz_names ROUT
        Push    "R2,LR"
10
        LDRB    R14,[R1],#1
        CMP     R14,#' '        ; User's string might not be null terminated
        MOVLS   R14,#0
        LDRB    R2,[R0],#1
        EOR     R2,R2,R14
        BICS    R2,R2,#&20      ; Caseless compare
        Pull    "R2,PC",NE      ; No match

        CMP     R14,#0
        BNE     %BT10
        Pull    "R2,PC"         ; Match

;-----------------------------------------------------------------------------
; The following paths are where to look for the configured territory.
;
netfslogon      DCB     "Logon Territory",0
netfsterr_path  DCB     "&.!Territory.Territory",0
netfsmess_path  DCB     "&.!Territory.Messages",0
floppyterr_path DCB     "ADFS::0."
territory_path  DCB     "$.!Territory.Territory",0
floppymess_path DCB     "ADFS::0."
messages_path   DCB     "$.!Territory.Messages",0
sprite_name     DCB     "disc",0
wild_card       DCB     "*",0
                ALIGN
      
svc_PostInit
        ; This is called after all the modules have been initialised.

        Debug   xx,"Post init service call received"

        Push    "r0-r9,LR"

        LDR     r0,configured_territory
        SWI     XTerritory_Exists       ; Chk if configured territory is already loaded.

        BEQ     territory_present       ; Yes, skip loading section.

        Debug   xx,"Configured territory not already loaded"

        Debug   xx,"Chk current filing system."

        MOV     r0,#OSArgs_ReadPTR
        MOV     r1,#0
        SWI     XOS_Args
        MOVVS   r0,#fsnumber_none
        ASSERT  fsnumber_none = 0
        ANDS    r0,r0,#&FF              ; FileSwitch 1.70-2.74 return duff internal value 'Nowt' here

        MOVEQ   r0,#TerritoryNum_UK
        STREQ   r0,configured_territory ; If no selected filing system, go back to English !
        BEQ     territory_present

        Debug   xx,"Number of selected FS ",R0

        ; Check to see if it is netfs

        TEQ     r0,#fsnumber_net
        ADRNEL  R1,territory_path       ; Look for territory on configured device (not NetFS).
        ADRNE   R2,messages_path
        BNE     load_files

        ; Yes, it is netfs.
        Debug   xx,"NetFS"

        ADRL    R0,netfslogon
        SWI     XOS_CLI
        BVS     load_error

        ADR     R1,netfsterr_path       ; Look for territory on NetFS.
        ADRL    R2,netfsmess_path

        ; No errors so far, try and load territory files.
        ; First load the territory module.
        ; Note: R1->territory path
        ;       R2->messages path
load_files
        Debug   xx,"Load files"
        MOV     R0,#ModHandReason_Load
        SWI     XOS_Module
        BVS     load_error

        ; Now load all the messages modules.

        MOV     R1,R2                   ; Copy messages path.
        ADRL    R0,error_buffer
01
        LDRB    R14,[R1],#1
        CMP     R14,#0
        STRNEB  R14,[R0],#1
        BNE     %BT01

        MOV     R14,#'.'
        STRB    R14,[R0],#1

        MOV     R1,R2                   ; R1->messages path
        MOV     R2,R0                   ; Place to put it (R2->end of copied path)
        MOV     R4,#0
        MOV     R5,#?error_buffer
        ADRL    R6,wild_card
01
        MOV     R3,#1
        MOV     R0,#OSGBPB_ReadDirEntries
        SWI     XOS_GBPB
        BVS     load_error
        CMP     R3,#1
        BNE     %FT02                   ; asked for 1 but got none

        MOV     R0,#ModHandReason_Load  ; load the message module
        Push    "R1"
        ADRL    R1,error_buffer
        DebugS  xx,"Loading module ",R1
        SWI     XOS_Module
        Pull    "R1"
        BVS     load_error
02
        CMP     R4,#-1
        BNE     %BT01                   ; Get next module

        ; Modules loaded, now check that configured territory exists.

        LDR     r0,configured_territory
        SWI     XTerritory_Exists         ; Chk if configured territory is already loaded.
        BEQ     territory_present
        MOV     r0,#0                     ; No message ! (falls through)

load_error                                ; Failed to load configured territory.
      [ debugxx
        ADD     R14,R0,#4
        DebugS  xx,"Original error is ",R14
      ]

      [ Embedded_UI

        ; On NC/STB - no way should we be bringing up a floppy picture. Instead, let's take the
        ; territory at the head of the chain (the last registered).

        LDR     r14,territories
        LDR     r0,[r14,#t_number]
        STR     r0,configured_territory

      |

        Push    "R0"                      ; Save error message

        ; Try to put the sprite on the screen.
        
        ; First claim a block big enough to print sprite

        MOV     R0,#8
        MOV     R1,#-1
        SWI     XSquash_Decompress        ; get workspace requirement
        BVS     load_error_message
        LDR     R4,spritedata+4           ; get size of unsquashed file
        ADD     R4,R4,#4                  ; space for size of sprite area

        ADD     R3,R4,R0
        MOV     R0,#ModHandReason_Claim
        SWI     XOS_Module
        BVS     load_error_message
        Push    "R2"

        ; Now decompress the sprite file

        MOV     R0,#0                     ; Buffers will be big enough
        ADD     R1,R2,R4                  ; use space after sprite file buffer
        STR     R4,[R2]                   ; store sprite area size
        SUB     R5,R4,#4
        ADD     R4,R2,#4
        ADR     R2,spritedata + (SpriteAreaCBsize + 4)
        LDR     R3,=endspritedata - spritedata - (SpriteAreaCBsize + 4)
        SWI     XSquash_Decompress
        BVS     load_error_message_free

        ; Now plot the sprite at the middle of the screen

        LDR     R0,=SpriteReason_ReadSpriteSize+&100
        LDR     R1,[SP]                    ; -> sprite area
        ADRL    R2,sprite_name
        SWI     XOS_SpriteOp
        BVS     load_error_message_free

        Push    "r3-r4"
        ADRL    R1,error_buffer
        SWI     XWimp_ReadPalette
        MOVVC   R0,R6
        MOVVC   R2,#-1
        MOVVC   R3,#0
        ADRVCL  R4,error_buffer+40
        SWIVC   XColourTrans_SelectTable
        Pull    "r3-r4"
        BVS     load_error_message_free


        MOV     R0,R6
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        BVS     load_error_message_free
        MOV     R3,R3,ASL R2
        MOV     R3,R3,ASR #1
        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        BVS     load_error_message_free
        MOV     R4,R4,ASL R2
        MOV     R4,R4,ASR #1

        ; R3 = x/2 R4 = y/2
        ; Get size of current mode.

        MOV     R0,#-1
        MOV     R1,#VduExt_XWindLimit
        SWI     XOS_ReadModeVariable
        MOVVC   R5,R2
        MOVVC   R1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        BVS     load_error_message_free
        MOV     R5,R5,ASL R2
        MOV     R5,R5,ASR #1

        MOV     R0,#-1
        MOV     R1,#VduExt_YWindLimit
        SWI     XOS_ReadModeVariable
        MOVVC   R6,R2
        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        BVS     load_error_message_free
        MOV     R6,R6,ASL R2
        MOV     R6,R6,ASR #1

        ; R5 = scx / 2 R6 = scy /2

        SWI     XOS_WriteI+4              ; Split text cursor
        SWIVC   XOS_WriteI+26             ; Restore windows
        SWIVC   XOS_WriteI+20             ; Restore colours
        SWIVC   XOS_WriteI+18             
        SWIVC   XOS_WriteI+00
        SWIVC   XOS_WriteI+128            ; GCOL 0,128
        SWIVC   XOS_WriteI+12             ; CLS
        BVS     load_error_message_free

        LDR     R0,=SpriteReason_PutSpriteScaled+&100
        LDR     R1,[SP]
        ADRL    R2,sprite_name
        SUB     R3,R5,R3
        SUB     R4,R6,R4
        Debug   xx,"Put sprite at ",R3,R4
        MOV     R5,#0
        ADRL    R6,error_buffer
        ADRL    R7,error_buffer+20
        SWI     XWimp_ReadPixTrans
        BVS     %FT01
        ADRL    R7,error_buffer+40
        LDR     R0,=SpriteReason_PutSpriteScaled+&100
        SWIVC   XOS_SpriteOp
01
load_error_message_free

        Pull    "R2"
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module

load_error_message

        MOV     r1, #1
        BL      switch_pointer          ; Ensure pointer is on
        SWI     XOS_Confirm
        TEQNE   r0, #13                 ; Allow confirmation with Return on keyboard
        BL      switch_pointer          ; Restore pointer state
        BLCS    ack_escape              ; If Escape pressed then acknowledge it
        Pull    "R0"
        ADREQL  R1,floppyterr_path      ; Now look for territory on floppy
        ADREQL  R2,floppymess_path
        BEQ     load_files

        MOV     r0, #TerritoryNum_UK
        STR     r0, configured_territory
        SWI     XOS_WriteI+4
        SWI     XOS_WriteI+26
        SWI     XOS_WriteI+12           ; Remove sprite with CLS to black

      ] ; Embedded_UI

territory_present                       
        BL      territory_selected      ; By this stage the configured territory is in memory.

        Pull    "r0-r9,PC"

svc_RTCSynchronised ROUT
        Entry   "r0"
        ; Do an AutoDST check
        BL      daylight_switch_check
        CLRV
        EXIT
        

switch_pointer                          ; Switch pointer based on r1, return old in r1 but preserve flags!
        EntryS
        MOV     r0, #OsByte_SelectPointer
        SWI     XOS_Byte
        EXITS

ack_escape                              ; Acknowledge escape but preserve flags.
        EntryS
        MOV     r0, #OsByte_AcknowledgeEscape
        SWI     XOS_Byte
        EXITS

open_messages_file
        Entry   r0-r2
        LDRB    r0, message_file_open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, message_file_block
        ADRL    r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        MOVVC   r2, #-1
        STRVCB  r2, message_file_open
        EXIT

message_write0 Entry r0-r7
        BL      open_messages_file
        BVS     %F30
        MOV     r1, r0
        ADR     r0, message_file_block
        MOV     r2, #0
        SWI     XMessageTrans_Lookup
        BVS     %F30
        B       %F20
10      LDR     r0, [sp, #4]
        SWI     XOS_Write0
        BVS     %F30
20      LDRB    r0, [r2], #1
        CMP     r0, #'%'
        LDREQB  r0, [r2], #1
        CMPEQ   r0, #'0'
        BEQ     %B10
        CMP     r0, #' '
        EXIT    CC
        SWI     XOS_WriteC
        BVC     %B20
30      STR     r0, [sp]
        EXIT

message_lookup Entry r1-r3
        BL      open_messages_file
        EXIT    VS
        ADR     r0, message_file_block
        SWI     XMessageTrans_Lookup
        MOVVC   r0, #0                  ; Exit OK
        MOVVS   r0, #1                  ; Token not looked up
        EXIT

message_errorlookup Entry r1-r7
        BL      open_messages_file
        EXIT    VS
        MOV     r4, r1
        ADR     r1, message_file_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

        LTORG

      [ :LNOT: Embedded_UI
spritedata
        INCBIN  $SpriteDisc
endspritedata
        ALIGN
      ]

;-----------------------------------------------------------------------------
; A new territory was selected. R0=territory number
;
territory_selected ROUT
        Push    "R0-R1,LR"

        ; Reassess the situation
        BL      daylight_switch_check
        
        ; Announce the selection
        MOV     R1,#Service_TerritoryStarted
        SWI     XOS_ServiceCall

        Pull    "R0-R1,PC"

;-----------------------------------------------------------------------------
; Find which sub timezone the TimeZone CMOS refers to.
; If no match, assume custom
;
which_timezone ROUT
        Push    "R2-R7,LR"
        MOV     R0,#DSTCMOSBit :OR: AutoDSTCMOSBit
        MOV     R1,#0
        BL      daylight_modify_cmos
        MOV     R7,R0

        MOV     R0,#OsByte_ReadCMOS
        MOV     R1,#TimeZoneCMOS
        SWI     XOS_Byte
        MOVVS   R5,#0
        BVS     %FT20

        LDR     R1,=15 * 60 * 100       ; CMOS stores to nearest 15 mins, we want cs
        MOV     R2,R2,LSL #24
        MOV     R2,R2,ASR #24           ; Sign extend
        MUL     R5,R2,R1

        MOV     R6,#0                   ; Scan all timezones in this territory
10
        MOV     R0,#-1
        MOV     R1,R6
        LDR     R4,=ReadTimeZones_Extension
        SWI     XTerritory_ReadTimeZones
        BVS     %FT20

        TEQ     R2,R5
        BEQ     %FT30                   ; The centiseconds match, take it

        TEQ     R4,#0
        BNE     %FT20                   ; Extended API not supported so stop trying

        ADD     R6,R6,#1
        B       %BT10
20
        MOV     R6,#-1
30
        MOV     R0,R6                   ; Timezone
        MOV     R1,R5                   ; Offset from UTC in signed centiseconds
        Pull    "R2-R7,PC"

        LNK     Daylight.s
@


4.18
log
@Escape some dollars
Detail:
  s/ModHead - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 0.56. Retagged as 'Manager-0_56'
@
text
@d480 1
a480 1
        ADREQ   r1, PathDefault
d605 1
d612 1
d635 3
d788 1
a788 1
        ADRNE   R1,territory_path       ; Look for territory on configured device (not NetFS).
d800 1
a800 1
        ADR     R2,netfsmess_path
d1017 8
@


4.17
log
@Add new flag to allow Territory_ConvertTimeFormats to take an arbitrary timezone offset in R4
Bit 19 clear behaves as before, R4 is the enumerated timezone offset within the territory, bit 19 set is an offset in centiseconds given by the caller.
ModHead.s: don't over declare the buffer size when enumerating !Territory, and mask the FS number with 0xFF to save an instruction and workaround a FileSwitch bug.
SWIs.s: New flag bit support in Territory_ConvertTimeFormats

Version 0.55. Tagged as 'Manager-0_55'
@
text
@d544 1
a544 1
Path            DCB     "TerritoryManager$Path", 0
@


4.16
log
@  More efficient when accessing CMOS
Detail:
  The routine daylight_modify_cmos was used for both reading and writing CMOS
  bits in two different bytes. Unfortunately it unconditionally wrote to
  both CMOS bytes every time, even if they weren't changing (including every
  time the routine was only used to read the bits). This makes the routine
  very slow, especially when extra-slow pseudo-CMOS devices like SD cards
  are actually used for non-volatile storage.
Admin:
  Tested on a beagleboard

Version 0.49. Tagged as 'Manager-0_49'
@
text
@d771 2
a772 2
        TEQ     r0,#&40000000           ; FileSwitch 1.70-2.74 return duff internal value 'Nowt' here
        TEQNE   r0,#fsnumber_none
a821 1
        MOV     R3,#1
d823 1
a823 1
        MOV     R5,#&100
d826 1
d831 1
a831 1
        BNE     %FT02                   ; Finished !
d833 1
a833 1
        MOV     R0,#ModHandReason_Load  ; load the module
d840 3
a842 2

        B       %BT01                   ; Get next module
a845 2
02

@


4.15
log
@Addition of support for automatic daylight saving switchover
Uses *CONFIGURE AutoDST to subsequently allow the computer to decide when to apply DST or not (the underlying CMOS bit is still set/cleared, for those applications reading it).
Messages files updated to include new syntax token.
SWI Territory_DaylightSaving and Territory_DaylightRules and Territory_ConvertTimeFormats added.
Flag definitions for all the SWIs added to exported header file.
The automatic switchover evaluates when the configure command is entered, territory is changed, or time is set (with Territory_SetTime) whether the rule is known for that year.
If no rule is known, standard time is selected, and a callback set to fire on New Year's day to try again.
If a rule is known, the next transition is calculated and a callback set.
ModHead.s
  Configure and status handlers updated for extra configuration command.
  Commoned up the OS_Byte bashing code (since the two flags bits are actually in two differenc CMOS bytes).
  *CONFIGURE <local_name_for_timezone> can now scan all timezones within a territory, not just the first.
  Magic numbers swapped for symbols where available.
  Message block and flag split into flag byte + handle word.
SWIs.s
  Daylight saving SWIs added.
  SWI Territory_ConvertTimeFormats addresses the inability to do some of the matrix of 16 combinations of local/UTC and 5 byte/ordinal conversions using the existing SWIs, and allows more conversion types to be added in the future.
TerrMgr.s
  Workspace shuffled for new functionality.
  Accept international_help switch passed in from outside.
SystemDisc
  Pixel errors in the Archimedes logo fixed.
Doc/AutoDST
Test/MultiTZTest
  Test program and SWI documentation.

Version 0.47. Tagged as 'Manager-0_47'
@
text
@d17 2
@


4.14
log
@Correct behaviour of Territory_ReadCurrentTimeZone.
Reading the current timezone now returns the current value read from the timezone CMOS (with DST applied or not as appropriate). The textual name in R0 comes from the respective territory module if the value in CMOS matches the standard time offset from the territory. If they do not match "Custom" is returned instead of pretending one thing but doing another,
Add new token "Custom" to all the messages files.

Behaviour of *CONFIGURE made more helpful.
When [un]setting the DST with *CONFIGURE [No]DST the DST bit is toggled on or off as expected.
When [un]setting the DST with *CONFIGURE [GMT|BST] (ie. the named zone for this territory) both the DST bit and timezone CMOS are updated. Likewise for other named timezones.
So, if you live in Spain using the Spain territory
*CONFIG.CET            => timezone +1:00, DST=off       "CET"
*CONFIG.TIMEZONE -4:45 => timezone -4:45, DST=unchanged "Custom"
*CONFIG.DST            => timezone -4:45, DST=on        "Custom"
*CONFIG.CEST           => timezone +1:00, DST=on        "CEST"

Fix stack imbalance when failing to resolve a territory name in *TERRITORY (Modhead line 84). Was causing an abort when toggling between two territories.
Fix a signed pointer comparison for the tail of *CONFIGURE command.
Change 1 register push/pull to use macros.
Remove trailing newlines from the non internationalised syntax messages.
Use OS_Args R0=R1=0 to read the current FS rather than having to parse the FS module's title string.
Get some more header files to remove some magic numbers in the source.
Change LNK'd files to use ".s" suffixes.

Version 0.44. Tagged as 'Manager-0_44'
@
text
@d27 1
a27 1
        DCD     Helptable      - Module_BaseAddr
d32 1
a32 1
 [ International_Help <> 0
d34 1
a34 1
 |
d36 2
a37 2
 ]
 [ :LNOT:No32bitCode
d39 1
a39 1
 ]
a40 1
;-----------------------------------------------------------------------------
d43 2
a44 2
                 ALIGN
 [ :LNOT:No32bitCode
d47 1
a47 1
 ]
d62 1
a62 1
; print current territory to screen
d101 1
d106 1
a106 1
; Print numbers and names of loaded territories.
d180 1
a180 1
        MOV     R0,#WriteCMOS           ; Write the CMOS RAM!
d188 1
a188 1
        MOV     R0,#ReadCMOS
d234 7
a240 8
        MOV     R0,#ReadCMOS
        MOV     R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
        ORRVC   R2,R2,#DSTCMOSBit
        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte

        Pull    "r1,r12,PC"
a242 1

d249 7
d257 5
a261 13
        MOV     R0,#ReadCMOS
        MOV     R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
        MOVVS   R4,#0
        MOVVC   R4,R2
        MOV     R0,#-1
        SWI     XTerritory_ReadTimeZones
        ADRVS   R0,Off
        ADRVS   R1,On
        TST     R4,#DSTCMOSBit
        MOVNE   R0,R1
        SWIVC   XOS_Write0
        BLVS    message_write0
d265 4
a268 4
config_DST_token
        DCB     "CDSTSyn", 0
On      DCB     "DST On",0
Off     DCB     "DST Off",0
d272 1
a272 1
; Handle *Configure NODST
d274 2
a275 2
;         R0=1 => *Status NODST was typed    (Ignore)
;         R0-> command tail => *Configure NODST
d278 1
a278 1
NODST_Code
d286 18
a303 6
        MOV     R0,#ReadCMOS
        MOV     R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
        BICVC   R2,R2,#DSTCMOSBit
        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte
d305 3
a307 1
        Pull    "r1,r12,PC"
d345 1
a345 1
        MOV     r0, #WriteCMOS
d348 3
d359 1
a359 1
        MOVVC   r0, #ReadCMOS
a394 3
;-----------------------------------------------------------------------------
Helptable
;-----------------------------------------------------------------------------
d396 2
a397 1
        Command Territory,1,0,International_Help
d399 5
a403 4
        Command Territory,1,1,Status_Keyword_Flag :OR: International_Help,TerritoryC
        Command DST,0,0,Status_Keyword_Flag :OR: International_Help
        Command NODST,0,0,Status_Keyword_Flag :OR: International_Help
        Command TimeZone,1,1,Status_Keyword_Flag :OR: International_Help,TimeZoneC
d405 1
a405 2
;-----------------------------------------------------------------------------
  [ International_Help <> 0
d413 2
a414 1
NODST_Help
d417 2
a418 1
NODST_Syntax
d422 10
a431 1
  |
d446 5
a450 3
NODST_Help
        DCB     "*Configure DST sets the clock for Daylight Saving Time", 13
        DCB     "*Configure NODST sets the clock for Local Standard Time.", 13
d452 3
a454 2
NODST_Syntax
        DCB     "Syntax: *Configure DST | NODST", 0
d459 1
a459 1
  ]
d461 1
d464 1
d466 1
a466 1
        Push    "r0-r4,LR"
d468 1
a468 1
; initialise Territory$Path if not already done
d484 2
a485 3
        LDR     r0, [r12]
        CMP     r0, #0                  ; clears V
        MOVNE   r12,r0
d488 1
a488 1
        MOV     r0, #6
d491 2
a492 2
        ADDVS   sp,sp,#4
        Pull    "r1-r3,PC",VS
d494 1
d497 1
a497 2
01
; Clear the territories list.
d502 1
d504 1
a504 5
  [ :LNOT::DEF: FixedTerritory

; Read configured territory from CMOS

        MOV     r0,#ReadCMOS
a506 1

d509 1
a509 3
  |
        MOV     r2,#FixedTerritory
  ]
d514 2
d517 6
a522 1
        STR     r0, message_file_open
a523 1
; Read the static string 'Custom' for Territory_ReadCurrentTimeZone
d534 1
a534 1
; Set a callback to issue the TerritoryManagerLoaded Service call
d540 1
a540 1
        Pull    "r0-r4,PC"
d558 39
a599 2

;Ursula format
a602 1
;
d626 1
a626 1
        BEQ     PostInit
d641 1
d648 1
a648 1
        MOV     R1,#Service_UKWord              ; if not 5, pass it on
d660 1
a660 1
        CMP     R0,#0
d663 3
a665 2
        Push    "r0-r4,LR"

d667 2
d670 9
a678 43
        Pull    "r0-r4,PC",VS   ; If error, ignore configure command.

; Try the standard time zone
00
        LDR     R2,[SP,#0*4]    ; R2 -> Command tail
01
        LDRB    R14,[R2],#1
        CMP     R14,#' '
        MOVLT   R14,#0
        LDRB    R3, [R0],#1
        EOR     R3,R3,R14
        BICS    R3,R3,#&20      ; Caseless compare
        BNE     %FT02           ; No match, try other string

        CMP     R14,#0
        BNE     %BT01
        MOV     R4,#0           ; Match! Turn off DST
        B       %FT04

; Try daylight saving time
02
        LDR     R2,[SP,#0*4]    ; R2 -> Command tail
03
        LDRB    R14,[R2],#1
        CMP     R14,#' '
        MOVLT   R14,#0
        LDRB    R3, [R1],#1
        EOR     R3,R3,R14
        BICS    R3,R3,#&20      ; Caseless compare
        Pull    "r0-r4,PC",NE   ; No match, give up

        CMP     R14,#0
        BNE     %BT03
        MOV     R4,#DSTCMOSBit  ; Match! Turn on DST

; Since this command has matched on the territory specific timezone
; name (with or without DST as set in R4) this writes the timezone
; CMOS in addition to the DST flag.
; To modify only the DST flag, use *CONFIGURE [No]DST instead.
04
        MOV     R0,#ReadCMOS    ; Get byte from CMOS
        MOV     R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
d680 17
a696 9
        BICVC   R2,R2,#DSTCMOSBit
        ORRVC   R2,R2,R4

        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte        ; Write back to CMOS

        MOVVC   R0,#-1          ; For configured territory
        SWIVC   XTerritory_ReadTimeZones
        BVS     %FT10
d700 1
a700 1
05
d703 1
a703 1
        BEQ     %FT07
d706 2
a707 2
        BNE     %BT05
07
d710 1
a710 1
        MOV     R0,#WriteCMOS
d712 4
a715 3
10
        STRVS   R0,[SP]
        Pull    "R0-R4,LR"
d718 1
a718 1
        MOV     PC,LR
d720 10
a729 6
;-----------------------------------------------------------------------------
;       RMKill'ing the module
Die
        LDR     r12, [r12]
        CMP     r12, #0
        MOVEQ   PC, LR
d731 3
a733 24
        Push    "R7-R11,LR"

        LDR     r0, message_file_open    ; Close the message file if open
        CMP     r0, #0
        ADRNE   r0, message_file_block
        SWINE   XMessageTrans_CloseFile
        MOV     r0, #0
        STR     r0, message_file_open

; Free all module blocks

        LDR     r2,territories
01
        CMP     r2,#0
        BEQ     %FT02
        LDR     r1,[r2,#next_ptr]
        MOV     r0,#ModHandReason_Free
        SWI     XOS_Module
        MOV     r2,r1
        B       %BT01
02

        CLRV
        Pull    "R7-R11,PC"              ; don't refuse to die
d748 3
a750 3

; This is called after all the modules have been initialised.
PostInit
d778 1
a778 1
; Check to see if it is netfs
d785 1
a785 1
; Yes, it is netfs.
d795 4
a798 4
; No errors so far, try and load territory files.
; First load the territory module.
; Note: R1->territory path
;       R2->messages path
d805 1
a805 1
; Now load all the messages modules.
d841 1
a841 1
; Modules loaded, now check that configured territory exists.
d851 1
a851 1
     [ debugxx
d854 1
a854 1
     ]
d856 1
a856 1
     [ Embedded_UI
d858 2
a859 2
; On NC/STB - no way should we be bringing up a floppy picture. Instead, let's take the
; territory at the head of the chain (the last registered).
d865 1
a865 1
     |
d869 3
a871 3
; Try to put the sprite on the screen.

; First claim a block big enough to print sprite
d886 1
a886 1
; Now decompress the sprite file
d898 1
a898 1
; Now plot the sprite at the middle of the screen
d930 2
a931 2
; R3 = x/2 R4 = y/2
; Get size of current mode.
d953 1
a953 1
; R5 = scx / 2 R6 = scy /2
d1006 2
a1007 4
territory_present                       ; By this stage the configured territory is in memory.

        MOV     R1,#Service_TerritoryStarted
        SWI     XOS_ServiceCall
d1013 1
a1013 1
        MOV     r0, #106
d1019 1
a1019 1
        MOV     r0, #126
d1025 1
a1025 1
        LDR     r0, message_file_open
d1034 1
a1034 1
        STRVC   r2, message_file_open
d1081 1
a1081 1
     [ :LNOT: Embedded_UI
d1086 61
a1146 1
     ]
d1148 1
a1148 1
        LNK     SWIs.s
@


4.13
log
@Fix to broken messages,the *configure syntax was being partially
tokenised from "Territor" to ESC PERTHOUSAND.
Also added some spaces because the status and configuration have never
lined up!

Version 0.42. Tagged as 'Manager-0_42'
@
text
@d41 1
a41 1
; ----------------------------------------------------------------------------------------------------------------------
d67 1
a67 1
        MOV     r2,#scratch_buffer_length
d81 1
a81 1
        Pull    "R1,R12,PC",VS
d90 1
a90 1
        CMP     R14,#32
d100 1
a100 1
; ----------------------------------------------------------------------------------------------------------------------
d117 1
a117 1
        MOV     r2,#scratch_buffer_length
d125 1
a125 1
        MOV     r2,#scratch_buffer_length
d143 1
d172 1
a172 1
        CMP     R14,#32
d213 1
a213 1
        DCB     "CTSyntax", 0
d215 1
a215 1
        DCB     "Status", 0
d239 1
a239 2
        MOVVC   R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
d277 1
a277 1
;         R0=1 => *Status NODST was typed      (same as DST)
d287 1
a287 1
        Pull    "r1,r12,PC",LE
d294 1
a294 2
        MOVVC   R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
d298 1
a298 1
; ----------------------------------------------------------------------------
d302 1
d304 1
a304 1
        STMDB   sp!, {lr}
d317 2
a318 1
        LDMVSIA sp!, {pc}
d326 2
a327 1
        LDMVSIA sp!, {pc}
d337 1
a337 1
        LDMIA   sp!, {pc}
d348 2
a349 1
        LDMVSIA sp!, {pc}
d373 1
a373 1
        LDMIA   sp!, {pc}
d376 1
a376 1
        DCB     "TZSyn", 0
d381 1
a381 1
; ----------------------------------------------------------------------------
d383 1
a383 1
; ----------------------------------------------------------------------------
d392 1
a392 1
; ----------------------------------------------------------------------------
d410 1
a410 1
        DCB     "*Territories lists the currently loaded territory modules.",10,13
d412 1
a412 1
        DCB     "Syntax: *Territories",0
d414 2
a415 2
        DCB     "*Territory sets the current territory.",10,13
        DCB     "*Territory with no parameter displays the current territory.",10,13
d417 1
a417 1
        DCB     "Syntax: *Territory [<Territory Number>]",0
d419 1
a419 1
        DCB     "*Configure Territory sets the default territory for the machine.",10,13
d421 1
a421 1
        DCB     "Syntax: *Configure Territory <Territory Number>",0
d424 2
a425 2
        DCB     "*Configure DST sets the clock for Daylight Saving Time",10,13
        DCB     "*Configure NODST sets the clock for Local Standard Time.",10,13
d428 1
a428 1
        DCB     "Syntax: *Configure DST | NODST",0
d435 1
a435 1
; -----------------------------------------------------------------------------
d484 1
a484 1
        MOVVS   r2,#1
d494 12
a505 1
        STR     r0, message_file_block
d515 4
a518 4
Path            DCB     "TerritoryManager$Path"
                DCB     0
PathDefault     DCB     "Resources:$.Resources.TerrMgr."
                DCB     0
d532 1
a532 1
; ----------------------------------------------------------------------------------------------------------------------
d576 1
a576 1
;-------------------------------------------------------------------------------------------------------------------
d592 1
a592 1
;-------------------------------------------------------------------------------------------------------------------
d595 1
a595 1
svc_UKConfig
a603 1
        LDR     R2,[SP,#0*4]    ; R2 -> Command tail
d606 2
d610 1
a610 1
        CMP     R14,#32
a611 1
        BIC     R14,R14,#&20
d613 4
a616 3
        BIC     R3,R3,#&20
        CMP     R14,R3
        BNE     %FT02           ; Try other string
d619 1
a619 1
        MOV     R4,#0
d624 1
a624 1
        LDR     R2,[SP,#0*4]
d627 1
a627 1
        CMP     R14,#32
a628 1
        BIC     R14,R14,#&20
d630 4
a633 3
        BIC     R3,R3,#&20
        CMP     R14,R3
        Pull    "r0-r4,PC",NE
d636 6
a641 1
        MOV     R4,#DSTCMOSBit
d643 1
a643 1
        MOV     R0,#ReadCMOS     ; Get byte from CMOS
a645 2
        ADDVS   SP,SP,#4
        Pull    "r1-r4,PC",VS
d647 2
a648 2
        BIC     R2,R2,#DSTCMOSBit
        ORR     R2,R2,R4         ; And set it to correct value.
d650 22
a671 3
        MOV     R0,#WriteCMOS     ; Get byte from CMOS
        MOV     R1,#AlarmAndTimeCMOS
        SWI     XOS_Byte
d674 2
a675 2
        MOV     R1,#0
        MOV     R0,#-1
d678 1
a678 1
; ----------------------------------------------------------------------------------------------------------------------
a680 2
        Push    "R0-R11,LR"
;
d683 3
a685 1
        Pull    "R0-R11,PC",EQ
d687 1
a687 1
        LDR     r0, message_file_block  ; Close the message file if open
d689 1
a689 1
        ADRNE   r0, message_file_block+4
d692 1
a692 1
        STR     r0, message_file_block
d708 1
a708 1
        Pull    "R0-R11,PC"              ; don't refuse to die
d710 1
a710 1
; ----------------------------------------------------------------------------------------------------------------------
d713 1
a713 2
netfsname       DCB     "NetFS",0
netfscommand    DCB     "Logon Territory",0
d732 1
a732 1
        SWI     XTerritory_Exists         ; Chk if configured territory is already loaded.
d734 1
a734 1
        BEQ     territory_present         ; Yes, skip loading section.
d740 6
a745 2
        MOV     r0,#20
        SWI     XOS_FSControl
d747 2
a748 4
        CMP     R1,#0

        MOVEQ   r0,#1
        STREQ   r0,configured_territory    ; If no selected filing system, go back to English !
d751 1
a751 4
        LDR     R14,[R1,#&10]
        ADD     R1,R1,R14                  ; Point at title string.

        DebugS  xx,"Title of selected FS ",R1
d755 1
a755 5
        ADRL    R0,netfsname
01
        LDRB    R14,[R1],#1
        LDRB    R2,[R0],#1
        CMP     R14,R2
a758 2
        CMP     R14,#0
        BNE     %BT01
d763 1
a763 1
        ADRL    R0,netfscommand
d790 1
a790 1
        MOV     R14,#"."
d800 1
a800 1
        MOV     R0,#9                   ; Get file names in directory
d868 2
a869 2
        ADR     R2,spritedata+20
        LDR     R3,=endspritedata-spritedata-20
d930 4
a933 4
        SWI     XOS_WriteI+4
        SWIVC   XOS_WriteI+26
        SWIVC   XOS_WriteI+20
        SWIVC   XOS_WriteI+18
d935 2
a936 2
        SWIVC   XOS_WriteI+128
        SWIVC   XOS_WriteI+12
d973 1
a973 1
        MOV     r0, #1
d977 1
a977 1
        SWI     XOS_WriteI+12
d1002 1
a1002 1
        LDR     r0, message_file_block
d1005 1
a1005 1
        ADR     r0, message_file_block+4
d1011 1
a1011 1
        STRVC   r2, message_file_block
d1018 1
a1018 1
        ADR     r0, message_file_block+4
d1031 1
a1031 1
        CMP     r0, #32
d1038 9
d1051 1
a1051 1
        ADR     r1, message_file_block + 4
d1060 1
a1060 1
        BIN     $SpriteDisc
@


4.12
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Detail:
  Removed additional BASIC tools that simply compress/decompress the Sprite
    file - standard squash application is used instead, and the code inside
    the Territory Manager has been updated to know that a full Squash file
    is what it has embedded within itself.  This also improves the memory
    allocation - the module is no longer praying that the sprite fits in
    25K when uncompressed ...
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.40. Tagged as 'Manager-0_40'
@
text
@d157 1
a157 1
        BLT     printsyntax
d212 1
a212 1
        DCB     "CTSyn", 0
d230 1
a230 1
        BLT     print_DSTsyntax
d307 1
a307 1
        BLT     timezone_printsyntax
@


4.11
log
@
  * Removed dependency on obsolete STB flag.

Detail:

  * No longer relies on the STB flag; instead utilises "Hdr:UserIF.<UserIF>"
    to provide the Embedded_UI flag.

    On Embedded systems, the picture of the Floppy disc is suppressed
    when the configured territory cannot be found.

Admin:

  * Built and tested on Lazarus 32-bit build.  Code is binary identical to
    previous versions that relied on the STB flag in both the Desktop and
    Embedded variants.

  * StripDepnd support moved from Makefile to MkClean.

  * Requires HdrSrc 1.17 or later.

Version 0.39. Tagged as 'Manager-0_39'
@
text
@d43 1
a43 5
Helpstr DCB     "Territory Mgr",9,"$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
        DCB     0
d819 8
a827 1
        MOV     R3,#45*1024
d832 1
a832 1
; Now decompress the sprite
d834 4
a837 2
        MOV     R0,#0                     ; Don't use fast method.
        ADD     R1,R2,#25*1024
d839 2
a840 4
        ADRL    R2,spritedata
        LDR     R3,=:FSIZE:"z.SystemDisc"
        MOV     R5,#25*1024
        STR     R5,[R4,#-4]
d1022 2
a1023 1
        BIN     "z.SystemDisc"
d1027 1
a1027 1
        LNK     s.SWIs
@


4.10
log
@32-bit compatible.

Version 0.36. Tagged as 'Manager-0_36'
@
text
@d806 1
a806 1
     [ STB
d947 1
a947 1
      ] ; STB
d1017 1
a1017 1
     [ :LNOT: STB
@


4.9
log
@Territory_SetTime modified to use OS_Word 15,5 for greater accuracy.
Catches OS_Word 15,5 using Service_UKWord, and implements it (with lower
accuracy) if the kernel doesn't.

Version 0.35. Tagged as 'Manager-0_35'
@
text
@d37 3
d49 5
d141 2
a142 2

        Pull    "PC",,^
d519 1
a519 1
        Pull    "r0-r9,PC",,^
d527 1
a527 2
        ASSERT  Service_UKWord   < Service_Reset
        ASSERT  Service_Reset    < Service_UKConfig
a533 1
        DCD     Service_Reset
a540 1
        TEQNE   r1,#Service_Reset
a551 3
        TEQ     R1,#Service_Reset
        BEQ     svc_reset

a559 6
; ----------------------------------------------------------------------------------------------------------------------
;       Reset button pressed. Wimp has shut down. Reset task handle to 0. Release linked lists.
svc_reset
        Push    "R0, LR"
        Pull    "R0, PC",,^

d570 1
a570 1
        MOVNES  PC,LR
d575 1
a575 1
        MOVNES  PC,LR
d580 1
a580 1
        Pull    "PC",,^
d587 1
a587 1
        MOVEQS  PC,LR
d593 1
a593 1
        Pull    "r0-r4,PC",VS,^ ; If error, ignore configure command.
d622 1
a622 1
        Pull    "r0-r4,PC",NE,^
d652 1
a652 1
        Pull    "R0-R11,PC",EQ,^
d674 2
a675 1
        Pull    "R0-R11,PC",,^           ; don't refuse to die
d957 1
a957 1
        Push    lr
d960 1
a960 1
        Pull    pc,,^
d963 1
a963 1
        Push    lr
d966 1
a966 1
        Pull    pc,,^
@


4.8
log
@Added Territory_Select SWI and *Territory command.

Version 0.34. Tagged as 'Manager-0_34'
@
text
@d519 1
d526 1
d534 2
a535 1
        TEQ     r1,#Service_Reset
d544 3
d569 17
@


4.7
log
@Another change to the DontUseCMOS variant. Option names changed - you should
now set the option -PD "FixedTerritory SETA n" where n is the number of the
territory you want selected, instead of setting DontUseCMOS.

Version 0.33. Tagged as 'Manager-0_33'
@
text
@d46 50
d378 1
d389 2
d406 5
@


4.6
log
@Another version of the DontUseCMOS hack. This time, get the territory to use
from the build options.

Version 0.32. Tagged as 'Manager-0_32'
@
text
@d411 1
a411 1
  [ :LNOT::DEF: DontUseCMOS
d422 1
a422 1
        MOV     r2,#UseThis
@


4.5
log
@Modified "DontUseCMOS" variant to ensure that a valid territory (ie UK) is
selected during module initialisation. The last-registered territory is then
used after Service_PostInit. No attempt is made to load from filing systems.

Version 0.31. Tagged as 'Manager-0_31'
@
text
@d422 1
a422 2
        MOV     r2,#1                           ; Keep it UK for now (modules will need some sort of territory
                                                ; during init). We'll select a better territory later
a620 2
  [ :LNOT::DEF: DontUseCMOS

a726 2

   ] ; :LNOT::DEF:DontUseCMOS
@


4.4
log
@CMOS ignoring code should now work.

Version 0.29. Tagged as 'Manager-0_29'
@
text
@d422 2
a423 1
        MOV     r2,#-1                          ; Invalid value - will cause last registered to be used
d622 2
d637 1
d730 2
@


4.3
log
@If STB flag is set, don't bring up floppy disc prompt, just take last-
registered territory (ie last in ROM), if configured can't be found.
Also, if you add
     -options OPTS="-PD \"DontUseCMOS SETL {TRUE}\""
to the components file, it will always use the last territory in ROM,
totally ignoring the CMOS.

Version 0.28. Tagged as 'Manager-0_28'
@
text
@d734 1
@


4.2
log
@Changed to use srccommit.
Modified to cope with new Hdr:CMOS.
Territory_IME SWI added.
Ursula branch merged.
German resources imported.

Version 0.27. Tagged as 'Manager-0_27'
@
text
@a15 1
        LEADR   Module_LoadAddr
d410 3
d421 3
d727 10
d867 2
d889 1
a889 1
        ENTRY   r0-r2
d902 1
a902 1
message_write0 ENTRY r0-r7
d926 1
a926 1
message_errorlookup ENTRY r1-r7
d937 1
d941 1
@


4.1
log
@Initial revision
@
text
@d41 5
a45 1
Helpstr DCB     "Territory Mgr",9,"$VString ($Date)",0
a393 1
      [ Version >= 5
a395 3
      |
        Pull    "r0-r3,PC",NE
      ]
d453 14
d468 6
a590 8

; Release all workspace

      [ Version < 5                     ; Now freed by kernel.
        MOV     r2, r12
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
      ]
@


4.1.4.1
log
@update to Ursula service format
@
text
@d453 1
a453 21

;Ursula format
;
        ASSERT  Service_Reset    < Service_UKConfig
        ASSERT  Service_UKConfig < Service_PostInit
;
UServTab
        DCD     0                           ;flags
        DCD     UService - Module_BaseAddr
        DCD     Service_Reset
        DCD     Service_UKConfig
        DCD     Service_PostInit
        DCD     0
        DCD     UServTab - Module_BaseAddr  ;anchor
Service 
        MOV     r0,r0                       ;magic instruction
        TEQ     r1,#Service_Reset
        TEQNE   R1,#Service_PostInit
        TEQNE   R1,#Service_UKConfig
        MOVNE   PC,LR
UService
@


4.1.4.1.2.1
log
@Makefile edits and various plumbing to make the darn thing build
@
text
@d467 1
a467 1
Service
d929 1
a929 1
        BIN     z.SystemDisc
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

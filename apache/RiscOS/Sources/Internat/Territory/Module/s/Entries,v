head	1.14;
access;
symbols
	Module-0_63:1.14
	Module-0_62:1.14
	Module-0_61:1.14
	Module-0_60:1.14
	Module-0_59:1.13
	Module-0_58:1.12
	Module-0_57:1.12
	Module-0_56:1.12
	Module-0_55:1.12
	Module-0_54:1.11
	Module-0_53:1.10
	Module-0_52:1.9
	RO_5_07:1.8
	Module-0_51:1.8
	Module-0_50:1.8
	Module-0_49:1.8
	Module-0_48:1.8
	Module-0_47:1.7
	Module-0_46:1.7
	Module-0_45:1.6
	Module-0_44:1.6
	Module-0_43:1.6
	Alpnet_approved:1.6
	Module-0_42:1.6
	dellis_autobuild_BaseSW:1.6
	Module-0_41:1.6
	Module-0_40:1.6
	Module-0_39:1.6
	Module-0_38:1.6
	Module-0_37:1.5
	Module-0_36:1.5
	Module-0_35:1.4
	sbrodie_sedwards_16Mar2000:1.4
	dcotton_autobuild_BaseSW:1.8
	Module-0_34:1.4
	Module-0_33:1.3
	Module-0_32:1.3
	Module-0_31:1.3
	Module-0_30:1.3
	Module-0_29:1.2
	Module-0_28:1.1
	Module-0_27:1.1
	Module-0_26:1.1;
locks; strict;
comment	@# @;


1.14
date	2013.11.26.23.03.59;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	G5yfgPu5QTxCeQex;

1.13
date	2013.11.24.12.08.51;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	ydeF3vWByzlQFwex;

1.12
date	2012.05.28.17.23.04;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	ZP2CrZzcPLMsVv6w;

1.11
date	2012.04.01.06.54.35;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	bv4LbApC6T7Hh8Zv;

1.10
date	2012.03.02.09.17.01;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	HvAzpsR97Qno2iVv;

1.9
date	2012.02.20.21.17.02;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	pifcrbq5LMUknWTv;

1.8
date	2001.03.22.13.54.53;	author sbrodie;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.17.23.19;	author sforrest;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.01.09.36.06;	author jfletche;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.08.11.05.06;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	99.04.19.12.30.05;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.10.19.11.47.09;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	98.09.21.09.59.40;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.11.20.54;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Fix for infinite loop compare the same numbers
Messing with the flags in r3 meant the main loop never thought the compare fulfilled the user's request, so tried again...
SYS"Territory_Collate",-1,"test1","test1",5 no longer hangs.

Version 0.60. Tagged as 'Module-0_60'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Sources.Entries

;--------------------------------------------------------
Alphabet
        Debug   xx,"Territory : Alphabet entry"

        MOV     r0,#AlphNum
        MOV     PC,LR

;--------------------------------------------------------
AlphabetIdent
        Debug   xx,"Territory : AlphabetIdentifier entry"

        ADR     r0,Alphabet_IdentString
        MOV     PC,LR

Alphabet_IdentString

        DCB     "$AlphabetName",0
        ALIGN


;--------------------------------------------------------
SelectKeyboardHandler

        Push    "r0-r2,LR"

        MOV     r0,#OsByte_Alphabet
        MOV     r1,#128+TerrNum
        SWI     XOS_Byte
        STRVS   r0,[SP]

        Pull    "r0-r2,PC"

;--------------------------------------------------------
WriteDirection

        MOV     r0,#WriteDir
        MOV     PC,LR

;--------------------------------------------------------
IME

        LDR     r0,=IMESWIChunk
        MOV     PC,LR

;--------------------------------------------------------


CharacterPropertyTable

        TEQ     r1,#Property_Control
        ADREQL  r0,ControlTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Uppercase
        ADREQL  r0,UppercaseTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Lowercase
        ADREQL  r0,LowercaseTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Alpha
        ADREQL  r0,AlphaTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Punctuation
        ADREQL  r0,PunctuationTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Space
        ADREQL  r0,SpaceTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Digit
        ADREQL  r0,DigitTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_XDigit
        ADREQL  r0,XDigitTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_Accented
        ADREQL  r0,AccentedTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_ForwardFlow
        ADREQL  r0,ForwardFlowTable
        MOVEQ   PC,LR
        TEQ     r1,#Property_BackwardFlow
        ADREQL  r0,BackwardFlowTable
        MOVEQ   PC,LR

        ADR     r0,ErrorBlock_UnknownProperty
        B       message_errorlookup

ErrorBlock_UnknownProperty
        DCD     TerritoryError_UnknownProperty
        DCB     "UnkProp",0
        ALIGN

;--------------------------------------------------------
GetLowerCaseTable

        ADRL    r0,ToLowerTable
        MOV     PC,LR

;--------------------------------------------------------
GetUpperCaseTable

        ADRL    r0,ToUpperTable
        MOV     PC,LR

;--------------------------------------------------------
GetControlTable

        ADRL    r0,ToControlTable
        MOV     PC,LR

;--------------------------------------------------------
GetPlainTable

        ADRL    r0,ToPlainTable
        MOV     PC,LR

;--------------------------------------------------------
GetValueTable

        ADRL    r0,ToValueTable
        MOV     PC,LR

;--------------------------------------------------------
GetRepresentationTable

        ADRL    r0,ToRepresentationTable
        MOV     PC,LR

;--------------------------------------------------------
; Collate
;     Entry:
;             R1 -> String 1   (0 terminated)
;             R2 -> String 2   (0 terminated)
;             R3 = flags
;                        bit 0 - Ignore case.
;                        bit 1 - Ignore accents
;                        bit 2 - Interpret cardinals numerically
;     Exit:
;             R0   <0 if S1 < S2
;                  =0 if S1 = S2
;                  >0 if S1 > S2
;             Other registers preserved.
;
;             Z set if equal (EQ).
;             C set and Z clear if S1 > S2 (HI)
;             N set and V clear if S1 < S2 (LT)
;
;             V set if error.

Collate

        Push    "r1-r8,LR"

        MOV     r3, r3, LSL #16
        MOV     r3, r3, LSR #16

        ; We start off ignoring case and accents
        ORR     r3,r3,#Collate_IgnoreCase :OR: Collate_IgnoreAccent
        ADRL    r4,ToLowerTable
        ADRL    r5,ToPlainForCollateTable
        ADRL    r7,SortValueTable
        ADRL    r8,ToRepresentationTable
01
        LDRB    r12,[r1],#1
        LDRB    r6 ,[r2],#1


        Debug   xx,"r12,r6",r12,r6

 [ CollateDanishAA
        TEQ     r12,#'A'
        TEQNE   r12,#'a'
        TEQNE   r6, #'A'
        TEQNE   r6, #'a'
        BNE     %FT35

        TEQ     r12,#'A'
        TEQNE   r12,#'a'
        BNE     %FT33           ; r6 must be an A/a
        LDRB    r0, [r1]
        TEQ     r0, r12
        BEQ     %FT31
        TEQ     r12,#'A'
        TEQEQ   r0,#'a'
        BNE     %FT32
31
        TEQ     r12,#'A'        ; Got aa, Aa or AA.
        MOVEQ   r12,#'Å'
        MOVNE   r12,#'å'
        ADD     r1, r1, #1

32
        TEQ     r6,#'A'
        TEQNE   r6,#'a'
        BNE     %FT35
33      LDRB    r0, [r2]
        TEQ     r0, r6
        BEQ     %FT34
        TEQ     r6,#'A'
        TEQEQ   r0,#'a'
        BNE     %FT35
34
        TEQ     r6,#'A'         ; Got aa, Aa or AA.
        MOVEQ   r6,#'Å'
        MOVNE   r6,#'å'
        ADD     r2, r2, #1
35
 ]
        TST     r3,#Collate_InterpretCardinals
        BEQ     %FT37
        MOV     r0,r12
        BL      is_digit
        MOVEQ   r0,r6
        BLEQ    is_digit
        BEQ     %FT60           ; Both are digits
37
        TST     r3,#Collate_IgnoreAccent
        LDRNEB  r12,[r5,r12]
        LDRNEB  r6 ,[r5,r6]

        Debug   xx,"r12,r6",r12,r6

        TST     r3,#Collate_IgnoreCase
        LDRNEB  r12,[r4,r12]
        LDRNEB  r6 ,[r4,r6]

        Debug   xx,"r12,r6",r12,r6

 [ CollateLatin1Ligatures
        TEQ     r12,#'ž'
        TEQNE   r12,#'Ÿ'
        TEQNE   r6, #'ž'
        TEQNE   r6, #'Ÿ'
        BNE     %FT05

        TEQ     r12,#'ž'
        TEQNE   r12,#'Ÿ'
        BNE     %FT03           ; r6 must be a ligature
        EOR     r3, r3, #&20000000
        TST     r3, #&20000000
        MOVNE   r12, #'f'
        SUBNE   r1, r1, #1
        BNE     %FT02
        TEQ     r12, #'ž'
        MOVEQ   r12, #'i'
        MOVNE   r12, #'l'

02      TEQ     r6,#'ž'
        TEQNE   r6,#'Ÿ'
        BNE     %FT05
03      EOR     r3, r3, #&10000000
        TST     r3, #&10000000
        MOVNE   r6, #'f'
        SUBNE   r2, r2, #1
        BNE     %FT05
        TEQ     r6, #'ž'
        MOVEQ   r6, #'i'
        MOVNE   r6, #'l'
05
 ]

 [ CollateOELigatures
        TEQ     r12,#'š'
        TEQNE   r12,#'›'
        TEQNE   r6, #'š'
        TEQNE   r6, #'›'
        BNE     %FT15

        TEQ     r12,#'š'
        TEQNE   r12,#'›'
        BNE     %FT13           ; r6 must be a ligature
        EOR     r3, r3, #&08000000
        TST     r3, #&08000000
        BEQ     %FT11
        SUB     r1, r1, #1
        TEQ     r12,#'š'
        MOVEQ   r12,#'O'
        MOVNE   r12,#'o'
        B       %FT12
11      TEQ     r12,#'š'
        MOVEQ   r12,#'E'
        MOVNE   r12,#'e'

12      TEQ     r6,#'š'
        TEQNE   r6,#'›'
        BNE     %FT15
13      EOR     r3, r3, #&04000000
        TST     r3, #&04000000
        BEQ     %FT14
        SUB     r2, r2, #1
        TEQ     r6,#'š'
        MOVEQ   r6,#'O'
        MOVNE   r6,#'o'
        B       %FT15
14      TEQ     r6,#'š'
        MOVEQ   r6,#'E'
        MOVNE   r6,#'e'
15
 ]

 [ CollateThornAsTH
        TEQ     r12,#'Þ'
        TEQNE   r12,#'þ'
        TEQNE   r6, #'Þ'
        TEQNE   r6, #'þ'
        BNE     %FT25

        TEQ     r12,#'Þ'
        TEQNE   r12,#'þ'
        BNE     %FT23           ; r6 must be a thorn
        EOR     r3, r3, #&02000000
        TST     r3, #&02000000
        BEQ     %FT21
        SUB     r1, r1, #1
        TEQ     r12,#'Þ'
        MOVEQ   r12,#'T'
        MOVNE   r12,#'t'
        B       %FT22
21      TEQ     r12,#'Þ'
        MOVEQ   r12,#'H'
        MOVNE   r12,#'h'

22      TEQ     r6,#'Þ'
        TEQNE   r6,#'þ'
        BNE     %FT25
23      EOR     r3, r3, #&01000000
        TST     r3, #&01000000
        BEQ     %FT24
        SUB     r1, r1, #1
        TEQ     r6,#'Þ'
        MOVEQ   r6,#'T'
        MOVNE   r6,#'t'
        B       %FT25
24      TEQ     r6,#'Þ'
        MOVEQ   r6,#'H'
        MOVNE   r6,#'h'
25
 ]

 [ CollateGermanSharpS
        TEQ     r12, #'ß'
        EOREQS  r3, r3, #&00800000
        TST     r3, #&00800000
        MOVNE   r12, #'s'
        SUBNE   r1, r1, #1

        TEQ     r6, #'ß'
        EOREQS  r3, r3, #&00400000
        TST     r3, #&00400000
        MOVNE   r6, #'s'
        SUBNE   r2, r2, #1
 ]

        LDRB    r12,[r7,r12]
        LDRB    r6 ,[r7,r6]

        Debug   xx,"r12,r6",r12,r6

        SUBS    r0,r12,r6
        Pull    "r1-r8,PC",NE           ; Not equal, result is result of compare.
        TEQ     r12,#0
        BNE     %BT01                   ; Equal but not 0, get next char.
30      LDR     r12,[sp,#8]             ; Get original flags
        EORS    r12,r3,r12
        Pull    "r1-r8,PC",EQ           ; Done desired comparison - they're equal

 [ :LNOT:CollateAccentsBackwards
        LDMIA   sp,{r1,r2}              ; Restore string pointers
 ]

        TST     r12,#Collate_IgnoreAccent ; Do they want us to differ accents?
        BICNE   r3,r3,#Collate_IgnoreAccent
 [ CollateAccentsBackwards
        BNE     %FT40

        LDMIA   sp,{r1,r2}
 |
        BNE     %BT01                   ; Back to the top, doing accents this time.
 ]

        BIC     r3,r3,#Collate_IgnoreCase ; Already obeying accent directive, so
        B       %BT01                   ; must be disobeying case - check case.

 [ CollateAccentsBackwards
40
; At this point the strings have just compared equal when ignoring case and
; accents. We are about to go around again, looking at accents this time. But
; the important point is that we must scan the string backwards. This is only
; required for French as far as I know, so for now, the following assertions
; will simplify things.

        ASSERT :LNOT: CollateThornAsTH
        ASSERT :LNOT: CollateDanishAA

; We know that the two strings must be of equivalent length, so as we rewind,
; r1 and r2 will hit the start simultaneously (as long as there's nothing
; really bizarre about the ToPlainForCollate table, such as ToPlain(f)='ž').

        LDR     r5, [sp,#0]             ; get back start of first string
41
        LDRB    r12,[r1,#-1]!
        LDRB    r6 ,[r2,#-1]!

        LDRB    r12,[r4,r12]            ; We must be ignoring case at this point
        LDRB    r6 ,[r4,r6]

      [ CollateLatin1Ligatures
        TEQ     r12,#'ž'
        TEQNE   r12,#'Ÿ'
        TEQNE   r6, #'ž'
        TEQNE   r6, #'Ÿ'
        BNE     %FT45

        TEQ     r12,#'ž'
        TEQNE   r12,#'Ÿ'
        BNE     %FT43           ; r6 must be a ligature
        EOR     r3, r3, #&20000000
        TST     r3, #&20000000
        MOVEQ   r12, #'f'
        BEQ     %FT42
        ADD     r1, r1, #1
        TEQ     r12, #'ž'
        MOVEQ   r12, #'i'
        MOVNE   r12, #'l'

42      TEQ     r6,#'ž'
        TEQNE   r6,#'Ÿ'
        BNE     %FT45
43      EOR     r3, r3, #&10000000
        TST     r3, #&10000000
        MOVEQ   r6, #'f'
        BEQ     %FT45
        ADD     r2, r2, #1
        TEQ     r6, #'ž'
        MOVEQ   r6, #'i'
        MOVNE   r6, #'l'
45
      ]

      [ CollateOELigatures
        TEQ     r12,#'š'
        TEQNE   r12,#'›'
        TEQNE   r6, #'š'
        TEQNE   r6, #'›'
        BNE     %FT55

        TEQ     r12,#'š'
        TEQNE   r12,#'›'
        BNE     %FT53           ; r6 must be a ligature
        EOR     r3, r3, #&08000000
        TST     r3, #&08000000
        BNE     %FT51
        TEQ     r12,#'š'
        MOVEQ   r12,#'O'
        MOVNE   r12,#'o'
        B       %FT52
51      TEQ     r12,#'š'
        MOVEQ   r12,#'E'
        MOVNE   r12,#'e'
        ADD     r1, r1, #1

52      TEQ     r6,#'š'
        TEQNE   r6,#'›'
        BNE     %FT55
53      EOR     r3, r3, #&04000000
        TST     r3, #&04000000
        BNE     %FT54
        TEQ     r6,#'š'
        MOVEQ   r6,#'O'
        MOVNE   r6,#'o'
        B       %FT55
54      TEQ     r6,#'š'
        MOVEQ   r6,#'E'
        MOVNE   r6,#'e'
        ADD     r2, r2, #1
55
      ]

        LDRB    r12,[r7,r12]
        LDRB    r6 ,[r7,r6]

        SUBS    r0,r12,r6
        Pull    "r1-r8,PC",NE           ; Not equal, result is result of compare.
        CMP     r1, r5                  ; are we now pointing at the start of the string?
        BNE     %BT41                   ; no, so get next character
        B       %BT30                   ; finished this pass - they're equal. Back to normal processing.
 ]
60
; Cardinal compare algorithm (ignores sign, decimal point & exponents)
; * Skip leading zeros in both numbers
; * Count length of both numbers
; * If equal length, just do strcmp()
; * If different length, longest wins
        Push    "r1-r2,r4-r5"

        MOV     r0,r12
61      BL      is_zero
        LDREQB  r0,[r1],#1
        BEQ     %BT61
        SUB     r4,r1,#1                ; First non '0'
62      BL      is_digit
        LDREQB  r0,[r1],#1
        BEQ     %BT62                   ; Is a digit

        MOV     r0,r6
63      BL      is_zero
        LDREQB  r0,[r2],#1
        BEQ     %BT63
        SUB     r5,r2,#1                ; First non '0'
64      BL      is_digit
        LDREQB  r0,[r2],#1
        BEQ     %BT64                   ; Is a digit

        SUB     r1,r1,r4                ; Lengths
        SUB     r2,r2,r5
        SUBS    r0,r1,r2
        LDREQB  r12,[r4],#1
        LDREQB  r6 ,[r5],#1
        STMEQIA sp,{r4-r5}

        Pull    "r1-r2,r4-r5"

        BEQ     %BT37                   ; Carry on collating from that digit
        Pull    "r1-r8,PC"              ; We have a winner

is_digit ROUT
        ; R0 = char, R8 -> representation table
        ; Returns Z=1 if char is entry 0-9 in the table
        Push    "r1,lr"
        MOV     r1,#9
10      LDRB    r14,[r8,r1]
        TEQ     r14,r0
        Pull    "r1,PC",EQ
        SUBS    r1,r1,#1
        BPL     %BT10
        Pull    "r1,PC"                 ; R1 -ve, therefore also NE
is_zero
        Push    "r1,lr"
        MOV     r1,#0
        B       %BT10

; ------------------------------------------------------------------------
; ReadTimeZones
;
; In:
;       IF R4 = 'ZONE'
;          R1 = timezone to lookup, 0 to NumberOfTZ - 1
;
; Out:
;       R0 -> name of standard TZ if this territory was in use
;       R1 -> name of summer TZ if this territory was in use
;       R2 = Offset from UTC to standard time
;       R3 = Offset from UTC to summer time.
;       IF R4 = 'ZONE' on entry, R4 = 0
;
ReadTimeZones
        LDR     r0, =ReadTimeZones_Extension
        TEQ     r0, r4
        MOVNE   r1, #0                  ; Behave as no extension
        MOVEQ   r4, #0                  ; Denote extension is supported

        CMP     r1, #NumberOfTZ
        ADRCS   r0,ErrorBlock_NoMoreZones
        BCS     message_errorlookup

        GBLA    tz_aligned
        GBLA    tz_tableentry
tz_aligned      SETA ((MaxTZLength + 1) + 3) :AND: :NOT: 3
tz_tableentry   SETA (tz_aligned * 2) + 4 + 4
        ADR     r0, tz_table
        MOV     r3, #tz_tableentry
        MLA     r0, r1, r3, r0
        ADD     r1, r0, #tz_aligned
        LDR     r2, [r0, #0 + (2 * tz_aligned)]
        LDR     r3, [r0, #4 + (2 * tz_aligned)]
        MOV     pc, lr

ErrorBlock_NoMoreZones
        DCD     TerritoryError_NoMoreZones
        DCB     "NMZones",0
        ALIGN

tz_table
        GBLA    counter
        GBLS    suffix
        GBLS    strstd
        GBLS    strdst
        GBLS    offstd
        GBLS    offdst
        WHILE   counter < NumberOfTZ
      [ counter >= 16
suffix    SETS  :STR:counter:RIGHT:2
      |
suffix    SETS  :STR:counter:RIGHT:1
      ]
strstd  SETS    "NODST":CC:suffix
strdst  SETS    "DST":CC:suffix
offstd  SETS    "NODSTOffset":CC:suffix
offdst  SETS    "DSTOffset":CC:suffix
        DCB     $strstd, 0
        SPACE   tz_aligned - 1 - :LEN:$strstd
        DCB     $strdst, 0
        SPACE   tz_aligned - 1 - :LEN:$strdst
        DCD     $offstd
        DCD     $offdst
counter SETA    counter + 1
        WEND

; ------------------------------------------------------------------------
; ReadSymbols
;
; In:
;       R1 - Reason code:
;               0 Return pointer to 0 terminated decimal point string.
;               1 Return pointer to 0 terminated thousands separator
;               2 Return pointer byte list containing the size of each
;                 group of digits in formatted nonmonetary quantities.
;                 255   = No further grouping
;                   0   = Repeat last grouping for rest of number
;                 other = Size of current group, the next byte contains
;                         the size of the next group of dogits before the
;                          current group.
;               3 Return pointer to 0 terminated international currency symbol.
;               4 Return pointer to 0 terminated currency symbol in local alphabet.
;               5 Return pointer to 0 terminated decimal point used for monetary quantities
;               6 Return pointer to 0 terminated thousands separator for monetary quantities
;               7 Return pointer byte list containing the size of each
;                 group of digits in formatted monetary quantities.
;               8 Return pointer to 0 terminated positive sign used for monetary quantities
;               9 Return pointer to 0 terminated negative sign used for monetary quantities
;              10 Return number of fractional digits to be displayed in an internationally
;                 formatted monetay quantity
;              11 Return number of fractional digits to be displayed in a formatted monetay
;                 quantity
;              12 Return 1 If the currency symbol precedes the value for a nonnegative
;                          formatted monetary quantity
;                        0 If the currency symbol succeeds the value for a nonnegative
;                          formatted monetary quantity
;              13 Return 1 If the currency symbol is separated by a space from the value for a
;                          nonnegative formatted monetary quantity
;                        0 If the currency symbol is not separated by a space from the value for a
;                          nonnegative formatted monetary quantity
;              14 Return 1 If the currency symbol precedes the value for a negative
;                          formatted monetary quantity
;                        0 If the currency symbol succeeds the value for a negative
;                          formatted monetary quantity
;              15 Return 1 If the currency symbol is separated by a space from the value for a
;                          negative formatted monetary quantity
;                        0 If the currency symbol is not separated by a space from the value for a
;                          negative formatted monetary quantity
;
;              16 Return for a nonnegative formatted monetary quantity
;                        0 If there are parentheses arround the quantity and currency symbol.
;                        1 If the sign string precedes the quantity and currency symbol.
;                        2 If the sign string succeeds the quantity and currency symbol.
;                        3 If the sign string immediately precedes the currency symbol.
;                        4 If the sign string immediately succeeds the currency symbol.
;              17 Return for a negative formatted monetary quantity
;                        0 If there are parentheses arround the quantity and currency symbol.
;                        1 If the sign string precedes the quantity and currency symbol.
;                        2 If the sign string succeeds the quantity and currency symbol.
;                        3 If the sign string immediately precedes the currency symbol.
;                        4 If the sign string immediately succeeds the currency symbol.
;              18 Return pointer to 0 terminated list separator
; Out:
;       R0 - Requested value.
ReadSymbols
        Push    "LR"

        ADR     R14,SymbolTable
        LDR     R0,[R14,R1,ASL #2]
        CMP     R0,#20
        ADDGE   R0,R0,R14

        Pull    "PC"

SymbolTable
        DCD     decimal_point           - SymbolTable
        DCD     thousands_sep           - SymbolTable
        DCD     grouping                - SymbolTable
        DCD     int_curr_symbol         - SymbolTable
        DCD     currency_symbol         - SymbolTable
        DCD     mon_decimal_point       - SymbolTable
        DCD     mon_thousands_sep       - SymbolTable
        DCD     mon_grouping            - SymbolTable
        DCD     positive_sign           - SymbolTable
        DCD     negative_sign           - SymbolTable
        DCD     int_frac_digits
        DCD     frac_digits
        DCD     p_cs_precedes
        DCD     p_sep_by_space
        DCD     n_cs_precedes
        DCD     n_sep_by_space
        DCD     p_sign_posn
        DCD     n_sign_posn
        DCD     list_symbol             - SymbolTable

decimal_point           DCB     "$Decimal",0
thousands_sep           DCB     "$Thousand",0
grouping                DCB     $Grouping
int_curr_symbol         DCB     "$IntCurr",0
currency_symbol         DCB     "$Currency",0
mon_decimal_point       DCB     "$MDecimal",0
mon_thousands_sep       DCB     "$MThousand",0
mon_grouping            DCB     $MGrouping
positive_sign           DCB     "$MPositive",0
negative_sign           DCB     "$MNegative",0
list_symbol             DCB     "$ListSymbol",0
        ALIGN

;---------------------------------------------------------------------------------
;ReadCalendarInformation
;
;In:
;   R1 = Pointer to 5 byte UTC time value.
;   R2 = Pointer to a 12 word buffer
;
;Out:
;
;   R1,R2 Preserved.
;
;   [R2+0]  = Number of first working day in the week.
;   [R2+4]  = Number of last working day in the week.
;   [R2+8]  = Number of months in the current year.
;             (current = one in which given time falls)
;   [R2+12] = Number of days in the current month.
;             (current = one in which given time falls)
;   [R2+16] = Max length of AM/PM string.
;   [R2+20] = Max length of WE string.
;   [R2+24] = Max length of W3 string.
;   [R2+28] = Max length of DY string.
;   [R2+32] = Max length of ST string (May be 0).
;   [R2+36] = Max length of MO string.
;   [R2+40] = Max length of M3 string.
;   [R2+44] = Max length of TZ string.
;
GetCalendarInformation
        Push    "r0-r11,LR"

        ADR     LR,CalendarInfo
        LDMIA   LR,{R0,R3-R11,LR}       ; Load fixed 11 items
        STMIA   R2!,{R0,R3,R4}          ; First three
        STMIB   R2,{R5-R11,LR}          ; Skip one, then next 8

        SWI     XTerritory_ReadCurrentTimeZone
        BVS     %FT02

        MOV     R2,R1
        LDR     R1,[SP,#1*4]
        BL      GetTimeValues

        ADRL    R0,MonthLengths
        LDRB    R0,[R0,R1]              ; Get length of month
        CMP     R1,#2                   ; Is Feb ?
        BNE     %FT01

        TST     R6, #3                  ; is year multiple of 4
        MOVNE   R0,#28                  ; no, then 29 Feb is bad
        BNE     %FT01

        TEQ     R6, #0                  ; is it a century year ?
        BNE     %FT01                   ; no, then 29 Feb is good

        TST     R5, #3                  ; is it a multiple of 400 ?
        MOVNE   R0,#28                  ; no, then 29 Feb is bad
01
        LDR     R2,[SP,#2*4]
        STR     R0,[R2,#12]
02
        STRVS   r0,[SP]
        Pull    "r0-r11,PC"

CalendarInfo
        DCD     FirstWorkDay    ; First working day in week 1=Sunday 7=Saturday
        DCD     LastWorkDay     ; Last  working day in week 1=Sunday 7=Saturday
        DCD     NumberOfMonths  ; Number of month in a year

        DCD     MaxAMPMLength   ; Max length of AM PM String
        DCD     MaxWELength     ; Max length of full day name
        DCD     MaxW3Length     ; Max length of short day name
        DCD     MaxDYLength     ; Max length of day in month
        DCD     MaxSTLength     ; Max length of st nd rd th ... string
        DCD     MaxMOLength     ; Max length of full month name.
        DCD     MaxM3Length     ; Max length of short month name.
        DCD     MaxTZLength     ; Max length of time zone name.

;---------------------------------------------------------------------------------
;NameToNumber
;
;In:
;   R1 = Pointer to territory name.
;
;Out:
;   R0 = 0 - Unknown territory
;        Else territory number.
NameToNumber     ROUT
        Entry   "r1-r7",8               ; We know tokens aren't long.

        BL      open_messages_file

; Enumerate all territory name tokens (TRnn)
        ADR     r0,message_file_block
        MOV     R4,#0                   ; First call
        ADR     R7,ToLowerTable

01
        ADR     R1,territory_token
        MOV     R2,SP
        MOV     R3,#8
        SWI     XMessageTrans_EnumerateTokens
        EXIT    VS
        CMP     R2,#0
        MOVEQ   r0,#0
        EXIT    EQ

; Get Message

        DebugS  xx,"Next token is ",R2
        MOV     R1,R2                   ; Token.
        MOV     R2,#0                   ; Don't copy message !
        SWI     XMessageTrans_Lookup
        EXIT    VS

; Got message, now compare with territory name in string.

        LDR     R1,[SP,#8]              ; get user R1
02
        LDRB    R14,[R2],#1
        CMP     R14,#10
        BEQ     %FT03                   ; End of message
        LDRB    R14,[R7,R14]            ; Lower case

        LDRB    R10,[R1],#1
        CMP     R10,#0
        MOVEQ   r0,#0
        EXIT    EQ
        LDRB    R10,[R7,R10]            ; Lower case

        CMP     R14,R10
        BEQ     %BT02                   ; Try next character.
        B       %BT01                   ; Try next token.
03
        LDRB    R10,[R1],#1
        CMP     R10,#" "
        BGE     %BT01                   ; Not end of user input !

        MOV     R0,#10                  ; Check token number
        ADD     R1,SP,#2
        SWI     XOS_ReadUnsigned
        MOVVC   R0,R2
        EXIT

territory_token
        DCB     "TR*",0
        ALIGN

        LNK     Tables.s

@


1.13
log
@Add support for collation with numbers
Flag bit 2 to Territory_Collate will now cause the territory module to consider digits 0-9 as though they were cardinals rather than as text.
For example, an fl ligature followed by 50 would be considered to be equal to "fl000000050" when in this mode.
Test program added to test directory, the algorithm used is based on strnatcmp().

Version 0.59. Tagged as 'Module-0_59'
@
text
@d532 2
a534 1
        BICEQ   r3,r3,#Collate_InterpretCardinals
d538 1
a538 1
        BEQ     %BT01                   ; Carry on collating from that digit
@


1.12
log
@Addition of supporting functions for automatic daylight saving switchover
In the default implementation SWI Territory_DaylightRules uses textual rule descriptions from the messages file for the respective territory. Other 3rd party territory module providers may choose to do it some other way, for example in code.
The use of MessageTrans allows for sneaky wildcarding of the rules too.
For all currently supported territories rules post year 2000 are included (for most EU countries this is simple due to pan European standardisation), other countries vary in complexity - the rules for the UK go back to the late 1960's mostly as a test vector for the parsing code.
DateTime.s:
  New parsing functions.
  New flags support added to Territory_ConvertDateAndTime to allow the output text to be transformed as though DST was (or wasn't) in effect.
  Related Territory_ConvertStandardDate/StandardTime/StandardDateAndTime changed too.
  Likewise Territory_ConvertOrdinalsToTime.
  Reindented a bit, swap to objasm's DCD and DCB for constant tables.
Entries.s
  New flags support added to Territory_ReadTimeZones.
  Macroised the table of timezones within a territory in a better way.
Finland.s
  Timezones renamed to preferred EET and EEST.
ModHead.s
  Split out the message file block into discrete block and flag.
Territory.s
  Removed unused 100 byte error buffer.

Version 0.55. Tagged as 'Module-0_55'
@
text
@d152 1
d167 1
a167 1
        Push    "r1-r7,LR"
d177 1
a177 1

d179 1
a179 1
        LDRB    r14,[r1],#1
d183 1
a183 1
        Debug   xx,"r14,r6",r14,r6
d186 2
a187 2
        TEQ     r14,#'A'
        TEQNE   r14,#'a'
d192 2
a193 2
        TEQ     r14,#'A'
        TEQNE   r14,#'a'
d196 1
a196 1
        TEQ     r0, r14
d198 1
a198 1
        TEQ     r14,#'A'
d202 3
a204 3
        TEQ     r14,#'A'        ; Got aa, Aa or AA.
        MOVEQ   r14,#'Å'
        MOVNE   r14,#'å'
d224 8
a231 1

d233 1
a233 1
        LDRNEB  r14,[r5,r14]
d236 1
a236 1
        Debug   xx,"r14,r6",r14,r6
d239 1
a239 1
        LDRNEB  r14,[r4,r14]
d242 1
a242 1
        Debug   xx,"r14,r6",r14,r6
d245 2
a246 2
        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
d251 2
a252 2
        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
d256 1
a256 1
        MOVNE   r14, #'f'
d259 3
a261 3
        TEQ     r14, #'ž'
        MOVEQ   r14, #'i'
        MOVNE   r14, #'l'
d278 2
a279 2
        TEQ     r14,#'š'
        TEQNE   r14,#'›'
d284 2
a285 2
        TEQ     r14,#'š'
        TEQNE   r14,#'›'
d291 3
a293 3
        TEQ     r14,#'š'
        MOVEQ   r14,#'O'
        MOVNE   r14,#'o'
d295 3
a297 3
11      TEQ     r14,#'š'
        MOVEQ   r14,#'E'
        MOVNE   r14,#'e'
d317 2
a318 2
        TEQ     r14,#'Þ'
        TEQNE   r14,#'þ'
d323 2
a324 2
        TEQ     r14,#'Þ'
        TEQNE   r14,#'þ'
d330 3
a332 3
        TEQ     r14,#'Þ'
        MOVEQ   r14,#'T'
        MOVNE   r14,#'t'
d334 3
a336 3
21      TEQ     r14,#'Þ'
        MOVEQ   r14,#'H'
        MOVNE   r14,#'h'
d356 1
a356 1
        TEQ     r14, #'ß'
d359 1
a359 1
        MOVNE   r14, #'s'
d369 1
a369 1
        LDRB    r14,[r7,r14]
d372 1
a372 1
        Debug   xx,"r14,r6",r14,r6
d374 3
a376 3
        SUBS    r0,r14,r6
        Pull    "r1-r7,PC",NE           ; Not equal, result is result of compare.
        TEQ     r14,#0
d378 3
a380 3
30      LDR     r14,[sp,#8]             ; Get original flags
        EORS    r14,r3,r14
        Pull    "r1-r7,PC",EQ           ; Done desired comparison - they're equal
d386 1
a386 1
        TST     r14,#Collate_IgnoreAccent ; Do they want us to differ accents?
d416 1
a416 1
        LDRB    r14,[r1,#-1]!
d419 1
a419 1
        LDRB    r14,[r4,r14]            ; We must be ignoring case at this point
d422 3
a424 3
 [ CollateLatin1Ligatures
        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
d429 2
a430 2
        TEQ     r14,#'ž'
        TEQNE   r14,#'Ÿ'
d434 1
a434 1
        MOVEQ   r14, #'f'
d437 3
a439 3
        TEQ     r14, #'ž'
        MOVEQ   r14, #'i'
        MOVNE   r14, #'l'
d453 1
a453 1
 ]
d455 3
a457 3
 [ CollateOELigatures
        TEQ     r14,#'š'
        TEQNE   r14,#'›'
d462 2
a463 2
        TEQ     r14,#'š'
        TEQNE   r14,#'›'
d468 3
a470 3
        TEQ     r14,#'š'
        MOVEQ   r14,#'O'
        MOVNE   r14,#'o'
d472 3
a474 3
51      TEQ     r14,#'š'
        MOVEQ   r14,#'E'
        MOVNE   r14,#'e'
d492 1
a492 1
 ]
d494 1
a494 1
        LDRB    r14,[r7,r14]
d497 2
a498 2
        SUBS    r0,r14,r6
        Pull    "r1-r7,PC",NE           ; Not equal, result is result of compare.
d503 52
a622 1

@


1.11
log
@A few bug fixes.
The scratch space was not large enough to hold the table for Territory_Register and overran. Buffer made bigger and assert added.
Convert time string to ordinals did not fault 29th Feb in 1900/2100/2200 due to leap year rule error.
For Japan, the SetUpEras function was never called so Japanese eras didn't work.
Duff error block being returned for SWI out of range (was using the error number instead of the address of the error block).
A couple of magic numbers swapped for header file defs.

Version 0.54. Tagged as 'Module-0_54'
@
text
@d500 3
a502 3
;       R0 = b31-27 zone within territory to return
;            b26-10 reserved (0)
;            b9-0   my territory number
d508 1
d511 25
a535 1
        MOV     r0,r0,LSR #27
d537 1
d540 3
a542 3
        GBLS    namenodst
        GBLS    namedst
        GBLS    offnodst
a544 2
        TEQ     r0,#counter
        BNE     %FT03
d550 10
a559 13
namenodst SETS  "NODST":CC:suffix
namedst   SETS  "DST":CC:suffix
offnodst  SETS  "NODSTOffset":CC:suffix
offdst    SETS  "DSTOffset":CC:suffix
        ADR     r0, %FT00
        ADR     r1, %FT01
        LDR     r2, =$offnodst
        LDR     r3, =$offdst
        MOV     pc, lr
00      DCB     $namenodst,0
01      DCB     $namedst,0
        ALIGN
03
a562 7
        ADR     r0,ErrorBlock_NoMoreZones
        B       message_errorlookup

ErrorBlock_NoMoreZones
        DCD     TerritoryError_NoMoreZones
        DCB     "NMZones",0
        ALIGN
d700 5
d706 1
a706 1
        BVS     %FT02
d757 1
a757 1
        ADR     r0,message_file_block+4
d796 1
a796 1
        B       %BT01                   ; Try next month.
@


1.10
log
@Add ability to programmatically enumerate available timezones within a territory.
Reduced GBLL flag proliferation by using a WHILE/WEND loop to generate the code in Territory_ReadTimeZones.
Moved the standard date and time format strings into 'DateTime.s'.
No longer returns untrappable error numbers of 0, nor unallocated error numbers.
Alaska now recognised as part of the USA following its incorporation in 1912.
Obsolete Yukon timezone removed from Canada.

SWI Territory_ReadTimeZones (&4304A)
------------------------------------
=> R0 bits 0-9 territory number
      bits 10-26 reserved, must be zero
      bits 27-31 timezone within territory
   or -1 to use the current territory (ie. as though bits 10-31 zero)
<= R0 = name of standard time
   R1 = name of summer time
   R2 = signed offset of standard time from UTC in cs
   R3 = signed offset of summer time from UTC in cs

Version 0.53. Tagged as 'Module-0_53'
@
text
@d42 1
a42 1
        MOV     r0,#71
d657 1
a657 1
;   R2 = Pointer to an 11 word buffer
d663 1
a663 1
;   [R2]    = Number of first working day in the week.
d666 1
a666 1
;                 (current = one in which given time falls)
d668 1
a668 1
;
@


1.9
log
@Fix Territory_ReadTimeZones to behave as documented.
It was reading the current timezone CMOS and returning that in R2 then adding the difference between standard and summertime to get R3.
This meant that when in one territory it was not possible to enumerate the other territories' offsets since they all returned the current CMOS value.
Now, R2 and R3 are purely informational (looked up from the table in the module).

All terrtories on CET now call summertime the preferred "CEST".

Removed unnecessary clean rule from Makefile. Changed some one register push/pull to use macros. Changed filenames to be ".s" at the end.

Added extra switches for the other regions of the world that are wide enough to span multiple timezones. Currently there is no API to read these, so they are defined to cause an assembly error (affects USA/Canada1/Australia). Fixing that is a subject of discussion, whether to support one territory having multiple timezones or just make some extra territories?

Version 0.52. Tagged as 'Module-0_52'
@
text
@d104 1
a104 1
        DCD     0
d500 3
a502 1
;       -
d510 1
a510 8
        Push    "LR"

        ADR     r0, NODSTName
        ADR     r1, DSTName
        LDR     r2, =NODSTOffset
        LDR     r3, =DSTOffset
        
        Pull    "PC"
d512 13
a524 4
      [ USTimeZones :LOR: CanadaTimeZones :LOR: MexicoTimeZones :LOR: AustraliaTimeZones \
        :LOR: BrazilTimeZones :LOR: RussiaTimeZones :LOR: MongoliaTimeZones \
        :LOR: DemRepCongoTimeZones :LOR: KazakhstanTimeZones :LOR: IndonesiaTimeZones
        ! 1,    "API can't return more than one timezone at present"
d526 15
d542 2
a543 5
NODSTName                 DCB "$NODST",0
DSTName                   DCB "$DST",0
StandardDateFormat        DCB "$DateFormat",0
StandardTimeFormat        DCB "$TimeFormat",0
StandardDateAndTimeFormat DCB "$DateAndTime",0
d545 3
a792 12
;--------------------------------------------------------
UnknownEntry
        Debug   xx,"Territory : Unknown entry"

        ADR     r0,ErrorBlock_UnknownEntry
        B       message_errorlookup

ErrorBlock_UnknownEntry
        DCD     &43040
        DCB     "UnkSWI",0
        ALIGN

@


1.8
log
@  Updated build structure to use the shared AAsmModule makefile.
  BBE no longer needs to export all the sources.
  Fixed some non-32bit compatible code.
Detail:
  srcbuild has been updated to be able to process components which want
    to contribute multiple targets to a build.  This means that it is
    no longer necessary to export the entire sources for this component
    into BBE builds.
  There were still a few LDM {..pc}^ instructions around - these have been
    fixed.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.08 or later.
  Requires Env 0.65 or later.
  Requires srcbuild 0.31 if you need to generate a BBE from this component.

Version 0.48. Tagged as 'Module-0_48'
@
text
@d502 4
a505 4
;       R0 - Pointer to name of standard TZ
;       R1 - Pointer to name of summer TZ.
;       R2 - Offset from UTC to standard time
;       R3 - Offset from UTC to summer time.
d508 14
a521 1
        STMDB   sp!, {lr}
a522 117
        MOV     r0, #ReadCMOS
        MOV     r1, #TimeZoneCMOS
        SWI     XOS_Byte
        LDMVSIA sp!, {pc}

        MOV     r2, r2, LSL #24
        MOV     r2, r2, ASR #24

 [ USTimeZones
        CMP     r2, #-22
        ADRGE   r0, NODSTName1
        ADRGE   r1, DSTName1
        BGE     %FT10
        CMP     r2, #-26
        ADRGE   r0, NODSTName2
        ADRGE   r1, DSTName2
        BGE     %FT10
        CMP     r2, #-30
        ADRGE   r0, NODSTName3
        ADRGE   r1, DSTName3
        ADRLT   r0, NODSTName4
        ADRLT   r1, DSTName4
 |
 [ CanadaTimeZones
        CMP     r2, #-15
        ADRGE   r0, NODSTName35
        ADRGE   r1, DSTName35
        BGE     %FT10
        CMP     r2, #-18
        ADRGE   r0, NODSTName4
        ADRGE   r1, DSTName4
        BGE     %FT10
        CMP     r2, #-22
        ADRGE   r0, NODSTName5
        ADRGE   r1, DSTName5
        BGE     %FT10
        CMP     r2, #-26
        ADRGE   r0, NODSTName6
        ADRGE   r1, DSTName6
        BGE     %FT10
        CMP     r2, #-30
        ADRGE   r0, NODSTName7
        ADRGE   r1, DSTName7
        BGE     %FT10
        CMP     r2, #-34
        ADRGE   r0, NODSTName8
        ADRGE   r1, DSTName8
        ADRLT   r0, NODSTName9
        ADRLT   r1, DSTName9
 |
 [ AustraliaTimeZones
        CMP     r2, #-31
        ADRGE   r0, NODSTName8
        ADRGE   r1, DSTName8
        BGE     %FT10
        CMP     r2, #-37
        ADRGE   r0, NODSTName95
        ADRGE   r1, DSTName95
        BGE     %FT10
        CMP     r2, #-39
        ADRGE   r0, NODSTName10
        ADRGE   r1, DSTName10
        BGE     %FT10
        ADRLT   r0, NODSTName95  ; assume they are in the central area
        ADRLT   r1, DSTName95
 |
        ADR     R0,NODSTName
        ADR     R1,DSTName
 ]
 ]
 ]
10
        ADD     r3, r2, r2, ASL #1
        ADD     r3, r2, r3, ASL #3
        RSB     r3, r3, r3, ASL #4
        RSB     r3, r3, r3, ASL #4

        MOV     r2, r3, ASL #4
        LDR     r3, =(DSTOffset-NODSTOffset)
        ADD     r3, r3, r2

        LDMIA   sp!, {pc}

 [ USTimeZones
NODSTName1                DCB "$NODST1",0
DSTName1                  DCB "$DST1",0
NODSTName2                DCB "$NODST2",0
DSTName2                  DCB "$DST2",0
NODSTName3                DCB "$NODST3",0
DSTName3                  DCB "$DST3",0
NODSTName4                DCB "$NODST4",0
DSTName4                  DCB "$DST4",0
 |
 [ CanadaTimeZones
NODSTName35               DCB "$NODST35",0
DSTName35                 DCB "$DST35",0
NODSTName4                DCB "$NODST4",0
DSTName4                  DCB "$DST4",0
NODSTName5                DCB "$NODST5",0
DSTName5                  DCB "$DST5",0
NODSTName6                DCB "$NODST6",0
DSTName6                  DCB "$DST6",0
NODSTName7                DCB "$NODST7",0
DSTName7                  DCB "$DST7",0
NODSTName8                DCB "$NODST8",0
DSTName8                  DCB "$DST8",0
NODSTName9                DCB "$NODST9",0
DSTName9                  DCB "$DST9",0
 |
 [ AustraliaTimeZones
NODSTName8                DCB "$NODST8",0
NODSTName95               DCB "$NODST95",0
NODSTName10               DCB "$NODST10",0
DSTName8                  DCB "$DST8",0
DSTName95                 DCB "$DST95",0
DSTName10                 DCB "$DST10",0
 |
a524 3
 ]
 ]
 ]
@


1.7
log
@
  * South African territory module created.

Detail:

  * Territory module for South Africa created, based upon the UK version
    but incorporating the differences as docmented in "Doc.Settings"
    (document ref. 2503,049/T-01).

  * StripDepnd support added to makefile.

Admin:

  * Built on RPC.  To be verified in development Bethany build.

Version 0.46. Tagged as 'Module-0_46'
@
text
@d893 1
a893 1
        LNK     s.Tables
@


1.6
log
@  Added Ireland, Spain & Australia.
Detail:
  * Territory information added for Ireland and Australia, taken from the
    UK.
  * Spain information from translators for names. Spanish collation order
    taken from GNU Lib C whilst waiting for more information from the
    translators.
  * MakeSorted perl script added to process localedata from GNU Lib C into
    a collation order.
Admin:
  * Awaiting more information from the translators to correct the
    spanish collation order.

Version 0.38. Tagged as 'Module-0_38'
@
text
@d686 1
a686 1
;                        4 If the sign string immediately succeeds the  currency symbol.
d692 1
a692 1
;                        4 If the sign string immediately succeeds the  currency symbol.
@


1.5
log
@Added Turkish, Italian and German territories. The Turkish and Italian are
still unfinished, and probably totally wrong, but at least they're there and
will build.

Also, a minor collation fix for Thorn=TH, and currency of France changed to
the Euro.

Version 0.36. Tagged as 'Module-0_36'
@
text
@d504 1
a504 1
;       R2 - Offser from UTC to standard time
d560 16
d580 1
d619 8
d629 1
@


1.4
log
@Implemented option for reverse prioritisation of accents during second
collation stage.
Added French and French Canadian territories.
Added option for standalone builds.

Version 0.34. Tagged as 'Module-0_34'
@
text
@d168 2
a169 3
 [ CollateLatin1Ligatures :LOR: CollateOELigatures :LOR: CollateDanishAA :LOR: CollateThornAsTH
        BIC     r3, r3, #&ff000000
 ]
d333 2
a334 2
23      EOR     r3, r3, #&04000000
        TST     r3, #&04000000
d345 14
@


1.3
log
@Changed to cope with new Hdr:CMOS
Fills in unknown SWI table entries correctly, as per PRM 3-794
Implemented Territory_IME SWI.

Version 0.30. Tagged as 'Module-0_30'
@
text
@a171 1
 [ newsortorder
a175 6
 |
        TST     r3,#Collate_IgnoreCase
        ADRNEL  r4,ToLowerTable
        TST     r3,#Collate_IgnoreAccent
        ADRNEL  r5,ToPlainForCollateTable
 ]
d298 1
a298 1
        SUB     r1, r1, #1
a355 1
 [ newsortorder
d357 1
a357 1
        LDR     r14,[sp,#8]             ; Get original flags
d361 1
d363 1
d367 5
d373 1
d377 104
a480 3
 |
        Pull    "r1-r7,PC",EQ           ; Both 0 -> Strings equal.
        B       %B01
d519 27
a545 1
10
d550 2
a551 1

d573 16
d591 1
@


1.2
log
@Nearly complete Danish territory added.
Dummy Swedish territory added.

Version 0.29. Tagged as 'Module-0_29'
@
text
@d56 6
d697 12
a709 1

@


1.1
log
@Japanese, UK and USA territories merged into one source tree.
Collation order fixed - three pass scheme, sorting first on letters, then on
accents, then on case.
Currency code GBL fixed to GBP [UK]
fi and fl ligatures collated as equivalent to separate fi, fl [UK, USA]
Territory_NameToNumber now handles non-contiguous names in Messages file.
Euro symbol marked as punctuation [UK, USA]
ToControlTable fixed [UK, USA]
%ST string changed to "Day" ideograph [Japan]
Territory name lists extended.

Version 0.26. Tagged as 'Module-0_26'
@
text
@d162 2
a163 2
 [ CollateLatin1Ligatures
        BIC     r3, r3, #&f0000000
d170 1
a170 1
        ADRL    r5,ToPlainTable
d175 1
a175 1
        ADRNEL  r5,ToPlainTable
d186 40
d269 78
@

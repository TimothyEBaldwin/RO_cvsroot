head	1.14;
access;
symbols
	IntKey-0_99:1.14
	IntKey-0_98-1:1.13
	IntKey-0_98:1.12
	IntKey-0_97:1.12
	IntKey-0_96:1.12
	IntKey-0_95:1.12
	IntKey-0_94:1.11
	IntKey-0_93:1.11
	IntKey-0_92:1.11
	IntKey-0_91:1.11
	IntKey-0_90:1.11
	RO_5_07:1.11
	IntKey-0_89:1.11
	IntKey-0_88:1.11
	IntKey-0_87:1.11
	IntKey-0_86:1.11
	IntKey-0_85:1.11
	IntKey-0_84:1.11
	IntKey-0_83:1.11
	IntKey-0_82:1.11
	IntKey-0_81:1.10
	IntKey-0_80:1.10
	IntKey-0_79:1.9
	IntKey-0_78:1.9
	IntKey-0_77:1.9
	IntKey-0_76:1.9
	dellis_autobuild_BaseSW:1.9
	IntKey-0_75:1.9
	IntKey-0_74:1.9
	IntKey-0_73:1.9
	IntKey-0_72:1.9
	IntKey-0_71:1.9
	sbrodie_sedwards_16Mar2000:1.9
	IntKey-0_70:1.9
	dcotton_autobuild_BaseSW:1.10
	IntKey-0_69:1.9
	IntKey-0_68:1.9
	IntKey-0_67:1.8
	IntKey-0_66:1.8
	IntKey-0_65:1.8
	IntKey-0_64:1.6
	IntKey-0_63:1.6
	IntKey-0_62:1.5
	IntKey-0_61:1.5
	IntKey-0_60:1.5
	IntKey-0_59:1.5
	IntKey-0_58:1.4
	IntKey-0_57:1.3
	IntKey-0_56:1.2
	IntKey-0_55:1.2
	IntKey-0_54:1.2
	IntKey-0_53:1.2
	IntKey-0_52:1.2
	bavison_Generic_InternationalKeyboard-0_51:1.2;
locks; strict;
comment	@# @;


1.14
date	2018.01.21.09.33.13;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	bZ0A71UCujpfZInA;

1.13
date	2017.10.22.20.07.15;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	2spUu13hKJVJp5cA;

1.12
date	2012.12.05.01.40.25;	author jlee;	state Exp;
branches;
next	1.11;
commitid	XFeMFw6wUN4JzYuw;

1.11
date	2001.11.27.16.58.00;	author kbracey;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.14.16.08.37;	author sbrodie;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.15.39.50;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	99.08.26.15.22.53;	author sforrest;	state Exp;
branches;
next	1.7;

1.7
date	99.08.26.13.49.16;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	99.04.26.11.24.36;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	99.02.17.08.59.53;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	98.11.11.12.25.28;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.11.09.10.57.30;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	98.09.02.08.54.48;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	98.09.01.16.38.27;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Fix ideograph range check and a couple of resource leaks
unicdata.c: condition changed to match unictype_is_ideograph() in UnicodeLib
keygen.c: free kb
keyconvert.c: free memory and close files on exit (the C environment would do this anyway, but this makes it explicit)
Picked up by static analysis
  https://www.riscosopen.org/forum/forums/4/topics/9503#posts-72623

Version 0.99. Tagged as 'IntKey-0_99'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

#include "Global/Keyboard.h"

#include "Unicode/iso10646.h"

#include "unicdata.h"
#include "structures.h"
#include "throwback.h"

#define MAX_FILE_DEPTH 16
static FILE *sourcefile[MAX_FILE_DEPTH];
static char *sourcefilename[MAX_FILE_DEPTH];
static int sourceline[MAX_FILE_DEPTH];
static int filedepth;

static const char *ExtraKeys, *FNKey;

static LLK keypad_codes[]={
                   KeyNo_NumPadSlash, KeyNo_NumPadStar, KeyNo_NumPadHash,
    KeyNo_NumPad7, KeyNo_NumPad8,     KeyNo_NumPad9,    KeyNo_NumPadMinus,
    KeyNo_NumPad4, KeyNo_NumPad5,     KeyNo_NumPad6,    KeyNo_NumPadPlus,
    KeyNo_NumPad1, KeyNo_NumPad2,     KeyNo_NumPad3,
    KeyNo_NumPad0,                    KeyNo_NumPadDot,  KeyNo_NumPadEnter,
    0
};

typedef struct charinfo
{
    UCS4 code;
    char *name;
} charinfo;

/* Must be sorted */
static charinfo funclist[] =
{
    0xC0, "ACORN",
    0xC8, "ALL CANDIDATES",
    0x08, "BACKSPACE",
    0x8A, "BREAK",
    0xC6, "CONVERT",
    0x8B, "COPY",
    0x7F, "DELETE",
    0x8E, "DOWN",
    0xC4, "EISUU",
    0x8B, "END",
    0x0D, "ENTER",
    0x1B, "ESCAPE",
    0x81, "F1",
    0xCA, "F10",
    0xCB, "F11",
    0xCC, "F12",
    0x82, "F2",
    0x83, "F3",
    0x84, "F4",
    0x85, "F5",
    0x86, "F6",
    0x87, "F7",
    0x88, "F8",
    0x89, "F9",
    0x1E, "HOME",
    0xCD, "INSERT",
    0xC7, "KANA",
    0xC3, "KANJI",
    0xC9, "KANJI NUMBER",
    0x8C, "LEFT",
    0xC1, "MENU",
    0xC5, "NO CONVERSION",
    0x9E, "PAGE DOWN",
    0x9F, "PAGE UP",
    0x80, "PRINT",
    0x8D, "RIGHT",
    0x8F, "UP",
    0xC2, "WIDTH",
};

#define FUNCTIONS (sizeof funclist / sizeof funclist[0])

static charinfo speclist[] =
{
    0x03, "CAPS LOCK",
    0x07, "CONFIGURED KEYBOARD",
    0x06, "DEFAULT KEYBOARD",
    0x09, "DELETE",
    0x08, "DIAL KEYBOARD",
    0x04, "KANA LOCK",
    0x01, "NUM LOCK",
    0x00, "SCROLL LOCK",
    0x05, "SHIFT-CAPS LOCK",
    0x02, "TAB",
};

#define SPECIALS (sizeof speclist / sizeof speclist[0])

static charinfo deadlist[] =
{
     2, "ACUTE ACCENT",
     6, "BREVE",
    11, "CARON",
    13, "CEDILLA",
     3, "CIRCUMFLEX ACCENT",
     8, "DIAERESIS",
     7, "DOT ABOVE",
    10, "DOUBLE ACUTE ACCENT",
     1, "GRAVE ACCENT",
     8, "GREEK DIALYTIKA",
    15, "GREEK DIALYTIKA TONOS",
    12, "GREEK TONOS",
     5, "MACRON",
    14, "OGONEK",
     9, "RING ABOVE",
    16, "STROKE",
     4, "TILDE",
    12, "VERTICAL LINE ABOVE",
};

#define DEADS (sizeof deadlist / sizeof deadlist[0])

static const char *current_output_file;
static FILE *current_output_handle;
static int throwback, depend;

void error(const char *p);

void error(const char *p)
{
    fprintf(stderr, "%s, line %d: %s\n", sourcefilename[filedepth],  sourceline[filedepth], p);
    if (throwback)
        throwback_send(1, sourceline[filedepth], p, sourcefilename[0], sourcefilename[filedepth]);
    fclose(current_output_handle);
    remove(current_output_file);
    exit(1);
}


static int cmp_name2(const void *p1, const void *p2)
{
    char *n = (char *) p1;
    charinfo *c2 = (charinfo *) p2;

    return strcmp(n, c2->name);
}

static UCS4 function_key_code(const char *p)
{
    UCS4 c, c2;
    int ctrl=0, shift=0;
    charinfo *ci;

    /* Check for raw &8A */
    if (*p == '&' && *(p+1) != '\0')
    {
        char *end;
        c = (UCS4) strtol(p+1, &end, 16);
        if (*end != '\0' || c < 0x80 || c >= 0xFF)
            error("Bad hex");
        return 0x80000000 + c;
    }

    /* Check for CTRL-B etc */
    if (strncmp(p, "CTRL-", 5) == 0)
    {
        c = p[5];
        c2 = p[6];
        if (c >= '@@' && c <= '_' && c2 == '\0')
            return c-'@@';
        if (c == '?' && c2 == '\0')
            return 127;
    }

    /* CTRL and SHIFT modifiers for other keys */

    if (strncmp(p, "CTRL-", 5) == 0)
    {
        ctrl = 0x20;
        p+=5;
    }

    if (strncmp(p, "SHIFT-", 6) == 0)
    {
        shift = 0x10;
        p+=6;
    }

    ci = (charinfo *) bsearch(p, funclist, FUNCTIONS, sizeof funclist[0], cmp_name2);
    if (ci == NULL)
    {
        error("Unknown function key");
        return NULL_UCS4;
    }

    if (ci->code < 0x80)
    {
        /* no shift/ctrl variants of these codes, and bit 31 needn't be set */
        return ci->code;
    }

    return (0x80000000 + ci->code) ^ ctrl ^ shift;
}

static UCS4 special_key_code(const char *p)
{
    charinfo *ci;

    ci = (charinfo *) bsearch(p, speclist, SPECIALS, sizeof speclist[0], cmp_name2);
    if (ci == NULL)
    {
        error("Unknown special key");
        return NULL_UCS4;
    }

    return 0x80010000 + ci->code;
}

static UCS4 dead_key_code(const char *p)
{
    charinfo *ci;

    ci = (charinfo *) bsearch(p, deadlist, DEADS, sizeof deadlist[0], cmp_name2);
    if (ci == NULL)
    {
        error("Unknown dead key");
        return NULL_UCS4;
    }

    return 0x80020000 + ci->code;
}

static UCS4 keycode_from_name(const char *name)
{
    if (name[0]=='-' && name[1]=='\0')
        return NULL_UCS4;

    if (strncmp(name, "FUNCTION KEY ", 13)==0)
        return function_key_code(name+13);

    if (strncmp(name, "SPECIAL KEY ", 12)==0)
        return special_key_code(name+12);

    if (strncmp(name, "DEAD KEY ", 9)==0)
        return dead_key_code(name+9);

    return UCS_from_name(name);
}

static char *getline(char *p, size_t plen)
{
    char *ret;
    int l;

  start_again:

    do
    {
        sourceline[filedepth]++;
        ret = fgets(p, plen, sourcefile[filedepth]);
        if (!ret)
        {
            /* EOF - either return from the current include file, or give up */
            if (filedepth)
            {
                free(sourcefilename[filedepth]);
                fclose(sourcefile[filedepth]);
                sourcefile[filedepth--] = NULL;
                l = 0;
                continue;
            }
            else
                return NULL;
        }

        l = strlen(p);
        if (p[l-1] == '\n')
            p[--l] = '\0';

        while (l && p[l-1] == ' ')
            p[--l] = '\0';

    } while (l == 0 || p[0] == '#');

    if (p[0] == '%' && memcmp(p, "%Include ", 9) == 0)
    {
        if (filedepth == MAX_FILE_DEPTH-1)
            error("%Include depth too great");
        else
        {
            const char *newinclude;
            if (strcmp(p+9, "@@ExtraKeys@@") == 0)
            {
                if (ExtraKeys)
                    newinclude = ExtraKeys;
                else
                    goto start_again;
            }
            else if (strcmp(p+9, "@@FNKey@@") == 0)
            {
                if (FNKey)
                    newinclude = FNKey;
                else
                    goto start_again;
            }
            else
                newinclude = p+9;

            /* Mustn't increment filedepth until all errors cleared */
            if ((sourcefilename[filedepth+1]=malloc(strlen(newinclude)+1)) == NULL)
                error("Out of memory");
            strcpy(sourcefilename[filedepth+1], newinclude);
#ifdef UNIX
            { char *dot = sourcefilename[filedepth+1]; while ((dot = strchr(dot, '.')) != NULL) *dot++ = '/'; }
#endif
            if ((sourcefile[filedepth+1] = fopen(sourcefilename[filedepth+1], "r")) == NULL)
                error("Unable to open %Include file");
            sourceline[++filedepth]=0;

            if (depend)
                add_dependency(current_output_file, sourcefilename[filedepth]);

            goto start_again;
        }
    }

    return p;
}

static bool is_modifier_key(LLK key)
{
    return key == KeyNo_Break || key == KeyNo_CtrlLeft || key == KeyNo_ShiftLeft ||
           key == KeyNo_ShiftRight || key == KeyNo_AltLeft || key == KeyNo_AltRight ||
           key == KeyNo_CtrlRight || key == KeyNo_FN ||
           key == KeyNo_LeftMouse || key == KeyNo_CentreMouse || key == KeyNo_RightMouse;
}

static bool is_keypad_key(LLK key)
{
    if(key == 0)
        return false;
    for(int i=0;i<sizeof(keypad_codes)/sizeof(keypad_codes[0]);i++)
        if(keypad_codes[i] == key)
            return true;
    return false;
}

static bool is_special_key(int key)
{
    return key == KeyNo_ScrollLock || key == KeyNo_NumLock || key == KeyNo_Tab ||
           key == KeyNo_CapsLock || is_modifier_key(key);
}

static void read_keypad(Keyboard *kb)
{
    int i=0;
    char buffer[256];
    char *second, *p;
    UCS4 k, k2;

    while (getline(buffer, 256))
    {
        if (buffer[0] == '$')
        {
            if (strcmp(buffer, "$EndKeypad")==0)
            {
                if (i < 17)
                    error("Too few keypad keys");
                return;
            }
            else
                error("Unexpected directive");
        }

        if (i >= 17)
            error("Too many keypad keys");

        second = strchr(buffer, ';');
        if (second)
        {
            *second='\0';
            p = (second++)-1;
            while (p>=buffer && *p==' ')
                *p--='\0';
            while (*second==' ')
                second++;
        }

        k = keycode_from_name(buffer);
        if (second)
            k2 = keycode_from_name(second);
        else
            k2 = k;

        if ((k >= 0x80 && k < 0x80000080) || (k >= 0x800000FF && k < 0xFFFFFFFF) ||
            (k2 >= 0x80 && k2 < 0x80000080) || (k2 >= 0x800000FF && k2 < 0xFFFFFFFF))
            error("I'm afraid you can't put that character on the keypad");

        kb->keypad[0][i]=(unsigned char)k;
        kb->keypad[1][i++]=(unsigned char)k2;
    }

    error("Unexpected end of file");
}

static void read_fnkey(Keyboard *kb)
{
    int i=0;
    char buffer[256];
    char *p;
    unsigned long k, k2;

    for (i=0; i<kb->maxkeys; i++)
        kb->key[i].fn = -1;

    kb->fnused = false;
    i = 0;

    while (getline(buffer, 256))
    {
        if (buffer[0] == '$')
        {
            if (strcmp(buffer, "$EndFNKey")==0)
            {
                return;
            }
            else
                error("Unexpected directive");
        }

        k = strtoul(buffer, &p, 16);
        if (k >= kb->maxkeys)
            error("Expected key number");

        k2 = strtoul(p, NULL, 16);
        if (k2 >= kb->maxkeys || k == k2)
            error("Expected key number");

        /* Can only map non-modifier keys to other non-modifier keys */
        if (is_modifier_key((LLK) k) && !kb->key[k].defined ||
            is_modifier_key((LLK) k2) && !kb->key[k2].defined)
            error("I'm sorry, I'm afraid I can't do that");

        kb->key[k].defined = true;
        kb->key[k2].defined = true;

        kb->key[k].fn = (LLK) k2;
        kb->fnused = true;
        if (++i > 0xFF)
            error("Too many FN mappings");
    }

    error("Unexpected end of file");
}

static void read_layer(Keyboard *kb, int layerno)
{
    char buffer[256];
    char scaps[8], caps[8];
    int key, i, replace=0;
    char *p;

    while (getline(buffer, 256))
    {
        char uc[8];

        if (buffer[0] == '$')
        {
            if (strcmp(buffer, "$EndLayer")==0)
                return;
        }

        key = (int) strtol(buffer, &p, 16);
        if (p == buffer || key < 0 || key >= kb->maxkeys)
            error("Expected key number");

        while (*p <= ' ' && *p != '\0')
            p++;

        if (*p != '\0')
        {
            if (strcmp(p, "replace") == 0)
                replace = 1;
            else
                error("Unexpected trailing garbage after key number");
        }

        if (!replace && kb->key[key].definedinlayer[layerno])
            error("Key already defined");

        if (is_modifier_key(key))
            kb->needshiftinglist = true;

        if (is_keypad_key(key))
            error("Use $Keypad to alter keypad keys");

        if (is_special_key(key))
            kb->needcodetable = true;

        kb->key[key].defined = true;
        kb->key[key].definedinlayer[layerno] = true;

        if (key >= kb->numkeys)
        {
            kb->numkeys = key + 1;
        }

        for (i=0; i<8; i++)
        {
            char *p=buffer, *q;
            static const char brack[] = "-[]-{}-()-<>";

            if (getline(buffer, 256) == NULL)
                error("Error reading key");

            q = *p != '-' ? strchr(brack, *p) : NULL;
            if (q)
            {
                uc[i] = q-brack+1;
                p++;
            }
            else
                uc[i] = 0;

            kb->key[key].character[layerno][i] = keycode_from_name(p);
        }

        /* Now we need to figure out the Caps Lock and Shift-Caps lock mappings.
         * The logic here is that two parts of a key may be an upper/lower pair,
         * marked with [ ] or { }. When Caps Lock is in force, you should always
         * get the upper case form of anything you press. When Shift-Caps is in
         * force, you should get the opposite case of anything you press.
         */
        kb->key[key].caps[layerno] = 0;
        for (i=0; i<8; i++)
        {
            int j;
            caps[i]=scaps[i]=i;
            for (j=0; j<8; j++)
            {
                if (uc[j] == uc[i] + 1)
                {
                    caps[i] = j;
                    scaps[i] = j;
                }
                else if (uc[j] == uc[i] - 1)
                    scaps[i] = j;
            }
            if (caps[i] == scaps[i])
            {
                kb->key[key].caps[layerno] |= caps[i] << i*4;
            }
            else
            {
                if (caps[i] == i)
                    kb->key[key].caps[layerno] |= (scaps[i]|8) << i*4;
                else
                    error("Inconsistent Caps Lock pairs");
            }
        }

        /* Now we work out if this is an "easy" key, ie one that the
         * kernel can handle itself.
         */
        kb->key[key].easylayer[layerno] = 0;
        for (i=0; i<8; i++)
        {
            UCS4 c = kb->key[key].character[layerno][i];
            kb->key[key].easych[layerno][i]=false;
            if ((i < 4 && (c <= 0x7F || c >= 0x80000080 && c <= 0x800000FE)) || c == 0xFFFFFFFF)
            {
                UCS4 kc, ksc;
                /* Okay, it's one of the kernel's 00-FF codes. What will the kernel
                 * do with Caps-Lock? */
                if ((c &~ 0x20) >= 'A' && (c &~ 0x20) <= 'Z')
                {
                    ksc = c ^ 0x20;
                    kc = c &~ 0x20;
                }
                else
                    kc = ksc = c;

                /* Does it match what we want? */
                if (ksc == kb->key[key].character[layerno][scaps[i]] &&
                    kc == kb->key[key].character[layerno][caps[i]])
                {
                    kb->key[key].easylayer[layerno]++;
                    kb->key[key].easych[layerno][i]=true;
                }
            }
        }
        if (kb->key[key].easylayer[layerno] < 8) kb->key[key].easylayer[layerno] = 0;
    }
    error("Unexpected end of file");
}

static void *xmalloc(size_t s)
{
    void *ret = malloc(s);
    if (!ret) error("Out of memory");
    return ret;
}

static void read_layout_file(Keyboard *kb)
{
    char buffer[256];
    int layer = -1;

    while (getline(buffer, 256))
    {
        if (buffer[0] == '$')
        {
            if (memcmp(buffer, "$Country ", 9)==0)
                kb->country = atoi(buffer + 9);
            else if (strcmp(buffer, "$LeftAltLayerSwitch")==0)
            {
                kb->leftaltlayerswitch = true;
                kb->needcodetable = true;
            }
            else if (memcmp(buffer, "$Layer ", 7)==0)
            {
                layer = atoi(buffer + 7);
                if (layer < 0 || layer >= MAXLAYERS)
                    error("Bad layer number");

                if (layer < kb->layers)
                    error("Layer already defined");

                read_layer(kb, layer);

                kb->layers++;
            }
            else if (strcmp(buffer, "$Keypad")==0)
            {
                if (kb->custompad)
                    error("Keypad already defined");
                kb->custompad=true;
                read_keypad(kb);
            }
            else if (strcmp(buffer, "$FNKey")==0)
                read_fnkey(kb);
            else if (memcmp(buffer, "$Type ", 6)==0)
            {
                strcpy(kb->type, buffer + 6);
            }
            else if (strcmp(buffer, "$Wide")==0)
            {
                kb->flags |= KeyHandler_Flag_Wide;
                kb->maxkeys = MAXKEYS;
            }
            else
                error("Unknown directive");
        }
        else
            error("Expecting a $ directive");
    }

}

static void output_layer(FILE *out, Keyboard *kb, int layerno)
{
    int i;

    fprintf(out, "\nUCSTable%s_%d\n", kb->id, layerno);

    for (i=0; i < kb->maxkeys; i++)
    {
        if (kb->key[i].defined && !kb->key[i].easy)
            fprintf(out, "        &       &%08X,&%08X,&%08X,&%08X ; &%02X\n"
                         "        &       &%08X,&%08X,&%08X,&%08X, &%08X\n",
                         kb->key[i].character[layerno][0],
                         kb->key[i].character[layerno][1],
                         kb->key[i].character[layerno][2],
                         kb->key[i].character[layerno][3],
                         i,
                         kb->key[i].character[layerno][4],
                         kb->key[i].character[layerno][5],
                         kb->key[i].character[layerno][6],
                         kb->key[i].character[layerno][7],
                         kb->key[i].caps[layerno]);
    }
}

static void output_simples(FILE *out, Keyboard *kb)
{
    int i,j,c, best;
    int t;

    if (kb->fnused)
    {
        /* Sorry lads, if FN's in use we can't have any simple keys */
        for (i=0; i<kb->maxkeys; i++)
            kb->key[i].easy = false;
        best = 0;
    }
    else
    {
        int bestmem;
        int specials;

        for (i=0; i<kb->maxkeys; i++)
        {
            kb->key[i].easy = true;
            for (j=0; j<kb->layers; j++)
            {
                if (!kb->key[i].easylayer[j])
                {
                    kb->key[i].easy = false;
                    break;
                }
                for (c=0; c<8; c++)
                    if (kb->key[i].character[j][c] != kb->key[i].character[0][c])
                    {
                        kb->key[i].easy = false;
                        break;
                    }
            }
        }

        /* How many should we put in the "easy" array? Want to
         * minimise memory usage. The memory usage is basically
         *      4 * (highest easy key+1) * width     for the KeyTran table
         *    + 36 * special keys * layers + special keys * width.    for SpecialList + UCSList
         *
         * Start off supposing every defined key is special,
         * then try effect of gradually extending the simple table.
         */

        for (i=0, specials=0; i < kb->maxkeys; i++)
            if (kb->key[i].defined)
                specials++;

        int width = (kb->flags & KeyHandler_Flag_Wide)?2:1;

        bestmem = 36*specials*kb->layers + specials*width;
        best = 0;

        for (i=0; i < kb->maxkeys; i++)
        {
            int mem;
            if (kb->key[i].easy && kb->key[i].defined) // we've saved one special code!!
                specials--;
            mem = (i+1)*4*width + 36*specials*kb->layers + specials*width;
            /*printf("%d simple, %d special, mem = %d\n", i, specials, mem);*/
            if (mem<bestmem)
            {
                best = i+1;
                bestmem = mem;
            }
        }

        for (i=best; i < kb->maxkeys; i++)
            kb->key[i].easy=false;
    }

    fprintf(out, "KeyTran%s\n", kb->id);
    for (i=0; i < best; i++)
        if (kb->key[i].easy)
            fprintf(out, "        $LLK    &%02X, &%02X, &%02X, &%02X\n",
                         kb->key[i].easych[0][0] ? kb->key[i].character[0][0]&0xFF : 0xFF,
                         kb->key[i].easych[0][1] ? kb->key[i].character[0][1]&0xFF : 0xFF,
                         kb->key[i].easych[0][2] ? kb->key[i].character[0][2]&0xFF : 0xFF,
                         kb->key[i].easych[0][3] ? kb->key[i].character[0][3]&0xFF : 0xFF);
        else
            fprintf(out, "        $LLK    &FF, &FF, &FF, &FF\n");

    fprintf(out, "KeyTran%sEnd\n\n", kb->id);

    fprintf(out, "\nSpecialList%s\n"
                 "        $LLK    ((SpecialList%sEnd - SpecialList%s) :SHR: LLKS) - 1\n",
                 kb->id, kb->id, kb->id);

    t=1;

    if (!kb->key[KeyNo_ShiftLeft].defined)     { fprintf(out, "        $LLK    KeyNo_ShiftLeft\n");   t++; }
    if (!kb->key[KeyNo_ShiftRight].defined)     { fprintf(out, "        $LLK    KeyNo_ShiftRight\n");  t++; }
    if (!kb->key[KeyNo_CtrlLeft].defined)      { fprintf(out, "        $LLK    KeyNo_CtrlLeft\n");    t++; }
    if (!kb->key[KeyNo_CtrlRight].defined)      { fprintf(out, "        $LLK    KeyNo_CtrlRight\n");   t++; }
    if (!kb->key[KeyNo_AltLeft].defined)       { fprintf(out, "        $LLK    KeyNo_AltLeft\n");     t++; }
    if (!kb->key[KeyNo_AltRight].defined)       { fprintf(out, "        $LLK    KeyNo_AltRight\n");    t++; }
    if (!kb->key[KeyNo_FN].defined)         { fprintf(out, "        $LLK    KeyNo_FN\n");          t++; }
    if (!kb->key[KeyNo_LeftMouse].defined)    { fprintf(out, "        $LLK    KeyNo_LeftMouse\n");   t++; }
    if (!kb->key[KeyNo_CentreMouse].defined)      { fprintf(out, "        $LLK    KeyNo_CentreMouse\n"); t++; }
    if (!kb->key[KeyNo_RightMouse].defined)    { fprintf(out, "        $LLK    KeyNo_RightMouse\n");  t++; }
    if (!kb->key[KeyNo_Break].defined)      { fprintf(out, "        $LLK    KeyNo_Break\n");       kb->key[KeyNo_Break].tablenum=t++; }

    fprintf(out, "SpecialList%sPad\n"
                 "        $LLK    KeyNo_NumPadSlash, KeyNo_NumPadStar, KeyNo_NumPadHash\n"
                 "        $LLK    KeyNo_NumPad7, KeyNo_NumPad8, KeyNo_NumPad9, KeyNo_NumPadMinus\n"
                 "        $LLK    KeyNo_NumPad4, KeyNo_NumPad5, KeyNo_NumPad6, KeyNo_NumPadPlus\n"
                 "        $LLK    KeyNo_NumPad1, KeyNo_NumPad2, KeyNo_NumPad3\n"
                 "        $LLK    KeyNo_NumPad0, KeyNo_NumPadDot, KeyNo_NumPadEnter\n",
                 kb->id);

    kb->key[KeyNo_NumPadSlash].tablenum=t++;
    kb->key[KeyNo_NumPadStar].tablenum=t++;
    kb->key[KeyNo_NumPadHash].tablenum=t++;
    kb->key[KeyNo_NumPad7].tablenum=t++;
    kb->key[KeyNo_NumPad8].tablenum=t++;
    kb->key[KeyNo_NumPad9].tablenum=t++;
    kb->key[KeyNo_NumPadMinus].tablenum=t++;
    kb->key[KeyNo_NumPad4].tablenum=t++;
    kb->key[KeyNo_NumPad5].tablenum=t++;
    kb->key[KeyNo_NumPad6].tablenum=t++;
    kb->key[KeyNo_NumPadPlus].tablenum=t++;
    kb->key[KeyNo_NumPad1].tablenum=t++;
    kb->key[KeyNo_NumPad2].tablenum=t++;
    kb->key[KeyNo_NumPad3].tablenum=t++;
    kb->key[KeyNo_NumPad0].tablenum=t++;
    kb->key[KeyNo_NumPadDot].tablenum=t++;
    kb->key[KeyNo_NumPadEnter].tablenum=t++;

    if (!kb->key[KeyNo_ScrollLock].defined) { fprintf(out, "        $LLK    KeyNo_ScrollLock\n");  kb->key[KeyNo_ScrollLock].tablenum=t++; }
    if (!kb->key[KeyNo_NumLock].defined)    { fprintf(out, "        $LLK    KeyNo_NumLock\n");     kb->key[KeyNo_NumLock].tablenum=t++; }
    if (!kb->key[KeyNo_Tab].defined)        { fprintf(out, "        $LLK    KeyNo_Tab\n");         kb->key[KeyNo_Tab].tablenum=t++; }
    if (!kb->key[KeyNo_CapsLock].defined)   { fprintf(out, "        $LLK    KeyNo_CapsLock\n");    kb->key[KeyNo_CapsLock].tablenum=t++; }

    fprintf(out, "SpecialList%sUCS", kb->id);

    for (j=0, i=0; i<kb->maxkeys; i++)
        if (kb->key[i].defined && !kb->key[i].easy)
        {
            fprintf(out, "%s&%02X", j==0 ? "\n        $LLK    " : ", ", i);
            j = (j+1)%8;
            kb->key[i].tablenum = t++;
        }

    fprintf(out, "\nSpecialList%sEnd\n"
                 "        ALIGN\n",
                 kb->id);
}

static void process_keyboard(FILE *in, FILE *out)
{
    int i, k, c;
    Keyboard *kb = xmalloc(sizeof *kb);
    strcpy(kb->type,"PC");
    kb->country = -1;
    kb->layers = 0;
    kb->numkeys = 0;
    kb->maxkeys = 0x100;
    kb->fnused = false;
    kb->needcodetable = false;
    kb->needshiftinglist = false;
    kb->custompad = false;
    kb->leftaltlayerswitch = false;
    kb->flags = 0;

    sourcefile[0] = in;

    for (k=0; k<MAXKEYS; k++)
    {
        kb->key[k].defined = false;
        kb->key[k].tablenum = 0;
        kb->key[k].easy = true;
        for (i=0; i<MAXLAYERS; i++)
        {
            for (c=0; c<8; c++)
            {
                kb->key[k].character[i][c] = NULL_UCS4;
                kb->key[k].easych[i][c]=true;
            }
            kb->key[k].caps[i]=(0<<0)|(1<<4)|(2<<8)|(3<<12)|(4<<16)|(5<<20)|(6<<24)|(7<<28);
            kb->key[k].definedinlayer[i]=false;
            kb->key[k].easylayer[i]=1;
        }
    }

    read_layout_file(kb);

    sprintf(kb->id,"%s%d",kb->type,kb->country);

    /* Key handler structure */

    fprintf(out, "LLKS    SETA    %d\n"
                 "LLK     SETS    %s\n",
                 ((kb->flags&KeyHandler_Flag_Wide)?1:0),
                 ((kb->flags&KeyHandler_Flag_Wide)?"\"DCW\"":"\"DCB\""));
                 

    fprintf(out, "KeyStruct%s\n"
                 "        &       KeyTran%s-KeyStruct%s\n"
                 "        &       ((KeyTran%sEnd-KeyTran%s) :SHR: (LLKS+2))%s\n"
                 "        &       InkeyTran%s%s-KeyStruct%s\n",
                 kb->id,
                 kb->id, kb->id,
                 kb->id, kb->id, (kb->flags?"+ KeyHandler_HasFlags":""),
                 kb->type, ((kb->flags&KeyHandler_Flag_Wide)?"W":""), kb->id);

    if (kb->needshiftinglist)
        fprintf(out, "        &       ShiftingKeyList%s-KeyStruct%s\n", kb->id, kb->id);
    else
        fprintf(out, "        &       ShiftingKeyList%s-KeyStruct%s\n", ((kb->flags&KeyHandler_Flag_Wide)?"W":""), kb->id);

    fprintf(out, "        &       SpecialList%s-KeyStruct%s\n",
                 kb->id, kb->id);

    if (kb->needcodetable)
        fprintf(out, "        &       SpecialCodeTable%s-KeyStruct%s\n", kb->id, kb->id);
    else
        fprintf(out, "        &       SpecialCodeTable-KeyStruct%s\n", kb->id);

    fprintf(out, "        &       KeyStructInit-KeyStruct%s\n"
                 "        &       PendingAltCode-KeyStruct%s\n",
                 kb->id, kb->id);
    fprintf(out, "        &       &%08x\n",kb->flags);

    /* Extra data required by intkey */

    if (kb->custompad)
        fprintf(out,
               "        &       PadK%sNumTran-KeyStruct%s-((SpecialList%sPad-SpecialList%s):SHR:LLKS)\n"
               "        &       PadK%sCurTran-KeyStruct%s-((SpecialList%sPad-SpecialList%s):SHR:LLKS)\n",
               kb->id, kb->id, kb->id, kb->id,
               kb->id, kb->id, kb->id, kb->id);
    else
        fprintf(out,
               "        &       PadKNumTran-KeyStruct%s-((SpecialList%sPad-SpecialList%s):SHR:LLKS)\n"
               "        &       PadKCurTran-KeyStruct%s-((SpecialList%sPad-SpecialList%s):SHR:LLKS)\n",
               kb->id, kb->id, kb->id,
               kb->id, kb->id, kb->id);

    if (kb->fnused)
        fprintf(out, "        &       FNTable%s-KeyStruct%s\n", kb->id, kb->id);
    else
        fprintf(out, "        &       0\n");

    for (i=0; i < MAXLAYERS; i++)
    {
        int j = i < kb->layers ? i : 0;
        fprintf(out, "        &       UCSTable%s_%d-KeyStruct%s-((SpecialList%sUCS-SpecialList%s):SHR:LLKS)*36\n", kb->id, j, kb->id, kb->id, kb->id);
    }

    fprintf(out, "\n");

    output_simples(out, kb);

    if (kb->needcodetable)
    {
        fprintf(out, "\nSpecialCodeTable%s\n", kb->id);

        if (!kb->key[KeyNo_ShiftLeft].defined)
            fprintf(out, "        &       ProcessKShift - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_ShiftRight].defined)
            fprintf(out, "        &       ProcessKShift - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_CtrlLeft].defined)
            fprintf(out, "        &       ProcessKCtrl - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_CtrlRight].defined)
            fprintf(out, "        &       ProcessKCtrl - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_AltLeft].defined)
        {
            if (kb->leftaltlayerswitch)
                fprintf(out, "        &       ProcessKAltLeft - SpecialCodeTable%s\n", kb->id);
            else
                fprintf(out, "        &       ProcessKAlt - SpecialCodeTable%s\n", kb->id);
        }
        if (!kb->key[KeyNo_AltRight].defined)
            fprintf(out, "        &       ProcessKAlt - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_FN].defined)
            fprintf(out, "        &       ProcessKFN - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_LeftMouse].defined)
            fprintf(out, "        &       ProcessKLeft - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_CentreMouse].defined)
            fprintf(out, "        &       ProcessKCentre - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_RightMouse].defined)
            fprintf(out, "        &       ProcessKRight - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_Break].defined)
            fprintf(out, "        &       ProcessKBreak - SpecialCodeTable%s\n", kb->id);
        for (i=0; i<17; i++)
            fprintf(out, "        &       ProcessK1Pad - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_ScrollLock].defined)
            fprintf(out, "        &       ProcessKScroll - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_NumLock].defined)
            fprintf(out, "        &       ProcessKNum - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_Tab].defined)
            fprintf(out, "        &       ProcessKTab - SpecialCodeTable%s\n", kb->id);
        if (!kb->key[KeyNo_CapsLock].defined)
            fprintf(out, "        &       ProcessKCaps - SpecialCodeTable%s\n", kb->id);
        for (i=0; i<kb->maxkeys; i++)
            if (kb->key[i].defined && !kb->key[i].easy)
                fprintf(out, "        &       ProcessUCS - SpecialCodeTable%s\n", kb->id);
    }
    else
    {
        /* Check the builtin special code table is large enough */
        fprintf(out,"        ASSERT ((SpecialList%sEnd-SpecialList%s):SHR:LLKS)-1 <= (SpecialCodeTableEnd-SpecialCodeTable):SHR:2\n",kb->id,kb->id);
    }

    if (kb->needshiftinglist)
    {
        fprintf(out, "\nShiftingKeyList%s\n"
                     "        $LLK    ((ShiftingKeyList%sEnd - ShiftingKeyList%s) :SHR: LLKS) - 1\n",
                     kb->id, kb->id, kb->id);

        if (!kb->key[KeyNo_ShiftLeft].defined)  fprintf(out, "        $LLKS    KeyNo_ShiftLeft\n");
        if (!kb->key[KeyNo_ShiftRight].defined)  fprintf(out, "        $LLKS    KeyNo_ShiftRight\n");
        if (!kb->key[KeyNo_CtrlLeft].defined)   fprintf(out, "        $LLKS    KeyNo_CtrlLeft\n");
        if (!kb->key[KeyNo_CtrlRight].defined)   fprintf(out, "        $LLKS    KeyNo_CtrlRight\n");
        if (!kb->key[KeyNo_AltLeft].defined)    fprintf(out, "        $LLKS    KeyNo_AltLeft\n");
        if (!kb->key[KeyNo_AltRight].defined)    fprintf(out, "        $LLKS    KeyNo_AltRight\n");
        if (!kb->key[KeyNo_FN].defined)      fprintf(out, "        $LLKS    KeyNo_FN\n");
        if (!kb->key[KeyNo_RightMouse].defined) fprintf(out, "        $LLKS    KeyNo_RightMouse\n");
        if (!kb->key[KeyNo_CentreMouse].defined)   fprintf(out, "        $LLKS    KeyNo_CentreMouse\n");
        if (!kb->key[KeyNo_LeftMouse].defined) fprintf(out, "        $LLKS    KeyNo_LeftMouse\n");
        if (!kb->key[KeyNo_Break].defined)   fprintf(out, "        $LLKS    KeyNo_Break\n");

        fprintf(out, "ShiftingKeyList%sEnd\n"
                     "        ALIGN\n",
                     kb->id);
    }

    for (i=0; i<kb->layers; i++)
        output_layer(out, kb, i);

    if (kb->fnused)
    {
        fprintf(out, "\nFNTable%s\n"
                     "        $LLK    (FNTable%sEnd - FNTable%s - 1) :SHR: (LLKS+1)\n",
                     kb->id, kb->id, kb->id);
        for (i=0; i<kb->maxkeys; i++)
            if (kb->key[i].fn != -1)
            {
                if (!kb->key[i].tablenum || !kb->key[kb->key[i].fn].tablenum)
                {
                    char buffer[128];
                    sprintf(buffer, "Consistency failure in FN map (%02X->%02X)", i, kb->key[i].fn);
                    error(buffer);
                }
                fprintf(out, "        $LLK    &%02X, &%02X\n", kb->key[i].tablenum,
                                                               kb->key[kb->key[i].fn].tablenum);
            }
        fprintf(out, "FNTable%sEnd\n", kb->id);
    }

    if (kb->custompad)
    {
        int j, n;
        for (n=0; n<=1; n++)
        {
            fprintf(out, n ? "\nPadK%sCurTran" : "\nPadK%sNumTran", kb->id);
            for (j=0, i=0; i<17; i++)
            {
                fprintf(out, "%s&%02X", j==0 ? "\n        =       " : ", ", kb->keypad[n][i]);
                j = (j+1)%8;
            }
        }
        putc('\n', out);
    }

    fprintf(out, "\n        ALIGN\n");
    fprintf(out, "\n        END\n");
    free(kb);
}

int main(int argc, char **argv)
{
    FILE *in, *out;

    if (argc >= 3 && strcmp(argv[1], "-depend")==0)
    {
        depend = 1;
        dependfilename = argv[2];
        argv+=2;
        argc-=2;
    }

    if (argc >= 2 && strcmp(argv[1], "-throwback")==0)
    {
        throwback = 1;
        argv++;
        argc--;
    }

    if (argc >= 3 && strcmp(argv[1], "-extra")==0)
    {
        ExtraKeys = argv[2];
        argv+=2;
        argc-=2;
    }

    if (argc >= 3 && strcmp(argv[1], "-fn")==0)
    {
        FNKey = argv[2];
        argv+=2;
        argc-=2;
    }

    if (argc != 3)
    {
        fprintf(stderr, "Usage: keygen [-depend filename] [-throwback] [-extra filename] [-fn filename]\n"
                        "              layout-file output-file\n");
        exit(1);
    }

    in = fopen(argv[1], "r");
    if (!in)
    {
        perror(argv[1]);
        exit(1);
    }

    out = fopen(argv[2], "w");
    if (!out)
    {
        perror(argv[2]);
        exit(1);
    }

    sourcefilename[0] = argv[1];
    current_output_handle = out;
    current_output_file = argv[2];
    if (depend)
        add_dependency(current_output_file, sourcefilename[0]);

    load_unidata("UniData");

    process_keyboard(in, out);

    return 0;
}
@


1.13
log
@Fix for access outside array bounds
Loop uses 0-7.
Ref https://www.riscosopen.org/forum/forums/4/topics/9503
Tagged as IntKey-0_98-1 since the module is unchanged, just the build tool.
@
text
@d1065 1
@


1.12
log
@Add support for the new 'wide' key handler format. Add support for keyboard types which have fundamentally different layouts to PC/Arc. Add a basic (UK) layout for the Pandora.
Detail:
  Doc/FileFormat, Doc/HandlerAPI - Updated docs with information about the new key handler format, and how to invoke it in layout files.
  c/keygen, c/unicdata, h/structures - Give keygen a bit of a tidy up. Add support for the new '$Type' directive to allow the keyboard type to be specified (to ensure correct intkey table is used, unique symbol names when the same country is supported by multiple keyboard types, etc.). Add support for the new key handler format.
  Sources/IntKeyBody, Sources/IntKeyMod, Sources/KeyStruct - Tidy up the code a bit to use key handler layout and key/OS_Byte numbers from Hdr:. Add support for the new key handler format, and for the new way keygen generates the layout files.
  layout/Pandora, Makefile, Sources/IntKeyBody, Sources/IntKeyMod, Sources/KeyStruct - Add a layout file for the Pandora, and modify IntKey to use different sets of layout files depending on the keyboard type.
Admin:
  New key handler format tested on Pandora. Old format tested on Pandora & BB-xM.
  Requires HdrSrc-2_20


Version 0.95. Tagged as 'IntKey-0_95'
@
text
@d478 1
a478 1
        char uc[4];
@


1.11
log
@Added Korean layout. If you don't have a real Korean keyboard, Alt+Num-Lock
acts as Hangul Lock, and Alt+Space (in the Hangul layer) acts as convert.

Version 0.82. Tagged as 'IntKey-0_82'
@
text
@d20 2
d29 13
a41 13
FILE *sourcefile[MAX_FILE_DEPTH];
char *sourcefilename[MAX_FILE_DEPTH];
int sourceline[MAX_FILE_DEPTH];
int filedepth;

const char *ExtraKeys, *FNKey;

char keypad_codes[]={
          0x23, 0x24, 0x25,
    0x37, 0x38, 0x39, 0x3A,
    0x48, 0x49, 0x4A, 0x4B,
    0x5A, 0x5B, 0x5C,
    0x65,       0x66, 0x67,
d52 1
a52 1
charinfo funclist[] =
d96 1
a96 1
charinfo speclist[] =
d112 1
a112 1
charinfo deadlist[] =
d136 2
a137 2
const char *current_output_file;
FILE *current_output_handle;
d140 2
d246 1
a246 1
UCS4 keycode_from_name(const char *name)
d263 1
a263 1
char *getline(char *p, size_t plen)
d343 6
a348 39
#define K_ScrollLock  0x0E
#define K_Break       0x0F
#define K_NumLock     0x22
#define K_NumPadSlash 0x23
#define K_NumPadStar  0x24
#define K_NumPadHash  0x25
#define K_Tab         0x26
#define K_NumPad7     0x37
#define K_NumPad8     0x38
#define K_NumPad9     0x39
#define K_NumPadMinus 0x3A
#define K_CtrlL       0x3B
#define K_NumPad4     0x48
#define K_NumPad5     0x49
#define K_NumPad6     0x4A
#define K_NumPadPlus  0x4B
#define K_ShiftL      0x4C
#define K_ShiftR      0x58
#define K_NumPad1     0x5A
#define K_NumPad2     0x5B
#define K_NumPad3     0x5C
#define K_CapsLock    0x5D
#define K_AltL        0x5E
#define K_AltR        0x60
#define K_CtrlR       0x61
#define K_NumPad0     0x65
#define K_NumPadDot   0x66
#define K_NumPadEnter 0x67
#define K_FN          0x6F
#define K_MSelect     0x70
#define K_MMenu       0x71
#define K_MAdjust     0x72

int is_modifier_key(int key)
{
    return key == K_Break || key == K_CtrlL || key == K_ShiftL ||
           key == K_ShiftR || key == K_AltL || key == K_AltR ||
           key == K_CtrlR || key == K_FN ||
           key == K_MSelect || key == K_MMenu || key == K_MAdjust;
d351 1
a351 1
int is_keypad_key(int key)
d353 6
a358 1
    return key != 0 && strchr(keypad_codes, key) != NULL;
d361 1
a361 1
int is_special_key(int key)
d363 2
a364 2
    return key == K_ScrollLock || key == K_NumLock || key == K_Tab ||
           key == K_CapsLock || is_modifier_key(key);
d367 1
a367 1
void read_keypad(Keyboard *kb)
d412 2
a413 2
        kb->keypad[0][i]=(char)k;
        kb->keypad[1][i++]=(char)k2;
d419 1
a419 1
void read_fnkey(Keyboard *kb)
d426 1
a426 1
    for (i=0; i<MAXKEYS; i++)
d445 1
a445 1
        if (k >= MAXKEYS)
d449 1
a449 1
        if (k2 >= MAXKEYS || k == k2)
d453 2
a454 2
        if (is_modifier_key((int) k) && !kb->key[k].defined ||
            is_modifier_key((int) k2) && !kb->key[k2].defined)
d457 2
a458 2
        kb->key[k].defined = 1;
        kb->key[k2].defined = 1;
d460 1
a460 1
        kb->key[k].fn = (int) k2;
d469 1
a469 1
void read_layer(Keyboard *kb, int layerno)
d487 1
a487 1
        if (p == buffer || key < 0 || key >= MAXKEYS)
d505 1
a505 1
            kb->needshiftinglist = 1;
d511 1
a511 1
            kb->needcodetable = 1;
d513 2
a514 2
        kb->key[key].defined = 1;
        kb->key[key].definedinlayer[layerno] = 1;
d582 1
a582 1
            kb->key[key].easych[layerno][i]=0;
d601 1
a601 1
                    kb->key[key].easych[layerno][i]=1;
d610 1
a610 1
void *xmalloc(size_t s)
d617 1
a617 1
void read_layout_file(Keyboard *kb)
d630 2
a631 2
                kb->leftaltlayerswitch = 1;
                kb->needcodetable = 1;
d650 1
a650 1
                kb->custompad=1;
d655 9
d673 1
a673 1
void output_layer(FILE *out, Keyboard *kb, int layerno)
d677 1
a677 1
    fprintf(out, "\nUCSTable%d_%d\n", kb->country, layerno);
d679 1
a679 1
    for (i=0; i < MAXKEYS; i++)
d697 1
a697 1
void output_simples(FILE *out, Keyboard *kb)
d705 2
a706 2
        for (i=0; i<MAXKEYS; i++)
            kb->key[i].easy = 0;
d714 1
a714 1
        for (i=0; i<MAXKEYS; i++)
d716 1
a716 1
            kb->key[i].easy = 1;
d721 1
a721 1
                    kb->key[i].easy = 0;
d727 1
a727 1
                        kb->key[i].easy = 0;
d735 2
a736 2
         *      4 * (highest easy key+1)     for the KeyTran table
         *    + 36 * special keys * layers + special keys.    for SpecialList + UCSList
d742 1
a742 1
        for (i=0, specials=0; i < MAXKEYS; i++)
d746 3
a748 1
        bestmem = 36*specials*kb->layers + specials;
d751 1
a751 1
        for (i=0; i < MAXKEYS; i++)
d756 1
a756 1
            mem = (i+1)*4 + 36*specials*kb->layers + specials;
d765 2
a766 2
        for (i=best; i < MAXKEYS; i++)
            kb->key[i].easy=0;
d769 1
a769 1
    fprintf(out, "KeyTran%d\n", kb->country);
d772 1
a772 1
            fprintf(out, "        =       &%02X, &%02X, &%02X, &%02X\n",
d778 1
a778 1
            fprintf(out, "        =       &FF, &FF, &FF, &FF\n");
d780 1
a780 1
    fprintf(out, "KeyTran%dEnd\n\n", kb->country);
d782 3
a784 3
    fprintf(out, "\nSpecialList%d\n"
                 "        =       SpecialList%dEnd - SpecialList%d - 1\n",
                 kb->country, kb->country, kb->country);
d788 42
a829 42
    if (!kb->key[K_ShiftL].defined)     { fprintf(out, "        =       K1ShiftLeft\n");   t++; }
    if (!kb->key[K_ShiftR].defined)     { fprintf(out, "        =       K1ShiftRight\n");  t++; }
    if (!kb->key[K_CtrlL].defined)      { fprintf(out, "        =       K1CtrlLeft\n");    t++; }
    if (!kb->key[K_CtrlR].defined)      { fprintf(out, "        =       K1CtrlRight\n");   t++; }
    if (!kb->key[K_AltL].defined)       { fprintf(out, "        =       K1AltLeft\n");     t++; }
    if (!kb->key[K_AltR].defined)       { fprintf(out, "        =       K1AltRight\n");    t++; }
    if (!kb->key[K_FN].defined)         { fprintf(out, "        =       K1FN\n");          t++; }
    if (!kb->key[K_MSelect].defined)    { fprintf(out, "        =       K1LeftMouse\n");   t++; }
    if (!kb->key[K_MMenu].defined)      { fprintf(out, "        =       K1CentreMouse\n"); t++; }
    if (!kb->key[K_MAdjust].defined)    { fprintf(out, "        =       K1RightMouse\n");  t++; }
    if (!kb->key[K_Break].defined)      { fprintf(out, "        =       K1Break\n");       kb->key[K_Break].tablenum=t++; }

    fprintf(out, "SpecialList%dPad\n"
                 "        =       K1NumPadSlash, K1NumPadStar, K1NumPadHash\n"
                 "        =       K1NumPad7, K1NumPad8, K1NumPad9, K1NumPadMinus\n"
                 "        =       K1NumPad4, K1NumPad5, K1NumPad6, K1NumPadPlus\n"
                 "        =       K1NumPad1, K1NumPad2, K1NumPad3\n"
                 "        =       K1NumPad0, K1NumPadDot, K1NumPadEnter\n",
                 kb->country);

    kb->key[K_NumPadSlash].tablenum=t++;
    kb->key[K_NumPadStar].tablenum=t++;
    kb->key[K_NumPadHash].tablenum=t++;
    kb->key[K_NumPad7].tablenum=t++;
    kb->key[K_NumPad8].tablenum=t++;
    kb->key[K_NumPad9].tablenum=t++;
    kb->key[K_NumPadMinus].tablenum=t++;
    kb->key[K_NumPad4].tablenum=t++;
    kb->key[K_NumPad5].tablenum=t++;
    kb->key[K_NumPad6].tablenum=t++;
    kb->key[K_NumPadPlus].tablenum=t++;
    kb->key[K_NumPad1].tablenum=t++;
    kb->key[K_NumPad2].tablenum=t++;
    kb->key[K_NumPad3].tablenum=t++;
    kb->key[K_NumPad0].tablenum=t++;
    kb->key[K_NumPadDot].tablenum=t++;
    kb->key[K_NumPadEnter].tablenum=t++;

    if (!kb->key[K_ScrollLock].defined) { fprintf(out, "        =       K1ScrollLock\n");  kb->key[K_ScrollLock].tablenum=t++; }
    if (!kb->key[K_NumLock].defined)    { fprintf(out, "        =       K1NumLock\n");     kb->key[K_NumLock].tablenum=t++; }
    if (!kb->key[K_Tab].defined)        { fprintf(out, "        =       K1Tab\n");         kb->key[K_Tab].tablenum=t++; }
    if (!kb->key[K_CapsLock].defined)   { fprintf(out, "        =       K1CapsLock\n");    kb->key[K_CapsLock].tablenum=t++; }
d831 1
a831 1
    fprintf(out, "SpecialList%dUCS", kb->country);
d833 1
a833 1
    for (j=0, i=0; i<MAXKEYS; i++)
d836 1
a836 1
            fprintf(out, "%s&%02X", j==0 ? "\n        =       " : ", ", i);
d841 1
a841 1
    fprintf(out, "\nSpecialList%dEnd\n"
d843 1
a843 1
                 kb->country);
d846 1
a846 1
void process_keyboard(FILE *in, FILE *out)
d850 1
d854 1
d856 5
a860 4
    kb->needcodetable = 0;
    kb->needshiftinglist = 0;
    kb->custompad = 0;
    kb->leftaltlayerswitch = 0;
d866 1
a866 1
        kb->key[k].defined = 0;
d868 1
a868 1
        kb->key[k].easy = 1;
d874 1
a874 1
                kb->key[k].easych[i][c]=1;
d877 1
a877 1
            kb->key[k].definedinlayer[i]=0;
d884 18
a901 6
    fprintf(out, "KeyStruct%d\n"
                 "        &       KeyTran%d-KeyStruct%d\n"
                 "        &       (KeyTran%dEnd-KeyTran%d) :SHR: 2\n"
                 "        &       InkeyTran-KeyStruct%d\n",
                 kb->country, kb->country, kb->country, kb->country, kb->country,
                 kb->country);
d904 1
a904 1
        fprintf(out, "        &       ShiftingKeyList%d-KeyStruct%d\n", kb->country, kb->country);
d906 1
a906 1
        fprintf(out, "        &       ShiftingKeyList-KeyStruct%d\n", kb->country);
d908 2
a909 2
    fprintf(out, "        &       SpecialList%d-KeyStruct%d\n",
                 kb->country, kb->country);
d912 1
a912 1
        fprintf(out, "        &       SpecialCodeTable%d-KeyStruct%d\n", kb->country, kb->country);
d914 6
a919 1
        fprintf(out, "        &       SpecialCodeTable-KeyStruct%d\n", kb->country);
d921 1
a921 3
    fprintf(out, "        &       KeyStructInit-KeyStruct%d\n"
                 "        &       PendingAltCode-KeyStruct%d\n",
                 kb->country, kb->country);
d925 4
a928 4
               "        &       PadK%dNumTran-KeyStruct%d-(SpecialList%dPad-SpecialList%d)\n"
               "        &       PadK%dCurTran-KeyStruct%d-(SpecialList%dPad-SpecialList%d)\n",
               kb->country, kb->country, kb->country, kb->country,
               kb->country, kb->country, kb->country, kb->country);
d931 4
a934 4
               "        &       PadKNumTran-KeyStruct%d-(SpecialList%dPad-SpecialList%d)\n"
               "        &       PadKCurTran-KeyStruct%d-(SpecialList%dPad-SpecialList%d)\n",
               kb->country, kb->country, kb->country,
               kb->country, kb->country, kb->country);
d937 1
a937 1
        fprintf(out, "        &       FNTable%d-KeyStruct%d\n", kb->country, kb->country);
d944 1
a944 1
        fprintf(out, "        &       UCSTable%d_%d-KeyStruct%d-(SpecialList%dUCS-SpecialList%d)*36\n", kb->country, j, kb->country, kb->country, kb->country);
d953 1
a953 1
        fprintf(out, "\nSpecialCodeTable%d\n", kb->country);
d955 9
a963 9
        if (!kb->key[K_ShiftL].defined)
            fprintf(out, "        &       ProcessKShift - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_ShiftR].defined)
            fprintf(out, "        &       ProcessKShift - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_CtrlL].defined)
            fprintf(out, "        &       ProcessKCtrl - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_CtrlR].defined)
            fprintf(out, "        &       ProcessKCtrl - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_AltL].defined)
d966 1
a966 1
                fprintf(out, "        &       ProcessKAltLeft - SpecialCodeTable%d\n", kb->country);
d968 1
a968 1
                fprintf(out, "        &       ProcessKAlt - SpecialCodeTable%d\n", kb->country);
d970 12
a981 12
        if (!kb->key[K_AltR].defined)
            fprintf(out, "        &       ProcessKAlt - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_FN].defined)
            fprintf(out, "        &       ProcessKFN - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_MSelect].defined)
            fprintf(out, "        &       ProcessKLeft - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_MMenu].defined)
            fprintf(out, "        &       ProcessKCentre - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_MAdjust].defined)
            fprintf(out, "        &       ProcessKRight - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_Break].defined)
            fprintf(out, "        &       ProcessKBreak - SpecialCodeTable%d\n", kb->country);
d983 10
a992 10
            fprintf(out, "        &       ProcessK1Pad - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_ScrollLock].defined)
            fprintf(out, "        &       ProcessKScroll - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_NumLock].defined)
            fprintf(out, "        &       ProcessKNum - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_Tab].defined)
            fprintf(out, "        &       ProcessKTab - SpecialCodeTable%d\n", kb->country);
        if (!kb->key[K_CapsLock].defined)
            fprintf(out, "        &       ProcessKCaps - SpecialCodeTable%d\n", kb->country);
        for (i=0; i<MAXKEYS; i++)
d994 6
a999 1
                fprintf(out, "        &       ProcessUCS - SpecialCodeTable%d\n", kb->country);
d1004 15
a1018 15
        fprintf(out, "\nShiftingKeyList%d\n"
                     "        =       ShiftingKeyList%dEnd - ShiftingKeyList%d - 1\n",
                     kb->country, kb->country, kb->country);

        if (!kb->key[K_ShiftL].defined)  fprintf(out, "        =       K1ShiftLeft\n");
        if (!kb->key[K_ShiftR].defined)  fprintf(out, "        =       K1ShiftRight\n");
        if (!kb->key[K_CtrlL].defined)   fprintf(out, "        =       K1CtrlLeft\n");
        if (!kb->key[K_CtrlR].defined)   fprintf(out, "        =       K1CtrlRight\n");
        if (!kb->key[K_AltL].defined)    fprintf(out, "        =       K1AltLeft\n");
        if (!kb->key[K_AltR].defined)    fprintf(out, "        =       K1AltRight\n");
        if (!kb->key[K_FN].defined)      fprintf(out, "        =       K1FN\n");
        if (!kb->key[K_MAdjust].defined) fprintf(out, "        =       K1RightMouse\n");
        if (!kb->key[K_MMenu].defined)   fprintf(out, "        =       K1CentreMouse\n");
        if (!kb->key[K_MSelect].defined) fprintf(out, "        =       K1LeftMouse\n");
        if (!kb->key[K_Break].defined)   fprintf(out, "        =       K1Break\n");
d1020 1
a1020 1
        fprintf(out, "ShiftingKeyList%dEnd\n"
d1022 1
a1022 1
                     kb->country);
d1030 4
a1033 4
        fprintf(out, "\nFNTable%d\n"
                     "        =       (FNTable%dEnd - FNTable%d - 1) / 2\n",
                     kb->country, kb->country, kb->country);
        for (i=0; i<MAXKEYS; i++)
d1042 1
a1042 1
                fprintf(out, "        =       &%02X, &%02X\n", kb->key[i].tablenum,
d1045 1
a1045 1
        fprintf(out, "FNTable%dEnd\n", kb->country);
d1053 1
a1053 1
            fprintf(out, n ? "\nPadK%dCurTran" : "\nPadK%dNumTran", kb->country);
@


1.10
log
@  Some bugfixes for keygen and keyconvert, discovered by gcc.
  Temporary GNUmakefile added containing UNIX build system.
Detail:
  gcc complained about returning the address of a local variable as
    a function result in both keygen and keyconvert.  The two variables
    concerned have now been made static like they should have been.
    Unlikely to have caused much aggravation, but only through luck.
  The Keyboard data structure has been updated to explicitly use an
    unsigned char in some places.  This is necessary for systems on
    which char is signed by default.
  The GNUmakefile is a temporary addition until native tool support can
    be sorted out.  In the xriscos environment, do "make links" and
    then "make rom" to build the module.  "make clean" will remove all
    the built stuff and the symbolic links.  Requires access to the
    exported Unicode library files.  keyconvert is built, but will not
    work for the obvious reason that it calls SWIs.
Admin:
  GNUmakefile will be removed at a later date - it's only temporary.
  Tested - builds the same module (for Keyboard=All, Machine=Phoebe)
    byte-identically.


Version 0.80. Tagged as 'IntKey-0_80'
@
text
@d1010 2
a1011 1
        fprintf(out, "ShiftingKeyList%dEnd\n",
@


1.9
log
@Corrected filename reference to UniData.

Version 0.68. Tagged as 'IntKey-0_68'
@
text
@a318 2
            if ((sourcefile[filedepth+1] = fopen(newinclude, "r")) == NULL)
                error("Unable to open %Include file");
d321 7
a327 2
            strcpy(sourcefilename[++filedepth], newinclude);
            sourceline[filedepth]=0;
@


1.8
log
@"FN" key support added by K. Bracey.  3rd party-specific keyboard mappings
defined and included by S. Forrest.

Both changes made in order to support the third
party handset.

Tested on a Risc PC against V0.02 of the RCMM Driver.

Version 0.65. Tagged as 'IntKey-0_65'
@
text
@d1113 1
a1113 1
    load_unidata("UniData215");
@


1.7
log
@Intermediate check-in
@
text
@d308 1
a308 1
            if (strcmp(p+9, "@@FNKey@@") == 0)
@


1.6
log
@Added ability to override modifier keys (eg Ctrl).
Added ability to redefine keys already specified (eg in inc.[tag]).
Added customisations for 3rd party using aforementioned features.

Version 0.63. Tagged as 'IntKey-0_63'
@
text
@d18 1
d32 1
a32 1
const char *ExtraKeys;
d308 7
d336 32
a367 14
#define K_ScrollLock 0x0E
#define K_Break      0x0F
#define K_NumLock    0x22
#define K_Tab        0x26
#define K_CtrlL      0x3B
#define K_ShiftL     0x4C
#define K_ShiftR     0x58
#define K_CapsLock   0x5D
#define K_AltL       0x5E
#define K_AltR       0x60
#define K_CtrlR      0x61
#define K_MSelect    0x70
#define K_MMenu      0x71
#define K_MAdjust    0x72
d373 2
a374 2
           key == K_CtrlR || key == K_MSelect || key == K_MMenu ||
           key == K_MAdjust;
d440 50
d674 2
d711 2
a712 3
    int i,j,c;
    int bestmem, best;
    int specials;
d714 8
a721 1
    for (i=0; i<MAXKEYS; i++)
d723 4
a726 2
        kb->key[i].easy = 1;
        for (j=0; j<kb->layers; j++)
d728 2
a729 1
            if (!kb->key[i].easylayer[j])
d731 1
a731 5
                kb->key[i].easy = 0;
                break;
            }
            for (c=0; c<8; c++)
                if (kb->key[i].character[j][c] != kb->key[i].character[0][c])
d736 7
a743 1
    }
d745 12
a756 12
    /* How many should we put in the "easy" array? Want to
     * minimise memory usage. The memory usage is basically
     *      4 * (highest easy key+1)     for the KeyTran table
     *    + 36 * special keys * layers + special keys.    for SpecialList + UCSList
     *
     * Start off supposing every defined key is special,
     * then try effect of gradually extending the simple table.
     */

    for (i=0, specials=0; i < MAXKEYS; i++)
        if (kb->key[i].defined)
            specials++;
d758 2
a759 2
    bestmem = 36*specials*kb->layers + specials;
    best = 0;
d761 1
a761 8
    for (i=0; i < MAXKEYS; i++)
    {
        int mem;
        if (kb->key[i].easy && kb->key[i].defined) // we've saved one special code!!
            specials--;
        mem = (i+1)*4 + 36*specials*kb->layers + specials;
        /*printf("%d simple, %d special, mem = %d\n", i, specials, mem);*/
        if (mem<bestmem)
d763 10
a772 2
            best = i+1;
            bestmem = mem;
d774 3
a778 3
    for (i=best; i < MAXKEYS; i++)
        kb->key[i].easy=0;

d796 13
a808 10
    if (!kb->key[K_ShiftL].defined)     fprintf(out, "        =       K1ShiftLeft\n");
    if (!kb->key[K_ShiftR].defined)     fprintf(out, "        =       K1ShiftRight\n");
    if (!kb->key[K_CtrlL].defined)      fprintf(out, "        =       K1CtrlLeft\n");
    if (!kb->key[K_CtrlR].defined)      fprintf(out, "        =       K1CtrlRight\n");
    if (!kb->key[K_AltL].defined)       fprintf(out, "        =       K1AltLeft\n");
    if (!kb->key[K_AltR].defined)       fprintf(out, "        =       K1AltRight\n");
    if (!kb->key[K_MSelect].defined)    fprintf(out, "        =       K1LeftMouse\n");
    if (!kb->key[K_MMenu].defined)      fprintf(out, "        =       K1CentreMouse\n");
    if (!kb->key[K_MAdjust].defined)    fprintf(out, "        =       K1RightMouse\n");
    if (!kb->key[K_Break].defined)      fprintf(out, "        =       K1Break\n");
d818 22
a839 4
    if (!kb->key[K_ScrollLock].defined) fprintf(out, "        =       K1ScrollLock\n");
    if (!kb->key[K_NumLock].defined)    fprintf(out, "        =       K1NumLock\n");
    if (!kb->key[K_Tab].defined)        fprintf(out, "        =       K1Tab\n");
    if (!kb->key[K_CapsLock].defined)   fprintf(out, "        =       K1CapsLock\n");
d848 1
d863 1
d874 1
d928 5
d964 2
d1001 1
d1007 1
a1007 2
        fprintf(out, "ShiftingKeyList%dEnd\n"
                     "        ALIGN\n",
d1014 20
d1046 1
a1046 1
        fprintf(out, "\n        ALIGN\n");
d1049 1
d1079 7
d1088 1
a1088 1
        fprintf(stderr, "Usage: keygen [-depend filename] [-throwback] [-extra filename]\n"
@


1.5
log
@Added capability to use Left Alt + Shift to change layers.
Created new PC-compatible two-layer Russian layout.

Version 0.59. Tagged as 'IntKey-0_59'
@
text
@d210 1
a210 1
    return 0x80000000 ^ ctrl ^ shift + ci->code;
d359 1
a359 1
           key == K_CapsLock;
d418 1
a418 1
    int key, i;
d432 1
a432 1
        if (p == buffer || *p != '\0' || key < 0 || key >= MAXKEYS)
d435 12
a446 1
        if (kb->key[key].definedinlayer[layerno])
d450 1
a450 1
            error("Cannot alter modifier keys");
d703 15
a717 5
                 "        =       SpecialList%dEnd - SpecialList%d - 1\n"
                 "        =       K1ShiftLeft, K1ShiftRight, K1CtrlLeft, K1CtrlRight\n"
                 "        =       K1AltLeft, K1AltRight\n"
                 "        =       K1LeftMouse, K1CentreMouse, K1RightMouse, K1Break\n"
                 "SpecialList%dPad\n"
d723 1
a723 1
                 kb->country, kb->country, kb->country, kb->country);
d752 1
d780 1
a780 3
                 "        &       InkeyTran-KeyStruct%d\n"
                 "        &       ShiftingKeyList-KeyStruct%d\n"
                 "        &       SpecialList%d-KeyStruct%d\n",
d782 10
a791 1
                 kb->country, kb->country, kb->country, kb->country);
d866 22
@


1.4
log
@%Include directive implemented in layout files - this gives a simpler
way of adding in the new keys and allows some commonality between layouts.
To get the new keys, you need to set the option EXTRAKEYS="-extra [tag]".
!IKHG removed.

Version 0.58. Tagged as 'IntKey-0_58'
@
text
@d562 5
d732 1
d808 6
a813 1
            fprintf(out, "        &       ProcessKAlt - SpecialCodeTable%d\n", kb->country);
@


1.3
log
@3rd party keys placed into UK, USA and Netherlands layouts - this is a temporary
measure until a proper build option is installed.
Dead key ring above + space now outputs U+00B0 (degree sign), rather than
U+02DB (ring above).

Version 0.57. Tagged as 'IntKey-0_57'
@
text
@d25 8
d82 1
a82 1
    0xC5, "NO CONVERT",
d133 1
a133 1
const char *current_file, *current_output_file;
d135 1
a135 2
static int line;
static int throwback;
d139 1
a139 1
    fprintf(stderr, "%s, line %d: %s\n", current_file, line, p);
d141 1
a141 1
        throwback_send(1, line, p, current_file, current_file);
d163 1
a163 1
    if (*p == '&')
d167 1
a167 1
        if (*end != '\0' || c >= 0xFF)
d169 1
a169 1
        return c < 0x80 ? c : 0x80000000 + c;
d258 1
a258 1
char *getline(char *p, size_t plen, FILE *f)
d263 2
d267 16
a282 3
        line++;
        ret = fgets(p, plen, f);
        if (!ret) return NULL;
d293 32
d362 1
a362 1
void read_keypad(FILE *in, Keyboard *kb)
d369 1
a369 1
    while (getline(buffer, 256, in))
d414 1
a414 1
void read_layer(FILE *in, Keyboard *kb, int layerno)
d421 1
a421 1
    while (getline(buffer, 256, in))
d460 1
a460 1
            if (getline(buffer, 256, in) == NULL)
d551 1
a551 1
void read_layout_file(FILE *in, Keyboard *kb)
d556 1
a556 1
    while (getline(buffer, 256, in))
d571 1
a571 1
                read_layer(in, kb, layer);
d580 1
a580 1
                read_keypad(in, kb);
d662 1
a662 1
        //printf("%d simple, %d special, mem = %d\n", i, specials, mem);
d728 2
d747 1
a747 1
    read_layout_file(in, kb);
d853 8
d868 7
d877 2
a878 1
        fprintf(stderr, "Usage: keygen [-throwback] layout-file output-file\n");
d896 1
a896 1
    current_file = argv[1];
d899 2
@


1.2
log
@Added Japan and Iceland to build.
Added hexadecimal keypad code entry.
Changed dead key tilde+space to U+007E, not U+02DC (Denmark needs this).
Added dead key stroke (only Turkey uses this).
@
text
@d159 2
a160 2
        c = (UCS4) strtol(p, &end, 16);
        if (*end != '\0')
d162 1
a162 1
        return c;
@


1.1
log
@Ursula branch merged.

Complete new keyboard definition system in terms of the UCS. See
Docs.FileFormat for information.
@
text
@d118 1
@

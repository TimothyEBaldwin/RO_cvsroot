head	4.31;
access;
symbols
	IntKey-0_99:4.31
	IntKey-0_98-1:4.31
	IntKey-0_98:4.31
	IntKey-0_97:4.30
	IntKey-0_96:4.29
	IntKey-0_95:4.28
	IntKey-0_94:4.26
	IntKey-0_93:4.25
	IntKey-0_92:4.25
	IntKey-0_91:4.24
	IntKey-0_90:4.24
	RO_5_07:4.24
	IntKey-0_89:4.24
	IntKey-0_88:4.24
	IntKey-0_87:4.23
	IntKey-0_86:4.23
	IntKey-0_85:4.22
	IntKey-0_84:4.22
	IntKey-0_83:4.22
	IntKey-0_82:4.22
	IntKey-0_81:4.21
	IntKey-0_80:4.21
	IntKey-0_79:4.20
	IntKey-0_78:4.20
	IntKey-0_77:4.20
	IntKey-0_76:4.19
	dellis_autobuild_BaseSW:4.18
	IntKey-0_75:4.18
	IntKey-0_74:4.18
	IntKey-0_73:4.17
	IntKey-0_72:4.17
	IntKey-0_71:4.17
	sbrodie_sedwards_16Mar2000:4.16
	IntKey-0_70:4.16
	dcotton_autobuild_BaseSW:4.21
	IntKey-0_69:4.16
	IntKey-0_68:4.16
	IntKey-0_67:4.16
	IntKey-0_66:4.16
	IntKey-0_65:4.16
	IntKey-0_64:4.14
	IntKey-0_63:4.14
	IntKey-0_62:4.14
	IntKey-0_61:4.14
	IntKey-0_60:4.14
	IntKey-0_59:4.14
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.3
	Ursula_RiscPC:4.2.2.3.0.2
	IntKey-0_58:4.13
	IntKey-0_57:4.13
	IntKey-0_56:4.13
	IntKey-0_55:4.13
	IntKey-0_54:4.13
	IntKey-0_53:4.13
	IntKey-0_52:4.12
	bavison_Generic_InternationalKeyboard-0_51:4.11
	bavison_InternationalKeyboard-0_45:4.2.2.5
	nicke_IntKey-0_36:4.1.7.3
	bavison_InternationalKeyboard-0_44:4.2.2.4
	rthornb_UrsulaBuild-19Aug1998:4.2.2.3
	UrsulaBuild_FinalSoftload:4.2.2.3
	bavison_InternationalKeyboard-0_43:4.2.2.3
	rthornb_UrsulaBuild-12Aug1998:4.2.2.2
	bavison_InternationalKeyboard-0_42:4.2.2.2
	Generic_InternationalKeyboard-0_41:4.8
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	Generic_InternationalKeyboard-0_40:4.7
	Generic_InternationalKeyboard-0_39:4.6
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	bavison_InternationalKeyboard-0_38:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.3
	afrost_Funai01-33:4.1.7.3
	Spinner_RCA116:4.1.7.3
	Spinner_B20_2:4.1.7.3
	Spinner_19_3:4.1.7.3
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.31
date	2014.11.22.13.24.54;	author rsprowson;	state Exp;
branches;
next	4.30;
commitid	20YFBELqseKvqbZx;

4.30
date	2013.04.01.20.00.12;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	7vryqOpRuliST6Kw;

4.29
date	2013.03.14.00.32.21;	author jlee;	state Exp;
branches;
next	4.28;
commitid	OErZtZ5Vmdv61HHw;

4.28
date	2012.12.05.01.40.22;	author jlee;	state Exp;
branches;
next	4.27;
commitid	XFeMFw6wUN4JzYuw;

4.27
date	2012.11.04.23.03.56;	author bavison;	state Exp;
branches;
next	4.26;
commitid	ge9CRMOtjqlRF6rw;

4.26
date	2012.01.27.21.02.03;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	0VkxIXhraOe34RQv;

4.25
date	2011.08.04.21.52.59;	author jlee;	state Exp;
branches;
next	4.24;
commitid	q6QwMxT5fQlg0fuv;

4.24
date	2002.11.28.16.29.57;	author bavison;	state Exp;
branches;
next	4.23;

4.23
date	2001.12.06.15.21.54;	author kbracey;	state Exp;
branches;
next	4.22;

4.22
date	2001.11.27.16.57.59;	author kbracey;	state Exp;
branches;
next	4.21;

4.21
date	2001.06.14.16.08.36;	author sbrodie;	state Exp;
branches;
next	4.20;

4.20
date	2000.11.21.17.39.33;	author sforrest;	state Exp;
branches;
next	4.19;

4.19
date	2000.11.02.13.06.00;	author sforrest;	state Exp;
branches;
next	4.18;

4.18
date	2000.06.26.11.41.29;	author kbracey;	state Exp;
branches;
next	4.17;

4.17
date	2000.04.28.13.06.57;	author kbracey;	state Exp;
branches;
next	4.16;

4.16
date	99.08.26.15.22.48;	author sforrest;	state Exp;
branches;
next	4.15;

4.15
date	99.08.26.13.49.14;	author kbracey;	state Exp;
branches;
next	4.14;

4.14
date	99.02.17.08.59.51;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	98.10.09.15.17.24;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	98.10.07.10.41.32;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	98.09.28.13.46.22;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	98.09.02.08.54.42;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	98.09.01.16.38.22;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	98.08.07.15.37.38;	author sforrest;	state Exp;
branches;
next	4.7;

4.7
date	98.07.15.11.19.20;	author sforrest;	state Exp;
branches;
next	4.6;

4.6
date	98.07.14.11.19.14;	author sforrest;	state Exp;
branches;
next	4.5;

4.5
date	98.02.24.11.26.24;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	97.07.15.13.53.27;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.07.14.09.46.17;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.22.14.10.17;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.38.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	98.07.02.12.51.38;	author bavison;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	98.08.11.17.18.52;	author bavison;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	98.08.18.21.05.22;	author bavison;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.09.10.15.20.39;	author bavison;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.09.24.12.33.04;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.38.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.49.50;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.44.45;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.59.22;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.17.12.33.56;	author tdobson;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.07.10.35.38;	author tdobson;	state Exp;
branches;
next	;


desc
@@


4.31
log
@Build fix
Would fail to build with anything other than Keyboard=All since the Pandora key table is only included in that case, yet the code refers to it unconditionally.
Wrapped Pandora bits with Keyboard=All switch.
Tested briefly in an IOMD ROM with Keyboard=UK.

Version 0.98. Tagged as 'IntKey-0_98'
@
text
@; > adfs::TimsWini.arm.SourceDisc.!IKHG.Source.IntKeyBody

; ************************************************************
; ***    C h a n g e   L i s t  (better late than never!)  ***
; ************************************************************

; Date       Description
; ----       -----------
; 17-Feb-88  Modified Norway/Denmark, Sweden/Finland
; 19-Feb-88  Modified InkeyTran so that INKEY(-95) returns state of new key
;             next to left shift key on international keyboards
; 19-Feb-88  Added code to select configured keyboard on initialisation
; 16-Mar-88  Conditional versioning between 1.20 and 2.00
;            Started modify AltCharTable mechanism
; 13-Apr-88  Fixed pound/backtick problem
; 14-Apr-88  Attempt to fix initialisation problem on A500s
; 28-Apr-88  Changed version string to "Int'l Keyboard"
; 20-Jul-88  Allow kbids from 1-31
; 24-Oct-88  Modify for International Keyboard Handler Generator
; 18-Jul-89  Started to modify to allow Alt+key to give dead accents
; 31-Jul-89  Changed 'Dir', 'Hdr' etc to 'IKHG$Dir', 'IKHG$Hdr' etc
; 18-Oct-89  Corrected entry for shift-2 in TopBitSetTable1
; 02-Feb-90  Added entries to IDD table, and changed Esperanto to 1100
; 22-Nov-91  TMD Changed selection of keyboard structure to use ID rather
;            than current keyboard country number, changed list of headers
; 26-Nov-91  TMD Changed initialisation to set keyboard to current keyboard,
;            rather than default, so that it doesn't override what the
;            Territory manager says.
; 16-Dec-91  OSS Corrected burnt in UK keyboard to match the spec.
;            Added Mexico (and Israel) to IDD table.
; 22-Jan-92  OSS Corrected Perth layout to match Tim Caspell's spec, made
;            ID 3 (PC) use Perth layout, enabled "WwYy" circumflex (Welsh).
; 16-Feb-92  OSS Added Tim's corrected Letters.Latin1, which tells !IKHG
;            how to uppercase y and w circumflex. The module binary is
;            unaffected.
; 04-Mar-92  TMD Removed Arthur120 conditionals.
;            Removed references to non-existent keyboard id 3 (was PC at one stage).
;            Tidied it up a bit.
;            Made it not hang up if no keyboard attached (bug RP-1355).
; 27-Jun-94  Sorted out sources for international build.
;            Added offsets in key structure so that keypad chars can be changed.
; 10-Aug-98  BJGA Added PC-style delete capability and Ursula service call table.
; 18-Aug-98  BJGA Fixed numerous layout bugs
; 31-Aug-98  Internals fully revised to use new UCS layout structures created
;            by keygen. Alphabet adaptive, including UTF-8.
; 02-Sep-98  Hexadecimal keypad selection added. If the first digit is 0,
;            then the number entered is read as hex. (Physical) keypad keys
;            "/", "*", "-", "+", "." and "Enter" stand for digits A-F respectively.
;            Also, logical keys A-F will work.
; 28-Sep-98  BJGA Merged in 10-Sep-98 and 24-Sep-98 changes to Ursula branch
;            viz: updated layout drawfiles; added dialling codes for Wales, Wales2,
;            DvorakUK and DvorakUSA; introduced quoted characters to !IKHG.Source.Chars;
;            layout changes to Belgium, Denmark, France, Germany, Greece, Israel,
;            LatinAm, Russia, Switzerland and Turkey; and Ctrl-Alt-F1/F2 use a callback.
;            Also fixed Japan delete key to be special.
; 26-Aug-99  Software support for "FN" key.
; 21-Nov-00  Support for South African keyboard (identical to USA) added
;

        GBLL    PCDel           ; option to have Delete key return &8B (Copy) instead
PCDel   SETL    {FALSE}

        GET     Global/ListOpts
        GET     Global/Macros
        GET     Global/System
        GET     Interface/ModHand
        GET     Interface/Internatio
        GET     Global/Services
        GET     Global/Countries
        GET     Global/Keyboard
        GET     Global/Proc
        GET     Interface/OSRSI6
        GET     Global/CPU/Arch
        GET     Global/OsBytes
        GET     Global/CMOS

 [ PCDel
CmosDelByte     * SystemSpeedCMOS
CmosDelBit      * 1
 ]

Country_UK      * 1
Country_Master  * 2
Country_Compact * 3
Country_Italy   * 4
Country_Spain   * 5
Country_France  * 6
Country_Germany * 7
Country_Portugal * 8
Country_Esperanto * 9
Country_Greece  * 10
Country_Sweden  * 11
Country_Finland * 12
Country_Denmark * 14
Country_Norway  * 15
Country_Iceland * 16
Country_Canada1 * 17
Country_Canada2 * 18
Country_Canada  * 19
Country_Turkey  * 20
Country_Arabic  * 21
Country_Ireland * 22
Country_HongKong * 23
Country_Russia  * 24
Country_Russia2 * 25
Country_Israel  * 26
Country_Mexico  * 27
Country_LatinAm * 28
Country_Australia * 29
Country_Austria * 30
Country_Belgium * 31
Country_Japan   * 32
Country_MiddleEast * 33
Country_Netherlands * 34
Country_Switzerland * 35
Country_Wales   * 36

Country_USA     * 48
Country_Wales2  * 49
Country_China   * 50
Country_Brazil  * 51
Country_SAfrica2 * 52
Country_Korea   * 53
Country_Taiwan  * 54

Country_ISO1    * 80
Country_ISO2    * 81
Country_ISO3    * 82
Country_ISO4    * 83
Country_ISO5    * 84
Country_ISO6    * 85
Country_ISO7    * 86
Country_ISO8    * 87
Country_ISO9    * 88

Country_DvorakUK  * 70
Country_DvorakUSA * 71

        MACRO
        IKT     $A, $B, $C, $D, $E, $F, $G, $H
        IKT2    $A
        IKT2    $B
        IKT2    $C
        IKT2    $D
        IKT2    $E
        IKT2    $F
        IKT2    $G
        IKT2    $H
        MEND

        MACRO
        IKT2    $TE
        LCLA    T
T       SETA    $TE
        [ (T :AND: &FF00) = 0
T       SETA    T :OR: &FF00
        ]
        [ (T :AND: &FF0000) = 0
T       SETA    T :OR: &FF0000
        ]
        [ (T :AND: &FF000000) = 0
T       SETA    T :OR: &FF000000
        ]
        &       T
        MEND

        MACRO
        IKTW    $A, $B, $C, $D, $E, $F, $G, $H
        IKTW2   $A
        IKTW2   $B
        IKTW2   $C
        IKTW2   $D
        IKTW2   $E
        IKTW2   $F
        IKTW2   $G
        IKTW2   $H
        MEND

        MACRO
        IKTW2   $TE
        LCLA    T
T       SETA    $TE
        [ (T :AND: &FFFF0000) = 0
T       SETA    T :OR: &FF0000
        ]
        &       T
        MEND

; UK Keyboard keys

; Bits in pending ALT flag

KBAlt_AccentMask  * 31

KBAlt_AltDown        * (1 :SHL: 5)
KBAlt_DigitsPresent  * (1 :SHL: 6)
KBAlt_SelectKeyboard * (1 :SHL: 7)      ; set after CTRL-ALT-F12

; Extra stuff we stick on the end of the keyboard handler
KeyHandler_PadNumTran         * KeyHandler_Size+&00 ; offset from structure to new entry for keypad numerics
KeyHandler_PadCurTran         * KeyHandler_Size+&04 ; offset from structure to new entry for keypad non-numerics
KeyHandler_FNTable            * KeyHandler_Size+&08
KeyHandler_UCSTable0          * KeyHandler_Size+&0C
KeyHandler_UCSTable1          * KeyHandler_Size+&10
KeyHandler_MySize             * KeyHandler_Size+&14 ; size of our key structure header

KBStat_NoKanaLock    * KBStat_NoShiftLock  ; we've reassigned this bit

; Module workspace allocation

        ^ 0, R12

NewKeyStructWP  # KeyHandler_MySize ; key structure header, must be first thing
OldKeyHandler   # 4
CurrentKeyboard # 4     ; current keyboard setting
OsbyteVars      # 4
AltDigitValue   # 4
CurrentAlphabet # 4
AlphabetTable   # 4
FallbackCode    # 4
DeleteChar      # 1
HexDigits       # 1

A1Key_WorkspaceSize * :INDEX: @@

        ^ :INDEX: CurrentKeyboard, R0

R0CurrentKeyboard # 4
R0OsbyteVars    # 4
R0AltDigitValue # 4     ; value of ALT+digits so far
R0CurrentAlphabet # 4
R0AlphabetTable # 4
R0FallbackCode  # 4
R0DeleteChar    # 1
R0HexDigits     # 1

; User key workspace allocation

        ^ 0, R12

ShiftCount      # 1
CtrlCount       # 1
AltCount        # 1
AltLeftDown     # 1     ; for layouts where Left-Alt + Shift toggles layers
FNDown          # 1
MyMouseButtons  # 1     ; bit0=R, bit1=C, bit2=L
TempAction      # 1     ; to remember the action in ProcessUCS
KeyReturn       # 2     ; length byte (1), value byte
KeyNULReturn    # 3     ; length byte (2), NUL, value byte
NowtReturn      * KeyNULReturn +1 ; zero length list
KeyUTFReturn    # 13    ; length byte (up to 12), 6 * (NUL, value)
KeyUTFReturnEnd # 0

; Handy macro to do the FN processing. Good for any non-modifier key.
; Corrupts R8 - always corruptible, and undefined on entry.

        GBLA    HandleFNsize

        MACRO
        HandleFN
01      LDRB    R8, FNDown              ; is FN down?
        TEQ     R8, #0                  ; if not, process as normal
        BEQ     %FT02
        Push    "R14"
        BL      FindFN
        Pull    "R14"
02
HandleFNsize    SETA    . - %BT01
        MEND

; **************** Module code starts here **********************

        AREA    |!!!Module|,CODE,READONLY

Module_BaseAddr

        DCD     0
        DCD     A1Key_Init    -Module_BaseAddr
        DCD     A1Key_Die     -Module_BaseAddr
        DCD     A1Key_Service -Module_BaseAddr
        DCD     A1Key_Title   -Module_BaseAddr
        DCD     A1Key_HelpStr -Module_BaseAddr
        DCD     0
 [ :LNOT:No32bitCode
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     A1Key_Flags   -Module_BaseAddr
 ]

A1Key_Title
        =       "InternationalKeyboard", 0

A1Key_HelpStr
        =       "Int'l Keyboard", 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
 ]
 [ Keyboard <> "All"
        =       " $Keyboard"
 ]
        =       0
        ALIGN

 [ :LNOT:No32bitCode
A1Key_Flags
        DCD     ModuleFlag_32bit
 ]

; **************************************************************************


; **************************************************************************
;
;       A1Key_Init - Initialisation routine
;

A1Key_Init Entry
        LDR     r2, [r12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #A1Key_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     wp, r2

        MOV     r0, #OsByte_Alphabet
        MOV     r1, #&FF                ; read current keyboard (as determined by Territory Mgr)
        SWI     XOS_Byte
        ORRVC   r1, r1, #128            ; and set current keyboard to that, to cause a kbd reset
        SWIVC   XOS_Byte

        BLVC    SetUpKeyStructureAndHandlerIfUs
        EXIT

; **************************************************************************
;
;       A1Key_Die - Die entry
;

A1Key_Die Entry
        LDR     wp, [r12]
        PHPSEI                          ; disable interrupts round this bit
        Push    r14                     ; (r14 contains previous I_bit status)

        MOV     r0, #0                  ; read current handler address
        SWI     XOS_InstallKeyHandler
        TEQ     r0, r12
        BNE     %FT10                   ; key handler isn't us, so exit

        LDR     r0, OldKeyHandler
        SWI     XOS_InstallKeyHandler

10
        Pull    r14
        PLP                             ; restore old IRQ state
        CLRV
        EXIT

; **************************************************************************
;
;       A1Key_Service - Main entry point for services
;
; in:   R1 = service reason code
;       R2 = parameter
;
; out:  R1 = 0 if we claimed it
;       R2 preserved
;

ServiceTable
        ASSERT  Service_Reset < Service_International
        ASSERT  Service_International < Service_KeyHandler 
        DCD     0 ; flags
        DCD     Service2 - Module_BaseAddr
        DCD     Service_Reset
        DCD     Service_International
        DCD     Service_KeyHandler
        DCD     0 ; terminator
        DCD     ServiceTable - Module_BaseAddr
A1Key_Service ROUT
        MOV     R0, R0
        TEQ     r1, #Service_Reset
        TEQNE   r1, #Service_KeyHandler
        TEQNE   r1, #Service_International
        MOVNE   pc, lr
Service2
        Entry   "r1"
        LDR     wp, [r12]                       ; point to workspace
        TEQ     r1, #Service_KeyHandler         ; if Service_KeyHandler
        BEQ     %FT10                           ; then branch

        TEQ     r1, #Service_Reset              ; else if Service_Reset
        TEQNE   r2, #Inter_Keyboard             ; or (the only other option) Service_International
                                                ; with reason code NewKeyboard
        BLEQ    SetUpKeyStructureAndHandlerIfUs ; then call routine
        EXIT

; it's Service_KeyHandler, so claim service if kbid recognised

10
        BL      SetUpKeyStructureAndHandlerIfUs ; call setup routine
        STR     r1, [sp]                        ; r1 on exit = 0 if it was us, else preserved
        EXIT

; **************************************************************************
;
;       SetUpKeyStructureAndHandlerIfUs - If suitable keyboard ID, set up
;       the keyboard structure and claim handler
;
; in:   r12 -> workspace
;       SVC or IRQ mode
;
; out:  r1 = 0 if we now own the handler
;       Otherwise r1 preserved
;

SetUpKeyStructureAndHandlerIfUs Entry "r0,r1"

        SavePSR r0
        SETPSR  SVC_mode, r1            ; switch into SVC mode so we can issue
        NOP

        Push    "r0-r4,lr"
        MOV     r0, #1
        SWI     XOS_InstallKeyHandler
        TEQ     r0, #KeyboardID_Archimedes
        TEQNE   r0, #KeyboardID_PC
        TEQNE   r0, #KeyboardID_RCMM
        TEQNE   r0, #KeyboardID_None
 [ Keyboard = "All"
        TEQNE   r0, #KeyboardID_Pandora
 ]
        BNE     %FT50
        Push    "r0"

        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_OSByteVars
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        BNE     %FT01

        MOV     r0, #OsByte_OSByteVarTableLo
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        ORR     r2, r1, r2, LSL #8
01
        STR     r2, OsbyteVars          ; set up osbyte vars address

        MOV     r0, #OsByte_Alphabet
        MOV     r1, #&FF                ; read keyboard number
        SWI     XOS_Byte
        STR     r1, CurrentKeyboard

        MOV     r0, #-1
        STR     r0, CurrentAlphabet
        STR     r0, FallbackCode

        MOV     r0, r12
        BL      GetAlphabetTable

        Pull    "r0"
 [ Keyboard = "All"
        TEQ     r0, #KeyboardID_Pandora
        ADREQL  r0, KeyStructureTable_Pandora
        ADRNEL  R0, KeyStructureTable_PC
 |
        ADRL    R0, KeyStructureTable_PC
 ]
        MOV     R4, R0
05
        LDMIA   R4!,{R2,R3}             ; load keyboard number, offset pair
        CMP     R2, #-1                 ; if end of table
        TEQNE   R1, R2                  ; or numbers match then drop through
        BNE     %BT05                   ; else try next
        ADD     R0, R0, R3              ; point to found table or default

; if we need the flags word, check that the kernel knows how to handle this key
; handler
        LDR     r3, [r0, #KeyHandler_KeyTranSize]
        TST     r3, #KeyHandler_HasFlags
        BEQ     %FT07
        MOV     r1, r0
        MOV     r0, #13
        SWI     XOS_ReadSysInfo        
        BVS     %FT50
        MOV     r0, r1
07

        WritePSRc SVC_mode + I_bit, r2  ; disable IRQs round this bit

        MOV     r2, #KeyHandler_MySize-4
        SUB     r1, r0, r12             ; offset from workspace to structure
10
        LDR     r3, [r0, r2]
        TEQ     r2, #KeyHandler_KeyTranSize ; is it KeyTranSize ?
        TEQNE   r2, #KeyHandler_Flags       ; or is it the flags ?
        TEQNE   r3, #0                      ; or is it 0
        ADDNE   r3, r3, r1                  ; if not then relative offset
        STR     r3, [r12, r2]
        SUBS    r2, r2, #4
        BCS     %BT10
; now set up key handler to point to us, if it doesn't already

        MOV     r0, #0
        SWI     XOS_InstallKeyHandler
        TEQ     r0, r12
        STRNE   r0, OldKeyHandler
        MOVNE   r0, r12
        SWINE   XOS_InstallKeyHandler

 [ PCDel
; scan CMOS to determine delete type
        MOV     r0, #OsByte_ReadCMOS
        MOV     r1, #CmosDelByte
        SWI     XOS_Byte
        TST     r2, #1 :SHL: CmosDelBit
        MOVEQ   r0, #&7F
        MOVNE   r0, #&8B
        STRB    r0, DeleteChar
 ]

        Pull    "r0-r4,lr"
        RestPSR r0                      ; return to original mode and IRQ state

        MOV     r0, #0
        STR     r0, [sp, #4]            ; set stacked r1 to 0, so we claim the service
        EXIT

; the keyboard id is not recognised by us, so put back old handler if it's
; set to us at the moment

50
        MOV     r0, #0
        SWI     XOS_InstallKeyHandler
        TEQ     r0, r12                 ; if it's us
        LDREQ   r0, OldKeyHandler       ; then put back old one
        SWIEQ   XOS_InstallKeyHandler

        Pull    "r0-r4,lr"
        RestPSR r0                      ; return to original mode and IRQ state
        NOP
        EXIT

; **************************************************************************

; Find out what alphabet the system is using
;
; on entry: r0 -> my workspace
; on exit: r3 = CurrentAlphabet = alphabet number
;          r4 = AlphabetTable = alphabet table or 0

GetAlphabetTable ROUT
        Entry   "r0,r1,r12"
        MOV     r12, r0
        SavePSR r0
        SETPSR  SVC_mode, r1            ; switch into SVC mode so we can issue SWIs
        NOP

        Push    "r0-r2,lr"
        MOV     r0, #OsByte_Alphabet
        MOV     r1, #&7F                ; read alphabet number
        SWI     XOS_Byte
        LDR     r3, CurrentAlphabet
        TEQ     r1, r3
        BNE     %FT50
        LDR     r4, AlphabetTable
20
        Pull    "r0-r2,lr"
        RestPSR r0                      ; return to original mode and IRQ state
        NOP
        EXIT

50      MOV     r3, r1
        STR     r3, CurrentAlphabet
        TEQ     r3, #ISOAlphabet_UTF8
        BEQ     %BT20

        MOV     r4, #0
        MOV     r1, #Service_International
        MOV     r2, #Inter_UCSTable
        SWI     XOS_ServiceCall
        STR     r4, AlphabetTable
        B       %BT20


; **************************************************************************

; Now the code to handle it

; Initialise keyboard table handler
;
; in:   R0 -> KeyStruct
;       R1 = keyboard id
;       R5 = KeyBdStatus
;       R7 = PendingAltType
;       R12 -> my workspace
;
; out:  R5 = new KeyBdStatus
;       R7 = new PendingAltType

KeyStructInit ROUT
        MOV     R0, #0                  ; no shift or ctrl keys down
        STRB    R0, ShiftCount
        STRB    R0, CtrlCount
        STRB    R0, AltCount
        STRB    R0, AltLeftDown
        STRB    R0, FNDown
        STRB    R0, MyMouseButtons
        STRB    R0, KeyNULReturn+1      ; NUL for NUL char return
        MOV     R0, #1                  ; string length for single key return
        STRB    R0, KeyReturn+0
        MOV     R0, #2                  ; length for NUL char return
        STRB    R0, KeyNULReturn+0

        BIC     R5, R5, #(KBStat_ShiftEngaged :OR: KBStat_CtrlEngaged :OR: KBStat_PendingAlt)
        ORR     R5, R5, #KBStat_NoKanaLock
        MOV     R7, #0                  ; 0 pending ALT
        MOV     PC, R14

ProcessKShift ROUT
        LDRB    R0, AltLeftDown         ; is Left Alt down (where it switches layers?)
        TEQ     R0, #1
        LDREQB  R0, ShiftCount
        TEQEQ   R0, #0                  ; if so, is Shift going down for the first time?
        TEQEQ   R1, #1
        EOREQ   R5, R5, #KBStat_NoKanaLock ; if so, toggle layers, then proceed as normal

        ADR     R0, ShiftCount
        MOV     R2, #KBStat_ShiftEngaged
ProcessShiftOrCtrl
        TEQ     R1, #0                  ; R1=1 => down, R1=0 => up
        LDRB    R3, [R0]
        ADDNE   R3, R3, #1              ; if down then increment (still NE)
        SUBEQS  R3, R3, #1              ; if up then decrement and setup Z
        STRB    R3, [R0]
        ORRNE   R5, R5, R2              ; one or more shift/ctrl keys down
        BICEQ   R5, R5, R2              ; zero shift/ctrl keys down
        MOV     PC, R14

ProcessKCtrl ROUT
        ADR     R0, CtrlCount
        MOV     R2, #KBStat_CtrlEngaged
        B       ProcessShiftOrCtrl

ProcessKFN ROUT
        STRB    R1, FNDown
        MOV     PC, R14

ProcessKRight ROUT
        MOV     R2, #1
ProcessMouseButton
        TEQ     R1, #0
        LDRB    R0, MyMouseButtons
        ORRNE   R0, R0, R2              ; button going down
        BICEQ   R0, R0, R2              ; button going up
        STRB    R0, MyMouseButtons
        MOV     PC, R3                  ; call his routine and exit

ProcessKCentre ROUT
        MOV     R2, #2
        B       ProcessMouseButton

ProcessKLeft ROUT
        MOV     R2, #4
        B       ProcessMouseButton

ProcessKAltLeft ROUT
        STRB    R1, AltLeftDown                 ; note new state of Left Alt
        TEQ     R1, #0                          ; are we going down?
        TSTNE   R5, #KBStat_ShiftEngaged        ; and is either Shift already down?
        EORNE   R5, R5, #KBStat_NoKanaLock      ; if so, toggle layers
        MOV     PC, R14

ProcessKAlt ROUT
        LDRB    R3, AltCount
        TEQ     R3, #0                  ; if no ALTs down so far, then must be

        STREQ   R3, R0AltDigitValue     ; going down, so zero cumulative digits
        STREQB  R3, R0HexDigits

        TEQ     R1, #0                  ; 0 => up, 1 => down
        ADDNE   R3, R3, #1              ; if down then increment
        SUBEQS  R3, R3, #1              ; if up then decrement and setup Z
        STRB    R3, AltCount
        BNE     %FT10

        TST     R7, #KBAlt_DigitsPresent ; if no digits present
        BEQ     %FT05                   ; then skip

        LDR     R1, R0AltDigitValue     ; load digits
        TST     R7, #KBAlt_SelectKeyboard ; selecting keyboard (CTRL-ALT-F12)?
        BNE     SelectIDDKeyboard

; return either byte, or UCS character

        Push    R14
        BL      GetAlphabetTable
        Pull    R14
        TEQ     R3, #ISOAlphabet_UTF8
        BNE     %FT02

        BIC     R1, R1, #&80000000      ; strip down to 31 bits
        BICS    R7, R7, #(KBAlt_AltDown :OR: KBAlt_DigitsPresent)
        BICEQ   R5, R5, #KBStat_PendingAlt
        B       ReturnUCS

02
        ADR     R6, KeyNULReturn        ; return 0 then byte
        STRB    R1, [R6, #2]
        B       %FT05

SelectIDDKeyboard
        ADR     R0, IDDTable
03
        LDMIA   R0!, {R2, R3}           ; load IDD number, country number
        CMP     R2, #-1                 ; end of table ?
        BEQ     %FT05                   ; then not recognised, so do nothing
        TEQ     R2, R1                  ; found match ?
        BNE     %BT03

        ORR     R1, R3, #&80
        Push    R14
        BL      SelectKeyboard
        Pull    R14

05
        BICS    R7, R7, #(KBAlt_AltDown :OR: KBAlt_DigitsPresent :OR: KBAlt_SelectKeyboard)
        B       %FT15
10
        ORRS    R7, R7, #KBAlt_AltDown
15
        ORRNE   R5, R5, #KBStat_PendingAlt ; if NZ then still need bit set
        BICEQ   R5, R5, #KBStat_PendingAlt ; else clear bit
        MOV     PC, R14

IDDTable
        &        44, Country_UK
        &        39, Country_Italy
        &        34, Country_Spain
        &        33, Country_France
        &        49, Country_Germany
        &       351, Country_Portugal
        &      1100, Country_Esperanto
        &        30, Country_Greece
        &        46, Country_Sweden
        &       358, Country_Finland
        &        45, Country_Denmark
        &        47, Country_Norway
        &       354, Country_Iceland
        &        90, Country_Turkey
        &       353, Country_Ireland
        &       852, Country_HongKong
        &         7, Country_Russia
        &       972, Country_Israel
        &        52, Country_Mexico
        &        61, Country_Australia
        &        43, Country_Austria
        &        32, Country_Belgium
        &        81, Country_Japan
        &        31, Country_Netherlands
        &        41, Country_Switzerland
        &      1222, Country_Wales
        &         1, Country_USA
        &      2222, Country_Wales2
;        &        86, Country_China
;        &        55, Country_Brazil
        &        27, Country_SAfrica2

        &      9944, Country_DvorakUK
        &       991, Country_DvorakUSA

        &      1001, Country_ISO1
        &      1002, Country_ISO2
        &      1003, Country_ISO3
        &      1004, Country_ISO4
        &      1005, Country_ISO5
        &      1006, Country_ISO6
        &      1007, Country_ISO7
        &      1008, Country_ISO8
        &      1009, Country_ISO9
        &       -1, -1

ProcessKCaps ROUT
        HandleFN
HandleKCaps
        TEQ     R1, #2                          ; is it first press ?
        MOVNE   PC, R14                         ; don't auto-repeat

        TST     R5, #KBStat_ShiftEngaged        ; if shift down
        BICNE   R5, R5, #KBStat_NoCapsLock      ; then force CAPS on
        ORRNE   R5, R5, #KBStat_ShiftEnable     ; and SHIFT CAPS state
        EOREQ   R5, R5, #KBStat_NoCapsLock      ; else toggle caps lock state
        BICEQ   R5, R5, #KBStat_ShiftEnable     ; and cancel shift enable

        MOV     PC, R14

ProcessKTab ROUT
        HandleFN
HandleKTab
        LDR     R3, R0OsbyteVars
        LDRB    R3, [R3, #OsByte_RW_TabCharCode]          ; TAB key code
        TST     R3, #&80                        ; top bit set ?
        BEQ     ReturnOneCharAlt                ; no, don't shift or ctrl it
        TST     R5, #KBStat_ShiftEngaged
        EORNE   R3, R3, #&10                    ; modify for shift
        TST     R5, #KBStat_CtrlEngaged
        EORNE   R3, R3, #&20                    ; modify for ctrl
ReturnOneCharAlt
        TST     R5, #KBStat_PendingAlt          ; if no pending alt
        TSTNE   R7, #KBAlt_AccentMask           ; or its not an accent
        ADREQ   R6, KeyReturn
        STREQB  R3, [R6, #1]                    ; then return this
        MOVEQ   PC, R14
        LDR     R4, [R0, #KeyHandler_PendingAltCode]
        ADD     PC, R0, R4                      ; call PendingAltCode, as the Kernel would


ProcessKDelete ROUT
        HandleFN
HandleKDelete
 [ PCDel
        LDRB    R1, R0DeleteChar                ; get configured delete character
 |
        MOV     R1, #&7F
 ]
        B       ReturnOneChar

ProcessKNum ROUT
        HandleFN
HandleKNum
        TEQ     R1, #2                          ; is it first press ?
        EOREQ   R5, R5, #KBStat_NoNumLock       ; yes, then toggle num lock
        MOV     PC, R14                         ; (don't auto-repeat)

ProcessKScroll ROUT
        HandleFN
HandleKScroll
        TEQ     R1, #2                          ; is it first press ?
        EOREQ   R5, R5, #KBStat_ScrollLock      ; yes, then toggle scroll lock
        MOV     PC, R14                         ; (don't auto-repeat)

ProcessKKana ROUT
        HandleFN
HandleKKana
        TEQ     R1, #2                          ; is it first press ?
        EOREQ   R5, R5, #KBStat_NoKanaLock      ; yes, then toggle kana lock
        MOV     PC, R14                         ; (don't auto-repeat)

ProcessKShiftCaps ROUT
        HandleFN
HandleKShiftCaps
        TEQ     R1, #2                          ; is it first press ?
        MOVNE   PC, R14                         ; (don't auto-repeat)
        EOR     R5, R5, #KBStat_NoCapsLock      ; toggle caps lock
        TST     R5, #KBStat_NoCapsLock
        ORREQ   R5, R5, #KBStat_ShiftEnable     ; set shift enable if caps lock on
        BICNE   R5, R5, #KBStat_ShiftEnable
        MOV     PC, R14

ProcessKBreak ROUT
        HandleFN
        ADD     PC, R3, #4                      ; offset for break routine

ProcessK1Pad ROUT
        HandleFN
        TST     R7, #KBAlt_AltDown
        BNE     AltKeyPad

        BICS    R7, R7, #KBAlt_AccentMask       ; cancel accents
        BICEQ   R5, R5, #KBStat_PendingAlt

        TST     R5, #KBStat_NoNumLock           ; test num lock
        LDREQ   R3, [R0, #KeyHandler_PadNumTran] ; num lock on
        LDRNE   R3, [R0, #KeyHandler_PadCurTran] ; num lock off
        ADD     R3, R3, R0
        LDRB    R1, [R3, R4]                    ; get table entry
        TEQ     R1, #&FF                        ; dummy key ?
        MOVEQ   PC, R14                         ; then exit

        LDR     R6, R0OsbyteVars
        LDRB    R2, [R6, #OsByte_RW_BaseOfNumericKeypad]        ; add on numeric key base
        SUB     R1, R1, #"0"
        ADD     R1, R1, R2

        LDRB    R2, [R6, #OsByte_RW_NumericKeypadModifier]         ; zero => ctrl/shift modifies
        TEQ     R2, #0
        BNE     %FT10                           ; [don't modify]

        TST     R1, #&80                        ; top bit set ?
        BEQ     %FT10                           ; no, then don't modify

        TST     R5, #KBStat_ShiftEngaged
        EORNE   R1, R1, #&10                    ; modify for shift
        TST     R5, #KBStat_CtrlEngaged
        EORNE   R1, R1, #&20                    ; modify for ctrl
10
ReturnOneChar
        ADR     R6, KeyReturn                   ; pass pointer back to MOS
        STRB    R1, [R6, #1]                    ; having poked byte in
        MOV     PC, R14

AltKeyPad ROUT
        LDR     R3, [R0, #KeyHandler_PadNumTran]
        LDRB    R1, R0HexDigits                 ; are we doing hex?
        ADD     R3, R3, R0
        TEQ     R1, #0
        BNE     AltKeyPadHex
        LDRB    R3, [R3, R4]                    ; get value from PadK1NumTran
        SUB     R3, R3, #"0"
        CMP     R3, #10                         ; if not in range 0-9
        BICHS   R7, R7, #(KBAlt_DigitsPresent :OR: KBAlt_SelectKeyboard)
                                                ; then get rid of digs + select
        ORRLO   R7, R7, #KBAlt_DigitsPresent    ; else indicate we have digits
        MOVHS   R2, #0                          ; if no digits
        STRHS   R2, R0AltDigitValue             ; then zero digits
        MOVHS   PC, R14                         ; and exit

        LDR     R2, R0AltDigitValue
        MOV     R1, #10
        MLAS    R3, R2, R1, R3                  ; digits = digits*10+new digit
        TSTEQ   R7, #KBAlt_SelectKeyboard
        STREQB  R1, R0HexDigits                 ; 0 pressed first - switch to hex (not IDD)
        STR     R3, R0AltDigitValue
        MOV     PC, R14

AltKeyPadHex
        LDRB    R1, [R3, R4]
        SUB     R1, R1, #"0"                    ; check digits first - they're logical
        CMP     R1, #10
        BLO     GotHex

        ADR     R4, HexPadTable                 ; scan table of physical codes
05      LDRB    R1, [R4], #2
        TEQ     R2, R1
        LDREQB  R1, [R4, #-1]
        BEQ     GotHex
        TEQ     R1, #0
        BNE     %BT05

GotHex
        LDR     R2, R0AltDigitValue
        ADD     R2, R1, R2, LSL #4              ; digits = digits*16+new digit
        STR     R2, R0AltDigitValue
        MOV     PC, R14

HexPadTable
        =       KeyNo_NumPadSlash, &A
        =       KeyNo_NumPadStar,  &B
        =       KeyNo_NumPadHash,  &C
        =       KeyNo_NumPadMinus, &C
        =       KeyNo_NumPadPlus,  &D
        =       KeyNo_NumPadDot,   &E
        =       KeyNo_NumPadEnter, &F
        =       0
        ALIGN

ReturnNULChar
        ADR     R6, KeyNULReturn
        STRB    R1, [R6, #2]
        MOV     PC, R14

; **************************************************************************
;
; In:  R0->handler
;      R1=action (shifting key:0,1=up,down;  non-shifting:2=first,3=autorepeat)
;      R2=low-level key number
;      R3->table of exit points
;      R4=special key number (eg 1 for first special key)
;      R5=KeyBdStatus
;      R6->a zero byte (so left unmodified -> no output)
;      R7=PendingAltType
;      R12->fixed workspace (allocated by kernel) - approx 170 bytes, not aligned
;
; Out: R0-R4 corrupted
;      R5 updated
;      R6->output (first byte=length, subsequent bytes to insert into buffer)
;      R7 updated

ProcessUCS ROUT
        HandleFN

        TST     R5, #KBStat_NoKanaLock
        LDRNE   R2, [R0, #KeyHandler_UCSTable0]
        LDREQ   R2, [R0, #KeyHandler_UCSTable1]
        ADD     R4, R4, R4, LSL #3      ; R4 = key * 9
        ADD     R2, R0, R2
        ADD     R2, R2, R4, LSL #2      ; R2 -> 36-byte entry for key

        TST     R7, #KBAlt_DigitsPresent
        BNE     CheckHexAtoF_ucs

; select the correct Shift/Ctrl/Alt variant.
        STRB    R1, TempAction
        MOV     R1, #0
        TST     R5, #KBStat_ShiftEngaged
        ORRNE   R1, R1, #4
        TST     R5, #KBStat_CtrlEngaged
        ORRNE   R1, R1, #8
        TST     R7, #KBAlt_AltDown
        ORRNE   R1, R1, #16

02      TST     R5, #KBStat_NoCapsLock
        BNE     %FT05

; process Caps Lock
        LDR     R4, [R2, #32]           ; get the capital-mapping word
        MOV     R4, R4, LSR R1
        AND     R4, R4, #&F             ; R4=alternate form for this character
        TST     R4, #8                  ; bit 3 of R4 set if only Shift-Caps changes
        BEQ     %FT03

        TST     R5, #KBStat_ShiftEnable
        BEQ     %FT05

        AND     R4, R4, #7
03      MOV     R1, R4, LSL #2

05      LDR     R1, [R2, R1]

06      TST     R1, #&80000000
        BNE     FunnyUCS

ReturnUCSAlt
        ANDS    R2, R7, #KBAlt_AccentMask   ; Check if we've got a pending accent
        MOVEQ   R2, #-1
        STREQ   R2, R0FallbackCode          ; clear "fallback" character
        BEQ     ReturnUCS

; We have to apply a dead accent now.

        ADRL    R4, AccentTable
        LDR     R2, [R4, R2, LSL #2]    ; offset to appropriate accent
        ADD     R4, R4, R2              ; R4 now points to accent list

        BICS    R7, R7, #KBAlt_AccentMask ; no more accents
        BICEQ   R5, R5, #KBStat_PendingAlt ; if no more then zero status bit
07
        LDR     R3, [R4], #8            ; R3 = base character
        CMP     R3, R1
        BHI     ReturnUCS               ; we're not in the list - return char unmodified
        BNE     %BT07                   ; not found it yet

        STR     R1, R0FallbackCode      ; remember unaccented form, in case accented form
                                        ; not available
        LDR     R1, [R4, #-4]           ; R1 = accented form

;       R1 = real UCS code
ReturnUCS
        CMP     R1, #&80
        BLO     ReturnOneOrNUL          ; 00-7F always the same

        Push    R14
        BL      GetAlphabetTable
        Pull    R14

        TEQ     R3, #ISOAlphabet_UTF8
        BNE     ReturnUCSForAlphabet

; Create the UTF-8 sequence
        Push    R5
        ADR     R6, KeyUTFReturnEnd
        MOV     R5, #2
        MOV     R4, #2_00100000
10
        AND     R2, R1, #2_00111111     ; continuation byte
        ORR     R2, R2, #2_10000000
        STRB    R2, [R6, #-1]!
        MOV     R2, #0                  ; don't forget the 0 padding...
        STRB    R2, [R6, #-1]!
        MOV     R1, R1, LSR #6
        CMP     R1, R4
        MOVHS   R4, R4, LSR #1
        ADDHS   R5, R5, #1
        BHS     %BT10

; and the leading byte...
        MOV     R4, #&FF00
        ORR     R2, R1, R4, LSR R5
        STRB    R2, [R6, #-1]!
        MOV     R2, #0                  ; don't forget the 0 padding...
        STRB    R2, [R6, #-1]!
        MOV     R5, R5, LSL #1
        STRB    R5, [R6, #-1]!
        Pull    R5
        MOV     PC, R14

ReturnUCSForAlphabet
        MOVS    R3, R4                  ; alphabet table
        BEQ     ReturnUCSForNoAlphabet

; find which (if any) of codes &80-&FF is what we want
        MOV     R6, #&80

13      LDR     R2, [R3, R6, LSL #2]
        TEQ     R1, R2
        MOVEQ   R1, R6
        BEQ     ReturnNULChar
        ADD     R6, R6, #1
        CMP     R6, #&FF
        BLS     %BT13

; can't find it - do we have a fallback?
15      LDR     R1, R0FallbackCode
        CMP     R1, #-1
        MOVNE   R6, #-1
        STRNE   R6, R0FallbackCode    ; clear fallback, else infinite loop
        BNE     ReturnUCS

; give up - output nothing
        ADR     R6, NowtReturn
        MOV     PC, R14

ReturnUCSForNoAlphabet                  ; Assume pure ISO Latin 1
        CMP     R1, #&FF
        BHI     %BT15
        B       ReturnNULChar

FunnyUCS
        CMN     R1, #1                 ; Check for &FFFFFFFF - nothing
        ADREQ   R6, NowtReturn

        BIC     R1, R1, #&80000000     ; &800000xx - a raw buffer code
        CMP     R1, #&100
        ADRLO   R6, KeyReturn
        STRLOB  R1, [R6, #1]
        MOVLO   PC, R14

; Oooh - it's summat special
        CMP     R1, #&10000
        BLO     %FT40                  ; &8000xxxx - daft
        CMP     R1, #&20000
        BLO     SpecialKey             ; &8001xxxx - special key
        CMP     R1, #&30000
        BLO     DeadKey                ; &8002xxxx - dead key

40      ADRHI   R6, NowtReturn
        MOV     PC, R14

CheckHexAtoF_simple
        LDR     R4, [R0, #KeyHandler_Flags]
        TST     R4, #KeyHandler_Flag_Wide
        LDR     R4, [R0, #KeyHandler_KeyTran]
        ADD     R4, R0, R4
        LDREQB  R4, [R4, R2, LSL #2]    ; get the base symbol for this key
        BEQ     CheckHexAtoF_common
        ADD     R4, R4, R2, LSL #3
  [ NoARMv4
        LDRB    R8, [R4]
        LDRB    R4, [R4, #1]
        ORR     R4, R8, R4, LSL #8
  |
        LDRH    R4, [R4]
  ]
        B       CheckHexAtoF_common


CheckHexAtoF_ucs
        LDR     R4, [R2, #0]            ; get the base symbol for this key
        B       CheckHexAtoF_common

CheckHexAtoF_common
; We're doing something digitty - if it's hex we need to check for A-F.
; If it's not hex or A-F, we return immediately - it's not sensible to
; be outputting standard Alt symbols while doing a keypad sequence, although
; this is what pre 0.50 versions did.

        LDRB    R2, R0HexDigits         ; are we doing hex?
        TEQ     R2, #0
        MOVEQ   PC, R14
        BIC     R4, R4, #&20            ; upper case the codes that matter
        CMP     R4, #"A"
        MOVLO   PC, R14
        CMP     R4, #"F"
        MOVHI   PC, R14
        SUB     R1, R4, #"A"-10
        B       GotHex

SpecialKey
        SUB     R4, R1, #&10000
        CMP     R4, #10
        LDRB    R1, TempAction
        ADDLO   PC, PC, R4, LSL #2
        B       %BT40
        B       HandleKScroll
        B       HandleKNum
        B       HandleKTab
        B       HandleKCaps
        B       HandleKKana
        B       HandleKShiftCaps
        B       HandleKDefaultKeyboard
        B       HandleKConfiguredKeyboard
        B       HandleKDialKeyboard
        B       HandleKDelete

DeadKey
        SUB     R1, R1, #&20000
        BIC     R7, R7, #KBAlt_AccentMask  ; clear accents
        ORR     R7, R7, R1                 ; put in new accent
        ORR     R5, R5, #KBStat_PendingAlt ; and indicate it
        MOV     PC, R14

; Silly entry conditions here. Can return normally,
; to carry on as normal, can pull PC from the stack
; to ignore the keypress altogether, or can call a new handler
; in the special table.
;
; Note that as in the HandleFN macro we're merrily scrambling R8.
;
FindFN  ROUT
        LDR     R8, [R0, #KeyHandler_FNTable] ; if no FN table at all
        TEQ     R8, #0
        MOVEQ   PC,R14

        Push    "R1,R3"
        LDR     R1, [R0, #KeyHandler_Flags]
        ADD     R3, R0, R8
        TST     R1, #KeyHandler_Flag_Wide
        BNE     FindFNWide
        
        LDRB    R8, [R3], #1            ; R8 = number of FN entries
        TEQ     R8, #0
        BEQ     NoFN
FNLoop  LDRB    R1, [R3], #2            ; R1 = base FN key, advance R3 to next entry
        CMP     R1, R4
        LDREQB  R4, [R3, #-1]           ; if R1 = this key, change R4 to new key
        BEQ     FNContinue
        BHI     NoFN                    ; if R1 > this key, its not there
        SUBS    R8, R8, #1
        BNE     FNLoop
NoFN
        Pull    "R1,R3,PC"              ; no FN entry - output nothing

FindFNWide
      [ NoARMv4
        LDR     R8, [R3], #2            ; R8 = number of FN entries
        MOVS    R8, R8, LSL #16
        MOV     R8, R8, LSR #16
        BEQ     NoFN
      |
        LDRH    R8, [R3], #2            ; R8 = number of FN entries
        TEQ     R8, #0
        BEQ     NoFN
      ]
FNLoopWide
      [ NoARMv4
        LDR     R1, [R3], #4            ; R1 = base FN key, advance R3 to next entry
        MOV     R1, R1, LSL #16
        CMP     R1, R4, LSL #16
        LDREQ   R4, [R3, #-2]           ; if R1 = this key, change R4 to new key
      |
        LDRH    R1, [R3], #4            ; R1 = base FN key, advance R3 to next entry
        CMP     R1, R4
        LDREQH  R4, [R3, #-2]           ; if R1 = this key, change R4 to new key
      ]
        BEQ     FNContinueWide
        BHI     NoFNWide                ; if R1 > this key, its not there
        SUBS    R8, R8, #1
        BNE     FNLoopWide
NoFNWide
        Pull    "R1,R3,PC"              ; no FN entry - output nothing

FNContinueWide
      [ NoARMv4
        MOV     R4, R4, LSL #16
        MOV     R4, R4, LSR #16
      ]

FNContinue
; Need to call the correct handler...
        LDR     R8, [R0, #KeyHandler_SpecialCodeTable]
        ADD     R8, R8, R0              ; R2 -> special code table
        SUB     R1, R8, #4              ; 0th entry is for 1st special
        LDR     R1, [R1, R4, LSL #2]    ; R1 = offset to code
        ADD     R8, R1, R8              ; R2 = address of code
        ADD     R8, R8, #HandleFNsize   ; Skip past the FN handling code :)
        Pull    "R1,R3,LR"
        MOV     PC, R8

; **************************************************************************
;
; in:   R0 -> key structure
;       R1 = action (2=first,3=autorepeat)
;       R2 = internal key number for char
;       R3 = character which would be returned if not an ALT
;       R5 = keyboard status
;       R6 -> a zero byte
;       R7 = pending alt type

PendingAltCode ROUT
        TST     R7, #KBAlt_DigitsPresent; is it because of keyboard selection?
        BNE     CheckHexAtoF_simple     ; if so, then nip off to deal with it

        TST     R7, #KBAlt_AccentMask   ; is it due to dead accent ?
        MOVEQ   PC, R14                 ; no, then must be Alt down - any real Alts are
                                        ; special - simple keys return nothing.

; called because of accented char

        MOV     R1, R3
        CMP     R1, #&80                ; is it a Basic Latin character?
        BLO     ReturnUCSAlt            ; if so - get ProcessUCS to add the accent

; Boring - it's just a function key. Remove the dead accent and
; output the function key.

        BICS    R7, R7, #KBAlt_AccentMask ; no more accents
        BICEQ   R5, R5, #KBStat_PendingAlt ; if no more then zero status bit

        B       ReturnOneChar

ReturnOneOrNUL
        CMP     R1, #0                  ; if 0 then return 0 0 (C=1)
        CMPNE   R1, #&80                ; elif -ve return 0 char
        BCS     ReturnNULChar
        B       ReturnOneChar           ; else return 0 char

HandleKDialKeyboard
        TST     R7, #KBAlt_AltDown              ; ensure Alt is down...
        ORRNE   R7, R7, #KBAlt_SelectKeyboard   ; set IDD selection flag
        MOV     PC, R14

HandleKConfiguredKeyboard ROUT
        MOV     R1, #&80                        ; select default keyboard
        B       SelectKeyboard
HandleKDefaultKeyboard
        MOV     R1, #&81                        ; select UK keyboard
SelectKeyboard
        SavePSR R3
        SETPSR  SVC_mode, R0                    ; select SVC mode
        NOP                                     ; wait for it to happen

        Push    R14
        ADR     R0, CallBack_SelectKeyboard
        SWI     XOS_AddCallBack                 ; R1 already set up
        Pull    R14

        RestPSR R3                              ; reenter previous mode
        NOP                                     ; wait for it to happen
ReturnNowt
        ADR     R6, NowtReturn                  ; return nowt
        MOV     PC, R14

CallBack_SelectKeyboard
        Push    "R0-R2,R14"
        MOV     R0, #OsByte_Alphabet
        MOV     R1, R12                         ; R12 used to pass keyboard + &80
        SWI     XOS_Byte
        Pull    "R0-R2,PC"

; **************************************************************************
;
;       Reverse table lookup for INKEY(-ve)
;

; For reference, here is the definitive internal key list. A number of codes
; are for BBC compatibility. For example, code 71 was the "@@" key on the
; BBC micro - there was no separate @@ key on the Archimedes UK layout,
; so the 2 key (Shift-2 was @@) generates this internal code. These compatibility
; codes should not be used by new programs.
;
; Don't forget that these codes are supposed to be for _physical_ keys -
; the code for the key to the left of backspace never changes, no matter
; how it is marked.
;
; Internal code    Key                Low-level codes
; 0                Shift              4C or 58
; 1                Ctrl               3B or 61
; 2                Alt                5E or 60
; 3                Left Shift         4C
; 4                Left Ctrl          3B
; 5                Left Alt           5E
; 6                Right Shift        58
; 7                Right Ctrl         61
; 8                Right Alt          60
; 9                Select             70
; 10               Menu               71
; 11               Adjust             72
; 12               FN                 6F
; 13               (not defined)
; 14               (not defined)
; 15               (not defined)
; 16               Q                  27
; 17               3                  13
; 18               4                  14
; 19               5                  15
; 20               F4                 04
; 21               8                  18
; 22               F7                 07
; 23               -                  1B
; 24               ^                  16 (BBC compatibility - see 52)
; 25               Left Arrow         62
; 26               Keypad 6           4A
; 27               Keypad 7           37
; 28               F11                0B
; 29               F12                0C
; 30               F10                0A
; 31               Scroll Lock        0E
; 32               Print              0D
; 33               W                  28
; 34               E                  29
; 35               T                  2B
; 36               7                  17
; 37               I                  2E
; 38               9                  19
; 39               0                  1A
; 40               _                  1B (BBC compatibility - see 23)
; 41               Down Arrow         63
; 42               Keypad 8           38
; 43               Keypad 9           39
; 44               Break              0F
; 45               `                  10
; 46               Pound              1D (not fitted)
; 47               Backspace          1E
; 48               1                  11
; 49               2                  12
; 50               D                  3E
; 51               R                  2A
; 52               6                  16
; 53               U                  2D
; 54               O                  2F
; 55               P                  30
; 56               [                  31
; 57               Up Arrow           59
; 58               Keypad +           4B
; 59               Keypad -           3A
; 60               Keypad Enter       67
; 61               Insert             1F
; 62               Home               20
; 63               Page Up            21
; 64               Caps Lock          5D
; 65               A                  3C
; 66               X                  4F
; 67               F                  3F
; 68               Y                  2C
; 69               J                  42
; 70               K                  43
; 71               @@                  12 (BBC compatibility - see 49)
; 72               :                  45 (BBC compatibility - see 87)
; 73               Return             47
; 74               Keypad /           23
; 75               Keypad Delete      (not mapped)
; 76               Keypad .           66
; 77               Num Lock           22
; 78               Page Down          36
; 79               '                  46
; 80               Shift Lock         (not mapped)
; 81               S                  3D
; 82               C                  50
; 83               G                  40
; 84               H                  41
; 85               N                  53
; 86               L                  44
; 87               ;                  45
; 88               ]                  32
; 89               Delete             34
; 90               Keypad #           25 (not normally fitted)
; 91               Keypad *           24
; 92               Keypad ,           (not mapped)
; 93               =                  1C
; 94               \                  4D
; 95               Not fitted (R)     6E (between / and Shift on Japanese keyboard)
; 96               Tab                26
; 97               Z                  4E
; 98               Space              5F
; 99               V                  51
; 100              B                  52
; 101              M                  54
; 102              ,                  55
; 103              .                  56
; 104              /                  57
; 105              End                35
; 106              Keypad 0           65
; 107              Keypad 1           5A
; 108              Keypad 3           5C
; 109              No Convert         6B
; 110              Convert            6C
; 111              Kana               6D
; 112              Escape             00
; 113              F1                 01
; 114              F2                 02
; 115              F3                 03
; 116              F5                 05
; 117              F6                 06
; 118              F8                 08
; 119              F9                 09
; 120              # (\ on BBC+Arch)  33
; 121              Right Arrow        64
; 122              Keypad 4           48
; 123              Keypad 5           49
; 124              Keypad 2           5B
; 125              Left Acorn         68
; 126              Right Acorn        69
; 127              Menu               6A

InkeyTranPC
        IKT     &6A, &69, &68, &5B, &49, &48, &64, &33          ; 80-87
        IKT     &09, &08, &06, &05, &03, &02, &01, &00          ; 88-8F
        IKT     &6D, &6C, &6B, &5C, &5A, &65, &35, &57          ; 90-97
        IKT     &56, &55, &54, &52, &51, &5F, &4E, &26          ; 98-9F
        IKT     &6E, &4D, &1C, &FF, &24, &25, &34, &32          ; A0-A7
        IKT     &45, &44, &53, &41, &40, &50, &3D, &FF          ; A8-AF
        IKT     &46, &36, &22, &66, &FF, &23, &47, &45          ; B0-B7
        IKT     &12, &43, &42, &2C, &3F, &4F, &3C, &5D          ; B8-BF
        IKT     &21, &20, &1F, &67, &3A, &4B, &59, &31          ; C0-C7
        IKT     &30, &2F, &2D, &16, &2A, &3E, &12, &11          ; C8-CF
        IKT     &1E, &1D, &10, &0F, &39, &38, &63, &1B          ; D0-D7
        IKT     &1A, &19, &2E, &17, &2B, &29, &28, &0D          ; D8-DF
        IKT     &0E, &0A, &0C, &0B, &37, &4A, &62, &16          ; E0-E7
        IKT     &1B, &07, &18, &04, &15, &14, &13, &27          ; E8-EF
        IKT     &FF, &FF, &FF, &6F, &72, &71, &70, &60          ; F0-F7
        IKT     &61, &58, &5E, &3B, &4C, &5E60, &3B61, &4C58    ; F8-FF

 [ Keyboard = "All"
InkeyTranPandoraW
        IKTW &06A, &069, &068, &05B, &049, &048, &064, &033             ; 80-87
        IKTW &009, &008, &006, &005, &003, &002, &001, &000             ; 88-8F
        IKTW &06D, &06C, &06B, &05C, &05A, &065, &035, &057             ; 90-97
        IKTW &056, &055, &054, &052, &051, &05F, &04E, &026             ; 98-9F
        IKTW &06E, &04D, &01C, &0FF, &024, &025, &01E, &01A             ; A0-A7
        IKTW &045, &044, &053, &041, &040, &050, &03D, &0FF             ; A8-AF
        IKTW &046, &036, &022, &066, &0FF, &023, &047, &20B             ; B0-B7
        IKTW &200, &043, &042, &02C, &03F, &04F, &03C, &05D             ; B8-BF
        IKTW &021, &020, &01F, &067, &03A, &04B, &059, &019             ; C0-C7
        IKTW &030, &02F, &02D, &016, &02A, &03E, &012, &011             ; C8-CF
        IKTW &01E, &01D, &010, &00F, &039, &038, &063, &204             ; D0-D7
        IKTW &01A, &019, &02E, &017, &02B, &029, &028, &00D             ; D8-DF
        IKTW &00E, &00A, &00C, &00B, &037, &04A, &062, &016             ; E0-E7
        IKTW &01B, &007, &018, &004, &015, &014, &013, &027             ; E8-EF
        IKTW &0FF, &0FF, &0FF, &06F, &072, &071, &070, &060             ; F0-F7
        IKTW &061, &058, &05E, &03B, &04C, &05E0060, &03B0061, &04C0058 ; F8-FF
 ]

; **************************************************************************

ShiftingKeyList
        =   ShiftingKeyListEnd-ShiftingKeyList-1
        =   KeyNo_ShiftLeft, KeyNo_ShiftRight, KeyNo_CtrlLeft, KeyNo_CtrlRight
        =   KeyNo_AltLeft, KeyNo_AltRight, KeyNo_FN
        =   KeyNo_RightMouse, KeyNo_CentreMouse, KeyNo_LeftMouse, KeyNo_Break
ShiftingKeyListEnd

ShiftingKeyListW
        DCW ((ShiftingKeyListWEnd-ShiftingKeyListW):SHR:1)-1
        DCW KeyNo_ShiftLeft, KeyNo_ShiftRight, KeyNo_CtrlLeft, KeyNo_CtrlRight
        DCW KeyNo_AltLeft, KeyNo_AltRight, KeyNo_FN
        DCW KeyNo_RightMouse, KeyNo_CentreMouse, KeyNo_LeftMouse, KeyNo_Break
ShiftingKeyListWEnd
        ALIGN

; **************************************************************************
;
; A general purpose special code list used by most UCS keyboard drivers -
; long enough for lots of keys, every one special.
;
SpecialCodeTable
        &       ProcessKShift - SpecialCodeTable
        &       ProcessKShift - SpecialCodeTable
        &       ProcessKCtrl - SpecialCodeTable
        &       ProcessKCtrl - SpecialCodeTable
        &       ProcessKAlt - SpecialCodeTable
        &       ProcessKAlt - SpecialCodeTable
        &       ProcessKFN - SpecialCodeTable
        &       ProcessKLeft - SpecialCodeTable
        &       ProcessKCentre - SpecialCodeTable
        &       ProcessKRight - SpecialCodeTable
        &       ProcessKBreak - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessK1Pad - SpecialCodeTable
        &       ProcessKScroll - SpecialCodeTable
        &       ProcessKNum - SpecialCodeTable
        &       ProcessKTab - SpecialCodeTable
        &       ProcessKCaps - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
        &       ProcessUCS - SpecialCodeTable
SpecialCodeTableEnd

; And the default keypad layout.

PadKNumTran
        =       "/*#789-456+1230.",&0D
PadKCurTran
        =       "/*#",&1E,&8F,&9F,"-",&8C,&FF,&8D,"+",&8B,&8E,&9E,&CD,&7F,&0D
        ALIGN

        END
@


4.30
log
@Correction to addressing mode in NoARMv4 case
Given the context, post indexed rather than post increment was intended.

Version 0.97. Tagged as 'IntKey-0_97'
@
text
@d441 1
d443 1
d476 1
d480 3
d1527 1
d1545 1
a1545 1

@


4.29
log
@Fix data aborts when handling dead keys
Detail:
  Source/IntKeyBody - Re-introduce the ALIGN directive that went AWOL in v0.95 of the module. Without this the first symbol in the next file (AccentTable from Source.Accents) isn't properly aligned, causing data aborts either when looking up AccentTable entries or when trying to use the results.
Admin:
  Tested on BB-xM
  Fixes issue reported on forums with dead keys causing aborts with the Netherlands keyboard layout:
  http://www.riscosopen.org/forum/forums/1/topics/1749?page=1#posts-20977


Version 0.96. Tagged as 'IntKey-0_96'
@
text
@d1157 1
a1157 1
        LDRB    R4, [R4], #1
@


4.28
log
@Add support for the new 'wide' key handler format. Add support for keyboard types which have fundamentally different layouts to PC/Arc. Add a basic (UK) layout for the Pandora.
Detail:
  Doc/FileFormat, Doc/HandlerAPI - Updated docs with information about the new key handler format, and how to invoke it in layout files.
  c/keygen, c/unicdata, h/structures - Give keygen a bit of a tidy up. Add support for the new '$Type' directive to allow the keyboard type to be specified (to ensure correct intkey table is used, unique symbol names when the same country is supported by multiple keyboard types, etc.). Add support for the new key handler format.
  Sources/IntKeyBody, Sources/IntKeyMod, Sources/KeyStruct - Tidy up the code a bit to use key handler layout and key/OS_Byte numbers from Hdr:. Add support for the new key handler format, and for the new way keygen generates the layout files.
  layout/Pandora, Makefile, Sources/IntKeyBody, Sources/IntKeyMod, Sources/KeyStruct - Add a layout file for the Pandora, and modify IntKey to use different sets of layout files depending on the keyboard type.
Admin:
  New key handler format tested on Pandora. Old format tested on Pandora & BB-xM.
  Requires HdrSrc-2_20


Version 0.95. Tagged as 'IntKey-0_95'
@
text
@d1797 1
@


4.27
log
@  Updates to comments describing the internal (OS_Byte) key numbers
Detail:
  * Corrected low-level key number for keypad-minus from &39 to &3A
  * Distinguished Return from Enter
  * Internal key number 72 (:) was incorrectly identified as the preferred
    scan code for low-level key &45 rather than 87 (;). Justification:
    (a) common sense (in all other cases it's the characters generated by the
        un-shifted key in the UK layout that's used to determine the mapping);
    (b) this agrees with the RISC OS 2 PRM (vol 2 page 479) which specifies
        which internal key code is the compatibility one. Compare that with
        the RISC OS 3 PRM which shows them graphically with no indication of
        which is the compatibility code. Unless you also have access to the
        key table for the BBC micro, it's otherwise hard to determine which
        code is which!
Admin:
  No code changes, so not tagged

Version 0.94. Not tagged
@
text
@d72 4
a75 1
        GET     Hdr:OSRSI6
a76 6
OsbyteSetCountry * &46
OsbyteSetAlphKey * &47
OsbyteFindOsbyteVars * &A6
OsbyteTABch     * &DB
OsbyteKeyBase   * &EE
OsbyteKeyOpt    * &FE
d78 1
a78 2
OsbyteReadCmos  * &A1
CmosDelByte     * &C3
d167 22
a190 116
K1Escape        * &00
K1Function1     * &01
K1Function2     * &02
K1Function3     * &03
K1Function4     * &04
K1Function5     * &05
K1Function6     * &06
K1Function7     * &07
K1Function8     * &08
K1Function9     * &09
K1Function10    * &0A
K1Function11    * &0B
K1Function12    * &0C
K1Print         * &0D
K1ScrollLock    * &0E
K1Break         * &0F
K1BackTick      * &10
K1Digit1        * &11
K1Digit2        * &12
K1Digit3        * &13
K1Digit4        * &14
K1Digit5        * &15
K1Digit6        * &16
K1Digit7        * &17
K1Digit8        * &18
K1Digit9        * &19
K1Digit0        * &1A
K1Minus         * &1B
K1Equals        * &1C
K1Pound         * &1D
K1BackSpace     * &1E
K1Insert        * &1F
K1Home          * &20
K1PageUp        * &21
K1NumLock       * &22
K1NumPadSlash   * &23
K1NumPadStar    * &24
K1NumPadHash    * &25
K1Tab           * &26
K1LetterQ       * &27
K1LetterW       * &28
K1LetterE       * &29
K1LetterR       * &2A
K1LetterT       * &2B
K1LetterY       * &2C
K1LetterU       * &2D
K1LetterI       * &2E
K1LetterO       * &2F
K1LetterP       * &30
K1OpenSquare    * &31
K1CloseSquare   * &32
K1BackSlash     * &33
K1Delete        * &34
K1Copy          * &35
K1PageDown      * &36
K1NumPad7       * &37
K1NumPad8       * &38
K1NumPad9       * &39
K1NumPadMinus   * &3A
K1CtrlLeft      * &3B
K1LetterA       * &3C
K1LetterS       * &3D
K1LetterD       * &3E
K1LetterF       * &3F
K1LetterG       * &40
K1LetterH       * &41
K1LetterJ       * &42
K1LetterK       * &43
K1LetterL       * &44
K1SemiColon     * &45
K1Tick          * &46
K1Return        * &47
K1NumPad4       * &48
K1NumPad5       * &49
K1NumPad6       * &4A
K1NumPadPlus    * &4B
K1ShiftLeft     * &4C
K1NotFittedLeft * &4D
K1LetterZ       * &4E
K1LetterX       * &4F
K1LetterC       * &50
K1LetterV       * &51
K1LetterB       * &52
K1LetterN       * &53
K1LetterM       * &54
K1Comma         * &55
K1Dot           * &56
K1Slash         * &57
K1ShiftRight    * &58
K1CursorUp      * &59
K1NumPad1       * &5A
K1NumPad2       * &5B
K1NumPad3       * &5C
K1CapsLock      * &5D
K1AltLeft       * &5E
K1Space         * &5F
K1AltRight      * &60
K1CtrlRight     * &61
K1CursorLeft    * &62
K1CursorDown    * &63
K1CursorRight   * &64
K1NumPad0       * &65
K1NumPadDot     * &66
K1NumPadEnter   * &67
K1AcornLeft     * &68
K1AcornRight    * &69
K1Menu          * &6A
K1NoConvert     * &6B
K1Convert       * &6C
K1Kana          * &6D
K1NotFittedRight * &6E
K1FN            * &6F
K1LeftMouse     * &70
K1CentreMouse   * &71
K1RightMouse    * &72

d199 7
a205 16
; Kernel-referenced entries
KVKeyTran            * &0
KVKeyTranSize        * &4
KVInkeyTran          * &8
KVShiftingList       * &C
KVSpecialList        * &10
KVSpecialCodeTable   * &14
KVInit               * &18
KVPendingAltCode     * &1C
; Private entries
KVPadNumTran         * &20 ; offset from structure to new entry for keypad numerics
KVPadCurTran         * &24 ; offset from structure to new entry for keypad non-numerics
KVFNTable            * &28
KVUCSTable0          * &2C
KVUCSTable1          * &30
KVSize               * &34 ; size of key structure header
d213 1
a213 1
NewKeyStructWP  # KVSize        ; key structure header, must be first thing
d337 1
a337 1
        MOV     r0, #OsbyteSetAlphKey
d441 1
d443 1
d453 1
a453 1
        MOV     r0, #OsbyteFindOsbyteVars
d461 1
a461 1
        MOV     r0, #OsbyteSetAlphKey
d473 4
a476 1
        ADRL    R0, KeyStructureTable
d485 12
d499 1
a499 1
        MOV     r2, #KVSize-4
d503 4
a506 3
        TEQ     r2, #KVKeyTranSize      ; is it KeyTranSize ?
        TEQNE   r3, #0                  ; or is it 0
        ADDNE   r3, r3, r1              ; if not then relative offset
a509 1

d521 1
a521 1
        MOV     r0, #OsbyteReadCmos
d568 1
a568 1
        MOV     r0, #OsbyteSetAlphKey
d809 1
a809 1
        LDRB    R3, [R3, #OsbyteTABch]          ; TAB key code
d822 1
a822 1
        LDR     R4, [R0, #KVPendingAltCode]
d881 2
a882 2
        LDREQ   R3, [R0, #KVPadNumTran]         ; num lock on
        LDRNE   R3, [R0, #KVPadCurTran]         ; num lock off
d889 1
a889 1
        LDRB    R2, [R6, #OsbyteKeyBase]        ; add on numeric key base
d893 1
a893 1
        LDRB    R2, [R6, #OsbyteKeyOpt]         ; zero => ctrl/shift modifies
d911 1
a911 1
        LDR     R3, [R0, #KVPadNumTran]
d955 7
a961 7
        =       K1NumPadSlash, &A
        =       K1NumPadStar,  &B
        =       K1NumPadHash,  &C
        =       K1NumPadMinus, &C
        =       K1NumPadPlus,  &D
        =       K1NumPadDot,   &E
        =       K1NumPadEnter, &F
d991 2
a992 2
        LDRNE   R2, [R0, #KVUCSTable0]
        LDREQ   R2, [R0, #KVUCSTable1]
d1148 3
a1150 1
        LDR     R4, [R0, #KVKeyTran]
d1152 10
a1161 1
        LDRB    R4, [R4, R2, LSL #2]    ; get the base symbol for this key
d1164 1
d1218 1
a1218 1
        LDR     R8, [R0, #KVFNTable]    ; if no FN table at all
d1223 1
d1225 4
a1228 1
        LDRB    R8, [R3], #1            ; R2 = number of FN entries
d1241 35
d1278 1
a1278 1
        LDR     R8, [R0, #KVSpecialCodeTable]
d1353 1
a1353 1
        MOV     R0, #OsbyteSetAlphKey
d1503 1
a1503 1
InkeyTran
d1521 19
d1543 4
a1546 4
        =       ShiftingKeyListEnd-ShiftingKeyList-1
        =       K1ShiftLeft, K1ShiftRight, K1CtrlLeft, K1CtrlRight
        =       K1AltLeft, K1AltRight, K1FN
        =       K1RightMouse, K1CentreMouse, K1LeftMouse, K1Break
d1548 7
a1796 1
        ALIGN
@


4.26
log
@Updated to use central headers for allocated keyboards.
Removed 'Ursula' switch, since the magic service call table works prior to that anyway.
Requires HdrSrc-1_95.

Version 0.94. Tagged as 'IntKey-0_94'
@
text
@d1472 1
a1472 1
; 59               Keypad -           39
d1485 2
a1486 2
; 72               :                  45
; 73               Enter              47
d1500 1
a1500 1
; 87               ;                  45 (BBC compatibility - see 72)
@


4.25
log
@Update to work with zero page relocation
Detail:
  Source/IntKeyBody - Try using OS_ReadSysInfo 6 to get the location of the OS_Byte variables before falling back on OS_Byte &A6
Admin:
  Tested on rev A2 BB-xM


Version 0.92. Tagged as 'IntKey-0_92'
@
text
@a62 3
        GBLL    Ursula          ; add Ursula service call table
Ursula  SETL    {TRUE}

d67 1
d69 2
a142 20
Alphabet_Latin1 * 101
Alphabet_Latin2 * 102
Alphabet_Latin3 * 103
Alphabet_Latin4 * 104
Alphabet_Cyrillic * 105
Alphabet_Arabic * 106
Alphabet_Greek  * 107
Alphabet_Hebrew * 108
Alphabet_Latin5 * 109
Alphabet_Welsh  * 110
Alphabet_UTF8   * 111
Alphabet_Latin9 * 112
Alphabet_Latin6 * 113

Keyboard_A500   * 0
Keyboard_A1     * 1
Keyboard_Perth  * 2
Keyboard_RCMM   * 3
Keyboard_None   * &FF

d390 1
a390 1
        DCD     A1Key_HC_Table-Module_BaseAddr
d416 1
a416 1
        DCD     1       ; 32-bit compatible
a420 1
A1Key_HC_Table * Module_BaseAddr
a487 1
 [ Ursula
d489 2
d493 3
a495 3
        DCD     Service_Reset         ; &27
        DCD     Service_International ; &43
        DCD     Service_KeyHandler    ; &44
a499 3
 |
A1Key_Service ROUT
 ]
a503 1
 [ Ursula
a504 2
 ]

d544 4
a547 4
        TEQ     r0, #Keyboard_A1
        TEQNE   r0, #Keyboard_Perth
        TEQNE   r0, #Keyboard_RCMM
        TEQNE   r0, #Keyboard_None
d673 1
a673 1
        TEQ     r3, #Alphabet_UTF8
d797 1
a797 1
        TEQ     R3, #Alphabet_UTF8
d1154 1
a1154 1
        TEQ     R3, #Alphabet_UTF8
@


4.24
log
@Turned off PC Delete option.
Added some 2- or 3-year old files that were sitting on Kevin's hard disc.

Version 0.88. Tagged as 'IntKey-0_88'
@
text
@d72 1
d576 8
d588 3
a590 2
        ORR     r1, r1, r2, LSL #8
        STR     r1, OsbyteVars          ; set up osbyte vars address
@


4.23
log
@First pass at a Taiwanese (Zhuyin) layout.

Version 0.86. Tagged as 'IntKey-0_86'
@
text
@d61 1
a61 1
PCDel   SETL    {TRUE}
@


4.22
log
@Added Korean layout. If you don't have a real Korean keyboard, Alt+Num-Lock
acts as Hangul Lock, and Alt+Space (in the Hangul layer) acts as convert.

Version 0.82. Tagged as 'IntKey-0_82'
@
text
@a125 1

d127 1
@


4.21
log
@  Some bugfixes for keygen and keyconvert, discovered by gcc.
  Temporary GNUmakefile added containing UNIX build system.
Detail:
  gcc complained about returning the address of a local variable as
    a function result in both keygen and keyconvert.  The two variables
    concerned have now been made static like they should have been.
    Unlikely to have caused much aggravation, but only through luck.
  The Keyboard data structure has been updated to explicitly use an
    unsigned char in some places.  This is necessary for systems on
    which char is signed by default.
  The GNUmakefile is a temporary addition until native tool support can
    be sorted out.  In the xriscos environment, do "make links" and
    then "make rom" to build the module.  "make clean" will remove all
    the built stuff and the symbolic links.  Requires access to the
    exported Unicode library files.  keyconvert is built, but will not
    work for the obvious reason that it calls SWIs.
Admin:
  GNUmakefile will be removed at a later date - it's only temporary.
  Tested - builds the same module (for Keyboard=All, Machine=Phoebe)
    byte-identically.


Version 0.80. Tagged as 'IntKey-0_80'
@
text
@d127 2
@


4.20
log
@
  * South African keyboard layout added.

Detail:

  * South Africa utilises a standard USA layout.  IntKey now recognises
    this, and supports "*Keyboard SAfrica".

  * New layout DrawFile created that describes the South African layout.

  * StripDepnd support added to makefile.

Admin:

  * Assembled and tested on RPC.

Version 0.77. Tagged as 'IntKey-0_77'
@
text
@d66 6
a71 6
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:Proc
@


4.19
log
@
  * Fixed problems with keys generating lower-case characters when
    Caps Lock is active.

Detail:

  * Faults were found in the Spanish and Welsh layouts.  In particular,
    'Q' on a Spanish layout would generate a lower-case version when
    Caps Lock was active.  And Welsh layouts had a similar fault with
    'Alt' + 'O'.  Now corrected.

Admin:

  * Fault noted in Bethany software.

  * Built and tested on a Risc PC.

Version 0.76. Tagged as 'IntKey-0_76'
@
text
@d57 1
d125 1
d877 1
d879 1
@


4.18
log
@  Fix to hexadecimal character entry.

Detail:
  If an alphabetic key was a "simple" key (eg E on the UK layout), then it
  wouldn't work as a hex digit during hexadecimal keypad entry. This bug has
  been in since the start of hexadecimal entry, but only came to light when
  the Euro sign moved away from Alt+E.

Version 0.74. Tagged as 'IntKey-0_74'
@
text
@d121 3
a123 1
Country_Wales2   * 49
@


4.17
log
@32-bit compatible.
FN key change broke hexadecimal keypad entry - now fixed.

Version 0.71. Tagged as 'IntKey-0_71'
@
text
@a56 2
; 28-Apr-00  FN key broke hexadecimal keypad entry - now fixed.
;            32-bit compatible.
d1096 1
a1096 1
        BNE     CheckHexAtoF
d1245 11
a1255 1
CheckHexAtoF
d1261 2
a1262 2
        LDRB    R4, R0HexDigits         ; are we doing hex?
        TEQ     R4, #0
a1263 1
        LDR     R4, [R2, #0]            ; get the base symbol for this key
d1345 3
@


4.16
log
@"FN" key support added by K. Bracey. 3rd party keyboard mappings
defined and included by S. Forrest.

Both changes made for the Lazarus project in order to support the third
party handset.

Tested on a Risc PC against V0.02 of the RCMM Driver.

Version 0.65. Tagged as 'IntKey-0_65'
@
text
@d57 2
d377 1
a377 3
; Corrupts R2 - this relies not only EVERY non-modifier handler not
; using R2, as if we end up calling a different handler, R2 will
; be corrupted.
d379 1
a379 1
	GBLA	HandleFNsize
d383 7
a389 5
01      LDRB    R2, FNDown              ; is FN down?
        TEQ     R2, #0                  ; if not, process as normal
        Push    "R14", NE
        BLNE    FindFN
        Pull    "R14", NE
d406 8
d429 5
d521 1
a521 1
        MOVNES  pc, lr
d535 1
a535 1
        EXITS
d542 1
a542 1
        EXITS
d558 2
a559 3
        MOV     r0, lr
        ORR     r1, r0, #SVC_mode       ; switch into SVC mode so we can issue SWIs
        TEQP    r1, #0
d599 1
a599 2
        TEQP    pc, #SVC_mode + I_bit   ; disable IRQs round this bit
        NOP                             ; needed to get objasm to assemble cleanly
d633 1
a633 1
        TEQP    r0, #0                  ; return to original mode and IRQ state
d637 1
a637 1
        EXITS
d650 1
a650 1
        TEQP    r0, #0                  ; return to original mode and IRQ state
d652 1
a652 1
        EXITS
d665 2
a666 3
        MOV     r0, lr          ; switch into SVC mode so we can issue SWIs
        ORR     r1, r0, #SVC_mode
        TEQP    r1, #0
d679 1
a679 1
        TEQP    r0, #0                  ; return to original mode and IRQ state
d681 1
a681 1
        EXITS
d875 1
d1290 1
a1290 1
; preserving flags to carry on as normal, can pull PC from the stack
d1294 1
a1294 1
; Note that as in the HandleFN macro we're merrily scrambling R2.
d1297 3
a1299 3
        LDR     R2, [R0, #KVFNTable]    ; if no FN table at all
        TEQ     R2, #0
        MOVEQS  PC,R14
d1302 3
a1304 3
        ADD     R3, R0, R2
        LDRB    R2, [R3], #1            ; R2 = number of FN entries
        TEQ     R2, #0
d1311 1
a1311 1
        SUBS    R2, R2, #1
d1318 3
a1320 3
        LDR     R2, [R0, #KVSpecialCodeTable]
        ADD     R2, R2, R0              ; R2 -> special code table
        SUB     R1, R2, #4              ; 0th entry is for 1st special
d1322 2
a1323 2
        ADD     R2, R1, R2              ; R2 = address of code
	ADD	R2, R2, #HandleFNsize   ; Skip past the FN handling code :)
d1325 1
a1325 1
        MOV     PC, R2
d1373 2
a1374 4
        MOV     R3, PC
        AND     R3, R3, #3
        EOR     R3, R3, #SVC_mode
        TEQP    R3, PC                          ; select SVC mode
d1382 1
a1382 1
        TEQP    R3, PC                          ; reenter previous mode
@


4.15
log
@Intermediate check-in
@
text
@d379 2
d383 1
a383 1
        LDRB    R2, FNDown              ; is FN down?
d388 1
d1291 1
a1291 1
        CMP     R2, #0
d1310 1
d1560 1
a1560 1
; long enough for 128 keys, every one special.
d1595 97
@


4.14
log
@Added capability to use Left Alt + Shift to change layers.
Created new PC-compatible two-layer Russian layout.

Version 0.59. Tagged as 'IntKey-0_59'
@
text
@d56 1
d153 1
d297 1
d322 4
a325 3
KVUCSTable0          * &28
KVUCSTable1          * &2C
KVSize               * &30 ; size of key structure header
d365 1
d374 14
d550 1
d589 2
a590 1
        TEQ     r2, #&04                ; is it KeyTranSize ?
d702 1
d740 4
d876 2
d890 2
d911 2
d921 2
d928 2
d935 2
d942 2
d953 1
d957 1
d1066 1
a1066 1
; Out: R0-R4 preserved
d1072 2
d1255 10
a1264 10
        B       ProcessKScroll
        B       ProcessKNum
        B       ProcessKTab
        B       ProcessKCaps
        B       ProcessKKana
        B       ProcessKShiftCaps
        B       ProcessKDefaultKeyboard
        B       ProcessKConfiguredKeyboard
        B       ProcessKDialKeyboard
        B       ProcessKDelete
d1273 37
d1345 1
a1345 1
ProcessKDialKeyboard
d1350 1
a1350 1
ProcessKConfiguredKeyboard ROUT
d1353 1
a1353 1
ProcessKDefaultKeyboard
d1408 1
a1408 1
; 12               (not defined)
d1540 1
a1540 1
        IKT     &FF, &FF, &FF, &FF, &72, &71, &70, &60          ; F0-F7
d1548 1
a1548 1
        =       K1AltLeft, K1AltRight
d1565 1
@


4.13
log
@Null keypad keys (eg 5 with Num Lock off) would return random strings.

Version 0.53. Tagged as 'IntKey-0_53'
@
text
@d360 1
d680 1
d694 7
d736 7
d1220 1
a1220 1
	B	ProcessKDelete
@


4.12
log
@Norweigan keyboard layout fixed (REVERSE SOLIDUS was totally missing).
Changed to use srccommit.

Version 0.52. Tagged as 'IntKey-0_52'
@
text
@a899 3
        LDR     R3, [R0, #KVPadNumTran]
        ADD     R3, R3, R0
;        ADRL    R3, PadK1NumTran-(SpecialList1Pad-SpecialList1) ; on
a905 4
        LDR     R6, R0OsbyteVars
        LDR     R2, [R0, #KVPadCurTran]
        ADD     R2, R2, R0
;        ADRL    R2, PadK1CurTran-(SpecialList1Pad-SpecialList1) ; off
d907 3
a909 1
        MOVNE   R3, R2                          ; numlock off -> use R2
d914 1
d937 1
d939 1
@


4.11
log
@Merged in 10-Sep-98 and 24-Sep-98 changes from Ursula branch:
* Updated/added layout drawfiles (Esperanto file further updated from Ursula
  branch version, to indicate characters available when alphabet is changed)
* Added dialling codes for Wales, Wales2, DvorakUK and DvorakUSA
* !IKHG.Source.Chars updated to use quoted characters
* Layout fixes applied to Belgium, Denmark, France, Germany, Greece, Israel,
  LatinAm, Russia, Switzerland and Turkey
* Ctrl-Alt-F1/F2 keyboard selection is performed on a callback

Prototype added to h.unicdata to allow keyconvert to compile.

Dynamic dependencies removed from Makefile; keyconvert removed during clean.

Delete key made special in Japan layout, to enable delete-type code.
@
text
@d386 4
a389 1
        =       "Int'l Keyboard", 9, "0.51 (28 Sep 1998)"
@


4.10
log
@Added Japan and Iceland to build.
Added hexadecimal keypad code entry.
Changed dead key tilde+space to U+007E, not U+02DC (Denmark needs this).
Added dead key stroke (only Turkey uses this).
@
text
@d50 6
d386 1
a386 1
        =       "Int'l Keyboard", 9, "0.50 (02 Sep 1998)"
d812 1
d814 4
d858 1
a858 1
        ADD     PC, R0, R4                      ; call PendingAltCode, as the Kernel wolud
d863 1
a863 1
        LDRB    R1, R0DeleteChar
d1265 2
a1266 2
        MOV     R0, #OsbyteSetAlphKey
        SWI     XOS_Byte
d1274 7
@


4.9
log
@Ursula branch merged.

Complete new keyboard definition system in terms of the UCS. See
Docs.FileFormat for information.
@
text
@d46 4
a330 1
 [ PCDel
d332 1
a332 2
unused          # 3
 ]
a343 1
 [ PCDel
d345 1
a345 2
R0unused        # 3
 ]
d380 1
a380 1
        =       "Int'l Keyboard", 9, "0.50 (01 Sep 1998)"
d723 1
d927 3
d933 1
a933 1
        BICCS   R7, R7, #(KBAlt_DigitsPresent :OR: KBAlt_SelectKeyboard)
d935 4
a938 4
        ORRCC   R7, R7, #KBAlt_DigitsPresent    ; else indicate we have digits
        MOVCS   R2, #0                          ; if no digits
        STRCS   R2, R0AltDigitValue             ; then zero digits
        MOVCS   PC, R14                         ; and exit
d942 3
a944 1
        MLA     R3, R2, R1, R3                  ; digits = digits*10+new digit
d948 31
d1009 3
d1022 1
a1022 1
        TST     R5, #KBStat_NoCapsLock
d1040 1
a1040 1
        TST     R1, #&80000000
d1158 18
@


4.8
log
@Updated the layouts for Sweden, Finland, Denmark and Norway to remove the
inconsistencies between the software layout and the actual keyboard layout.

Ran all layouts through !IKHG to generate new source files containing the new
106 key tables (support for Windows '95 keyboards).
@
text
@d42 4
d48 6
a60 7
        GET     !IKHG.Source.Chars.Latin1

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

d67 5
d110 1
a123 2
Country_DvorakLH  * 78
Country_DvorakRH  * 79
a124 1
Alphabet_Bfont  * 100
d134 4
a137 2

Alphabet_Cyrillic2 * 120
a143 9
        GBLL    BleedinDaveBell
BleedinDaveBell SETL    {TRUE}

        [ BleedinDaveBell
Alphabet_Default * Alphabet_Latin1
        |
Alphabet_Default * Alphabet_Bfont
        ]

a171 21
        MACRO
        BodgeKeyHandler $cond
        MEND

        MACRO
$label  DoTopBit        $No
$label  ROUT
        ADRL    R3, TopBitSetTable$No-((K$No.TopBitSet-SpecialList$No):SHL:4)
        B       DoTopBitCommon
        MEND

        MACRO
        DoAccent $No, $AName
PendingAltCode$No
        ADR     R6, KeyReturn
        STRB    R3, [R6, #1]
PendingAltSpecial$No
        ADRL    R4, AccentTable_$AName
        B       PendingAltSpecialCommon
        MEND

d251 1
a251 1
K1NotFitted     * &4D
d278 7
d297 17
a313 4
KVPendingAltSpecial  * &20 ; offset from structure to new entry
KVPadNumTran         * &24 ; offset from structure to new entry for keypad numerics
KVPadCurTran         * &28 ; offset from structure to new entry for keypad non-numerics
KVSize               * &2C ; size of key structure header
a321 1
CurrentKeyAlphabet # 4  ; alphabet for current keyboard
d324 7
a336 1
R0CurrentKeyAlphabet # 4
d339 7
d355 1
d359 2
d380 1
a380 3
        =       "Int'l Keyboard"
        =       TAB
        =       "0.41 (07 Aug 1998)"
d457 12
d470 1
d475 3
d536 6
a541 8
        Push    R1
        MOV     r3, r1
        MOV     r1, #Service_International
        MOV     r2, #Inter_CNoToANo
        MOV     r4, #Alphabet_Default
        SWI     XOS_ServiceCall
        STR     r4, CurrentKeyAlphabet  ; alphabet associated with this kb
        Pull    R1
d553 1
d555 1
a556 1
        MOV     r2, #KVSize-4
d574 11
a586 1
        NOP
d609 43
d678 1
d733 1
a733 1
        LDR     R0, R0AltDigitValue     ; load digits
d735 19
a753 3
        ADREQ   R6, KeyNULReturn        ; no, then return NUL char
        STREQB  R0, [R6, #2]
        BEQ     %FT05
d755 2
a756 1
        ADR     R1, IDDTable
d758 1
a758 1
        LDMIA   R1!, {R2, R3}           ; load IDD number, country number
d761 1
a761 1
        TEQ     R2, R0                  ; found match ?
d793 1
a793 1
        &	 90, Country_Turkey
d799 6
a804 6
        &	 61, Country_Australia
        &	 43, Country_Austria
        &	 32, Country_Belgium
        &	 81, Country_Japan
        &	 31, Country_Netherlands
        &	 41, Country_Switzerland
d831 3
a833 3
        LDR     R1, R0OsbyteVars
        LDRB    R1, [R1, #OsbyteTABch]          ; TAB key code
        TST     R1, #&80                        ; top bit set ?
d836 1
a836 1
        EORNE   R1, R1, #&10                    ; modify for shift
d838 1
a838 1
        EORNE   R1, R1, #&20                    ; modify for ctrl
a839 3
        ADR     R6, KeyReturn                   ; pass pointer back to MOS
        STRB    R1, [R6, #1]                    ; having poked byte in
ReturnCharAlt
d842 14
a855 3
        MOVEQ   PC, R14                         ; then return this
        LDR     R1, [R0, #KVPendingAltSpecial]  ; else call the special entry
        ADD     PC, R0, R1
d867 14
d894 1
a894 1
        LDR     R1, R0OsbyteVars
d900 2
a901 2
        LDRB    R0, [R3, R4]                    ; get table entry
        TEQ     R0, #&FF                        ; dummy key ?
d904 3
a906 3
        LDRB    R2, [R1, #OsbyteKeyBase]        ; add on numeric key base
        SUB     R0, R0, #"0"
        ADD     R0, R0, R2
d908 1
a908 1
        LDRB    R2, [R1, #OsbyteKeyOpt]         ; zero => ctrl/shift modifies
d912 1
a912 1
        TST     R0, #&80                        ; top bit set ?
d916 1
a916 1
        EORNE   R0, R0, #&10                    ; modify for shift
d918 1
a918 1
        EORNE   R0, R0, #&20                    ; modify for ctrl
d922 1
a922 1
        STRB    R0, [R6, #1]                    ; having poked byte in
a941 5
ReturnNULCharAlt
        ADR     R6, KeyNULReturn                ; store char
        STRB    R1, [R6, #2]
        B       ReturnCharAlt

d944 1
a944 1
        STRB    R0, [R6, #2]
d947 28
a974 1
DoTopBitCommon ROUT
d976 1
a976 1
        ADDNE   R3, R3, #2
d978 1
a978 1
        ADDNE   R3, R3, #4
d980 11
a990 9
        ADDNE   R3, R3, #8
        LDRB    R1, [R3, R4, LSL #4]!
        LDRB    R6, [R3, #1]

; 0 => non-alpha, 1 => alpha, 2 => dead accent, 3 => nowt

        MOVS    R6, R6, LSL #31         ; put bit 1 into C, bit 0 into N
        BCS     %FT20
        BPL     ReturnOneOrNULAlt       ; not alpha, so skip
d993 99
a1091 9
        EORNE   R3, R3, #2
        TSTEQ   R5, #KBStat_NoCapsLock
        ORREQ   R3, R3, #2
        LDRB    R1, [R3]
ReturnOneOrNULAlt
        CMP     R1, #0                  ; if zero (C=1 if equal)
        CMPNE   R1, #&80                ; or if >= &80
        BCS     ReturnNULCharAlt        ; then return NUL char
        B       ReturnOneCharAlt
d1093 22
a1114 1
; come here for dead accent (N=0) or for nowt (N=1)
d1116 25
a1140 5
20
        ADR     R6, NowtReturn          ; point to zero length list
        BICPL   R7, R7, #KBAlt_AccentMask ; if accent, then clear accents
        ORRPL   R7, R7, R1              ; put in new accent
        ORRPL   R5, R5, #KBStat_PendingAlt ; and indicate it
a1144 2
;       PendingAltCode1 - Process Alt+Char or Accent+Char
;
d1146 1
d1148 1
a1148 2
;       R3 = character which would be returned if not an ALT, if not special
;       R4 -> accent table for this keyboard's alphabet
d1150 1
a1150 1
;       R6 -> list that would be returned if not an ALT
a1151 3
;
; out:  R6 -> returned key list
;
d1153 1
a1153 1
PendingAltSpecialCommon ROUT
d1155 2
a1156 1
        BEQ     AlternateChar           ; no, then must be Alt down
d1160 6
a1165 3
        AND     R2, R7, #KBAlt_AccentMask ; get just the accent
        LDR     R2, [R4, R2, LSL #2]    ; offset to appropriate accent
        ADD     R4, R4, R2              ; R4 now points to accent list
d1170 1
a1170 8
        LDRB    R2, [R6]                ; load length of current returned list
        LDRB    R2, [R6, R2]            ; R2 = unaccented character
10
        LDRB    R3, [R4], #2            ; R3 = source char
        TEQ     R3, #0                  ; zero => end of list
        MOVEQ   PC, R14                 ; so return char unmodified
        TEQ     R3, R2                  ; if not the char we want
        BNE     %BT10                   ; then loop
a1171 1
        LDRB    R0, [R4, #-1]           ; else load translated char
d1173 2
a1174 2
        CMP     R0, #0                  ; if 0 then return 0 0 (C=1)
        CMPNE   R0, #&80                ; elif -ve return 0 char
d1178 4
d1183 1
a1183 21
AlternateChar ROUT
        MOV     R2, R2, LSL #2                  ; multiply index by 4

        TST     R5, #KBStat_CtrlEngaged
        ADDNE   R2, R2, #2

        TST     R5, #KBStat_ShiftEngaged
        ADDNE   R2, R2, #1

        TEQ     R2, #(K1Function1 :SHL: 2) +2   ; is it CTRL-ALT-F1 ?
        BEQ     SelectUKKeyboard                ; then select UK keyboard
        TEQ     R2, #(K1Function2 :SHL: 2) +2   ; is it CTRL-ALT-F2 ?
        BEQ     SelectConfiguredKeyboard        ; then select configured kb
        TEQ     R2, #(K1Function12 :SHL: 2) +2  ; is it CTRL-ALT-F12
        ORREQ   R7, R7, #KBAlt_SelectKeyboard   ; then set IDD selection flag

        B       ReturnNowt                      ; if not one of these
                                                ; then return nowt, since all
                                                ; real ALTs are special

SelectConfiguredKeyboard ROUT
d1186 1
a1186 1
SelectUKKeyboard
a1205 2
        OutputAccentTable_Latin1

d1211 140
d1377 144
@


4.7
log
@Added the files needed for building a keyboard driver for Finland.  Although
the layout for Finland is identical to that of Sweden, this addition has been
made for the sake of completeness.  It also allows a version of the module to
be built using "Finland" as the keyboard setting in the build environment.

The version number of the module has also been incremented to V0.40 to
flag the addition to the source code.
@
text
@d369 1
a369 1
        =       "0.40 (15 Jul 1998)"
@


4.6
log
@Updated version number
@
text
@d369 1
a369 1
        =       "0.39 (14 Jul 1998)"
@


4.5
log
@Added new codes for Win95 and Japanese keyboard to InkeyTran
@
text
@d369 1
a369 1
        =       "0.37 (15 Jan 1996)"
@


4.4
log
@Tidied up some of the foreign layouts.
Swapped middot and bullet in UK layouts.
Made Ctrl+Alt do Ctrl as per QWERTY keytops in UK and USA Dvorak layouts
(not one-handed ones).
@
text
@d965 1
a965 1
        IKT     &FF, &FF, &FF, &5B, &49, &48, &64, &33          ; 80-87
d967 1
a967 1
        IKT     &FF, &FF, &FF, &5C, &5A, &65, &35, &57          ; 90-97
d969 1
a969 1
        IKT     &FF, &4D, &1C, &FF, &24, &25, &34, &32          ; A0-A7
@


4.3
log
@Rationalised structure - now builds a module containing either one
keyboard (+UK) or all keyboards, dependent on setting of <Keyboard>.

Added several new keyboards and improved existing ones.

Modernised !IKHG. In particular allowed editing of keypad, movement of Enter
backspace and shift, and allowed Caps Lock to work on characters obtained
using Alt.
@
text
@a144 3
        GBLL    NewKeyStructureTable
NewKeyStructureTable    SETL    {TRUE}

a517 1
      [ NewKeyStructureTable
a525 9
      |
        CMP     R1, #(KeyStructureTableEnd-KeyStructureTable) :SHR: 2
                                        ; if out of range
        MOVCS   R1, #0                  ; then use default

        ADRL    R0, KeyStructureTable
        LDR     R1, [R0, R1, LSL #2]    ; load offset to correct structure
        ADD     R0, R0, R1              ; R0 -> appropriate structure
      ]
a990 59


; Now the code to handle it

ProcessK1BackTick ROUT
        TST     R5, #KBStat_CtrlEngaged         ; if ctrl down then
        BNE     ReturnNowt                      ; return nothing
        TST     R7, #KBAlt_AltDown              ; if alt down
        BNE     %FT10                           ; then do other things
        TST     R5, #KBStat_ShiftEngaged        ; if shift down
        MOVNE   R1, #"~"                        ; then ~
        BNE     ReturnOneCharAlt
        Push    R14
        BL      TestForBfont                    ; else check for Bfont
        Pull    R14
        MOVEQ   R1, #&BB                        ; BFont back tick
        MOVNE   R1, #&60                        ; anything else back tick
        B       ReturnOneOrNULAlt
10
        TST     R5, #KBStat_ShiftEngaged        ; if shift down
        MOVNE   R1, #&B0                        ; then 
        MOVEQ   R1, #&AC                        ; else 
        B       ReturnNULCharAlt

ProcessK1Pound ROUT
        TST     R7, #KBAlt_AltDown              ; if alt down or
        TSTEQ   R5, #KBStat_CtrlEngaged         ; ctrl down then
        BNE     ReturnNowt                      ; return nothing
        Push    R14
        BL      TestForBfont
        Pull    R14
        BNE     %FT10
        TST     R5, #KBStat_ShiftEngaged
        MOVEQ   R1, #&60                        ; Bfont pound
        MOVNE   R1, #&9E                        ; Bfont currency
        B       ReturnNULCharAlt
10
        TST     R5, #KBStat_ShiftEngaged
        MOVEQ   R1, #&A3                        ; anything else 'pound'
        MOVNE   R1, #&A4                        ; anything else currency
        B       ReturnNULCharAlt


; **************************************************************************
;
;       TestForBfont - Check if keyboard corresponds to a Bfont font
;
; in:   IRQ mode
;       R0 -> key structure (= module workspace)
;
; out:  Z => Bfont, NZ => anything else
;

TestForBfont ROUT
        Push    R14
        LDR     R14, R0CurrentKeyAlphabet
        TEQ     R14, #Alphabet_Bfont
        Pull    PC

@


4.2
log
@Version Spin_merge taken
@
text
@a52 2
        LEADR   Module_LoadAddr

d91 9
d113 5
d354 2
d372 5
a376 1
        =       "0.37 (15 Jan 1996)", 0
d388 1
a388 1
A1Key_Init ENTRY
d419 1
a419 1
A1Key_Die ENTRY
d455 1
a455 1
        ENTRY   "r1"
d485 1
a485 1
SetUpKeyStructureAndHandlerIfUs ENTRY "r0,r1"
d696 5
a700 6
        &       044, Country_UK
        &       001, Country_USA
        &       039, Country_Italy
        &       034, Country_Spain
        &       033, Country_France
        &       049, Country_Germany
d703 2
a704 2
        &       030, Country_Greece
        &       046, Country_Sweden
d706 2
a707 2
        &       045, Country_Denmark
        &       047, Country_Norway
d709 2
a710 1
        &       000, Country_Ireland
d712 1
a712 1
        &       007, Country_Russia
d714 8
a721 1
        &       052, Country_Mexico
d957 1
a957 1
        MOVNV   R0, R0                          ; wait for it to happen
d965 1
a965 1
        MOVNV   R0, R0                          ; wait for it to happen
@


4.2.2.1
log
@Added Ursula service call table.

Added PC-type delete support in shared source and UK keyboard driver. Note that
the other keyboard drivers will not currently support the option, nor has !IKHG
been modified to produce suitable files.
@
text
@a41 2
; 30-Jun-98  BJGA Added PC-style delete capabilities and Ursula service call table.
; 02-Jul-98  BJGA Now uses allocated CMOS bit.
a43 6
	GBLL	PCDel		; option to have Delete key return &8B (Copy) instead
PCDel	SETL	{TRUE}

	GBLL	Ursula		; add Ursula service call table
Ursula	SETL	{TRUE}

a65 5
 [ PCDel
OsbyteReadCmos  * &A1
CmosDelByte     * &C3
CmosDelBit      * 1
 ]
a317 4
 [ PCDel
DeleteChar	# 1
	ALIGN
 ]
a326 4
 [ PCDel
R0DeleteChar	# 1
	ALIGN
 ]
d358 1
a358 1
        =       "0.38 (02 Jul 1998)", 0
a430 9
 [ Ursula
ServiceTable
        DCD     0 ; flags
        DCD     Service2 - Module_BaseAddr
        DCD     Service_Reset         ; &27
        DCD     Service_International ; &43
        DCD     Service_KeyHandler    ; &44
        DCD     0 ; terminator
        DCD     ServiceTable - Module_BaseAddr
a431 4
        MOV     R0, R0
 |
A1Key_Service ROUT
 ]
d436 1
a436 3
 [ Ursula
Service2
 ]
a542 11
 [ PCDel
; scan CMOS to determine delete type
        MOV     r0, #OsbyteReadCmos
        MOV     r1, #CmosDelByte
        SWI     XOS_Byte
        TST     r2, #1 :SHL: CmosDelBit
        MOVEQ   r0, #&7F
        MOVNE   r0, #&8B
        STRB    r0, DeleteChar
 ]

a738 6

 [ PCDel
ProcessKDelete ROUT
        LDRB    R1, R0DeleteChar
        B       ReturnOneCharAlt
 ]
@


4.2.2.2
log
@Changed build structure and updated to InternationalKeyboard 0.41 / !IKHG 3.01
from trunk, thereby acquiring Windows 95 and Japanese key support, and made
further changes, viz:

Fixed lastreadkey bug in !IKHG, added NOP so Int'l Keyboard assembles cleanly.
Added Welsh alphabet and Wales2 country support.
Switched Wales into and Russia2 out of build.
In UK layout, moved bullet from Alt-Shift-8 to Alt-Shift-\.
In Wales layout, added Alt-T = TM, Alt-Shift-Z = single left angle-quote,
  and Alt-Shift-X = single right angle-quote.
Fixed !IKHG to call key D16 "End" instead of "Cpy".
Merged PC-delete code and Ursula service call table back in from Ursula branch.
Added PC-delete compatibility to !IKHG.
Added Alt-E shortcut for Euro symbol as follows:
  * No further action was required:
      Italy, Norway, Esperanto
  * oe/OE moved to Q:
      UK, Spain, France, Sweden, Finland, Denmark, Canada, Belgium,
      Netherlands, Switzerland, USA
  * oe/OE moved to W:
      Germany, Iceland, LatinAm, Turkey
  * oe/OE moved to U:
      DvorakUK, DvorakUSA
  * e circumflex replaced with Euro:
      Wales, Wales2
DvorakLH and DvorakRH have not had a Euro shortcut added; Greece, Israel,
Russia and Russia2 don't have a Euro in their alphabets.
Comments on the above arrangements are welcome.

Reprocessed all handlers to encompass changes (including !IKHG.Layouts files).
@
text
@d42 2
a43 1
; 10-Aug-98  BJGA Added PC-style delete capability and Ursula service call table.
d61 2
a105 9
Country_LatinAm * 28
Country_Australia * 29
Country_Austria * 30
Country_Belgium * 31
Country_Japan   * 32
Country_MiddleEast * 33
Country_Netherlands * 34
Country_Switzerland * 35
Country_Wales   * 36
a107 1
Country_Wales2   * 49
a118 5
Country_DvorakUK  * 70
Country_DvorakUSA * 71
Country_DvorakLH  * 78
Country_DvorakRH  * 79

d146 3
d333 1
a333 1
unused          # 3
d346 1
a346 1
R0unused        # 3
a362 2
        AREA    |!!!Module|,CODE,READONLY

d379 1
a379 5
        =       "0.42 (10 Aug 1998)"
 [ Keyboard <> "All"
        =       " $Keyboard"
 ]
        =       0
d391 1
a391 1
A1Key_Init Entry
d422 1
a422 1
A1Key_Die Entry
d473 1
a473 2

        Entry   "r1"
d503 1
a503 1
SetUpKeyStructureAndHandlerIfUs Entry "r0,r1"
d539 1
d548 9
a558 1
        NOP                             ; needed to get objasm to assemble cleanly
d725 6
a730 5
        &        44, Country_UK
        &        39, Country_Italy
        &        34, Country_Spain
        &        33, Country_France
        &        49, Country_Germany
d733 2
a734 2
        &        30, Country_Greece
        &        46, Country_Sweden
d736 2
a737 2
        &        45, Country_Denmark
        &        47, Country_Norway
d739 1
a739 2
        &	 90, Country_Turkey
        &       353, Country_Ireland
d741 1
a741 1
        &         7, Country_Russia
d743 1
a743 8
        &        52, Country_Mexico
        &	 61, Country_Australia
        &	 43, Country_Austria
        &	 32, Country_Belgium
        &	 81, Country_Japan
        &	 31, Country_Netherlands
        &	 41, Country_Switzerland
        &         1, Country_USA
d787 1
a788 1
 [ PCDel
d790 1
a790 2
 |
        MOV     R1, #&7F
a791 1
        B       ReturnOneCharAlt
d985 1
a985 1
        NOP                                     ; wait for it to happen
d993 1
a993 1
        NOP                                     ; wait for it to happen
d1006 1
a1006 1
        IKT     &6A, &69, &68, &5B, &49, &48, &64, &33          ; 80-87
d1008 1
a1008 1
        IKT     &6D, &6C, &6B, &5C, &5A, &65, &35, &57          ; 90-97
d1010 1
a1010 1
        IKT     &6E, &4D, &1C, &FF, &24, &25, &34, &32          ; A0-A7
d1032 59
@


4.2.2.3
log
@Bugfixes to increase consistency across handlers:

Belgium: added fi, fl, thorn, bullet, TM, SHY, Minus
DvorakUK: bullet moved to Alt-*
DvorakUSA: bullet moved to Alt-*
France: added TM, Yen, O slash; removed redundant sterling, currency and
  section duplicates; added bullet
Germany: added bullet, Minus, single guillemots (Ctrl-Alt), Euro (oops!)
Italy: added OE, TM, single guillemots, sexed quotes, Minus
LatinAm: replaced Alt-3 with sterling; added bullet
Netherlands: added fi, fl, eth, bullet, SHY, Minus; Alt-S is now German
  double s instead of section
Norway: added OE, TM
Spain: moved bullet to Alt-*
Switzerland: added fi, fl, TM; German double s available without Shift;
  added single guillemots (Ctrl-Alt)
Turkey: added TM, sexed quotes, single guillemots, bullet, perthousand
UK: moved bullet to Alt-*
USA: added masculine/feminine ordinals; added bullet at Alt-*
Wales: swapped " and @@; added OE, Minus, em- and en-dash; replaced E circumflex
  on Alt-E; added AE, Euro, fi, fl, O slash, Yen on Ctrl-Alt-A/E/I/L/O/Y

Also switched out Canada layout, because it does not appear to be up-to-date.
@
text
@a42 1
; 18-Aug-98  BJGA Fixed numerous layout bugs
d390 1
a390 1
        =       "0.43 (18 Aug 1998)"
@


4.2.2.4
log
@Updated/added layout drawfiles for all Ursula layouts.

Alt-Delete now does nothing (matches behaviour before it was definable).

Added "dialling codes" for Wales (1222), Wales2 (2222), DvorakUK (9944)
and DvorakUSA (991).

!IKHG.Chars files now use quoted characters instead of codes. This requires
the alphabet to be correctly set before viewing, but makes visual
inspection more reliable.

Layout-specific changes
~~~~~~~~~~~~~~~~~~~~~~~
Belgium/Denmark/France/Germany:
  Corrected double/single sexed quotes positions

Esperanto:
  Reintroduced into build, based upon trunk version, but without the
    characters that are absent from the Latin3 alphabet.

Greece:
  Added stress-diaeresis dead key on Alt-stress
  Removed Shift-B2 (undefined in Greek alphabet)

Israel:
  Removed inverted-!, inverted-? and Minus (not in Hebrew alphabet)
  Corrected multiply (in different place in Hebrew alphabet)
  Re-inserted divide in conventional position
  Added ASCII 0 on Ctrl-0
  Removed duplicate of Alt-0, Shift-Alt-R/S/Y
  Removed Ctrl versions of final pe (breaks Ctrl key convention)

LatinAm:
  Removed duplicate bar from Alt-1

Russia:
  Changed Ctrl combinations to follow the standard rules (Ctrl-0-9 works,
    any other Ctrl not in range @@,A-Z,[,\,],^,_ does nothing)

Switzerland:
  Removed duplicates of Alt-7/8/9, acute/tilde dead keys, [, ], {, }, \, dbl-s
  Ctrl-diaeresis now produces a dead accent, to match the other dead keys
  ASCII 28 now produced by Ctrl-\ instead of Ctrl-<
  Corrected double/single sexed quotes positions

Turkey:
  Added ASCII 0 combination on Ctrl-O-diaeresis
@
text
@d391 1
a391 1
        =       "0.44 (10 Sep 1998)"
a757 1
        &      1222, Country_Wales
a758 4
        &      2222, Country_Wales2

        &      9944, Country_DvorakUK
        &       991, Country_DvorakUSA
a802 2
        TST     R5, #KBStat_PendingAlt          ; Alt-Delete shouldn't do anything
        MOVNE   PC, R14
d804 1
a804 1
        LDRB    R1, R0DeleteChar                ; get configured delete character
@


4.2.2.5
log
@Bugfix: Ctrl-Alt-F1/F2 keyboard selection now done on a callback.
@
text
@d391 1
a391 1
        =       "0.45 (24 Sep 1998)"
d1012 2
a1013 2
        ADR     R0, CallBack_SelectKeyboard
        SWI     XOS_AddCallBack                 ; R1 already set up
a1020 7

CallBack_SelectKeyboard
        Push    "R0-R2,R14"
        MOV     R0, #OsbyteSetAlphKey
        MOV     R1, R12                         ; R12 used to pass keyboard + &80
        SWI     XOS_Byte
        Pull    "R0-R2,PC"
@


4.1
log
@Initial revision
@
text
@d93 3
a95 1
                    
d133 3
d358 1
a358 1
        =       "0.36 (27 Jun 1994)", 0
d503 10
d520 1
d679 1
a679 1
        &       001, Country_UK
d901 1
a901 1
        
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d93 1
a93 3

Country_USA     * 48

a130 3
        GBLL    NewKeyStructureTable
NewKeyStructureTable    SETL    {TRUE}

d353 1
a353 1
        =       "0.37 (15 Jan 1996)", 0
a497 10
      [ NewKeyStructureTable
        ADRL    R0, KeyStructureTable
        MOV     R4, R0
05
        LDMIA   R4!,{R2,R3}             ; load keyboard number, offset pair
        CMP     R2, #-1                 ; if end of table
        TEQNE   R1, R2                  ; or numbers match then drop through
        BNE     %BT05                   ; else try next
        ADD     R0, R0, R3              ; point to found table or default
      |
a504 1
      ]
d663 1
a663 1
        &       001, Country_USA
d885 1
a885 1

@


4.1.7.2
log
@Updated US and UK tables to meet revision 1.4 of the Keyboard Extension Software
Functional Specification for a 3rd party STB.
@
text
@d42 1
a42 1
; 17-Mar-97  TMD: Added new codes for 3rd party extra keys (in both US + UK tables).
@


4.1.7.3
log
@TMD: Updated version number of module (I forgot to do this before).
@
text
@d42 1
a42 1
; 21-Mar-97  0.38 TMD: Added new codes for 3rd party extra keys (in both US + UK tables).
d358 1
a358 1
        =       "0.38 (21 Mar 1997)", 0
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d93 1
a93 3

Country_USA     * 48

a130 3
        GBLL    NewKeyStructureTable
NewKeyStructureTable    SETL    {TRUE}

d353 1
a353 1
        =       "0.37 (15 Jan 1996)", 0
a497 10
      [ NewKeyStructureTable
        ADRL    R0, KeyStructureTable
        MOV     R4, R0
05
        LDMIA   R4!,{R2,R3}             ; load keyboard number, offset pair
        CMP     R2, #-1                 ; if end of table
        TEQNE   R1, R2                  ; or numbers match then drop through
        BNE     %BT05                   ; else try next
        ADD     R0, R0, R3              ; point to found table or default
      |
a504 1
      ]
d663 1
a663 1
        &       001, Country_USA
d885 1
a885 1

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

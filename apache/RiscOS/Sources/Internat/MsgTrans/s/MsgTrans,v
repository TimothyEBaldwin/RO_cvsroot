head	4.18;
access;
symbols
	MsgTrans-0_49:4.18
	MsgTrans-0_48:4.17
	MsgTrans-0_47-2:4.16
	RO_5_07:4.16
	MsgTrans-0_47:4.16
	MsgTrans-0_46:4.15
	MsgTrans-0_45:4.14
	MsgTrans-0_44:4.13
	MsgTrans-0_43:4.12
	dellis_autobuild_BaseSW:4.11
	MsgTrans-0_42:4.11
	MsgTrans-0_41:4.10
	MsgTrans-0_40:4.9
	MsgTrans-0_39:4.8
	MsgTrans-0_38:4.7
	MsgTrans-0_37:4.6
	MsgTrans-0_36:4.4
	MsgTrans-0_35:4.3
	sbrodie_sedwards_16Mar2000:4.2
	MsgTrans-0_34-4_2_2_1:4.2.2.1
	sbrodie_MsgTrans_dev_bp:4.2
	sbrodie_MsgTrans_dev:4.2.0.2
	dcotton_autobuild_BaseSW:4.13
	Ursula_merge:4.1.4.2
	MsgTrans-0_34:4.2
	nturton_MsgTrans-0_31:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	nicke_MsgTrans-0_31:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	sbrodie_MsgTrans_0_33:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	sbrodie_MsgTrans_experimental_bp:4.1
	sbrodie_MsgTrans_experimental:4.1.0.8
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2012.05.26.08.28.35;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	fZ2M0hnDv1up2d6w;

4.17
date	2011.08.04.21.55.27;	author jlee;	state Exp;
branches;
next	4.16;
commitid	BssanoUYJY071fuv;

4.16
date	2004.02.25.14.03.26;	author jbyrne;	state Exp;
branches;
next	4.15;

4.15
date	2003.12.05.13.03.23;	author jbyrne;	state Exp;
branches;
next	4.14;

4.14
date	2002.11.22.21.31.45;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	2001.06.13.16.43.55;	author sbrodie;	state Exp;
branches;
next	4.12;

4.12
date	2001.03.22.14.47.43;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	2000.08.18.09.34.20;	author sbrodie;	state Exp;
branches;
next	4.10;

4.10
date	2000.08.16.13.11.20;	author sbrodie;	state Exp;
branches;
next	4.9;

4.9
date	2000.08.07.13.58.47;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.06.02.09.47.49;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2000.05.18.11.45.49;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.17.14.57.44;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.14.13.43.50;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.02.14.17.30;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.28.13.44.34;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.04.18.25.29;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.40.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1
	4.1.8.1;
next	;

4.2.2.1
date	99.12.06.12.00.14;	author sbrodie;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2000.04.28.14.53.16;	author sbrodie;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2000.05.02.08.06.12;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.40.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.54.52;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.04.14.14.39.39;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.07.21.14.10.16;	author sbrodie;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.45.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.00.25;	author nturton;	state Exp;
branches;
next	;

4.1.8.1
date	98.05.05.15.37.56;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Pop of LR+PC refactored.
{TRUE} and {FALSE} used in place of aasm names.

Version 0.49. Tagged as 'MsgTrans-0_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;
; MsgTrans.s (MessageTrans)
;
; Copyright (C) Acorn Computers Ltd. 1989 - 2000
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:Symbols
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:NewErrors
        GET     Hdr:WimpSpace
        GET     Hdr:Messages
        GET     Hdr:Proc
        GET     Hdr:Services
        GET     Hdr:MsgTrans
        GET     Hdr:HostFS
        GET     Hdr:NDRDebug
        GET     Hdr:PublicWS
        GET     Hdr:Squash
        GET     Hdr:OSRSI6

        GET     VersionASM

        GBLL    debug
        GBLL    debugswi
        GBLL    debugxx
        GBLL    debugenum                               ; For MessageTrans_EnumerateTokens
        GBLL    debugservice
        GBLL    debugerr                                ; For MessageTrans_ErrorLookup
        GBLL    debugintr                               ; For internationalisation
        GBLL    debugFSW
        GBLL    debughash
        GBLL    debughashalloc
        GBLL    debugstats

        GBLL    keepstats                               ; keep use counts on files - view with ShowMsgs
keepstats       SETL   {TRUE}
    [ keepstats
        ! 0, "WARNING: Keeping usage count statistics"
    ]

debug           SETL   {FALSE}
debugswi        SETL   debug :LAND: {TRUE}
debugxx         SETL   debug :LAND: {TRUE}
debugenum       SETL   debug :LAND: {TRUE}
debugservice    SETL   debug :LAND: {TRUE}
debugerr        SETL   debug :LAND: {TRUE}
debugintr       SETL   debug :LAND: {TRUE}
debugFSW        SETL   debug :LAND: {TRUE}
debughash       SETL   debug :LAND: {TRUE}
debughashalloc  SETL   debug :LAND: {FALSE}
debugstats      SETL   debug :LAND: {TRUE} :LAND: keepstats

debug_module    SETL   {TRUE}                          ; to use DebugIt
hostvdu         SETL   :LNOT:debug_module

; The following macro is provided for assistance debugging MessageTrans.
; By setting it to true, the module title changes to DbgMessageTrans and
; the SWI chunk prefix changes similarly, the SWI chunk changes to &C0E00
; This enables it to be softloaded on a RISC OS machine without confusing
; all the applications and modules relying on MessageTrans services.
    [ :LNOT: :DEF: AltTitleAndSWI
        GBLL    AltTitleAndSWI
AltTitleAndSWI  SETL   {FALSE}
    ]

; If set to true, claims 32 32-byte blocks in our private workspace, to enable
; us to claim/release blocks very quickly
; DOES NOT WORK YET
        GBLL    ChocolateProxies
ChocolateProxies  SETL {FALSE}

; If set to true, attempt to construct a hash table for the kernel dictionary.
        GBLL    HashDictionary
HashDictionary    SETL {TRUE}

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Workspace layout
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                                ^       0, wp
wsorigin                        #       0
link_header                     #       4
current_ForegroundBuffer        #       1
current_IRQBuffer               #       1
ThreadNess                      #       1
    [ ChocolateProxies
ProxyCountdown                  #       1       ; don't use chocolate blocks until this gets to 0
    |
alignpadding                    #       13
    ]
ptr_IRQsema                     #       4
MessageFile_block               #       5*4
GlobalMessageFile_block         #       5*4
Dictionary                      #       4
    [ HashDictionary
DictionaryHash                  #       4*256
    ]

MaxThreadNess * 2

    [ ChocolateProxies
ProxyBlockSize                  *       32      ; cannot change!
ProxyBlocks                     *       32      ; one bit per block in ProxyAlloc
ProxyAlloc                      #       4
ProxyMemorySize                 *       ProxyBlockSize * ProxyBlocks
ProxyMemory                     #       ProxyMemorySize
ChocolateCountdown              *       0
    ]

        ASSERT  (link_header-wsorigin)=0

ForegroundBuffersNo             *       16
IRQBuffersNo                    *       4
Buffersize                      *       &100

        AlignSpace 16

; These two must appear consecutively in the workspace
ForegroundBuffers               #       Buffersize*ForegroundBuffersNo
IRQBuffers                      #       Buffersize*IRQBuffersNo

workspace_size  * @@-wsorigin

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module header
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        AREA    |MsgTrans$$Code|, CODE, READONLY, PIC

Module_BaseAddr

        DCD     0                                       ; Start
        DCD     Init             - Module_BaseAddr
        DCD     Die              - Module_BaseAddr
        DCD     Service          - Module_BaseAddr
        DCD     TitleString      - Module_BaseAddr
        DCD     HelpString       - Module_BaseAddr
        DCD     0                                       ; CommandTable
        [ AltTitleAndSWI
        DCD     &C0E00
        |
        DCD     MessageTransSWI_Base
        ]
        DCD     MySWIDecode      - Module_BaseAddr
        DCD     MySWINames       - Module_BaseAddr
        DCD     0
        DCD     0
   [ :LNOT: No32bitCode
        DCD     MyFlags          - Module_BaseAddr
   ]

HelpString      DCB     "MessageTrans", 9, "$Module_HelpVersion", 0
                ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module flags.  Bit 0 set means module is 32-bit aware and safe
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   [ :LNOT: No32bitCode
MyFlags DCD     ModuleFlag_32bit
   ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; File control block format
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Only the 32 byte blocks are ever linked into the MessageTrans chain.  MessageTrans always
; allocates blocks of 32 bytes long.  Clients will only pass 16 byte blocks normally, but
; can pass 32 byte blocks by specfiying R3 = FAST on the call to MessageTrans_OpenFile.  The
; client supplies certain guarantees by doing this too, notably: block will be safe (ie. NOT
; on the SVC stack); the client will call MessageTrans_CloseFile. If the client fails to do
; the latter, the hash table will be leaked.

                ^       0
fcb_link        #       4                               ; only linked in if not client buffer
fcb_flags       #       4                               ; flags in proxy blocks
fcb_fileptr     #       4                               ; pointer to file data: 0 => not loaded
fcb_filename    #       4                               ; pointer to filename
fcb_hash        #       4                               ; hash table (if fcb_flags & flg_hashing)
fcb_clnt_block  #       4                               ; pointer back to client's block
fcb_use_count   #       4                               ; usage counter (only if keepstats is true)
fcb_reserved    #       4                               ; reserved for future use
fcb_size        #       0

                ^       0
fcb_clnt_magic  #       4                               ; magic word in client's proxy block
fcb_clnt_flags  #       4                               ; flags in the client's block
fcb_real_block  #       4                               ; pointer to proxy descriptor
fcb_clnt_fname  #       4                               ; pointer to filename
fcb_clnt_size   #       0


flg_inresourcefs        *       1 :SHL: 0               ; file data is in resourcefs, else RMA
flg_ourbuffer           *       1 :SHL: 1               ; means that on closing we must free the buffer
flg_addtolist           *       1 :SHL: 2               ; means treat seeing as opening

flg_defer_hash_creation *       1 :SHL: 25              ; defer creation of the hash table
flg_new_api             *       1 :SHL: 26              ; client set R3 to magic value on OpenFile SWI
flg_worth_hashing       *       1 :SHL: 27              ; set if MessageTrans_OpenFile feels it's worth it
flg_hashing             *       1 :SHL: 28              ; the client's hash table pointer is valid
flg_freeblock           *       1 :SHL: 29              ; we allocated this descriptor in the RMA
flg_proxy               *       1 :SHL: 30              ; fcb_fileptr points to our own descriptor
flg_sqshinresourcefs    *       1 :SHL: 31              ; means a squashed file in resourcefs

flg_hidden_from_client  *       (2_1111111 :SHL: 25)    ; Mask for internal only flags.

MinimumHashableFileSize *       80                      ; minimum file size to enable hashing
MinimumTokenCount       *       8                       ; number of tokens required to enable hashing

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Init entry - claim and initialise workspace.
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Init    Entry

        LDR     r2, [r12]
        TEQ     r2,#0
        BNE     %FT01

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =workspace_size
        SWI     XOS_Module
        EXIT    VS

        STR     r2, [ r12 ]
01      MOV     wp, r2

    [ ChocolateProxies
        MVN     r0, #0
        STR     r0, ProxyAlloc
        MOV     r0, #ChocolateCountdown
        STRB    r0, ProxyCountdown
    ]
        MOV     r0, #0
        STR     r0, link_header
        STRB    r0, current_ForegroundBuffer
        STRB    r0, current_IRQBuffer
        STR     r0, MessageFile_block
        STR     r0, GlobalMessageFile_block
        STR     r0, Dictionary
        STRB    r0, ThreadNess

        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_IRQsema
        STR     r2, ptr_IRQsema

; Try to open message files
        BL      AttemptOpenMessagesFiles
        Debug   xx,"Module initialisation completed"
        CLRV
        EXIT

MessagesFileName         DCB     "Resources:$.Resources.MsgTrans.Messages", 0
GlobalMessagesFileName   DCB     "Resources:$.Resources.Global.Messages", 0
        ALIGN

; --------------------------------------------------------------------------------
;
; AttemptOpenMessagesFiles
;
; Attempt to open ours and the global messages files.
; Error not returned - failure simply means they're not open.
;

AttemptOpenMessagesFiles Entry "r0-r3"

        LDR     r0, MessageFile_block
        TEQ     r0, #0
        BNE     %FT50
        ADR     r0, MessageFile_block + 4
        ADR     r1, MessagesFileName
        DebugS   xx,"Opening MsgTrans message file", r1
        MOV     r2, #0
        BL      SWIMessageTrans_OpenFile
        MOVVS   r0, #0
        STR     r0, MessageFile_block                   ; Either 0 or the correct address

50
        LDR     r0, GlobalMessageFile_block
        CMP     r0, #0                                  ; clears V
        EXIT    NE
        ADR     r0, GlobalMessageFile_block + 4
        ADR     r1, GlobalMessagesFileName
        DebugS   xx,"Opening global message file", r1
        MOV     r2, #0
        BL      SWIMessageTrans_OpenFile
        MOVVS   r0, #0
        STR     r0, GlobalMessageFile_block             ; Either 0 or the correct address
        Debug   xx,"Global file opened",r0

        CLRV
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Die entry - throw away all blocks without telling anybody
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ;       Allocated data for each block is freed (hash table, file data
        ;       and proxy) and flg_addtolist is set in the flags of the original
        ;       client block. Next time a lookup is performed the file will be
        ;       reopened. Note that accessing the client block is safe since
        ;       only files opened with R2=0 are on this list, and their client
        ;       descriptors must be in RMA.
        ;       The module workspace is freed by the kernel on exit.


Die     Entry

        ; Don't bother closing our own messages files because we're going to
        ; reopen them anyway on initialisation.

        LDR     wp, [ r12 ]
        LDR     r6, magicnumber_fast
DieLoop
        LDR     r0, link_header
        CMP     r0, #0                                  ; clears V
        EXIT    EQ
        LDR     r14, [ r0, #fcb_link ]                  ; Delete block from chain
        STR     r14, link_header
        LDR     r4, [ r0, #fcb_clnt_block ]             ; Get pointer back to client block

        BL      HashTableDelete                         ; Delete the hash table (if any)
        BL      CloseFileFreeData                       ; Free proxy block and file data (if any)

        LDR     r0, [ r4, #fcb_clnt_magic ]             ; Get the client magic word
        EORS    r0, r0, r6                              ; Check (and set r0 to 0)
        BNE     DieLoop                                 ; Don't attempt to modify client block if invalid
        STR     r0, [ r4, #fcb_real_block ]             ; Mark it as 'no valid data'
        STR     r0, [ r4, #fcb_clnt_magic ]             ; Clear the magic word
        LDR     r0, [ r4, #fcb_clnt_flags ]
        AND     r0, r0, #flg_worth_hashing:OR:flg_new_api  ; Preserve only these flags
        ORR     r0, r0, #flg_addtolist                  ; Magic flag to cope with a new MessageTrans
        STR     r0, [ r4, #fcb_clnt_flags ]             ; Set the flags to tell a new MessageTrans to reopen

        B       DieLoop

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handling
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ursula format
;
        ASSERT  Service_ResourceFSStarted < Service_ResourceFSDying
        ASSERT  Service_ResourceFSDying   < Service_TerritoryStarted
        ASSERT  Service_TerritoryStarted  < Service_ModulePostInit
;
UServTab
        DCD     0                              ;flags
        DCD     UService - Module_BaseAddr
        DCD     Service_ResourceFSStarted
        DCD     Service_ResourceFSDying
        DCD     Service_TerritoryStarted
        DCD     Service_ModulePostInit
        DCD     0                              ;terminator
        DCD     UServTab - Module_BaseAddr     ;anchor
Service
        MOV     r0,r0                          ;magic instruction
        Debug   service,"Service call entry: R0,R1,R2 =", r0, r1, r2
        TEQ     r1, #Service_ResourceFSDying
        TEQNE   r1, #Service_TerritoryStarted
        TEQNE   r1, #Service_ResourceFSStarted
        TEQNE   r1, #Service_ModulePostInit
        MOVNE   pc, lr
UService
        TEQ     r1, #Service_ModulePostInit
        BEQ     Service_ModulePostInit_Handler

        ;       It is possible that the contents of ResourceFS has now
        ;       changed.  We must now mark all message files that used
        ;       ResourceFS as being invalid i.e. the data pointer must be
        ;       set to zero so that when data is required the address of the
        ;       data will be re-computed.  If the service was either
        ;       TerritoryStarted or ResourceFSStarted then it is also
        ;       important to tell any clients that they must re-cache any
        ;       pointers into the message file and that they must re-open
        ;       any menu structures built from the message file, to do this
        ;       the service call Service_MessageFileClosed is issued.
        ;       All blocks remain "Open" and on the list.

        Push    "r0-r2, lr"
        LDR     wp, [ r12 ]
        MOV     r1, #Service_Serviced                   ; Keep a flag to see if any files have changed
        LDR     r2, link_header                         ; Look at the head of the chain
ResourceFSLoop
        Debug   service,"block",r2
        TEQ     r2, #0
        BEQ     FinishResourceFS
        LDR     r0, [ r2, #fcb_flags ]
        Debug   service,"flags",r0
        TST     r0, #flg_inresourcefs                   ; Is it in the ROM?
        BLNE    Service_CheckFileMoved                  ; has this change affected this file?
        MOVNE   r1, #Service_MessageFileClosed          ; Flag for later service call
        MOVNE   r0, #0
        STRNE   r0, [ r2, #fcb_fileptr ]                ; Mark data as 'not there'
        MOVNE   r0, r2
        BLNE    HashTableDelete
        LDR     r2, [ r2, #fcb_link ]
        B       ResourceFSLoop

FinishResourceFS
        TEQ     r1, #Service_Serviced                   ; Do we want to send a service call at all?
        MOVNE   r0, #0                                  
        LDRNE   r14, [ sp, #4 ]                         ; Get the actual service call type
        TEQNE   r14, #Service_ResourceFSDying           ; Don't prod clients on ResourceFS death
        [       debugservice
        BEQ     %76
        Debug   service,"Service_MessageFileClosed: in ",r0,r1
        SWI     XOS_ServiceCall                         ; can't return error
        Debug   service,"Service_MessageFileClosed: out",r0,r1
76
        |
        SWINE   XOS_ServiceCall                         ; can't return error
        ]

        ; just in case we hadn't got them open already, lets try again...
        LDR     r14, [sp, #4]
        TEQ     r14, #Service_ResourceFSStarted
        BLEQ    AttemptOpenMessagesFiles

ExitServiceResourceFS
        Pull    "r0-r2, pc"

Service_ModulePostInit_Handler
        ;       When we are first initialised we send round a
        ;       Service_MessageFileClosed. This is needed to tell clients
        ;       that had direct pointers into message data created by a
        ;       previous MessageTrans that these are no longer valid.

        ADRL    r12, Module_BaseAddr
        TEQ     r0, r12                                 ; is it us that has just been initialised?
        MOVNE   pc, lr                                  ; no
        Push    "r0-r1, lr"
        MOV     r0, #0
        MOV     r1, #Service_MessageFileClosed          ; Flag for later service call
        Debug   service,"Initial Service_MessageFileClosed: in ",r0,r1
        SWI     XOS_ServiceCall                         ; can't return error
        Debug   service,"Initial Service_MessageFileClosed: out",r0,r1
        Pull    "r0-r1, pc"

        ; This routine looks at the descriptor pointed to be R2 and determines
        ; whether the file has moved or not.  If it has not, then it returns with Z set.
        ; If it has, then it returns with Z clear.  All other flags are corrupted.
        ; The effect of this is that the service call Service_MessageFileClosed does not
        ; go around unnecessarily (ie. it only goes round if one of the message files
        ; currently open and buffered by MessageTrans from ResourceFS has actually changed).
        ; This optimisation will relieve RAMFSFiler of its need to commit suicide every time
        ; ResourceFS changes.  ShowMsgs will confirm that none of the data pointers are 0
        ; after a ResourceFS change.
Service_CheckFileMoved Entry "r1-r4"
        LDR     r4, [ r2, #fcb_fileptr ]
        LDR     r1, [ r2, #fcb_filename ]
        DebugS  service, "check_file_moved filename:", r1
        BL      internal_fileinfo
        TEQ     r0, #flg_inresourcefs                   ; error block won't be 1, will it? :)
        TEQEQ   r2, r4

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI decoding: R11 = SWI index to call
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
$lab    MySWI   $swiname
        [ :LNOT: AltTitleAndSWI
        ASSERT  MessageTransSWI_Base+(.-jptable)/4 = $swiname
        ]
$lab    B       SWI$swiname
        MEND

MySWIDecode ROUT
        CMP     r11, #maxswi
        LDRCC   wp, [ r12 ]                             ; De-reference to workspace
        ADDCC   pc, pc, r11, LSL #2
        B       error_badswi

; jump table must follow immediately

jptable
        MySWI   MessageTrans_FileInfo                   ; &041500
        MySWI   MessageTrans_OpenFile                   ; &041501
        MySWI   MessageTrans_Lookup                     ; &041502
        MySWI   MessageTrans_MakeMenus                  ; &041503
        MySWI   MessageTrans_CloseFile                  ; &041504
        MySWI   MessageTrans_EnumerateTokens            ; &041505
        MySWI   MessageTrans_ErrorLookup                ; &041506
        MySWI   MessageTrans_GSLookup                   ; &041507
        MySWI   MessageTrans_CopyError                  ; &041508
        MySWI   MessageTrans_Dictionary                 ; &041509

maxswi  *       (.-jptable)/4

TitleString
MySWINames
        [ AltTitleAndSWI
        DCB     "Dbg"
        ]
        DCB     MessageTransSWI_Name, 0
        DCB     "FileInfo", 0
        DCB     "OpenFile", 0
        DCB     "Lookup", 0
        DCB     "MakeMenus", 0
        DCB     "CloseFile", 0
        DCB     "EnumerateTokens", 0
        DCB     "ErrorLookup", 0
        DCB     "GSLookup", 0
        DCB     "CopyError", 0
        DCB     "Dictionary", 0
        DCB     0
        ALIGN

error_badswi
        Push    "r1,r2,r4,lr"
        ADR     r0, ErrorBlock_NoSuchSWI
        MOV     r1, #0
        MOV     r2, #0
        ADR     r4, TitleString
        BL      SWIMessageTrans_ErrorLookup
        Pull    "r1,r2,r4,pc"

        MakeInternatErrorBlock NoSuchSWI,,BadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI definitions
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; SWI MessageTrans_FileInfo
; In    R1 -> filename
; Out   R0 = flag word:
;            bit 0 set => this file is in Resources: (can be accessed directly)
;            bits 1..31 reserved (ignore them)
;       R1   Preserved
;       R2 = size of buffer required to hold file
;            if R0 bit 0 set, the buffer is not required for read-only access

SWIMessageTrans_FileInfo Entry "r3"

    [ debugswi
        ADD     sp, sp, #1*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_FileInfo", r1
        DebugS  swi,"Filename =", r1
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_FileInfo"
        Debug   swi,"OUT: MessageTrans_FileInfo", r0, r1, r2
        Pull    "pc"
55
        ALTENTRY
    ]

        BL      internal_fileinfo
        BICVC   r0, r0, #flg_hidden_from_client         ; flags not for external consumption
        MOVVC   r2, r3                                  ; R2 = size of buffer required

        EXIT

; ..............................................................................

; In    R1 -> filename
; Out   R0 = flag word:
;            bit 0 set => this file is in Resources: (can be accessed directly)
;            bits 1..31 reserved (ignore them)
;       R1   Preserved
;       R2 = address of file data minus 4 (if resourcefs)
;       R3 = size of buffer that would be required to hold file data

ErrorBlock_Recurse
        DCD     ErrorNumber_MessageTrans_Recurse
        DCB     "Recursion in MessageTrans",0
        ALIGN

internal_fileinfo Entry "r1,r4-r7"

        LDRB    lr, ThreadNess
        CMP     lr, #MaxThreadNess
        XError  Recurse, HS
        EXIT    VS
        ADD     lr, lr, #1
        STRB    lr, ThreadNess

        DebugS  xx,"MessageTrans_FileInfo", r1
        DebugS  FSW,"MessageTrans:OSFind_ReadFile",r1

        MOV     r0, #OSFind_ReadFile
        SWI     XOS_Find
        BVS     %FT99
        MOV     r1, r0                                  ; R1 = file handle

        Debug   FSW,"Handle=",r0

        MOV     r3, r1                                  ; save for a moment
        MOV     r0, #FSControl_ReadFSHandle
        SWI     XOS_FSControl
        ANDVC   r4, r2, #&FF                            ; R4 = filing system number
        SUBVC   r5, r1, #4                              ; R5 -> file size, data
        MOVVC   r1, r3

        MOVVC   r0, #OSArgs_ReadEXT
        SWIVC   XOS_Args                                ; R2 = extent of file
        ADDVC   r3, r2, #4                              ; R3 = file size + 4
        BVS     %FT95

        TEQ     r4, #fsnumber_resourcefs
        MOVNE   r0, #0
        MOVNE   r2, #0
        BNE     %FT95

        MOV     r2, r5

        ; It's in resourcefs - check for squashed file
        LDR     lr, SQSHTag
        LDR     r0, [r2, #4]                            ; 'SQSH' tag at start of squash files
        TEQ     r0, lr
        LDREQ   lr, =&ffffff00                          ; filetype_text in load address
        LDREQ   r0, [r2, #12]
        BICEQ   r0, r0, #&ff
        TEQEQ   r0, lr

        MOVNE   r0, #flg_inresourcefs
        MOVEQ   r0, #flg_sqshinresourcefs
        LDREQ   r3, [r2, #8]                            ; Unsquashed size
        ADDEQ   r3, r3, #4

95      MVNVS   r7, #1 << 31
        MOVVC   r7, #0
        MOV     r6, r0
        MOV     r0, #0
        SWI     XOS_Find                                ; close file even if error
        MOVVC   r0, r6
        ADDS    r7, r7, #1                              ; preserve V

        Debug   xx,"Result: r0, r2, r3 =", r0, r2, r3

99
        Debug   FSW,"Out"
        LDRB    lr, ThreadNess
        SUB     lr, lr, #1
        STRB    lr, ThreadNess

        EXIT

SQSHTag DCB     "SQSH"
        ALIGN

; -----------------------------------------------------------------------------

; SWI MessageTrans_OpenFile
; In    R0 -> 4-word data structure
;             must be held in the RMA if R2=0 on entry
;       R1 -> filename, held in the RMA if R2=0 on entry
;       R2 -> buffer to hold file data
;             0 => allocate some space in the RMA,
;                  or use the file directly if it's in Resources:
;       If R3 = the constant "FAST" then the client is assumed
;             to have allocated a 32-byte block and guarantees to
;             call MessageTrans_CloseFile to allow us to free the
;             hash table.
;       If R3 = the constant "SLOW" then the client explicitly does
;             NOT want a hash table created (typically because only
;             one token is going to be looked up)


; Conditions for setting flg_worth_hashing:
;  "File is large enough" AND
;   ("Client used new API with magic constant in R3" OR "Client did not supply a buffer in R2")

; Conditions for generating a proxy block:
;  "Client did not supply a buffer in R2"

magicnumber_fast DCB     "FAST"
magicnumber_slow DCB     "SLOW"

SWIMessageTrans_OpenFile Entry "r0-r6"

    [ debugswi
        ADD     sp, sp, #7*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_OpenFile",r0,r1,r2,r3
        DebugS  swi,"Filename =",r1
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_OpenFile"
        Debug   swi,"OUT: MessageTrans_OpenFile",r0,r1,r2,r3
        Pull    "pc"
55
        ALTENTRY
    ]

        ; Check to see if the client descriptor refers to a proxy block on our list.
        LDR     r6, [ r0, #fcb_clnt_magic ]             ; read the client's magic word
        LDR     r5, magicnumber_fast
        CMP     r5, r6                                  ; clears V on match
        BNE     %FT20                                   ; magic word didn't match, so no proxy or hash table
        LDR     r5, [ r0, #fcb_clnt_flags ]             ; get client block flags
        TST     r5, #flg_proxy                          ; proxy flag set?
        BEQ     %FT15                                   ; no, so no proxy, but is 32-byte block so may have hash table
        LDR     r5, [ r0, #fcb_real_block ]             ; get pointer to proxy block
        ADR     r14, link_header - fcb_link             ; Check if the block is already in the list
OpenScanLoop
        LDR     r14, [ r14, #fcb_link ]
        TEQ     r14, #0                                 ; end of list?
        BEQ     %FT20                                   ; OK - didn't find it
        TEQ     r14, r5                                 ; is it the proxy we are looking for?
        BNE     OpenScanLoop                            ; no, so go round again
        LDR     r4, [ r5, #fcb_clnt_block ]
        TEQ     r4, r0                                  ; back pointer matches?
        BNE     %FT14                                   ; no - something odd has happened

        ; Descriptor is on list. If it's a directly accessed ResourceFS file,
        ; we just need to make sure the pointer is valid, otherwise we need to
        ; close the file before reloading to free allocated memory.
        LDR     r4, [ r5, #fcb_flags ]
        TST     r4, #flg_inresourcefs                   ; is it being directly accessed in ResourceFS?
        BEQ     %FT15                                   ; no, so force reload

        LDR     r4, [ r5, #fcb_filename ]               ; get filename pointer in proxy block
        TEQ     r1, r4                                  ; were we called with the same pointer?
        BNE     %FT15                                   ; no, so might be a different file

        LDR     r4, [ r5, #fcb_fileptr ]
        TEQ     r4, #0                                  ; is file pointer valid?
        EXIT    NE                                      ; yes, so nothing to do. Note V clear due to CMP above.
        
        Debug   xx, "Reloading ResourceFS file"
        BL      internal_fileinfo                       ; get file information
        BVS     ExitOpenQuick                           ; sorry - a problem occurred
        STR     r2, [ r5, #fcb_fileptr ]                ; set message data pointer
        EXIT
14
        Debug   xx, "ERROR: Proxy back pointer didn't match"
15
        Debug   xx, "Closing file and reloading"
        BL      SWIMessageTrans_CloseFile               ; close to discard allocated memory before continuing
20
        ADDS    r0, r1, #0                              ; R1=0? If so, R0=0,Z set,V clear; else R0 corrupt, Z+V clear
        LDREQ   r3, [r2, #0]                            ; Discover the length of the data
        BLNE    internal_fileinfo                       ; R0 = flags, R2 -> data, R3 = size
        BVS     ExitOpenQuick                           ; sorry - a problem occurred

        LDR     r4, stk_filedesc                        ; R4 -> file descriptor
        LDR     r5, stk_buffersize                      ; get caller's R3
        LDR     lr, magicnumber_fast                    ; get the magic word
        TEQ     lr, r5
        ORREQ   r0, r0, #flg_new_api+flg_worth_hashing  ; remember new API used.
        MOVEQ   lr, #0
        STREQ   lr, [r4, #fcb_clnt_block]               ; zero the back pointer
    [ keepstats
        STREQ   lr, [r4, #fcb_use_count]                ; zero the usage counter
    ]

        LDR     r14, magicnumber_slow                   ; get the magic word
        CMP     r14, r5                                 ; was it "SLOW" ?
        BICEQ   r0, r0, #flg_worth_hashing
        LDRNE   r14, stk_buffer                         ; get caller's R2
        CMP     r14, #0
        ORREQ   r0, r0, #flg_worth_hashing

        CMP     r3, #MinimumHashableFileSize            ; big enough to considering hashing this file?
        BICCC   r0, r0, #flg_worth_hashing              ; no - so forget that we'd like to do it

        STR     r0, [ r4, #fcb_clnt_flags ]
        STR     r1, [ r4, #fcb_filename ]
        STR     r5, [ r4, #fcb_clnt_magic ]             ; set magic word to caller's R3 (i.e. FAST if 32-byte block)

        LDR     r14, stk_buffer                         ; get caller's R2 again
        CMP     r14, #0                                 ; always clears V
        BNE     UseSuppliedBuffer

        BL      CopyDescriptorToRMA                     ; allocate a new descriptor, changes R4
        BVS     ExitOpenQuick                           ; failed to claim memory

        Debug   xx, "Proxy descriptor created in RMA OK"
        ; By now, R4 points to our own RMA proxy block if necessary, or the original
        ; client's block pointer.

        TST     r0, #flg_inresourcefs
        BEQ     FileNotDirectROM                        ; If it isn't in ResourceFS
        Debug   xx, "Use ResourceFS data directly"
        STR     r2, [ r4, #fcb_fileptr ]                ; R2 -> message data

ExitOpenFile
        LDRVC   r14, link_header                        ; If not an error, then link in to list
        STRVC   r14, [ r4, #fcb_link ]
        STRVC   r4, link_header
    [ debugservice
        BLVC    dump_chain
    ]
ExitOpenFile_NoLink
        MOVVC   r0, r4
        BLVC    HashTableAlloc                          ; allocate and construct the hash table if wanted
ExitOpenQuick
        STRVS   r0, [ sp, #0 ]                          ; If error store in exit frame
        EXIT

UseSuppliedBuffer                                       ; Doesn't matter which FS its from
        Debug   xx, "Using user-supplied buffer"
        BIC     r0, r0, #flg_inresourcefs               ; flg_inresourcefs means we're pointing
        STR     r0, [ r4, #fcb_flags ]                  ; at resourcefs now
        STR     r14, [ r4, #fcb_fileptr ]               ; Put its address in the block
        CMP     r1, #0                                  ; Did we get passed a filename?  (clear V always)
        MOVNE   r5, r2
        MOVNE   r2, r14
        BLNE    OpenFile_LoadIntoBuffer
        B       ExitOpenFile_NoLink

FileNotDirectROM
        ; r0=flags
        ; r1=filename
        ; r2=resourcefs address
        ; r3=size needed
        ; r4=messagefile block
        Debug   xx, "Make our own buffer for file in RMA"
        MOV     r6, r0
        MOV     r0, #ModHandReason_Claim                ; R3 is still size to claim
        SWI     XOS_Module
        MOVVC   r0, r6
        BLVC    OpenFile_LoadIntoBuffer
        LDRVC   r14, [ r4, #fcb_flags ]
        ORRVC   r14, r14, #flg_ourbuffer                ; Mark this as ours so we free it on Close
        STRVC   r14, [ r4, #fcb_flags ]
        STRVC   r2, [ r4, #fcb_fileptr ]                ; Put its address in the block
        BVC     ExitOpenFile
        MOV     r4, r0                                  ; Keep the error
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     r0, r4
        SETV
        B       ExitOpenQuick

    [ debugservice
dump_chain Entry "r0-r1"
        MRS     r1, CPSR
        LDR     r0, link_header
        Debug   service, "dump_chain: Head pointer",r0
dc_loop
        LDR     r0, [r0, #fcb_link]
        Debug   service, "dump_chain: Link pointer",r0
        CMP     r0, #0
        BNE     dc_loop
        MSR     CPSR_f, r1
        EXIT
    ]

    [ {FALSE}
        ; This error is not returned any more
err_alreadyopen
        Push    "r1, r2"
        ADR     r0, ErrorBlock_FileOpen
        LDR     r1, MessageFile_block                   ; Either 0 or the block address
        MOV     r2, #0
        BL      SWIMessageTrans_ErrorLookup
        Pull    "r1, r2"
        B       ExitOpenFile

ErrorBlock_FileOpen
        DCD     ErrorNumber_MessageTrans_FileOpen
        DCB     "FilOpen", 0
        ALIGN
    ]

CopyDescriptorToRMA Entry "r0-r3,r5,r6,r7"
    [ ChocolateProxies
        LDRB    r3, ProxyCountdown
        TEQ     r3, #0
        BNE     %FT10
        LDR     r1, ProxyAlloc                          ; bit set = array entry available
        RSB     r3, r1, r3
        ANDS    r3, r3, r1
        BEQ     %FT10                                   ; none left!
        BIC     r1, r1, r3
        STR     r1, ProxyAlloc
        ADR     r2, ProxyMemory
01
        MOVS    r3, r3, LSR #1
        ADDNE   r2, r2, #ProxyBlockSize
        BNE     %BT01
10
    ]
        MOV     r3, #fcb_size
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module                              ; Try and get a new RMA block for descriptor
        EXIT    VS                                      ; OK - leave it then
        LDMIA   r4, {r0,r1,r3,r5}                       ; get data from client's original descriptor block
        ORR     r1, r1, #flg_proxy                      ; Set flag that we allocated this block
        ASSERT  fcb_clnt_magic = 0                      ; place for magic word
        ASSERT  fcb_clnt_flags = 4                      ; Store flag so TranslateFindDescriptor knows about it
        ASSERT  fcb_real_block = 8                      ; link from client descriptor to our new descriptor
        ASSERT  fcb_clnt_fname = 12                     ; Store copy of filename pointer for now
        LDR     r0, magicnumber_fast                    ; get the magic word
        STMIA   r4, {r0, r1, r2, r5}
        MOV     r0, #0
        EOR     r1, r1, #flg_freeblock :OR: flg_proxy   ; set flg_freeblock, clears flg_proxy
        MOV     r6, #0                                  ; hash table pointer set to 0
        MOV     r7, r4                                  ; backwards pointer to client block
        STMIA   r2, {r0,r1,r3,r5,r6,r7}                 ; copy information to our own internal descriptor
    [ keepstats
        STR     r6, [r2, #fcb_use_count]                ; zero the usage counter
    ]
        MOV     r4, r2                                  ; replace caller's descriptor pointer
        EXIT                                            ; and return.

TranslateFindDescriptor Entry "r1"

        ; This routine checks a descriptor to see if it was a proxy that was set up previously
        ; by CopyDescriptorToRMA.  If it was, then the proxy pointer is dereferenced to get the
        ; real block's address.  Must preserve C and V.

        TEQ     r0, #0                                  ; a null pointer?
        LDRNE   r1, [ r0, #fcb_clnt_flags ]             ; get flags from descriptor block
        TSTNE   r1, #flg_proxy                          ; was it a proxy?
        LDRNE   r0, [ r0, #fcb_real_block ]             ; It was - follow the proxy link
        EXIT


; Subroutine for MessageTrans_OpenFile
;
; In  r0 = flags
;     r1 = filename
;     r2 = destination buffer
;     r3 = length
;     r5 = resourcefs source address (if relevant)
; Out r0 corrupt
OpenFile_LoadIntoBuffer Entry "r1-r6"

        ; Store buffer length at start of buffer
        STR     r3, [r2], #4

        TST     r0, #flg_sqshinresourcefs
        BEQ     %FT50

        MOV     r4, r2                                  ; destination

        ; Claim decompression workspace
        MOV     r0, #&8                                 ; how much workspace do we need?
        SWI     XSquash_Decompress
        EXIT    VS

        MOV     r3, r0
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS

        ; Do the decompression
        MOV     r0, #0                                  ; decompress slow (with limits)
        MOV     r1, r2                                  ; workspace
        MOV     r2, r5                                  ; input
        LDR     r3, [r2], #24                           ; inbytes (and skip the SQSH header)
        SUB     r3, r3, #24                             ; discount the squash header
        LDR     r5, [r2, #-16]                          ; outbytes
        SWI     XSquash_Decompress

        ; Free the decompression workspace, ignoring errors
        SavePSR r5
        Push    "r0"

        MOV     r2, r1
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module

        Pull    "r0"
        RestPSR r5,,f
    [ No32bitCode
        NOP
    ]

        EXIT

50
        ; Load file without faff
        MOV     r0, #OSFile_Load
        MOV     r3, #0
        SWI     XOS_File

        EXIT

;......................................................................................

EnsureFileIsOpen
        ; In    R0 -> data structure
        ; Out   R3 -> pointer to data
        ;       R4 -> pointer to byte after data
        ;       R1, R2 Trashed
        ;       R0 may have been changed if file was reopened due to MessageTrans reinitialisation
        LDR     r3, [ r0, #fcb_fileptr ]
        CMP     r3, #0                                  ; Clears V
        LDRNE   r4, [ r3 ], #4                          ; R4 = size of file + 4
        ADDNE   r4, r4, r3
        SUBNE   r4, r4, #4                              ; R4 -> byte after end of file
        MOVNE   pc, lr                                  ; Return fast in easy case

        ;       Here there is no file, it is one of four possible cases
        ;       The data has been removed by a Service_ResourceFS(Dying|Started)
        ;       If this is the case then just look it up again, this will have the
        ;       Flag set flg_inresourcefs=1, flg_ourbuffer=0, flg_addtolist=0.
        ;       The other three cases all have the flg_addtolist=1

FileIsNotHere
        LDR     r3, [ r0, #fcb_flags ]
        TST     r3, #flg_addtolist
        BNE     ReOpenBlock
        TST    r3, #flg_inresourcefs
        BEQ    err_invaliddescriptor
        Push    "r0, lr"
        LDR     r1, [ r0, #fcb_filename ]
        DebugS  xx, "Reloading file",r1
        BL      internal_fileinfo                       ; get file information
        Pull    "r1, pc", VS                            ; exit on error
        Pull    "r0"                                    ; Pointer to data structure
        MOV     r3, r2                                  ; Address of data - 4
        STR     r3, [ r0, #fcb_fileptr ]                ; R2 -> message data
FileNowOpen
        LDR     r4, [ r3 ], #4                          ; R4 = size of file + 4
        ADD     r4, r4, r3
        SUB     r4, r4, #4                              ; R4 -> byte after end of file
        Pull    "pc"

ReOpenBlock
        Push    "lr"
        LDR     r1, [ r0, #fcb_filename ]               ; get filename pointer
        MOV     r2, #0
        TST     r3, #flg_new_api                        ; was new API flag set?
        LDRNE   r3, magicnumber_fast                    ; if so, re-open the same way
        TSTEQ   r3, #flg_worth_hashing                  ; was worth hashing flag set?
        LDREQ   r3, magicnumber_slow                    ; if not, re-open with SLOW
        DebugS  xx, "Reopening file",r1
        BL      SWIMessageTrans_OpenFile                ; reload file. Proxy and hash table will be created if necessary
        Pull    "pc", VS                                ; exit on error
        BL      TranslateFindDescriptor                 ; get the new file descriptor
        LDR     r3, [ r0, #fcb_fileptr ]                ; get the message data pointer
        B       FileNowOpen

err_invaliddescriptor
        Push    "r1, r2, lr"
        ADR     r0, ErrorBlock_BadDesc
        LDR     r1, MessageFile_block                   ; Either 0 or the block address
        MOV     r2, #0
        BL      SWIMessageTrans_ErrorLookup
        Pull    "r1, r2, pc"

ErrorBlock_BadDesc
        DCD     ErrorNumber_MessageTrans_BadDesc
        DCB     "BadDesc:Message file descriptor is invalid", 0
        ALIGN

; -----------------------------------------------------------------------------

; SWI MessageTrans_GSLookup
; In    R0 -> 4-word data structure passed to MessageTrans_LoadFile
;       R1 -> token, terminated by 0, 10 or 13, or "token:default"
;       R2 -> buffer to hold result (0 => don't copy it)
;       R3 = buffer size (if R2 non-0)
;       R4 -> parameter 0 (0 => don't substitute for "%0")
;       R5 -> parameter 1 (0 => don't substitute for "%1")
;       R6 -> parameter 2 (0 => don't substitute for "%2")
;       R7 -> parameter 3 (0 => don't substitute for "%3")
; Out   R0,R1 -> preserved.
;       R2 -> result string (read-only with no parameter substitution if R2=0 on entry)
;       R3 = size of result before terminator (character 10 if R2=0 on entry, else 0)

;       Same as MessageTrans_Lookup, only string is GSTransed before you get it back,
;       This needs an intermediate buffer, and so will fail if one cannot be allocated
;       from the RMA.

SWIMessageTrans_GSLookup

    [ debugswi
        Push    "lr"
        Debug   swi,"IN:  MessageTrans_GSLookup",r0,r1,r2,r3,r4,r5,r6,r7
        DebugS  swi,"Token =",r1
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_GSLookup"
        Debug   swi,"OUT: MessageTrans_GSLookup",r0,r1,r2,r3,r4,r5,r6,r7
        Pull    "pc"
55
    ]

;       If R2 = 0 this SWI is identical to MessageTrans_Lookup.

        CMP     r2, #0
        BEQ     SWIMessageTrans_Lookup

;       Else ...

        Push    "r0-r1, r4-r7, r8-r10, lr"

        MOV     r9, r2                                  ; Keep the user's buffer
        MOV     r10, r3

;       First allocate a buffer to hold the result to be the same
;       length as the buffer provided by the client.

        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        STRVS   r0, [ sp, #0 ]
        Pull    "r0-r1, r4-r7, r8-r10, pc", VS

        MOV     r8, r2                                  ; Keep address of claimed buffer for later freeing
        LDMIA   sp, { r0, r1 }                          ; Restore entry values of R0 and R1

;       Now all registers are as on entry, but R2/R3 describes the new buffer

        BL      SWIMessageTrans_Lookup                  ; Go find the message
        MOVVC   r0, r2                                  ; Output of lookup
        MOVVC   r1, r9                                  ; User's buffer pointer
        MOVVC   r2, r10                                 ; User's buffer length
        SWIVC   XOS_GSTrans                             ; Now GSTrans the result
        BVS     FreeGSBufferAndExit

;       Free the buffer and return.

        Push    "r0, r1, r2"
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        STRVS   r0, [ sp, #0 ]
        Pull    "r0, r2, r3"
        STRVS   r0, [ sp, #0 ]
 [ :LNOT:No32bitCode
        TEQ     pc, pc
        Pull    "r0-r1, r4-r7, r8-r10, pc", EQ          ; corrupt flags for 32-bit exit
 ]
        Pull    "r0-r1, r4-r7, r8-r10, pc", VS
        Pull    "r0-r1, r4-r7, r8-r10, pc",, ^

FreeGSBufferAndExit
        STR     r0, [ sp, #0 ]                          ; Shove error into stack
        MOV     r0, #ModHandReason_Free
        MOV     r2, r8
        SWI     XOS_Module
        SETV                                            ; Force error, cleared by SWI
        Pull    "r0-r1, r4-r7, r8-r10, pc"

; -----------------------------------------------------------------------------

; SWI MessageTrans_ErrorLookup
; In    R0 -> Error block (Word aligned) containing error number , token, terminated by 0 or error number , "token:default"
;       R1 -> 4-word data structure passed to MessageTrans_LoadFile
;       R2 -> buffer to hold result (0 => Use internal buffer)
;       R3 =  buffer size (if R2 non-0)
;       R4 -> parameter 0 (0 => don't substitute for "%0")
;       R5 -> parameter 1 (0 => don't substitute for "%1")
;       R6 -> parameter 2 (0 => don't substitute for "%2")
;       R7 -> parameter 3 (0 => don't substitute for "%3")
; Out   R0 -> Error buffer used
;       V Set

SWIMessageTrans_ErrorLookup Entry "r1-r8"

    [ debugswi
        ADD     sp, sp, #8*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_ErrorLookup", r0, r1, r2, r3, r4, r5, r6, r7
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_ErrorLookup"
        Debug   swi,"OUT: MessageTrans_ErrorLookup", r0, r1, r2, r3, r4, r5, r6, r7
        Pull    "pc"
55
        ALTENTRY
    ]

; Set things up for MessageTrans_Lookup

; First find a buffer to use:

        CMP     r2,#0
        BLEQ    AllocateInternalBuffer                  ; R2=0 means check IRQsema

        ;       Now R2 -> Buffer to use
        ;       R3 =  Buffer Size
        LDR     r14, [ r0 ], #4                         ; Copy error number.
        ADD     r2, r2, #4                              ; Point at text start.
        Push    "r14"                                   ; Stack error number.
        MOV     r8, r0
        MOV     r0, r1                                  ; 4 word data structure
        MOV     r1, r8                                  ; Pointer to the error token
        SUB     r3, r3, #4                              ; Adjust output buffer size, because we have already changed R2

; Now
;       R0 -> File block
;       R1 -> Token
;       R2 -> Where to put translation
;       R3 -> Buffer size - 4 for error number.
;       R4 .. R7 as on entry.

        BL      SWIMessageTrans_Lookup                  ; Get the translation
        SUBVC   r0, r2, #4                              ; Point back at the error number
        Pull    "r14"
        STRVC   r14, [ r0 ]                             ; Store error number last.

        SETV                                            ; Always exit with V set
        EXIT

; -----------------------------------------------------------------------------

; SWI MessageTrans_CopyError
; In    R0 -> Error block (Word aligned) containing error number ,and error text terminated by 0
; Out   R0 -> Error buffer used
;       V Set

SWIMessageTrans_CopyError Entry "r1-r3"

; First find a buffer to use:

        MOV     r2, #0                                  ; look at IRQsema
        BL      AllocateInternalBuffer
        SUB     r3, r3, #4
        MOV     r1, r2                                  ; Keep copy for exit

; Now R2 -> Buffer to use
;     R3 ~= Buffer Size

        Debug   err,"Using buffer at ", r2

        LDR     r14, [ r0 ], #4                         ; Copy error number.
        STR     r14, [ r2 ], #4

CopyErrorLoop
        DECS    r3
        STREQB  r3, [ r2 ]                              ; Terminate when buffer is about to overflow
        LDRNEB  r14, [ r0 ], #1
        STRNEB  r14, [ r2 ], #1
        TEQNE   r14, #0
        BNE     CopyErrorLoop

        SETV
        MOV     r0, r1

        EXIT

; -----------------------------------------------------------------------------

; SWI MessageTrans_EnumerateTokens
; In    R0 -> 4-word data structure passed to MessageTrans_OpenFile
;       R1 -> token, terminated by 0, 10, 13 or ":"
;             wildcards: ? = match 1 char, * = match 0 or more chars
;       R2 -> buffer to hold result
;       R3 = buffer size
;       R4 = place marker (0 for first call)
; Out   R2 -> buffer, containing next token if found, with terminator copied from input
;             R2=0 => no more tokens found (we've finished)
;       R3 = length of result excluding terminator (if R2<>0)
;       R4 = place marker for next call (non-0)

; NOTE: Absolutely do not change the meaning of R4.  The hash table construction
;       code relies on it being an index into the file data.

                ^       0, sp
stk_filedesc    #       4               ; r0            ; R0-R3 as for MessageTrans_Lookup
stk_token       #       4               ; r1
stk_buffer      #       4               ; r2
stk_buffersize  #       4               ; r3
stk_place       #       4               ; r4

SWIMessageTrans_EnumerateTokens Entry "r0-r9"

    [ debugswi
        ADD     sp, sp, #10*4                           ; discard saved registers
        Debug   swi,"IN:  MessageTrans_EnumerateTokens", r0, r1, r2, r3, r4
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_EnumerateTokens"
        Debug   swi,"OUT: MessageTrans_EnumerateTokens", r0, r1, r2, r3, r4
        TEQ     r2, #0
        DebugSIf NE, swi,"Token found =", r2
        Pull    "pc"
55
        ALTENTRY
    ]

        DebugS  enum,"Token to match =", r1

        BL      TranslateFindDescriptor

        MOV     r9, r1                                  ; Save a pointer to the client's token
        BL      EnsureFileIsOpen
        BVS     ExitEnumerateTokens

        LDR     r14, stk_place
        ADD     r3, r3, r14                             ; r3 -> where to scan from
        CMP     r3, r4                                  ; Check we are within the file
        BHS     FinishEnumerateTokens                   ; Exit now if past end

; search each line of the file in turn, looking for <token>:

matchtoken
        MOV     r1, r9                                  ; R1 -> token to match with
        MOV     r5, r3                                  ; R5 -> token in file
02
        BL      get_R0_R1                               ; R0 := [ R1 ], #1  and  LS => it's a terminator
        BLS     %FT03

        BL      getbyte                                 ; R8 = next char from file
        BVS     FinishEnumerateTokens

        CMP     r8, #"#"                                ; ignore comment lines completely
        BEQ     skipline2

        TEQ     r0, #"*"                                ; just match whole of rest of token for now
        BEQ     matchrest

        CMP     r8, #"/"                                ; stop if reached end of token
        CMPNE   r8, #":"                                ; if followed by ":", skip to end of line
        CMPNE   r8, #&1f                                ; if end of line, skip to next
        BLS     skiptoken2

        CMP     r8, #"?"                                ; wildcard
        CMPNE   r0, r8
        CMPNE   r0, #"?"                                ; input token can also be wildcarded on this call
        BEQ     %BT02

; skip to next token on line, or skip line if no more tokens

skiptoken2
        BL      skiptonexttoken                         ; R3 -> next char, R8 = current char
        BVC     matchtoken

skipline2
        BLVC    skiptonextline
        BVC     matchtoken

; error => EOF, so indicate that we've finished

FinishEnumerateTokens
        Debug   enum, "No more tokens to enumerate"
        SUBS    r14, r14, r14                           ; R14=0, clear V
        STR     r14, stk_buffer                         ; buffer ptr = 0 on exit => no more found
ExitEnumerateTokens
        STRVS   r0, [ sp, #0 ]
        EXIT

; "*" encountered in match token - currently this must be the last char

matchrest
        BL      get_R0_R1
        BLS     EnumerateFoundToken                     ; found it!
        ADR     r0, ErrorBlock_Syntax
        LDR     r1, MessageFile_block                   ; Either 0 or the block address
        MOV     r2, #0
        MOV     r4, r9
        BL      SWIMessageTrans_ErrorLookup
        B       ExitEnumerateTokens

ErrorBlock_Syntax
        DCD     ErrorNumber_MessageTrans_Syntax
        DCB     "Syntax", 0
        ALIGN

; reached end of token - matched if next char is ":", "/" or linefeed

03      BL      getbyte
        BVS     FinishEnumerateTokens
        CMP     r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #":"                                ; token must be followed by ":"
        CMPNE   r8, #&1f
        BHI     skiptoken2

31      CMP     r8, #":"                                ; skip to ":", where message is
        BEQ     EnumerateFoundToken
        BL      getbyte
        BVC     %BT31
        B       FinishEnumerateTokens

EnumerateFoundToken
        ; Found token - R0 = terminator of match token copy the
        ; found token into the supplied buffer, and terminate with R0

        MOV     r3, r5                                  ; R3 -> start of token in file
        LDR     r2, stk_buffer                          ; R2 -> output buffer
        LDR     r6, stk_buffersize                      ; R6 = counter

35      BL      getbyte                                 ; error here => corrupt file
        BVS     ExitEnumerateTokens
        SUBS    r6, r6, #1                              ; watch for buffer overflow
        BLLT    err_buffoverflow
        BVS     ExitEnumerateTokens
        CMP     r8, #"/"                                ; finished if "/", ":" or newline
        CMPNE   r8, #":"
        CMPNE   r8, #&1f
        STRHIB  r8, [ r2 ], #1
        BHI     %BT35
        STRB    r0, [ r2 ]                              ; R2 -> terminator (use same one as input)

        LDR     r6, stk_buffer
        SUBS    r5, r2, r6                              ; R5 = number of bytes copied, excluding terminator
        BEQ     skiptoken2                              ; ignore null tokens (R8 = terminator)

        BL      skiptonexttoken                         ; ignore errors (EOF), since that's for next time

        LDR     r0, stk_filedesc
        BL      TranslateFindDescriptor
        LDR     r0, [ r0, #fcb_fileptr ]
        ADD     r0, r0, #4                              ; R0 -> start of file data (ignore size field)
        SUB     r3, r3, r0                              ; R3 = offset within file for next time
        STR     r3, stk_place                           ; place marker for next call
        STR     r5, stk_buffersize                      ; length of token excluding terminator

        CLRV
        B       ExitEnumerateTokens                     ; DON'T return V flag

;......................................................................................

; In    R1 -> input token
; Out   R0 = next character in token
;       R1 -> character after that
;       LS => R0 is a terminator

get_R0_R1 ROUT
        LDRB    r0, [ r1 ], #1                          ; token is terminated by 0, 10, 13 or ":"
        CMP     r0, #","                                ; terminate on ","
        CMPNE   r0, #")"                                ; terminate on ")"
        CMPNE   r0, #":"                                ; terminate on ":"
        CMPNE   r0, #" "                                ; terminate on ctrl-char or space
        MOV     pc, lr

; -----------------------------------------------------------------------------

; SWI MessageTrans_Lookup
; In    R0 -> 4-word data structure passed to MessageTrans_LoadFile
;       R1 -> token, terminated by 0, 10 or 13, or "token:default"
;       R2 -> buffer to hold result (0 => don't copy it)
;       R3 = buffer size (if R2 non-0)
;       R4 -> parameter 0 (0 => don't substitute for "%0")
;       R5 -> parameter 1 (0 => don't substitute for "%1")
;       R6 -> parameter 2 (0 => don't substitute for "%2")
;       R7 -> parameter 3 (0 => don't substitute for "%3")
; Out   R1 -> token terminator
;       R2 -> result string (read-only with no parameter substitution if R2=0 on entry)
;       R3 = size of result before terminator (character 10 if R2=0 on entry, else 0)

                ^       4*4, sp         ; r0-r3 as for MessageTrans_EnumerateTokens
stk_parameter0  #       4               ; r4
stk_parameter1  #       4               ; r5
stk_parameter2  #       4               ; r6
stk_parameter3  #       4               ; r7
stk_endpars     #       0

SWIMessageTrans_Lookup

    [ debugswi
        Push    "lr"
        Debug   swi,"IN:  MessageTrans_Lookup",r0,r1,r2,r3,r4,r5,r6,r7
        DebugS  swi,"Token =",r1
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_Lookup"
        Debug   swi,"OUT: MessageTrans_Lookup",r0,r1,r2,r3,r4,r5,r6,r7
        Pull    "pc"
55
    ]

        Push    "r0-r3,lr"                              ; Preserve the inputs in case it fails

        DebugS  FSW,">>",r1

        BL      TranslateFindDescriptor                 ; changes R0
        CMP     r0, #0                                  ; Were we given a message block? (clears V)
        CMPEQ   r0, #&80000000                          ; set V if Z was set
        BLVC    internal_lookup
        LDRVC   r0, [sp], #16                           ; Restore old R0 on success to not confuse client, junk R1-R3
        Pull    "pc", VC                                ; Match found so return
DoGlobalLookup
        LDR     r0, GlobalMessageFile_block
        BL      TranslateFindDescriptor
        Debug   xx,"Global file :", r0

        Pull    "lr"                                    ; pull caller's R0 into lr (to junk it or re-stack it)
        CMP     r0, #0                                  ; Clears V - was the global descriptor zero?
        Pull    "r1-r3"
        BEQ     NoGlobalMessageFile                     ; What an unlikely thing (requires return address on stack only)

        ; only got lr left stacked now
        Push    "lr"                                    ; re-stack caller's R0.  We've kept it safe now.
        BL      internal_lookup
        STRVS   r0, [sp]                                ; replace caller's R0 with an error block
        Pull    "r0,pc"                                 ; return

internal_lookup Entry "r0-r10"

        Debug   xx,"MessageTrans_Lookup",r0,r1,r2,r3,r4,r5
        DebugS  xx,"Token =",r1

        MOV     r9, r1                                  ; Pointer to the token for error insertion
        BL      EnsureFileIsOpen
        BVS     %FT80

        LDR     r1, [r0, #fcb_flags]
        AND     r8, r1, #flg_hashing :OR: flg_worth_hashing :OR: flg_defer_hash_creation
        TST     r8, #flg_defer_hash_creation            ; Create this time?  Clear flag for next time around
        BICNE   r1, r1, #flg_defer_hash_creation
        STRNE   r1, [r0, #fcb_flags]        
        TEQ     r8, #flg_worth_hashing
        BLEQ    HashTableAlloc
        LDR     r1, [r0, #fcb_flags]
        BICVS   r1, r1, #flg_worth_hashing :OR: flg_hashing :OR: flg_defer_hash_creation
        STRVS   r1, [r0, #fcb_flags]
        TST     r1, #flg_hashing
    [ keepstats
        ; We can only do stats when hashing as that's the only guaranteed case of having 32 byte block
        LDRNE   r8, [r0, #fcb_use_count]
        ADDNE   r8, r8, #1
        STRNE   r8, [r0, #fcb_use_count]
    ]
        LDRNE   r8, [r0, #fcb_hash]
        TEQNE   r8, #0
        BEQ     findtoken                               ; no hash table, behave as before

        DebugS   hash, "Looking up in hash table : ",r9

        Push    "r2,r3,r8"
        MOV     r1, r9                                  ; token we are searching for
        MOV     r2, r9
        MOV     r3, #0                                  ; length of the token
71      BL      get_R0_R1
        ADDHI   r3, r3, #1
        BHI     %BT71
        BL      AllocHashR2R3toR1
        Debug   hash, "Hash value",r1
        CMP     r1, #NumBuckets
        Pull    "r2,r3,r8",EQ
        BEQ     findtoken                               ; wildcarded :-(   We don't do those
        MOV     r7, r1                                  ; remember which hash chain for later
        LDR     r2, [r8, r7, LSL #2]!                   ; retrieve address of first hash entry
        LDR     r10, [r8, #4]                           ; get terminator
        Debug   hash, "Hash chain at address",r2
72
        MOV     r1, r9
        CMP     r2, r10                                 ; finished this list?
        BEQ     %FT78                                   ; done
        LDR     r3, [r2], #4                            ; get next hash entry
        Debug   hash, "Next hash address", r3
73
        BL      get_R0_R1
        BLS     %FT76                                   ; terminator?  this could be it!
        BL      getbyte
        BVS     %BT72                                   ; error? next!
       ;CMP     r8, #"*"                                ; wildcard?
       ;BEQ     %FT77
        CMP     r8, #":"                                ; if followed by ":", skip to end of line
        CMPNE   r8, #"/"                                ; also stop if reached end of token
        CMPNE   r8, #&1f
        BLS     %BT72                                   ; try next entry
        CMP     r8, #"?"
        CMPNE   r8, r0
        BEQ     %BT73
        B       %BT72

76      BL      getbyte
        BVS     %BT72                                   ; no
        CMP     r8, #":"                                ; token must be followed by ":"
        CMPNE   r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #&1f
        BHI     %BT72
77
        LDR     r2, [sp], #12                           ; restore r2, trash stacked r3 & r8
        B       %FT31                                   ; we got it!

78
        Debug   hash, "Need to look down wildcard chain if r7 != 00000040.  r7 is", r7
        TEQ     r7, #NumBuckets                         ; which chain have we just searched?
        MOVNE   r7, #NumBuckets                         ; so we know next time we've tried the wildcard chain
        LDRNE   r8, [sp, #8]                            ; get hash table header pointer back
        ADDNE   r8, r8, #NumBuckets*4                   ; point at wildcard chain header
        LDMNEIA r8, {r2,r10}                            ; load wildcard chain head and terminator words
        TEQNE   r2, r10                                 ; quick pre-check to see if chain is empty
        BNE     %BT72                                   ; try wildcard chain if it's not empty
        LDR     r2, [sp], #12                           ; already tried wildcard token list, restore R2, trash r3,r8
        CMP     r0, #&100                               ; LO if we don't have the proper error message yet (R0 is a char)
        BHS     %FT98                                   ; give up with existing error block
80
        MOV     r4, r3                                  ; fake the EOF condition for getbyte
        BL      getbyte                                 ; get and translate the error message
        B       %FT98                                   ; and give up

; search each line of the file in turn, looking for <token>:

findtoken
        MOV     r1, r9                                  ; R1 -> token

02      BL      get_R0_R1                               ; LS => terminator
        BLS     %FT03

        BL      getbyte
        BVS     %FT98

        CMP     r8, #"#"                                ; ignore comment lines completely
        BEQ     skipline

        CMP     r8, #":"                                ; if followed by ":", skip to end of line
        CMPNE   r8, #"/"                                ; also stop if reached end of token
        CMPNE   r8, #&1f
        BLS     skiptokens

        CMP     r8, #"?"                                ; wildcard
        CMPNE   r0, r8
        BEQ     %BT02

; skip to next token on line, or skip line if no more tokens

skiptokens
        BL      skiptonexttoken
        BVC     findtoken

skipline
        BLVC    skiptonextline
        BVC     findtoken

; if error, see if there was a default value after the token

98
        MOVS    r3, r8                                  ; R3 -> start of default value (or 0 if there wasn't any)
        BEQ     %FT99
        Debug   intr,"default found in string"
        MOV     r4, r3                                  ; R3 -> start of default value
53      LDRB    r14, [ r4 ], #1
        CMP     r14, #10
        CMPNE   r14, #13
        CMPNE   r14, #0
        BNE     %BT53
        MOV     r1, r4                                  ; update R1
        DebugS  intr,"default is ", r3
        B       dosubstit                               ; and do parameter substitution

99
        STRVS   r0, [ sp, #0 ]
        EXIT

; reached end of token - matched if next char is ":", "/" or linefeed

03
        BL      getbyte
        BVS     %BT98
        CMP     r8, #":"                                ; token must be followed by ":"
        CMPNE   r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #&1f
        BHI     skiptokens

31      CMP     r8, #":"                                ; skip to ":", where message is
        BEQ     %FT32
        BL      getbyte
        BVC     %BT31
        B       %BT98
32

; found token - read the rest of the line into the output buffer
; r1 -> one after terminator of token supplied

dosubstit

        SUB     r1, r1, #1                              ; return R1 -> token terminator
        STR     r1, stk_token

        ASSERT  :INDEX: stk_token = 4
        ASSERT  :INDEX: stk_buffer = 8
        ASSERT  :INDEX: stk_buffersize = 12

        LDMIB   sp, { r0-r1, r5 }                       ; R5 = counter
        CMP     r1, #0                                  ; if no buffer supplied,
        BNE     decode_string                           ; return a pointer to the string
        STR     r3, stk_buffer
33      BL      getbyte
        BVS     %BT99
        CMP     r8, #&1b
        ADDEQ   r3, r3, #1
        CMP     r8, #10
        CMPNE   r8,#13
        CMPNE   r8,#0
        BNE     %BT33

        SUB     r3, r3, #1                              ; R3 -> terminator
        LDR     r14, stk_buffer
        SUB     r3, r3, r14
        STR     r3, stk_buffersize
        B       %BT99

decode_string

        ;amg: don't call MessageTrans_Dictionary - just set R9=0 to indicate that
        ;     we don't have the value yet

        MOV     r9, #0
;        BL      SWIMessageTrans_Dictionary
;        MOV     r9, r0                                  ; R9 points to kernel dictionary

04      BL      getbyte
        BVS     %BT99
        CMP     r8, #"%"
        BEQ     %FT05
        CMP     r8, #&1b
        BEQ     expand_tok
41      CMP     r8, #10                                 ; stop on linefeed
        CMPNE   r8, #0
        CMPNE   r8, #13
        SUBNES  r5, r5, #1
        MOVEQ   r8, #0                                  ; terminate with 0
        STRB    r8, [ r1 ], #1
        BNE     %BT04
42
        LDR     r14, stk_buffer
        SUB     r14, r1, r14                            ; R14 = length of string
        SUB     r14, r14, #1                            ; excluding terminator
        STR     r14, stk_buffersize
        B       %BT99

; just read "%" - if next character is "0", expand parameter

05      BL      getbyte                                 ; R8 = "0" or "1" (hopefully)
        BVS     %BT99
        SUB     r14, r8, #"0"
        CMP     r14, #4                                 ; parameters 0..3 allowed
        BLO     %FT06
        CMP     r14, #"%"-"0"
        SUBNE   r3, r3, #1                              ; "%%" => "%", else "%x" => "%x"
51      MOV     r8, #"%"
        B       %BT41

; expand parameter into output buffer

06
        ADR     r0, stk_parameter0
        LDR     r0, [ r0, r14, LSL #2 ]                 ; R0 -> parameter
        CMP     r0, #0                                  ; if none, don't substitute
        SUBEQ   r3, r3, #1
        BEQ     %BT51
07      LDRB    r14, [ r0 ], #1
        CMP     r14, #0                                 ; stop on 0
        CMPNE   r14, #10                                ; or linefeed
        CMPNE   r14, #13                                ; or carriage return
        SUBNES  r5, r5, #1
        STRNEB  r14, [ r1 ], #1
        BNE     %BT07
        CMP     r5, #0                                  ; if buffer not full,
        BNE     %BT04                                   ; continue
        MOV     r14, #0                                 ; terminate with 0
        STRB    r14, [ r1 ], #1
        B       %BT42                                   ; else stop now

expand_tok
        LDR     r6, stk_parameter0
        BL      getbyte
        BL      expand_tok1
        CMP     r5, #0                                  ; any space left?
        BGT     %BT04
        B       %BT42

expand_tok1
        STMDB   sp!, {r0, lr}

        ;amg : ok, I give up. We need to make the call to SWIMessageTrans_Dictionary if
        ;      we've not done it already. Moving it to here ensure that it doesn't get
        ;      called when there's no need to call it.
    [ HashDictionary :LAND: {TRUE}
        ADDS    r0, r9, #0                              ; clear V
        BLEQ    SWIMessageTrans_Dictionary
        LDMVSIA sp!, {r0, pc}                           ; didn't find it?
        MOV     r9, r0                                  ; R9 points to kernel dictionary

explp   SUBS    r8, r8, #1                              ; dictionary entries are 1-255; 0 means use R6 string
        ADRCS   r14, DictionaryHash
        LDRCS   r0, [r14, r8, LSL #2]                   ; check hash table entry
        TEQCS   r0, #0                                  ; was it zero (no entry found) ? (must leave C set)
        LDMEQIA sp!, {r0, pc}                           ; exit if so (if R8 was 0 on entry, Z will be clear)
        SUBCCS  r0, r6, #1                              ; R8 was zero, so get R6-1 into R0.  Clear C if R6 was 0
        LDMCCIA sp!, {r0, pc}
    |
        MOVS    r0, r9
        BLEQ    SWIMessageTrans_Dictionary
        MOVEQ   r9, r0                                  ; R9 points to kernel dictionary

explp   SUBS    r8, r8, #1
        LDRHIB  r14, [r0]
        ADDHI   r0, r0, r14
        BHI     explp
        SUBCCS  r0, r6, #1
        LDMCCIA sp!, {r0, pc}
    ]
explp1  LDRB    r8, [r0, #1]!
        CMP     r8, #0
        LDMEQIA sp!, {r0, pc}
        CMP     r8, #&1b
        BEQ     explp2
        SUBS    r5, r5, #1
        MOVLE   r8, #0
        STRB    r8, [r1], #1
        LDMLEIA sp!, {r0, pc}
        B       explp1
explp2
        LDRB    r8, [r0, #1]!
        BL      expand_tok1
        CMP     r5, #0
        BNE     explp1
        LDMIA   sp!, {r0, pc}

NoGlobalMessageFile
        XError  TokenNotFound
        Pull    "pc"

ErrorBlock_TokenNotFound
        DCD     ErrorNumber_MessageTrans_TokenNotFound
        DCB     "TokNFnd", 0
        ALIGN

;...............................................................................

; In    r3 -> next byte in message file
;       r4 -> end-of-file
; Out   r8 = last char read, r3 -> next possible token
;       "Message token not found" error if read past EOF

        ; This version, of the same routines, is considerably faster.
        ; It's important to optimise these routines because when searching
        ; for a token, we spend a great deal of time here skipping over
        ; blank lines.
        ; The following two loops are almost identical - one looks for
        ; newline, the other for newline-or-slash.

skiptonexttoken
        CMP     r8, #"/"
        CMPNE   r8, #&1f
        BLS     skiptonextline4
        CMP     r8, #":"
        LDRB    r8, [r3], #1
        BNE     skiptonexttoken

skiptonextline
        CMP     r8, #&20
        BCC     skiptonextline3
skiptonextline0
        TST     r3, #3
        LDRNEB  r8, [r3], #1
        BNE     skiptonextline
        LDRB    r8, [r3], #1
        B       skiptonextline
skiptonextline1
        LDR     r8, [r3], #4
        CMP     r8, #&20000000
        BIC     r8, r8, #&ff000000
        CMPCS   r8, #&200000
        BIC     r8, r8, #&ff0000
        CMPCS   r8, #&2000
        BIC     r8, r8, #&ff00
        CMPCS   r8, #&20
        BCS     skiptonextline1
        SUB     r3, r3, #3
skiptonextline2
        CMP     r8, #&20
        LDRCSB  r8, [r3], #1
        BCS     skiptonextline2
skiptonextline3
        CMP     r8, #&1b          ; Skip over ESC <token>
        ADDEQ   r3, r3, #1        ; Must never have ESC <EOF>!
        CMPNE   r8, #9            ; Tabs allowed in messages
        CMPNE   r8, #31           ; Also hard space
        BEQ     skiptonextline0
skiptonextline4
        CMP     r3, r4
        BCS     getbyte
        CLRV
        MOV     pc, lr

;...............................................................................
; In    R3 -> next byte in message file
;       R4 -> end-of-file
;       R9 -> pointer to the token we are trying to find (for the error message)
; Out   R3 updated
;       R8 = next byte if not EOF
;       If read past EOF, V is set, R0 points to "Message token not found" error
;       and R8 points to the string after the ':' in the token, or is 0 if none.

getbyte                                                 ; This version does not push LR in the normal non-end-of-file case.
        CMP     r3, r4                                  ; Check we are within the file
        LDRLOB  r8, [ r3 ], #1                          ; Yes, so read the byte
 [ No32bitCode
        BICLOS  pc, lr, #VFlag                          ; Then return with V clear
 |
        MSRLO   CPSR_f, #0                              ; V clear, maintains LO condition
        MOVLO   pc, lr
 ]
        Push    "lr"                                    ; It's an error, get the error message
        ADR     r0, ErrorBlock_TokenNotFound
        ;       R9 is the token to be inserted into the error message
        ;       If a ":" follows the token then don't insert the token
        ;       in the error message.
        DebugS  intr,"Saved token is ",r9
        MOV     r8, r9                                  ; Copy the token pointer
01
        LDRB    r14, [ r8 ], #1
        CMP     r14, #" "                               ; Check for terminating condition
        BLT     %FT02
        CMP     r14, #":"                               ; Check for a ":"
        BNE     %BT01                                   ; Keep scanning if neither happened
        Debug   intr,": in token return"
        SETV
        Pull    "pc"

02
        Debug   intr,"no : in token"
        Push    "r1-r7"                                 ; Return frame is now R1-R7, PC
        LDR     r1, MessageFile_block                   ; Either 0 or the block address
        MOV     r2, #0                                  ; No supplied buffer
        MOV     r3, #0
        MOV     r4, r9                                  ; The token to insert as %0
        MOV     r5, #0                                  ; No more supplied parameters
        MOV     r6, #0
        MOV     r7, #0
        BL      SWIMessageTrans_ErrorLookup
        [       debugintr
        ADD     r1, r0, #4
        DebugS  intr, "getbyte: error lookup returned", r1
        ]
        MOV     r8, #0
        Pull    "r1-r7, pc"


; -----------------------------------------------------------------------------
; SWI MessageTrans_CloseFile
; In    R0 -> 4-word data structure passed to MessageTrans_OpenFile

SWIMessageTrans_CloseFile Entry "r0-r3"

    [ debugswi
        ADD     sp, sp, #4*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_CloseFile",r0
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_CloseFile"
        Debug   swi,"OUT: MessageTrans_CloseFile",r0
        Pull    "pc"
55
        ALTENTRY
    ]

        BL      TranslateFindDescriptor
        TEQ     r0, #0
        BEQ     %FT99
        ADR     r11, link_header - fcb_link
    [ debugstats
        LDR     r2, [ r0, #fcb_flags ]
        TST     r2, #flg_hashing
        BEQ     %F09
        LDR     r1, [ r0, #fcb_filename ]
        LDR     r2, [ r0, #fcb_use_count ]
        DebugS  stats, "MessageTrans file closed", r1
        Debug   stats, "Use count", r2
09
    ]
        BL      HashTableDelete                         ; delete hash table (if any)
CloseFileLoop
        LDR     r1, [ r11, #fcb_link ]
        CMP     r1, #0                                  ; clear V
        BEQ     %FT20                                   ; not on chain of allocated blocks
        TEQ     r1, r0
        MOVNE   r11, r1
        BNE     CloseFileLoop

        LDR     r14, [ r0, #fcb_link ]                  ; delete block from chain
        STR     r14, [ r11, #fcb_link ]

        BL      CloseFileFreeData
20
        LDR     r1, stk_filedesc                        ; get original client block (may = R0 though)
        LDR     r0, [r1]                                ; get client flags
        TST     r0, #flg_proxy:OR:flg_new_api           ; originally opened with R2 non-zero and old API?
        EXIT    EQ                                      ; leave descriptor alone so badly behaved programs can still do lookups
        MOV     r3, #0
        STR     r3, [ r1, #fcb_clnt_magic ]             ; blat the magic word
        STR     r3, [ r1, #fcb_clnt_flags ]             ; blat the flags
        STR     r3, [ r1, #fcb_real_block ]             ; blat the proxy pointer/data pointer

        EXIT
99
        Pull    "r0-r3, lr"
        B       err_invaliddescriptor

; Subroutine for MessageTrans_CloseFile and module Die
;
; In  r0 -> file descriptor
; Out r0-r3 corrupt (or V set and r0 is error)
CloseFileFreeData Entry
        LDR     r14, [ r0, #fcb_flags ]
        LDR     r3, [ r0, #fcb_fileptr ]
        TST     r14, #flg_ourbuffer
        MOVEQ   r3, #0                                  ; ensure R3 is set correctly to avoid later test
        TST     r14, #flg_freeblock
        BEQ     %FT20

    [ ChocolateProxies
        Push    "r3"
        ADR     r2, ProxyMemory
        SUBS    r2, r0, r2
        RSBCSS  r1, r2, #ProxyMemorySize
        LDRCS   r1, ProxyAlloc
        MOVCS   r2, r2, LSR #5
        MOVCS   r3, #1
        ORRCS   r1, r1, r3, LSL r2
        STRCS   r1, ProxyAlloc
        MOVCC   r2, r0
        MOVCC   r0, #ModHandReason_Free
        SWICC   XOS_Module
        Pull    "r3"
    |
        MOVNE   r2, r0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module
    ]
20
        ADDS    r2, r3, #0                              ; clears V and sets/clears Z appropriately
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module

        EXIT

; -----------------------------------------------------------------------------

; SWI MessageTrans_MakeMenus
; In    R0 -> 4-word data structure passed to MessageTrans_OpenFile
;       R1 -> menu definition (see below)
;       R2 -> RAM buffer to hold menu structure
;       R3 = size of RAM buffer
; Out   [R1..] = menu data
;       R2 -> end of menu structure
;       R3 = bytes remaining in buffer (should be 0 if you got it right)
;       "Buffer overflow" error if buffer is too small

SWIMessageTrans_MakeMenus Entry "r1, r4-r11"

    [ debugswi
        ADD     sp, sp, #9*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_MakeMenus", r0, r1, r2, r3
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_MakeMenus"
        Debug   swi,"OUT: MessageTrans_MakeMenus", r0, r1, r2, r3
        Pull    "pc"
55
        ALTENTRY
    ]

        Debug   xx,"MessageTrans_MakeMenus", r0, r1, r2, r3

        BL      TranslateFindDescriptor

loop1   LDRB    r14, [ r1 ]                             ; reached end if title token null
        TEQ     r14, #0
        EXIT    EQ

        CMP     r3, #m_headersize
        BLT     menuerr_buffoverflow

        MOV     r9, r2                                  ; R9 -> start of this menu

        MOV     r4, r3
        BL      int_lookup_nopars                       ; R4-R7 set to 0 automatically
        EXIT    VS

        ADD     r2, r2, #m_ti_fg_colour                 ; R2 -> next bit
        SUB     r8, r3, #3                              ; R8 = current max width (-3 for borders)

        ADD     r1, r1, #1                              ; skip token terminator

        LDRB    r14, [ r1 ], #1                         ; title fg
        STRB    r14, [ r2 ], #1
        LDRB    r14, [ r1 ], #1                         ; title bg
        STRB    r14, [ r2 ], #1
        LDRB    r14, [ r1 ], #1                         ; work fg
        STRB    r14, [ r2 ], #1
        LDRB    r14, [ r1 ], #1                         ; work bg
        STRB    r14, [ r2 ], #1 + 4                     ; (skip item width for now)
        ASSERT  m_itemheight = m_itemwidth + 4
        LDRB    r14, [ r1 ], #1                         ; height of items
        STR     r14, [ r2 ], #4
        LDRB    r14, [ r1 ], #1                         ; gap between items
        STR     r14, [ r2 ], #4
        ASSERT  m_headersize = m_ti_fg_colour + 16

        SUB     r3, r4, #m_headersize                   ; R3 = space left in buffer

loop2   CMP     r3, #mi_size
        BLT     menuerr_buffoverflow

        Push    "r1"
        BL      skiptoken                               ; R1 -> byte after token
        ADD     r1, r1, #3
        BIC     r6, r1, #3                              ; word-align (use R6 for later)
        Pull    "r1"

        LDMIA   r6!, { r5, r10, r11 }                   ; R5 = item flags for this item
                                                        ; R10 = submenu offset
                                                        ; R11 = icon flags
        Push    "r2, r3"
        TST     r5, #mi_it_writeable                    ; if writeable and indirected,
        TSTNE   r11, #if_indirected                     ; icon data set up already
        LDRNE   r3, [ r2, #mi_icondata + 8 ]            ; R3 = buffer size
        LDRNE   r2, [ r2, #mi_icondata + 0 ]            ; R2 -> buffer
        BNE     %FT01
        TST     r11, #if_indirected
        MOVEQ   r3, #12                                 ; 12 bytes allowed if direct
        ADDEQ   r2, r2, #mi_icondata
        MOVNE   r2, #0                                  ; else look up token in place
01      BL      int_lookup_nopars
        MOV     r4, r2                                  ; R4 -> text string
        MOV     r7, r3                                  ; R7 = text length
        Pull    "r2,r3"
        EXIT    VS

        MOV     r1, r6                                  ; R1 -> input data

        CMP     r10, #0
        ADDNE   r10, r9, r10                            ; make submenu pointer absolute

        STMIA   r2!, { r5, r10, r11 }                   ; itemflags, submenu, iconflags

        ADD     r2, r2, #12                             ; skip icondata

        TST     r11, #if_indirected                     ; done if not indirected
        BEQ     %FT02

        TST     r5, #mi_it_writeable
        STREQ   r4, [ r2, #-12 ]                        ; text string
        MOVEQ   r14, #0
        STREQ   r14, [ r2, #-8 ]                        ; no validation string
        ADDEQ   r14, r7, #1
        STREQ   r14, [ r2, #-4 ]                        ; length (with terminator)

02      CMP     r7, r8
        MOVGT   r8, r7

        TST     r5, #mi_it_lastitem
        BEQ     loop2

        MOV     r8, r8, LSL #4                          ; multiply by 16
        ADD     r8, r8, #12                             ; and add 12
        STR     r8, [ r9, #m_itemwidth ]                ; fill this in last

        B       loop1                                   ; continue until null token found

        EXIT

menuerr_buffoverflow
        BL      err_buffoverflow
        EXIT


err_buffoverflow
        ADR     r0, ErrorBlock_BuffOverflow
        Push    "r1, r2, lr"
        MOV     r1, #0                                  ; Force the global case
        MOV     r2, #0
        BL      SWIMessageTrans_ErrorLookup
        Pull    "r1, r2, pc"

ErrorBlock_BuffOverflow
        DCD     ErrorNumber_CDATBufferOverflow
        DCB     "BufOFlo", 0
        ALIGN

;......................................................................................

; In    r1 -> start of token
; Out   r1 -> byte after end of token

skiptoken Entry

01      LDRB    r14, [ r1 ], #1                         ; skip the token
        CMP     r14, #","
        CMPNE   r14, #")"
        CMPNE   r14, #32
        BHI     %BT01

        EXIT

;......................................................................................

; int_lookup_nopars: lookup with no parameters
; In    R0 -> 4-word data structure passed to MessageTrans_LoadFile
;       R1 -> token, terminated by <=32, "," or ")"
;       R2 -> buffer to hold result (0 => don't copy it)
;       R3 = buffer size (if R2 non-0)
; Out   R1 -> token terminator
;       R2 -> terminator (character 10 if R2=0 on entry, 0 otherwise)
;       R3 = size of result, excluding terminator

int_lookup_nopars Entry "r4-r7"

        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        BL      SWIMessageTrans_Lookup

        EXIT

DictionaryFileName       DCB     "Resources:$.Resources.Kernel.Dictionary", 0
        ALIGN

    [ HashDictionary
        ; Returns address of first byte of dictionary in R0 if V clear; error if V set
SWIMessageTrans_Dictionary Entry   "r0-r3"

    [ debugswi
        ADD     sp, sp, #4*4                            ; discard saved registers
        Debug   swi,"IN:  MessageTrans_Dictionary"
        BL      %FT55
        DebugE  swi,"ERR: MessageTrans_Dictionary"
        Debug   swi,"OUT: MessageTrans_Dictionary",r0
        Pull    "pc"
55
        ALTENTRY
    ]

        LDR     r2, Dictionary
        CMP     r2, #0
        ADREQ   r1, DictionaryFileName
        BLEQ    internal_fileinfo
        ADDVC   r0, r2, #4
        STR     r0, [sp]
        EXIT    VS
        LDR     r1, Dictionary
        STR     r2, Dictionary
        TEQ     r1, r2
        EXIT    EQ
        ADR     r3, DictionaryHash
        MOV     r1, #0
dichashloop
        LDRB    r2, [r0]              ; read length byte of R1'th entry
        TEQ     r2, #0                ; end of list?
        STRNE   r0, [r3, r1, LSR #22] ; store hash entry
        STREQ   r2, [r3, r1, LSR #22] ; store zero
        ADDNE   r0, r0, r2
        ADDS    r1, r1, #1 :SHL: 24
        BNE     dichashloop
        EXIT
    |
SWIMessageTrans_Dictionary
        STMDB   sp!, {r1, r2, r3, lr}
        LDR     r2, Dictionary
        CMP     r2, #0
        ADREQ   r1, DictionaryFileName
        BLEQ    internal_fileinfo
        MOVVC   r0, r2
        STRVC   r0, Dictionary
        ADDVC   r0, r0, #4
        LDMIA   sp!, {r1, r2, r3, pc}
    ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Hashing routines
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; The hash tables are pretty simple.  There are 64 main buckets plus a special
; bucket for tokens containing wildcards.  The data structure allocated from the
; RMA has the following structure (specified in C for clarity only)

; struct {
;   struct {
;     char **list;
;   } buckets[64 + 1 + 1];    /* buckets + wildcards + terminator */
;   char *token[number_of_tokens_in_file];
; } hashtable;

; Each entry in hashtable.token is a direct pointer into the messages file.

; hashtable.buckets[n].list points to the first entry in hashtable.token for a
; token which has a hash value of n.  All subsequent entries have the same hash
; value up to but excluding the entry to which hashtable.buckets[n+1].list
; points.  All the entries in buckets[].list are valid.  Empty buckets are
; signified by buckets[n+1].list having the same value as buckets[n].list.  The
; wildcard bucket (hashtable.buckets[64].list) works in the same way -
; terminating bucket #63 and marking the first entry in the wildcard bucket (ie
; bucket #64).   The terminator word (hashtable.buckets[65].list) is used as
; the terminator for bucket #64 only.

; sizeof(hashtable) will always be 264 + (4 * tokens).

; AllocHashR2R3toR1 generates the bucket number (0-63) for a normal token, or
; 64 for a wildcarded token.  Thus to lookup a token, calculate the hash value
; and search the appropriate bucket, then if not found, search the wildcard
; bucket, then if not found fail the lookup.  Unfortunately, you cannot do
; anything but a sequential file search if the client asks to lookup something
; with a wildcard in it - but this should be extremely rare.

NumBuckets      *       64                              ; MUST be a power of two
        ASSERT (NumBuckets * 4) <= Buffersize           ; must fit in a _kernel_oserror

HashTableDelete Entry "r0-r3"
        ; Delete the hash table in the descriptor pointed to by R0
        ; Preserves all registers; corrupts all flags.
        ; Must not write pointer unless we were hashing in case it was a
        ; small non-proxied descriptor.
        Debug   hash, "HashTableDelete", r0
        LDR     r2, [r0, #fcb_flags]                    ; check flags
        TST     r2, #flg_hashing                        ; hashing enabled?
        EXIT    EQ                                      ; no - don't touch hash pointer
        MOV     r1, #0
        BIC     r2, r2, #flg_hashing                    ; clear hash enable
        STR     r2, [r0, #fcb_flags]                    ; store flags
        LDR     r2, [r0, #fcb_hash]                     ; find location of table
        STR     r1, [r0, #fcb_hash]                     ; mark unused whatever
        TEQ     r2, #0                                  ; got a hash table?
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module                              ; release hash table
        EXIT

HashTableAlloc Entry "r0-r11"
        ; Allocate space in the hash table.  R0 is our internal descriptor.
        ; Preserves all registers.  Corrupts NZC, V clear if OK, V set on error
        BL      HashTableDelete
        LDR     r1, [r0, #fcb_flags]
        TST     r1, #flg_worth_hashing                  ; worth the effort and space in descriptor?
        BIC     r1, r1, #flg_hashing :OR: flg_worth_hashing
        STR     r1, [r0, #fcb_flags]
        EXIT    EQ
        Debug   hash, "HashTableAlloc - constructing hash table"

        MOV     r2, #-1                                 ; get a foreground buffer
        BL      AllocateInternalBuffer                  ; abuse of internal buffers - but pretty safe
        MOV     r8, r2                                  ; for safekeeping - a temporary buffer for the tokens
        MOV     r9, r3                                  ; ditto
        MOV     r2, #-1                                 ; get a foreground buffer
        BL      AllocateInternalBuffer                  ; actually need a couple of them :-)
        MOV     r6, r2                                  ; for safekeeping - this one holds the counters
        MOV     r7, #0                                  ; number of wildcard tags
        MOV     r11, #0                                 ; total number of tags
        MOV     r4, #NumBuckets                         ; index for enumeration - will be zero at end of 10 loop
10      SUBS    r4, r4, #1
        STR     r7, [r6, r4, LSL #2]
        BNE     %BT10
        ; ASSERT r4 contains 0 here
20
        ADRL    r1, StarToken                           ; we want everything
        MOV     r2, r8                                  ; Set buffer
        MOV     r3, r9                                  ; size of buffer
        Push    "r11"
        BL      SWIMessageTrans_EnumerateTokens         ; get next token
        Pull    "r11"
        BVS     %FT90
        TEQ     r2, #0                                  ; done?
        BEQ     %FT30                                   ; completed the enumeration
        ADD     r11, r11, #1                            ; inc total
        BL      AllocHashR2R3toR1                       ; hash R2[0..R3] into R1
        CMP     r1, #NumBuckets                         ; Got a wildcard?
        ADDEQ   r7, r7, #1                              ; yes - increment wildcard bucket counter
        LDRNE   r2, [r6, r1, LSL #2]                    ; no - increment counter for bucket
        ADDNE   r2, r2, #1
        STRNE   r2, [r6, r1, LSL #2]
        B       %BT20
30
        Debug   hash, "Tokens in file",r11
        CMP     r11, #MinimumTokenCount                 ; enough tokens to be worthwhile? Instruction also clears V
        LDRLO   r11, [r0, #fcb_flags]
        BICLO   r11, r11, #flg_worth_hashing            ; not worth the effort - don't bother in future
        STRLO   r11, [r0, #fcb_flags]
        EXIT    LO
        ADD     r3, r11, #NumBuckets+2                  ; tag count + one per bucket + wildcard bucket + final terminator
        MOV     r3, r3, LSL #2                          ; convert to bytes
        Debug   hash, "Claiming memory", r3
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module                              ; let's go!
        EXIT    VS
        LDR     r0, [sp, #0*4]                          ; get descriptor back into R0 back again
        STR     r2, [r0, #fcb_hash]                     ; store the hash table memory
        MOV     r4, #0                                  ; ready the index for enumeration again
40      SUBS    r3, r3, #4
        STR     r4, [r2, r3]
        BNE     %BT40
        ADD     r1, r2, #(NumBuckets+2)*4               ; skip the bucket pointers and final terminator to find chain mem
        ; ASSERT r3 and r4 contain 0 here
50      LDR     r0, [r6, r3, LSL #2]                    ; get r3'th entry from counter table
        Debug   hashalloc, "Bucket,Entries",r3,r0
        STR     r1, [r2, r3, LSL #2]                    ; write head pointer
        ADD     r1, r1, r0, LSL #2                      ; add number of entries
        ADD     r3, r3, #1                              ; increment r3
        TEQ     r3, #NumBuckets                         ; done?
        BNE     %BT50
        MOV     r11, r2                                 ; remember where the head pointer table is
        STR     r1, [r2, r3, LSL #2]!                   ; store final header pointer (for wildcard token chain)
        ADD     r1, r1, r7, LSL #2                      ; number of wildcard chain entries
        STR     r1, [r2, #4]                            ; store final terminator
        LDR     r0, [sp, #0*4]                          ; retrieve entry R0 - our internal descriptor
        LDR     r7, [r0, #fcb_fileptr]                  ; guaranteed valid!
        ADD     r7, r7, #4                              ; skip over the file size field
60      ADD     r6, r7, r4                              ; remember where we were at the moment
        ADR     r1, StarToken
        MOV     r2, r8
        MOV     r3, r9
        Push    "r11"
        BL      SWIMessageTrans_EnumerateTokens         ; we know what to do now
        Pull    "r11"
        BVS     %FT80
        CMP     r2, #0                                  ; clears V!
        BEQ     %FT70
        BL      HashAdvanceToRealToken                  ; updates R6 if necessary
        BL      AllocHashR2R3toR1
        Debug   hashalloc, "Storing in bucket",r1
        LDR     r1, [r11, r1, LSL #2]                   ; get the pointer
65      LDR     r2, [r1], #4                            ; look for a space in the table
        TEQ     r2, #0
        BNE     %BT65
        DebugS  hashalloc, "Storing token", r6
        STR     r6, [r1, #-4]!                          ; store in table
        B       %BT60                                   ; next!
70      LDR     r0, [sp, #0*4]                          ; retrieve client descriptor
        LDR     r1, [r0, #fcb_flags]                    ; mark the hash table valid
        ORR     r1, r1, #flg_hashing :OR: flg_worth_hashing
        STR     r1, [r0, #fcb_flags]
        Debug   hash, "HashTableAlloc exiting having set up the hash table"
        ; V must be clear - the only branch from above ensures this is the case
        EXIT

80      ; avoid leaking the hash table memory - cannot use HashTableDelete - flg_hashing isn't set yet
        LDR     r0, [sp, #0*4]                          ; get descriptor back into R0 back again
        LDR     r2, [r0, #fcb_hash]                     ; store the hash table memory
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
90
        Debug   hash,"ERROR returned by MessageTrans_EnumerateTokens"

        CLRV
        EXIT


StarToken
        DCB     "*", 0
        ALIGN

        ROUT

HashAdvanceToRealToken Entry "r0,r8"
        ; R2 is the buffer into which the token has been copied
        ; R4 points to EOF or to the byte following this token's value
        ; R6 is a pointer into the messages file at or after which the token lives
        ; Routine updates R6 if it didn't actually point to the token pointed to by R2
        LDRB    r0, [r2]                ; what we were given
10      LDRB    r8, [r6]
        TEQ     r0, r8
        TEQNE   r8, #"?"
       ;TEQNE   r8, #"*"
        EXIT    EQ                      ; Found the token OK.
        ADD     r6, r6, #1
        CMP     r6, r4                  ; EOF or past token value?  Cannot possibly happen? Something is
        EXIT    EQ                      ; terribly wrong if this safety valve is used - paranoia?
        CMP     r8, #"#"                ; comment to end of line?
        BNE     %BT10
20
        CMP     r8, #&20
25      LDRCSB  r8, [r6], #1
        BCS     %BT20
30
        CMP     r8, #27
        ADDEQ   r6, r6, #1
        CMPNE   r8, #9
        CMPNE   r8, #31
        BNE     %BT10                   ; don't like this character - treat as end of comment
        LDRB    r8, [r6], #1
        B       %BT20

        ROUT

AllocHashR2R3toR1 Entry "r0,r2-r4"
        ; Generates the hash of the token at address R2 length R3 into R1
        ; R1 is NumBuckets if the symbol contains wildcards, else in the
        ; range 0 to (NumBuckets-1)
        MOV     r1, #0
10      LDRB    r4, [r2], #1
        TEQ     r4, #"?"
       ;TEQNE   r4, #"*"
        MOVEQ   r1, #NumBuckets
        EXIT    EQ
        SUBS    r3, r3, #1
        EORPL   r1, r4, r1, ROR #1
        BPL     %BT10
        EOR     r1, r1, r1, LSR #30
        EOR     r1, r1, r1, LSR #24
        EOR     r1, r1, r1, LSR #12
        EOR     r1, r1, r1, LSR #6
        AND     r1, r1, #(NumBuckets-1)
        EXIT

AllocateInternalBuffer Entry "r8"
        ; Allocate one of MessageTrans's internal buffers from IRQ or foreground pools
        ; depending on the kernel's IRQsema flag.  Returns buffer in R2, length in R3
        ; Used when client does not supply a buffer to *Lookup and in HashTableAlloc
        ; If R2=0 on entry, the IRQsema is checked
        ; If R2=-1 on entry, a foreground buffer is used
        ; R2 anything else will not work
        ; On exit: R2 points to buffer, R3 is buffer size
        MVNS    r3, r2                                  ; R3=0, Z set => force foreground pool
        LDRNE   r3, ptr_IRQsema
        LDRNE   r3, [r3]                                ; If R3<>0 now, R2 must have been 0
        TEQNE   r3, #0                                  ; Z set => force foreground pool
        ADR     r2, ForegroundBuffers
        ADDNE   r2, r2, #Buffersize*ForegroundBuffersNo
        LDREQB  r14, current_ForegroundBuffer
        LDRNEB  r14, current_IRQBuffer
        ADD     r2, r2, r14, LSL #8                     ; Point at correct buffer to use
        ADD     r14, r14, #1
        MOVEQ   r8, #ForegroundBuffersNo
        MOVNE   r8, #IRQBuffersNo
        CMP     r14, r8
        MOVGE   r14, #0
        TEQ     r3, #0
        STREQB  r14, current_ForegroundBuffer
        STRNEB  r14, current_IRQBuffer                  ; And set new buffer number.
        MOV     r3, #Buffersize
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Debugging routines
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      [ debug
        InsertNDRDebugRoutines
      ]

        END
@


4.17
log
@Update to work with zero page relocation
Detail:
  s/MsgTrans - Try OS_ReadSysInfo 6 to get IRQsema pointer before falling back on legacy address. Store pointer in workspace for speedy access.
Admin:
  Tested on rev A2 BB-xM


Version 0.48. Tagged as 'MsgTrans-0_48'
@
text
@d55 1
a55 1
keepstats       SETL   true
d60 11
a70 11
debug           SETL   false
debugswi        SETL   debug :LAND: true
debugxx         SETL   debug :LAND: true
debugenum       SETL   debug :LAND: true
debugservice    SETL   debug :LAND: true
debugerr        SETL   debug :LAND: true
debugintr       SETL   debug :LAND: true
debugFSW        SETL   debug :LAND: true
debughash       SETL   debug :LAND: true
debughashalloc  SETL   debug :LAND: false
debugstats      SETL   debug :LAND: true :LAND: keepstats
d72 2
a73 2
debug_module    SETL    {TRUE}                          ; to use DebugIt
hostvdu         SETL    :LNOT:debug_module
d82 1
a82 1
AltTitleAndSWI  SETL   false
d89 1
a89 1
ChocolateProxies  SETL false
d93 1
a93 1
HashDictionary    SETL true
d1029 1
a1029 1
        Pull    "lr, pc", VS                            ; exit on error
d1770 1
a1770 1
    [ HashDictionary :LAND: true
a1817 3
        [       False
        DCB     "TokenNotFound", 0
        |
a1818 1
        ]
@


4.16
log
@  Backwards-compatibility fix.
Detail:
  MessageTrans_CloseFile will now not clear the file descriptor if the
  file was opened in a local memory block (R2 non-zero) with the old
  API (R3 not a magic value). This restores compatibility with some badly
  behaved applications (e.g. ARPlayer) that do lookups after closing a
  file. Also add a simple check to catch the use of invalid file descriptors
  (such as ones that have been closed), and add a new error message to be
  returned in this case.
  Minor change to MTransTest to help test the above.
Admin:
  Basic testing with MTransTest. Confirmed that ARPlayer now works.


Version 0.47. Tagged as 'MsgTrans-0_47'
@
text
@d38 1
d110 1
d135 2
d261 9
d2508 2
a2509 1
        LDRNE   r3, [ r2, #IRQsema ]                    ; If R3<>0 now, R2 must have been 0
@


4.15
log
@  Fix miscellaneous memory leaks and minor bugs.
Detail:
  - The module now frees (almost) all allocated memory on finalisation and
    can be reinitialised correctly. On finalisation, flg_addtolist is set in
    the flags of the client blocks of all files that had proxy blocks, and this
    causes the files to be reopened if they are used again. Note that any
    hash tables for files opened with the new API and R2 non-zero will be
    left allocated as the module cannot keep track of these. This works as
    everything remains valid, but if the format of the hash table is ever
    changed, and a new module is to be softloaded, the issue of identifying
    hash tables created by a previous version will need to be addressed.
  - When the module has been initialised it now immediately sends out a
    Service_MessageFileClosed. This is to warn that any direct pointers
    into data allocated by a previous MessageTrans are invalid.
  - Avoid calling OS_ServiceCall with r1=0 in our service call handler as
    this does nothing.
  - When MessageTrans_OpenFile was called on a file descriptor that was
    already open, allocated data (proxy, file and hash table) was leaked.
    Open files are now closed before being re-opened. Note that the error
    'Message file already open' will never be returned, though it has been
    left in the messages file for now.
  - All lines in message files can now be terminated by either NUL, CR or LF.
    This was the general rule previously, but there were some explicit
    checks for LF as the terminator of a token which have been removed.
  - The hashing code allowed '*' to be used as a wildcard in tokens in the
    message file, but this is not allowed in the specification or in the normal
    token matching code and so has been commented out.
  - Errors from EnsureFileIsOpen were incorrectly handled in internal_lookup.
  - Fix typo in skiptoken (compare to 32, not 3). This will make
    MessageTrans_MakeMenus behave as documented in allowing tokens in
    the menu block to be terminated by 0, 10 or 13 (rather than just 0).
  - Change HashTableAlloc to take descriptor pointer in R0 rather than R4.
    This avoids internal_lookup corrupting R4 when a hash table is recreated
    by a lookup occurring after a ResourceFS file changed. Previously
    the lookup would return junk when this happened.
  - MessageTrans_CloseFile now wipes the descriptor block so that
    MessageTrans_OpenFile won't get confused if the descriptor is re-used to
    open a different file. Check for null pointer to avoid killing the machine.
  - The fourth word of the 16-byte descriptor blocks was previously listed
    as spare but actually set to point to the filename. This is now required
    to allow file reopening on module reinitialisation to work.
  - Debugging improved. New 'debugswi' flag will print registers on entry to
    and exit from all the SWIs. New 'debughashalloc' flag allows hash table
    allocation debugging to be turned off.
Admin:
  - Service_ModulePostInit is used to trigger sending the initial
    Service_MessageFileClosed, so a kernel supporting this is required.
  - A new test program 'MTransTest' has been added. This allows testing
    of all combinations of file types and open methods.
  - Thoroughly tested with MTransTest as a debug module. Briefly tested in
    a ROM build. All seems well so far.


Version 0.46. Tagged as 'MsgTrans-0_46'
@
text
@d1010 2
a1011 2
        ;TST    r3, #flg_inresourcefs
        ;BEQ    err_invaliddescriptor
d1040 13
a1052 1
        
d1943 1
a1943 1
        EXIT    EQ                                      ; return on null pointer (should return error?)
d1970 3
d1979 3
@


4.14
log
@Fix for tokens of the form notinthefile:defaultstring failing.
This was caused by R4 not being setup on entry to getbyte which then
thought it had fallen off the end of the messages file.

Version 0.45. Tagged as 'MsgTrans-0_45'
@
text
@d42 1
d50 1
d60 1
d68 1
d71 2
a72 2
        GBLL    hostvdu
hostvdu SETL    true
d184 3
a186 3
; client supplies certain guarantees by doing this too, notably: block will be safe (ie. in
; RMA/DA - specifically NOT in application space and NOT on the SVC stack); the client will call
; MessageTrans_CloseFile.  If the client fails to do the latter, the hash table will be leaked.
d203 1
a203 1
fcb_clnt_spare  #       4                               ; spare (but is initialised as pointer to filename)
d259 1
d299 1
a299 1
        Debug   xx,"Global file opened ",r0
d310 6
a315 4
        ;       If the block is a normal ResourceFS block then zero fcb_fileptr
        ;       and set the flg_addtolist so we can restart it OK.
        ;       If the block is buffered by us then zero fcb_fileptr, and set
        ;       the flg_addtolist so we can restart it OK, and free the buffer.
d325 1
d327 2
a328 2
        LDR     r6, link_header
        CMP     r6, #0                                  ; clears V
d330 1
a330 1
        LDR     r14, [ r6, #fcb_link ]                  ; Delete block from chain
d332 14
a346 11
        LDR     r14, [ r6, #fcb_flags ]                 ; Check to see if there is a buffer to release
        ORR     r14, r14, #flg_addtolist                ; Magic to cope with a new MessageTrans
        STR     r14, [ r6, #fcb_flags ]
        TST     r14, #flg_ourbuffer
        LDR     r2, [ r6, #fcb_fileptr ]                ; Old pointer (in case we want to free it)
        STR     r2,  [ r6, #fcb_link ]                  ; Save in case of re-start
        MOV     r0, #0
        STR     r0, [ r6, #fcb_fileptr ]                ; Mark it as 'no valid data'
        BEQ     DieLoop
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
d357 1
d365 1
d374 1
d377 3
d413 4
a416 3
        LDR     r14, [ sp, #4 ]                         ; Get the actual service call type
        TEQ     r14, #Service_ResourceFSDying
        MOVNE   r0, #0                                  ; Don't prod clients on ResourceFS death
d435 17
d464 1
a464 1
        Debug   service, "check_file_moved filename:", r1
d550 12
a671 1
;       If R1 = 0 and R2 != 0, then R4 is the length of the buffer pointed to be R2.
d686 11
a696 2
        Debug   xx,"MessageTrans_OpenFile",r0,r1,r2,r3,r4
        DebugS  xx,"Filename =",r1
d698 1
d701 7
a707 3
        EOR     r6, r6, r5                              ; R6 = 0 if client magic word matched
        LDR     r14, link_header                        ; Check if the block is already in the list
        B       %FT10
d709 2
a710 4
        LDR     r14, [ r14, #fcb_link ]                 ; no - so go around again
10      TEQ     r14, r0
        BEQ     err_alreadyopen
        TEQ     r14, #0
d712 3
a714 6
        TEQ     r6, #0
        BNE     OpenScanLoop                            ; magic word didn't match
        LDR     r4, [ r14, #fcb_flags ]
        TST     r4, #flg_freeblock                      ; was it our block in the chain?
        BEQ     OpenScanLoop                            ; no, so go around again
        LDR     r4, [ r14, #fcb_real_block ]
d716 1
a716 10
        BNE     OpenScanLoop                            ; no
        LDR     r5, [ r0, #fcb_clnt_flags ]             ; get client block flags
        TST     r5, #flg_proxy                          ; proxy flag set?
        BICEQS  r5, r5, #flg_inresourcefs + flg_proxy   ; after here, Z is set if it wasn't a pointer to us
        BNE     OpenScanLoop                            ; bits which we didn't
        LDR     r5, [ r0, #fcb_fileptr ]                ; check the forwards link
        TEQ     r5, r14                                 ; does it match?
        BNE     OpenScanLoop
        ; More than likely that this is a re-entered block if we get to here.
        BEQ     err_alreadyopen
d718 25
d749 2
a750 1
        LDR     r4, stk_buffersize                      ; get caller's R3
d752 1
a752 1
        TEQ     lr, r4
a753 1
        LDREQ   r4, stk_filedesc                        ; R4 -> file descriptor
a759 1
        LDR     r4, stk_buffersize                      ; get caller's R3 again
d761 1
a761 1
        CMP     r14, r4                                 ; was it "SLOW" ?
d763 1
a763 1
        LDRNE   r14, stk_buffer
a769 1
        LDR     r4, stk_filedesc                        ; R4 -> file descriptor
d772 1
d774 1
a774 1
        LDR     r14, stk_buffer
d781 1
a781 1
        Debug   xx, "Copied to RMA OK if neccessary"
a784 1
        Debug   xx, "Make our own buffer"
d787 1
a787 1
        Debug   xx, "ResourceFS data"
d798 1
d805 1
d821 1
d853 2
d864 6
d897 1
a897 1
        ASSERT  fcb_clnt_spare = 12                     ; Store copy of filename pointer for now
d985 40
d1026 15
a1040 4
ErrorBlock_FileOpen
        DCD     ErrorNumber_MessageTrans_FileOpen
        DCB     "FilOpen", 0
        ALIGN
d1063 10
a1072 1
        Push    "r0-r1, r4-r7, r8-r10, lr"
d1077 1
a1077 4
        BNE     %FT01
        BL      SWIMessageTrans_Lookup
        STRVS   r0, [ sp, #0 ]
        Pull    "r0-r1, r4-r7, r8-r10, pc"
a1078 1
01
d1081 2
d1146 11
a1184 1
        Debug   err, "R0 is ", r0
d1252 14
a1265 2
        Debug   enum,"MessageTrans_EnumerateTokens", r0, r1, r2, r3, r4
        DebugS  enum,"Token to match =",r1
d1274 3
a1276 1
        ADD     r3, r3, r14                     ; r3 -> where to scan from
a1296 1
        CMPNE   r8, #10
d1298 2
a1299 1
        BEQ     skiptoken2
a1347 1
        CMPNE   r8, #10
d1349 2
a1350 1
        BNE     skiptoken2
d1373 3
a1375 3
        CMPNE   r8, #10
        STRNEB  r8, [ r2 ], #1
        BNE     %BT35
a1396 47
EnsureFileIsOpen
        ; In    R0 -> data structure
        ; Out   R3 -> pointer to data
        ;       R4 -> pointer to byte after data
        ;       R1, R2 Trashed
        LDR     r3, [ r0, #fcb_fileptr ]
        CMP     r3, #0                                  ; Clears V
        LDRNE   r4, [ r3 ], #4                          ; R4 = size of file + 4
        ADDNE   r4, r4, r3
        SUBNE   r4, r4, #4                              ; R4 -> byte after end of file
        MOVNE   pc, lr                                  ; Return fast in easy case

        ;       Here there is no file, it is one of four possible cases
        ;       The data has been removed by a Service_ResourceFS(Dying|Started)
        ;       If this is the case then just look it up again, this will have the
        ;       Flag set flg_inresourcefs=1, flg_ourbuffer=0, flg_addtolist=0.
        ;       The other three cases all have the flg_addtolist=1

FileIsNotHere
        Push    "r0, lr"
        LDR     r14, [ r0, #fcb_flags ]
        TST     r14, #flg_addtolist
        BNE     ReOpenBlock
        LDR     r1, [ r0, #fcb_filename ]
        Debug   xx, "Reloading file",r1
        BL      internal_fileinfo                       ; load file if not already done
        LDRVC   r0, [ sp, #0 ]                          ; Pointer to data structure
        MOVVC   r3, r2                                  ; Address of data - 4
        STRVC   r3, [ r0, #fcb_fileptr ]                ; R2 -> message data
FileNowOpen
        LDRVC   r4, [ r3 ], #4                          ; R4 = size of file + 4
        ADDVC   r4, r4, r3
        SUBVC   r4, r4, #4                              ; R4 -> byte after end of file
        STRVS   r0, [ sp, #0 ]
        Pull    "r0, pc"

ReOpenBlock
        TST     r14, #(flg_inresourcefs :OR: flg_ourbuffer)
        LDREQ   r2, [ r0, #fcb_link ]
        MOVNE   r2, #0
        LDR     r1, [ r0, #fcb_filename ]
        BL      SWIMessageTrans_OpenFile
        LDRVC   r3, [ r0, #fcb_fileptr ]
        B       FileNowOpen

;......................................................................................

d1433 12
d1458 1
a1458 1
        Debug   xx,"Global file : ", r0
d1478 1
a1478 1
        BVS     %FT98
d1484 1
a1484 1
        STRNE   r1, [r0, #fcb_flags]
a1485 1
        MOVEQ   r4, r0
d1530 6
a1535 6
        CMP     r8, #"*"                                ; wildcard?
        BEQ     %FT77
        CMP     r8, #"/"                                ; also stop if reached end of token
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; if followed by ":", skip to end of line
        BEQ     %BT72                                   ; try next entry
d1543 4
a1546 4
        CMP     r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; token must be followed by ":"
        BNE     %BT72
d1562 4
a1565 2
        MOVLO   r4, r3                                  ; fake the EOF condition for getbyte
        BLLO    getbyte                                 ; get and translate the error message
d1582 4
a1585 4
        CMP     r8, #"/"                                ; also stop if reached end of token
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; if followed by ":", skip to end of line
        BEQ     skiptokens
d1626 4
a1629 4
        CMP     r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; token must be followed by ":"
        BNE     skiptokens
d1863 3
a1865 2
;       R8 = next byte,
;       "Message token not found" error if read past EOF
d1906 1
a1906 1
        DebugS  intr, "error lookup returns ", r1
d1918 10
a1927 1
        Debug   xx,"MessageTrans_CloseFile",r0
d1929 3
a1932 1
        BL      TranslateFindDescriptor
d1943 1
a1943 1
        BL      HashTableDelete
d1947 1
a1947 1
        EXIT    EQ                                      ; ignore it if unknown
a1951 3
        LDR     r2, [ r0, #fcb_fileptr ]
        MOV     r3, #0
        STR     r3, [ r0, #fcb_fileptr ]
d1955 2
a1956 1
        LDR     r14, [ r0, #fcb_flags ]
d1958 1
d1960 12
d1973 1
a1973 1
        MOVEQ   r2, #0                                  ; ensure R2 is set correctly to avoid later test
d1975 2
a1976 1
        STMFD   sp!, {r2}
d1978 1
a1978 1
        BEQ     %FT20
d1990 1
a1990 1
20
d1996 2
a1997 5
        LDMFD   sp!, {r2}

        ADDS    r2, r2, #0                              ; clears V and sets/clears Z appropriately
        EXIT    EQ

a2000 1
        STRVS   r0, [ sp, #0 ]
d2017 11
d2156 1
a2156 2
        CMPNE   r14, #3
2
d2188 12
d2294 1
a2294 1
        ; Allocate space in the hash table.  R4 is our internal descriptor.
a2295 1
        MOV     r0, r4
d2297 1
a2297 1
        LDR     r1, [r4, #fcb_flags]
d2300 1
a2300 1
        STR     r1, [r4, #fcb_flags]
a2302 1
        MOV     r0, r4                                  ; store descriptor in r0
d2349 1
a2349 1
        LDR     r0, [sp, #4*4]                          ; get descriptor back into R0 back again
d2358 1
a2358 1
        Debug   hash, "Bucket,Entries",r3,r0
d2368 1
a2368 1
        LDR     r0, [sp, #4*4]                          ; retrieve entry R4 - our internal descriptor
d2383 1
a2383 1
        Debug   hash, "Storing in bucket",r1
d2388 1
a2388 1
        DebugS  hash, "Storing token", r6
d2391 1
a2391 1
70      LDR     r0, [sp, #4*4]                          ; retrieve client descriptor
d2400 1
a2400 1
        LDR     r0, [sp, #4*4]                          ; get descriptor back into R0 back again
d2426 1
a2426 1
        TEQNE   r8, #"*"
d2455 1
a2455 1
        TEQNE   r4, #"*"
@


4.13
log
@  Takes more care to preserve R0 in SWI MessageTrans_Lookup.
Detail:
  The caller's R0 was being junked if the message had to be looked up in
    the global messages file.  This is contrary to the documentation in
    the PRM.
Admin:
  Not tested - but it builds.
  Might fix Bugzilla bug #4444 - unlikely but possible.


Version 0.44. Tagged as 'MsgTrans-0_44'
@
text
@d34 1
d58 8
a65 8
debugxx         SETL   debug :LAND: false
debugenum       SETL   debug :LAND: false
debugservice    SETL   debug :LAND: false
debugerr        SETL   debug :LAND: false
debugintr       SETL   debug :LAND: false
debugFSW        SETL   debug :LAND: false
debughash       SETL   debug :LAND: false
debugstats      SETL   debug :LAND: false :LAND: keepstats
d68 1
a68 1
hostvdu SETL    false
d1478 3
a1480 1
53      LDRB    r14, [ r8 ], #1
d1485 1
a1485 1
        MOV     r1, r8                                  ; update R1
d2151 1
a2151 1
        ADR     r1, StarToken                           ; we want everything
@


4.12
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.43. Tagged as 'MsgTrans-0_43'
@
text
@d834 1
a834 1
        ; real block's address.
d1317 1
a1317 1
        Push    "lr"
d1321 5
a1325 8
        CMP     r0, #0                                  ; Were we given a message block?
        BEQ     DoGlobalLookup                          ; No, skip straight to global lookup
        Push    "r0-r3"                                 ; Preserve the inputs in case it fails
        BL      TranslateFindDescriptor
        BL      internal_lookup
        LDRVC   r0, [sp], #4                            ; Restore old R0 on success to not confuse client
        ADDVS   sp, sp, #4                              ; Junk old R0 on failure - client will get error block
        ADDVC   sp, sp, #12                             ; Remove the stored input values R1-R3
a1326 1
        Pull    "r1-r3"                                 ; Restore the stored input values R1-R3
d1331 11
a1341 3
        CMP     r0, #0                                  ; Clears V
        BEQ     NoGlobalMessageFile                     ; What an unlikely thing
        Pull    "lr"                                    ; unstack LR and fall through into internal_lookup
@


4.11
log
@  Hash tables are now deleted if the message file is changed in ResourceFS.
Detail:
  Previously, MessageTrans forgot to delete the old hash table when it
    detected that a ResourceFS message file had actually moved, so lookups
    to the new file failed since the old hash table was being used.
Admin:
  Tested in Ursula build.
  Required by Kernel 5.32 for correct operation when softloading a replacement
    Kernel messages file.

Version 0.42. Tagged as 'MsgTrans-0_42'
@
text
@d162 1
a162 5
HelpString      DCB     "MessageTrans", 9, "$Module_MajorVersion ($Module_Date)"
                [ Module_MinorVersion <> ""
                DCB     " $Module_MinorVersion"
                ]
                DCB     0
a299 2
magicnumber     DCB     "FAST"

d621 3
d634 3
d643 1
a643 1
        LDR     r5, magicnumber
d678 1
a678 1
        LDR     lr, magicnumber                         ; get the magic word
d688 5
a692 1
        LDR     r14, stk_buffer
d703 1
d817 1
a817 1
        LDR     r0, magicnumber                         ; get the magic word
a1776 1

@


4.10
log
@  Added new API for direct access to data blocks.
Detail:
  R1=0 on MessageTrans_OpenFile indicates that the message data is
    already in client memory and should be accessed directly (at
    the address pointed to R2+4 - R2+0 is a length word)
  Documentation and a test program for new mode of access added.
Admin:
  Tested with the test program.

Version 0.41. Tagged as 'MsgTrans-0_41'
@
text
@d210 1
d218 1
a218 1
flg_hidden_from_client  *       (2_111111 :SHL: 26)     ; Mask for internal only flags.
d395 2
d425 1
a425 1
        ; The affect of this is that the service call Service_MessageFileClosed does not
d1344 4
a1347 2
    [ :DEF: deferhashcreation
        AND     r8, r1, #flg_hashing :OR: flg_worth_hashing
d1352 1
a1352 1
        BICVS   r1, r1, #flg_worth_hashing :OR: flg_hashing
a1353 1
    ]
@


4.9
log
@  Fixed an amusing stack imbalance in err_buffoverflow.
Detail:
  Any attempt to generate the "Buffer overflow" error message would fail
    due to the lookup routine pushing r1, r2 and lr - but only pulling pc.
  Errors from MessageTrans_EnumerateTokens are now trapped and cause
    building of the hash table to be aborted.  This stops other amusing
    aborts caused by ColourTrans using MessageTrans_OpenFile *PURELY*
    for the effect of getting the file unsqueezed for it.  ColourTrans
    is also disappointed by the private contents of the descriptor not
    matching what it thinks they are any more.  ColourTrans 1.70 and
    later now get things unsquashed via the official mechanism (it asks
    the Squash module ...)
Admin:
  Tested debug build - it no longer aborts if asked to open
   Resources:$.Resources.Colours.Tables.8desktop
  ROM build untested.

Version 0.40. Tagged as 'MsgTrans-0_40'
@
text
@d624 1
d636 1
a636 1
        Debug   xx,"MessageTrans_OpenFile",r0,r1,r2
d669 3
a671 1
        BL      internal_fileinfo                       ; R0 = flags, R2 -> data, R3 = size
d729 4
a732 3
        MOV     r5, r2
        MOV     r2, r14
        BL      OpenFile_LoadIntoBuffer
@


4.8
log
@  Fixed buffer overflow on tokenised lookups.
Detail:
  The token expansion code was not decrementing the buffer length counter
    as it expanded the tokens, which results in a buffer overrun if the
    buffer wasn't large enough to hold the detokenised result.
Admin:
  Reported in news thread on comp.sys.acorn.programmer:
    <PINE.OSF.4.21.0006011352260.13635-100000@@ermine.ox.ac.uk>
    <be18dbc749.sbrodie@@sbrodie.cam.pace.co.uk>
    <lrwbt1l2jjd.fsf@@ermine.ox.ac.uk>
  New test program (LookupToks) verifies that MsgTrans 0.39 fixes the bug
    (and demonstrates the fault in earlier versions (tested in 0.31))

Version 0.39. Tagged as 'MsgTrans-0_39'
@
text
@d965 2
a966 3
        MRS     lr, CPSR
        TST     lr, #2_11100
        Pull    "r0-r1, r4-r7, r8-r10, pc", NE          ; corrupt flags for 32-bit exit
d1144 1
d1961 1
a1961 1
        Pull    "pc"
d2138 1
a2138 1
        EXIT    VS
d2191 1
d2211 12
@


4.7
log
@Fixed stack imbalance in "efficiency improvements".
Module header now builds correctly in 32-bit case.

Version 0.38. Tagged as 'MsgTrans-0_38'
@
text
@d1587 3
a1589 1
        B       %BT04
d1626 5
a1630 3
        STRNEB  r8, [r1], #1
        LDREQB  r8, [r0, #1]!
        BLEQ    expand_tok1
d1632 6
@


4.6
log
@  Replaced AAsm msr and mrs with ObjAsm MSR and MRS
Detial:
  Recent merge was fouled-up a little.
Admin:
  To be tested soon.

Version 0.37. Tagged as 'MsgTrans-0_37'
@
text
@d159 1
a159 1
        DCD     MyModuleFlags    - Module_BaseAddr
d1736 1
a1736 1
        Push    "r1-r6"                                 ; Return frame is now R1-R7, PC
@


4.5
log
@Intermediate checkin - efficiency improvements.  Untested
@
text
@d965 1
a965 1
        mrs    ,lr, CPSR
d1714 1
a1714 1
        msr LO, CPSR_f, #0                              ; V clear, maintains LO condition
@


4.4
log
@  New hashing facilities added to improve lookup times.
  Better debugging support added.
Detail:
  MessageTrans will construct hash tables for all the messages file that
    it thinks are worthwhile (>7 tokens, file is >80 bytes long).  API
    change documentation in Doc/HashingAPI.
  SVC stack tests now removed - proxy blocks are always used unless the
    caller used the new API (R3=FAST) and supplied a buffer in R2 on the
    call to MessageTrans_OpenFile.
  Test programs enhanced to not require the Palette messages file to be
    present - the Switcher messages are used instead.
  ShowMsgs test program now takes -c (show client blocks), -f (show flags
    as character strings) and <search substr> to restrict the output of
    the program to those blocks with filenames which contain the search
    substring.
  The old 16-byte client blocks contain the magic word, a flags word,
    pointer to the proxy block and a spare word.  Currently this spare
    word is filled in with a copy of the pointer to filename.  This is
    done for ShowMsgs benefit only - do not rely on this.  Similarly,
    the 7th word of the 32-byte blocks is used as a counter for the
    number of token lookups performed on that file - this is for testing
    only (to assess how much the hashing is helping) and must not be
    relied on either.
  MessageTrans no longer calls its own SWIs but uses BL to call them
    directly.  Saves SWI call overhead, plus makes the module standalone
    and the debug module tests are useful.
  Debug module capability added.  The debug module uses a different SWI
    name & number chunk and a different title to enable it to be loaded
    and tested without disrupting the rest of the machine.
  Messages re-organised so "Token not found" is the first in the file as
    this is the most commonly looked up message.
  Now built using objasm/link, instead of aasm.
Admin:
  Tested in Ursula ROM images for several weeks.  Test programs show
    data structures as expected.
  Requires link 5.15 (RiscOS/Library; tag Library-0_41 or later)


Version 0.36. Tagged as 'MsgTrans-0_36'
@
text
@d1325 1
a1325 2
        BL      internal_lookup                         ; Look it up again
        Pull    "pc"
d1458 3
a1460 17
        LDR     r3, stk_token
51
        DebugS  intr,"token is: ", r3
        LDRB    r14, [ r3 ], #1
        CMP     r14, #":"                               ; look for ":"
        BEQ     %FT52
        CMP     r14, #32
        BHS     %BT51
        Debug   intr,"no token found, return error"
        SETV                                            ; no default - report error
        B       %FT99


52
        Debug   intr,"default found in string"
        MOV     r4, r3                                  ; R3 -> start of default value
53      LDRB    r14, [ r4 ], #1
d1465 1
a1465 1
        MOV     r1, r4                                  ; update R1
d1717 1
a1717 1
        Push    "r7, lr"                                ; It's an error, get the error message
d1723 1
a1723 1
        MOV     r7, r9                                  ; Copy the token pointer
d1725 1
a1725 1
        LDRB    r14, [ r7 ], #1
d1732 1
a1732 1
        Pull    "r7, pc"
d1749 1
@


4.3
log
@32-bit compatible.

Version 0.35. Tagged as 'MsgTrans-0_35'
@
text
@d15 5
a19 64
; > Sources.MsgTrans

;;----------------------------------------------------------------------------
;; MessageTrans module
;;
;; Change List
;; -----------
;;  2-Nov-89    0.01    File created
;;  7-Nov-89    0.02    Return R1->token terminator from MessageTrans_Lookup
;;                      Also allow <=32, "," or ")" as token terminators
;;  8-Nov-89            Report error if file is opened more than once
;;  8-Nov-89    0.03    Fix bug: R1 was returned as a byte from Lookup!
;; 13-Nov-89    0.04    Skip comment lines correctly
;; 22-Feb-90    0.05    Change to look for fsnumber_resourcefs (not deskfs)
;; 23-Feb-90    0.06    Allow "token:default" in case messages unavailable
;; 10-Jan-91            Implement MessageTrans_EnumerateTokens
;; 11-Jan-91    0.07    Fix bug: Die entry wasn't in module header!
;; 05-Mar-91    0.08    Added MessageTrans_ErrorLookup
;;                      Added workspace allocation
;; 14-Mar-91    0.09    Added MessageTrans_GSLookup.
;; 14-Mar-91    0.10    Added Global messages file.
;;                      Added Message file for MessageTrans errors
;;              0.11    Addd 'token' to message token not found message.
;; 31-May-91    0.12    Fixed bug in Service_TerritoryLoaded
;; 04-Jul-91    0.13    (WStoye) Optimised message lookup - 3.5* faster.
;;              0.14    Copy error number last in error lookup.
;; 26-Aug-91    0.15    Increased number of error buffers to 10.
;; 19-Nov-91    0.16    Allow for lines ending in 0's as well as 10's when
;;                      looking up tokens - the client can do this if it wants.
;;                      Allow 13's as well (consistency only)
;; 24-Jan-92    0.17    Add new SWI; MessageTrans_CopyError
;; 29-Jan-92    0.18    General tidy up, removed all version-conditional
;;                      assembly, ensured that the Service entry was fast,
;;                      made wp constant through out the entire module (i.e.
;;                      it is never used for anything else, removed the funny
;;                      sav_token code by a proper passed pointer so that
;;                      recursion is not a problem, includes initialising it
;;                      from EnumerateTokens so that there isn't an address
;;                      exception after the last token.
;; 04-Feb-92    0.19    Fix bugs in new work.
;; 17-Feb-92    0.20    2 X speed improvement on MessageTrans_Lookup
;; 26-Feb-92    0.21    Handle workspace allocation on initialisation correctly.
;; 11-Mar-92    0.22    Put a limit on the number of internal_fileinfos that can
;;                      be current at any one time.
;; 19-Jul-93    0.24    ECN:
;;                      Add SWI MessageTrans_Dictionary
;;                      Expand messages when looking up into a buffer using
;;                      OS_PrettyPrint style detokenisation.
;;                      Allow Tab (9), Hard space (31) and <ESC><N> in messages.
;; 09-Aug-93    0.25    Bruce Cockburn;
;;                      Fixed stack imbalance problem in GSLookup.
;; 02-Sep-93    0.26    ECN:
;;                      Fixed token expansion so <ESC>0 substitutes the string pointed
;;                      to by R4. Similar to %0 substitution.
;; 01-Feb-94    0.27    JSR:
;;                      Increased number of foreground message buffers to 16 (was 10)
;; 01-Mar-94    0.28    amg:
;;                      Defer the call to MessageTrans_Dictionary in the token expansion
;;                      until it is actually needed. The overhead of the call was making
;;                      it run unacceptably slowly on 3.10.
;;
;;----------------------------------------------------------------------------

Module_BaseAddr
d47 8
a54 1
        GBLL    svcstkdescr                             ; Copy SVC stack based descriptors to RMA if true
d63 2
a64 1
svcstkdescr     SETL   true
d69 20
d96 8
a103 2
current_ForegroundBuffer        #       4
current_IRQBuffer               #       4
d107 4
a110 4
ThreadNess                      #       4
        [ svcstkdescr
SVCSTK_size                     #       4
        ]
d113 9
a124 1

a125 1

d128 1
d138 1
a138 1
        LEADR   Module_LoadAddr
d140 1
a140 1
        ASSERT  (.=Module_BaseAddr)
d149 3
d153 1
d158 3
a160 3
  [ :LNOT: No32bitCode
        DCD     MyFlags          - Module_BaseAddr
  ]
a161 1
TitleString     DCB     "MessageTrans", 0
d169 4
a172 1
  [ :LNOT: No32bitCode
d174 1
a174 1
  ]
d180 7
d189 1
a189 1
fcb_flags       #       4
d192 4
d198 8
d209 4
a212 1
        [ svcstkdescr
d214 1
a214 2
flg_ourdescriptor       *       1 :SHL: 30              ; indirect messageblock - fcb_fileptr points to RMA descriptor
        ]
d217 4
a221 3
        [ svcstkdescr
OldSVCStackSize         *       8192                    ; Ursula kernels will supply the correct absolute address
        ]
d226 1
a226 1
Init    ENTRY
d240 6
a245 14
        [ svcstkdescr
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #16                         ; Ursula: read top of SVC stack call
        SWI     XOS_ReadSysInfo
        MOV     r0, sp, LSR #20
        MOVVS   r2, #OldSVCStackSize
        ADDVSS  r2, r2, r0, LSL #20             ; clears V
        TEQ     r2, #0
        MOVEQ   r2, #OldSVCStackSize
        SUBNE   r2, r2, r0, LSL #20             ; calculate stack size
        STR     r2, SVCSTK_size
        ]

d248 2
a249 2
        STR     r0, current_ForegroundBuffer
        STR     r0, current_IRQBuffer
d253 1
a253 1
        STR     r0, ThreadNess
a256 1

d272 1
a272 1
AttemptOpenMessagesFiles Entry "r0-r2"
d279 1
d291 1
d303 2
d316 1
a316 1
Die     ENTRY
d360 1
a361 2

        MOV     r0,r0                          ;magic instruction
d379 1
a379 1
        Push    "r0-r1, lr"
d382 1
a382 1
        LDR     r14, link_header                        ; Look at the head of the chain
d384 2
a385 1
        TEQ     r14, #0
d387 2
a388 1
        LDR     r0, [ r14, #fcb_flags ]
d390 1
d393 2
a394 2
        STRNE   r0, [ r14, #fcb_fileptr ]               ; Mark data as 'not there'
        LDR     r14, [ r14, #fcb_link ]
d417 20
a436 1
        Pull    "r0-r1, pc"
d444 1
d446 1
d472 1
d474 3
d497 1
a497 1
        SWI     XMessageTrans_ErrorLookup
d515 1
a515 1
SWIMessageTrans_FileInfo ENTRY "r3"
d518 1
a518 6
        [ svcstkdescr
        BICVC   r0, r0, #(flg_ourdescriptor :OR: flg_freeblock :OR: flg_sqshinresourcefs)
                                                        ; flags not for external consumption
        |
        BICVC   r0, r0, #flg_sqshinresourcefs           ; flag not for external consumption
        ]
d523 1
a523 1
; .............................................................................
d538 1
a538 1
internal_fileinfo ENTRY "r1,r4-r6"
d540 1
a540 1
        LDR     lr, ThreadNess
d545 1
a545 1
        STR     lr, ThreadNess
d590 2
a591 1
95      MOV     r5, pc
d596 1
a596 1
        TEQVCP  r5, #0
d598 1
a598 1
        Debug   xx,"Result: r0, r2 =", r0, r2
d602 1
a602 1
        LDR     lr, ThreadNess
d604 1
a604 1
        STR     lr, ThreadNess
d620 12
d638 3
d642 1
d644 2
a645 1
        TEQ     r14, r0
d648 15
a662 1
        LDRNE   r14, [ r14, #fcb_link ]
d664 2
d667 1
d669 19
a687 1
        BVS     ExitOpenFile
d690 1
a690 1
        STR     r0, [ r4, #fcb_flags ]
d693 1
a693 2
        LDR     r14, stk_buffer
        TEQ     r14, #0                                 ; If client buffer supplied,
d696 8
d706 1
a709 3
        [ svcstkdescr
        BLVC    CopyDescriptorToRMA                     ; make duplicate of block in RMA if needed - updates R4
        ]
d713 3
d717 2
d752 15
a766 1
        B       ExitOpenFile
d773 1
a773 1
        SWI     XMessageTrans_ErrorLookup
d777 18
a794 17
        [ svcstkdescr

        ; This routine examines the position of the client's supplied 4-word buffer to make sure
        ; that it isn't on the SVC stack.  It if isn't then all is left alone.  Otherwise, a new
        ; descriptor is grabbed from the RMA and the client's block is reset to be marked to point
        ; to the (safe) proxy RMA block.  The client's flags have flg_ourdescriptor set.
        ; Our real blocks have flg_freeblock set.

CopyDescriptorToRMA EntryS "r0-r3,r6"

        MOV     r0, sp, LSR #20
        SUBS    r0, r4, r0, LSL #20                     ; subtract base of SVC stack from descriptor
        LDRHS   r3, SVCSTK_size                         ; get size of SVC mode stack
        RSBHSS  r0, r0, r3                              ; was it between that and the top of the stack?
        EXITS   LO                                      ; it wasn't - so we won't bother copying this one


d798 1
a798 4
        EXITS   VS                                      ; OK - leave it then

        Debug   xx,"CopyToRMA *PERFORMING COPY* to RMA block",r2

d800 15
a814 5
        ORR     r1, r1, #flg_ourdescriptor              ; Set flag that we allocated this block
        STR     r1, [ r4, #fcb_flags ]
        STR     r2, [ r4, #fcb_fileptr ]                ; link back to internal descriptor
        EOR     r1, r1, #flg_freeblock :OR: flg_ourdescriptor   ; set flg_freeblock, clears flg_ourdescriptor
        STMIA   r2, {r0,r1,r3,r5}                       ; copy information to our own internal descriptor
d816 1
a816 2
        EXITS                                           ; and return.

d822 1
a822 1
        ; real block 'saddress.
d825 3
a827 3
        LDRNE   r1, [ r0, #fcb_flags ]                  ; get flags from descriptor block
        TSTNE   r1, #flg_ourdescriptor                  ; was it a proxy?
        LDRNE   r0, [ r0, #fcb_fileptr ]                ; It was - follow the proxy link
a829 2
        ]

d839 1
a839 1
OpenFile_LoadIntoBuffer Entry "r1-r5"
d878 3
d924 2
a925 1
        SWIEQ   XMessageTrans_Lookup
d927 1
a927 2
        Pull    "r0-r1, r4-r7, r8-r10, pc", VS
        Pull    "r0-r1, r4-r7, r8-r10, pc", EQ
d929 1
d948 1
a948 1
        SWI     XMessageTrans_Lookup                    ; Go find the message
a979 2
GSTransIsOK

d1001 1
a1001 1
        BNE     %FT01                                   ; There is a buffer supplied
a1002 22
        MOV     r14, #0
        LDR     r14, [ r14, #IRQsema ]
        CMP     r14, #0
        ADREQ   r2, ForegroundBuffers
        ADRNEL  r2, IRQBuffers
        LDREQ   r14, current_ForegroundBuffer
        LDRNE   r14, current_IRQBuffer
        ADD     r2, r2, r14, ASL #8                     ; Point at correct buffer to use
        ADD     r14, r14, #1
        MOVEQ   r8, #ForegroundBuffersNo
        MOVNE   r8, #IRQBuffersNo
        CMP     r14, r8
        MOVGE   r14, #0
        MOV     r8, #0
        LDR     r8, [ r8, #IRQsema ]
        CMP     r8, #0
        STREQ   r14, current_ForegroundBuffer
        STRNE   r14, current_IRQBuffer                  ; And set new buffer number.
        MOV     r3, #Buffersize

        Debug   err,"Using buffer at ",r2
01
d1020 1
a1020 1
        SWI     XMessageTrans_Lookup                    ; Get the translation
d1036 1
a1036 1
SWIMessageTrans_CopyError Entry "r9"
d1040 4
a1043 17
        MOV     r14, #0
        LDR     r14, [ r14, #IRQsema ]
        CMP     r14, #0
        ADREQ   r9, ForegroundBuffers
        ADRNEL  r9, IRQBuffers
        LDREQ   r10, current_ForegroundBuffer
        LDRNE   r10, current_IRQBuffer
        ADD     r9, r9, r10, ASL #8                     ; Point at correct buffer to use
        ADD     r10, r10, #1
        MOVEQ   r11, #ForegroundBuffersNo
        MOVNE   r11, #IRQBuffersNo
        CMP     r10, r11
        MOVGE   r10, #0
        CMP     r14, #0
        STREQ   r10, current_ForegroundBuffer
        STRNE   r10, current_IRQBuffer                  ; And set new buffer number.
        MOV     r10, #Buffersize - 4
d1045 2
a1046 2
; Now R9 -> Buffer to use
;     R10 ~= Buffer Size
d1048 1
a1048 1
        Debug   err,"Using buffer at ", r9
a1049 1
        MOV     r11, r9
d1051 1
a1051 1
        STR     r14, [ r11 ], #4
d1054 2
a1055 2
        DECS    r10
        STREQB  r10, [ r11 ]                            ; Terminate when buffer is about to overflow
d1057 1
a1057 1
        STRNEB  r14, [ r11 ], #1
d1062 1
a1062 1
        MOV     r0, r9
d1080 3
a1094 1
        [ svcstkdescr
a1095 1
        ]
d1160 1
a1160 1
        SWI     XMessageTrans_ErrorLookup
a1209 1
        [ svcstkdescr
a1210 1
        ]
d1220 1
a1220 1
;.....................................................................................
d1246 1
d1267 1
a1267 1
;.....................................................................................
a1310 1
        [ svcstkdescr
a1312 3
        |
        Push    "r1-r3"                                 ; Preserve the inputs in case it fails
        ]
a1313 1
        [ svcstkdescr
a1315 1
        ]
d1321 1
d1328 1
a1328 5
NoGlobalMessageFile
        XError  TokenNotFound
        Pull    "pc"

internal_lookup ENTRY "r0-r9"
d1337 86
d1467 1
d1610 5
d1616 8
d1634 1
d1644 14
a1657 1
;..............................................................................
d1715 1
a1715 10
;..............................................................................
ErrorBlock_TokenNotFound
        DCD     ErrorNumber_MessageTrans_TokenNotFound
        [       False
        DCB     "TokenNotFound", 0
        |
        DCB     "TokNFnd", 0
        ]
        ALIGN

d1759 1
a1759 1
        SWI     XMessageTrans_ErrorLookup
d1772 1
a1772 1
SWIMessageTrans_CloseFile ENTRY "r0-r2"
a1776 1
        [ svcstkdescr
d1778 11
a1788 1
        ]
d1798 2
a1799 2
        MOV     r14, #0
        STR     r14, [ r0, #fcb_fileptr ]
a1802 1
        [ svcstkdescr
d1804 2
d1810 15
d1828 1
d1830 1
a1831 3
        |
        TEQ     r2, #0                                  ; no file data to delete
        ]
a1833 4
        [ :LNOT:svcstkdescr
        LDR     r14, [ r0, #fcb_flags ]                 ; delete file block if allocated
        TST     r14, #flg_ourbuffer                     ; client buffers not included
        ]
d1852 1
a1852 1
SWIMessageTrans_MakeMenus ENTRY "r1, r4-r11"
a1855 1
        [ svcstkdescr
a1856 1
        ]
d1964 1
a1964 1
        SWI     XMessageTrans_ErrorLookup
d1972 1
a1972 1
;.....................................................................................
d1977 1
a1977 1
skiptoken ENTRY
d1988 1
a1988 1
;.....................................................................................
d1999 1
a1999 1
int_lookup_nopars ENTRY "r4-r7"
d2005 1
a2005 1
        SWI     XMessageTrans_Lookup
d2012 26
d2048 250
a2307 1

@


4.2
log
@Ursula and Spinner branches merged.
Changed to use srccommit.

Version 0.34. Tagged as 'MsgTrans-0_34'
@
text
@d171 3
a173 1
        DCD     0
d183 4
d255 2
a256 1
        EXITS
d284 2
a285 2
        TEQ     r0, #0
        EXITS   NE
d294 2
a295 1
        EXITS
d318 2
a319 2
        TEQ     r6, #0
        EXITS   EQ
d680 1
a680 1
CopyDescriptorToRMA Entry "r0-r3,r6"
d716 1
a716 1
        EXITS
d759 2
a760 1
        Push    "r0,pc"
d766 2
a767 2
        Pull    "r0,lr"
        TEQP    pc, lr
d850 5
d1466 1
a1466 1
        LDMCCIA sp!, {r0, pc}^
d1469 1
a1469 1
        LDMEQIA sp!, {r0, pc}^
d1530 3
a1532 2
        MOVCCS  pc, lr
        B       getbyte
d1554 1
d1556 4
d1610 2
a1611 2
        TEQ     r1, #0
        EXITS   EQ                                      ; ignore it if unknown
@


4.2.2.1
log
@  Hashing added.
  32-bit compatible.
Detail:
  MessageTrans will construct hash tables for message files in order
    to improve token lookup times.  Preliminary testing shows that
    lookup speeds can be up to 9 times faster in some cases. Primary
    beneficiaries of the hash strategy are FileSwitch, the Internet
    module and MessageTrans itself for the Global messages file.
    Cost is 264+4t bytes (where t = number of tokens in the file) and
    a minor performance penalty on the one-off construction of the
    hash table when the file is first opened.
  Test build capability added.  When the AltTitleAndSWI variable is
    set to true, the module builds with a different module name, SWI
    chunk name and SWI chunk number - thus allowing it to be softloaded
    on a machine and tested without interfering with the module which
    is controlling the rest of the system's message lookups.
Admin:
  Testing ongoing.  Test builds are running in desktop OS builds
    for an extended period of testing before this change is committed
    to the trunk.

Version 0.34, 4.2.2.1. Tagged as 'MsgTrans-0_34-4_2_2_1'
@
text
@d48 1
a48 1
;;                      made wp constant through out the entire module (i..e.
d106 1
a106 1
        GBLL    debughash
d115 1
a115 1
debughash       SETL   debug :LAND: false
a119 8
; The following macro is provided for assistance debugging MessageTrans.
; By setting it to true, the module title changes to DbgMessageTrans and
; the SWI chunk prefix changes similarly, the SWI chunk changes to &C0E00
; This enables it to be softloaded on a RISC OS machine without confusing
; all the applications and modules relying on MessageTrans services.
        GBLL    AltTitleAndSWI
AltTitleAndSWI  SETL   false

d129 2
a130 2
MessageFile_block               #       8*4
GlobalMessageFile_block         #       8*4
d133 3
d141 1
d143 1
a145 1
; These two must appear consecutively in the workspace
a165 3
        [ AltTitleAndSWI
        DCD     &C0E00
        |
a166 1
        ]
d171 1
a171 1
        DCD     MyModuleFlags    - Module_BaseAddr
d173 1
d187 1
a187 1
fcb_flags       #       4                               ; flags in proxy blocks
a189 3
fcb_hash        #       4                               ; hash table (if fcb_flags & flg_hashing)
fcb_clnt_block  #       4                               ; pointer back to client's block
fcb_reserved    #       8                               ; reserved for future use
a191 8
                ^       0
fcb_clnt_magic  #       4                               ; magic word in client's proxy block
fcb_clnt_flags  #       4                               ; flags in the client's block
fcb_real_block  #       4                               ; pointer to proxy descriptor
fcb_clnt_spre2  #       4                               ; spare in client's proxy block
fcb_clnt_size   #       0


d195 1
a195 4

flg_new_api             *       1 :SHL: 26              ; client set R3 to magic value on OpenFile SWI
flg_worth_hashing       *       1 :SHL: 27              ; set if MessageTrans_OpenFile feels it's worth it
flg_hashing             *       1 :SHL: 28              ; the client's hash table pointer is valid
d197 2
a198 1
flg_proxy               *       1 :SHL: 30              ; fcb_fileptr points to our own descriptor
a200 4
flg_hidden_from_client  *       (2_111111 :SHL: 26)     ; Mask for internal only flags.

MinimumHashableFileSize *       1                       ; minimum file size to enable hashing
MinimumTokenCount       *       1                       ; number of tokens required to enable hashing
d202 3
d223 14
d248 2
a249 2
        CLRV
        EXIT
d263 1
a263 1
AttemptOpenMessagesFiles Entry "r0-r3"
a269 2
        DebugS   xx,"Opening MsgTrans message file", r1
        LDR     r3, magicnumber
d277 2
a278 2
        CMP     r0, #0                                  ; clears V
        EXIT    NE
a280 1
        DebugS   xx,"Opening global message file", r1
a281 1
        LDR     r3, magicnumber
d287 1
a287 2
        CLRV
        EXIT
a290 2
magicnumber     DCB     "FAST"

d310 2
a311 2
        CMP     r6, #0                                  ; clears V
        EXIT    EQ
d346 2
a348 1
        Debug   service,"Service call entry: R0,R1,R2 =", r0, r1, r2
a402 6

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module flags.  Bit 0 set means module is 32-bit aware and safe
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MyModuleFlags   DCD     1       ; 32-bit OK

a408 1
        [ :LNOT: AltTitleAndSWI
a409 1
        ]
a434 1
TitleString
a435 3
        [ AltTitleAndSWI
        DCB     "Dbg"
        ]
d456 1
a456 1
        BL      SWIMessageTrans_ErrorLookup
d477 6
a482 1
        BICVC   r0, r0, #flg_hidden_from_client         ; flags not for external consumption
d487 1
a487 1
; ..............................................................................
d502 1
a502 1
internal_fileinfo ENTRY "r1,r4-r7"
d554 1
a554 2
95      MVNVS   r7, #1 << 31
        MOVVC   r7, #0
d559 1
a559 1
        ADDS    r7, r7, #1                              ; preserve V
d561 1
a561 1
        Debug   xx,"Result: r0, r2, r3 =", r0, r2, r3
a582 12
;       If R3 = the constant "FAST" then the client is assumed
;             to have allocated a 32-byte block and guarantees to
;             call MessageTrans_CloseFile to allow us to free the
;             hash table.


; Conditions for setting flg_worth_hashing:
;  "File is large enough" AND
;   ("Client used new API with magic constant in R3" OR "Client did not supply a buffer in R2")

; Conditions for generating a proxy block:
;  "Client did not supply a buffer in R2"
a588 3
        LDR     r6, [ r0, #fcb_clnt_magic ]             ; read the client's magic word
        LDR     r5, magicnumber
        EOR     r6, r6, r5                              ; R6 = 0 if client magic word matched
a589 1
        B       %FT10
d591 1
a591 2
        LDR     r14, [ r14, #fcb_link ]                 ; no - so go around again
10      TEQ     r14, r0
d594 1
a594 15
        BEQ     %FT20                                   ; OK - didn't find it
        TEQ     r6, #0
        BNE     OpenScanLoop                            ; magic word didn't match
        LDR     r4, [ r14, #fcb_flags ]
        TST     r4, #flg_freeblock                      ; was it our block in the chain?
        BEQ     OpenScanLoop                            ; no, so go around again
        LDR     r4, [ r14, #fcb_real_block ]
        TEQ     r4, r0                                  ; back pointer matches?
        BNE     OpenScanLoop                            ; no
        LDR     r5, [ r0, #fcb_clnt_flags ]             ; get client block flags
        TST     r5, #flg_proxy                          ; proxy flag set?
        BICEQS  r5, r5, #flg_inresourcefs + flg_proxy   ; after here, Z is set if it wasn't a pointer to us
        BNE     OpenScanLoop                            ; bits which we didn't
        LDR     r5, [ r0, #fcb_fileptr ]                ; check the forwards link
        TEQ     r5, r14                                 ; does it match?
a595 2
        ; More than likely that this is a re-entered block if we get to here.
        BEQ     err_alreadyopen
a596 1
20
d598 1
a598 16
        BVS     ExitOpenQuick                           ; sorry - a problem occurred

        LDR     r4, stk_buffersize                      ; get caller's R3
        LDR     lr, magicnumber                         ; get the magic word
        TEQ     lr, r4
        ORREQ   r0, r0, #flg_new_api+flg_worth_hashing  ; remember new API used.
        LDREQ   r4, stk_filedesc                        ; R4 -> file descriptor
        MOVEQ   lr, #0
        STREQ   lr, [r4, #fcb_clnt_block]               ; zero the back pointer

        LDR     r14, stk_buffer
        CMP     r14, #0
        ORREQ   r0, r0, #flg_worth_hashing

        CMP     r3, #MinimumHashableFileSize            ; big enough to considering hashing this file?
        BICCC   r0, r0, #flg_worth_hashing              ; no - so forget that we'd like to do it
d601 1
a601 1
        STR     r0, [ r4, #fcb_clnt_flags ]
d604 2
a605 1
        CMP     r14, #0                                 ; always clears V
a607 8
        BL      CopyDescriptorToRMA                     ; allocate a new descriptor, changes R4
        BVS     ExitOpenQuick                           ; failed to claim memory

        Debug   xx, "Copied to RMA OK if neccessary"
        ; By now, R4 points to our own RMA proxy block if necessary, or the original
        ; client's block pointer.

        Debug   xx, "Make our own buffer"
a609 1
        Debug   xx, "ResourceFS data"
d613 3
a619 2
        BLVC    HashTableAlloc                          ; allocate and construct the hash table if wanted
ExitOpenQuick
d653 1
a653 1
        B       ExitOpenQuick
d664 17
a680 1
CopyDescriptorToRMA Entry "r0-r3,r5,r6,r7"
d684 4
a687 1
        EXIT    VS                                      ; OK - leave it then
d689 5
a693 9
        ORR     r1, r1, #flg_proxy                      ; Set flag that we allocated this block
        STR     r1, [ r4, #fcb_clnt_flags ]             ; Store flag so TranslateFindDescriptor knows about it
        STR     r2, [ r4, #fcb_real_block ]             ; link from client descriptor to our new descriptor
        EOR     r1, r1, #flg_freeblock :OR: flg_proxy   ; set flg_freeblock, clears flg_proxy
        LDR     r6, magicnumber                         ; get the magic word
        STR     r6, [ r4, #fcb_clnt_magic ]             ; store the magic word
        MOV     r6, #0                                  ; hash table pointer set to 0
        MOV     r7, r2                                  ; backwards pointer to client block
        STMIA   r2, {r0,r1,r3,r5,r6,r7}                 ; copy information to our own internal descriptor
d695 2
a696 1
        EXIT                                            ; and return.
d702 1
a702 1
        ; real block's address.
d705 6
a710 4
        LDRNE   r1, [ r0, #fcb_clnt_flags ]             ; get flags from descriptor block
        TSTNE   r1, #flg_proxy                          ; was it a proxy?
        LDRNE   r0, [ r0, #fcb_real_block ]             ; It was - follow the proxy link
        EXIT
d721 1
a721 1
OpenFile_LoadIntoBuffer Entry "r1-r6"
d751 1
a751 3
        MVNVS   r5, #1<<31
        MOVVC   r5, #0
        Push    "r0"
d757 2
a758 2
        Pull    "r0"
        ADDS    r5, r5, #1                              ; restore V
d802 1
a802 2
        BNE     %FT01
        SWI     XMessageTrans_Lookup
d804 2
a805 1
        Pull    "r0-r1, r4-r7, r8-r10, pc"
a806 1
01
a840 3
 [ No26bitCode
        Pull    "r0-r1, r4-r7, r8-r10, pc"              ; corrupt flags
 |
a842 1
 ]
d852 2
d875 21
a895 1
        BLEQ    AllocateInternalBuffer                  ; R2=0 means check IRQsema
d897 2
d932 1
a932 1
SWIMessageTrans_CopyError Entry "r1-r3"
d936 17
a952 4
        MOV     r2, #0                                  ; look at IRQsema
        BL      AllocateInternalBuffer
        SUB     r3, r3, #4
        MOV     r1, r2                                  ; Keep copy for exit
d954 2
a955 2
; Now R2 -> Buffer to use
;     R3 ~= Buffer Size
d957 1
a957 1
        Debug   err,"Using buffer at ", r2
d959 1
d961 1
a961 1
        STR     r14, [ r2 ], #4
d964 2
a965 2
        DECS    r3
        STREQB  r3, [ r2 ]                              ; Terminate when buffer is about to overflow
d967 1
a967 1
        STRNEB  r14, [ r2 ], #1
d972 1
a972 1
        MOV     r0, r1
a989 3
; NOTE: Absolutely do not change the meaning of R4.  The hash table construction
;       code relies on it being an index into the file data.

d1002 1
d1004 1
d1119 1
d1121 1
d1131 1
a1131 1
;......................................................................................
d1177 1
a1177 1
;......................................................................................
d1221 1
d1224 3
d1228 1
d1231 1
a1236 1
        BL      TranslateFindDescriptor
d1243 5
a1247 1
internal_lookup ENTRY "r0-r10"
a1255 71
        LDR     r1, [r0, #fcb_flags]
        TST     r1, #flg_hashing
        LDRNE   r8, [r0, #fcb_hash]
        TEQNE   r8, #0
        BEQ     findtoken                               ; no hash table, behave as before

        Debug   hash, "Looking up in hash table"

        Push    "r2,r3,r8"
        MOV     r1, r9                                  ; token we are searching for
        MOV     r2, r9
        MOV     r3, #0                                  ; length of the token
71      BL      get_R0_R1
        ADDHI   r3, r3, #1
        BHI     %BT71
        BL      AllocHashR2R3toR1
        Debug   hash, "Hash value",r1
        CMP     r1, #NumBuckets
        Pull    "r2,r3,r8",EQ
        BEQ     findtoken                               ; wildcarded :-(   We don't do those
        MOV     r7, r1                                  ; remember which hash chain for later
        LDR     r2, [r8, r7, LSL #2]!                   ; retrieve address of first hash entry
        LDR     r10, [r8, #4]                           ; get terminator
        Debug   hash, "Hash chain at address",r2
72
        MOV     r1, r9
        CMP     r2, r10                                 ; finished this list?
        BEQ     %FT78                                   ; done
        LDR     r3, [r2], #4                            ; get next hash entry
        Debug   hash, "Next hash address", r3
73
        BL      get_R0_R1
        BLS     %FT76                                   ; terminator?  this could be it!
        BL      getbyte
        BVS     %BT72                                   ; error? next!
        CMP     r8, #"*"                                ; wildcard?
        BEQ     %FT77
        CMP     r8, #"/"                                ; also stop if reached end of token
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; if followed by ":", skip to end of line
        BEQ     %BT72                                   ; try next entry
        CMP     r8, #"?"
        CMPNE   r8, r0
        BEQ     %BT73
        B       %BT72

76      BL      getbyte
        BVS     %BT72                                   ; no
        CMP     r8, #"/"                                ; "/" or newline => alternatives
        CMPNE   r8, #10
        CMPNE   r8, #":"                                ; token must be followed by ":"
        BNE     %BT72
77
        LDR     r2, [sp], #12                           ; restore r2, trash stacked r3 & r8
        B       %FT31                                   ; we got it!

78
        Debug   hash, "Need to look down wildcard chain if r7 != 00000040.  r7 is", r7
        TEQ     r7, #NumBuckets                         ; which chain have we just searched?
        MOVNE   r7, #NumBuckets                         ; so we know next time we've tried the wildcard chain
        LDRNE   r8, [sp, #8]                            ; get hash table header pointer back
        ADDNE   r8, r8, #NumBuckets*4                   ; point at wildcard chain header
        LDMNEIA r8, {r2,r10}                            ; load wildcard chain head and terminator words
        TEQNE   r2, r10                                 ; quick pre-check to see if chain is empty
        BNE     %BT72                                   ; try wildcard chain if it's not empty
        LDR     r2, [sp], #12                           ; already tried wildcard token list, restore R2, trash r3,r8
        CMP     r0, #&100                               ; LO if we don't have the proper error message yet (R0 is a char)
        MOVLO   r4, r3                                  ; fake the EOF condition for getbyte
        BLLO    getbyte                                 ; get and translate the error message
        B       %FT98                                   ; and give up

a1299 1
        Debug   intr,"no token found, return error"
d1452 1
a1452 1
        LDMCCIA sp!, {r0, pc}
d1455 1
a1455 1
        LDMEQIA sp!, {r0, pc}
d1462 1
a1462 14
NoGlobalMessageFile
        XError  TokenNotFound
        Pull    "pc"

ErrorBlock_TokenNotFound
        DCD     ErrorNumber_MessageTrans_TokenNotFound
        [       False
        DCB     "TokenNotFound", 0
        |
        DCB     "TokNFnd", 0
        ]
        ALIGN

;...............................................................................
a1515 3
 [ No26bitCode
        MOVCC   pc, lr
 |
a1516 1
 ]
d1519 10
a1528 1
;...............................................................................
a1537 5
 [ No26bitCode
        LDRLOB  r8, [ r3 ], #1                          ; Yes, so read the byte
        msr LO, CPSR_f, #0                              ; V clear, maintains LO condition
        MOVLO   pc, lr
 |
a1539 1
 ]
d1580 1
a1580 1
SWIMessageTrans_CloseFile ENTRY "r0-r3"
d1585 1
d1587 1
a1587 1
        BL      HashTableDelete
d1590 1
a1590 4
        CMP     r1, #0                                  ; clear V
 [ No26bitCode
        EXIT    EQ                                      ; ignore it if unknown
 |
a1591 1
 ]
d1597 2
a1598 2
        MOV     r3, #0
        STR     r3, [ r0, #fcb_fileptr ]
d1602 1
a1603 2
        LDR     r1, stk_filedesc                        ; get original client block (may = R0 though)
        STR     r3, [ r1, #fcb_clnt_magic ]             ; blat the magic word
d1613 3
d1618 4
d1644 1
d1646 1
d1762 1
a1762 1
;......................................................................................
d1778 1
a1778 1
;......................................................................................
d1795 1
a1795 1
        BL      SWIMessageTrans_Lookup
a1813 249
; Hashing routines
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; The hash tables are pretty simple.  There are 64 main buckets plus a special
; bucket for tokens containing wildcards.  The data structure allocated from the
; RMA has the following structure (specified in C for clarity only)

; struct {
;   struct {
;     char **list;
;   } buckets[64 + 1 + 1];    /* buckets + wildcards + terminator */
;   char *token[number_of_tokens_in_file];
; } hashtable;

; Each entry in hashtable.token is a direct pointer into the messages file.

; hashtable.buckets[n].list points to the first entry in hashtable.token for a
; token which has a hash value of n.  All subsequent entries have the same hash
; value up to but excluding the entry to which hashtable.buckets[n+1].list
; points.  All the entries in buckets[].list are valid.  Empty buckets are
; signified by buckets[n+1].list having the same value as buckets[n].list.  The
; wildcard bucket (hashtable.buckets[64].list) works in the same way -
; terminating bucket #63 and marking the first entry in the wildcard bucket (ie
; bucket #64).   The terminator word (hashtable.buckets[65].list) is used as
; the terminator for bucket #64 only.

; sizeof(hashtable) will always be 264 + (4 * tokens).

; AllocHashR2R3toR1 generates the bucket number (0-63) for a normal token, or
; 64 for a wildcarded token.  Thus to lookup a token, calculate the hash value
; and search the appropriate bucket, then if not found, search the wildcard
; bucket, then if not found fail the lookup.  Unfortunately, you cannot do
; anything but a sequential file search if the client asks to lookup something
; with a wildcard in it - but this should be extremely rare.

NumBuckets      *       64                              ; MUST be a power of two
        ASSERT (NumBuckets * 4) <= Buffersize           ; must fit in a _kernel_oserror

HashTableDelete ENTRY "r0-r3"
        ; Delete the hash table in the descriptor pointed to by R0
        ; Preserves all registers; corrupts all flags.
        ; Must not write pointer unless we were hashing in case it was a
        ; small non-proxied descriptor.
        Debug   hash, "HashTableDelete", r0
        LDR     r2, [r0, #fcb_flags]                    ; check flags
        TST     r2, #flg_hashing                        ; hashing enabled?
        EXIT    EQ                                      ; no - don't touch hash pointer
        MOV     r1, #0
        BIC     r2, r2, #flg_hashing                    ; clear hash enable
        STR     r2, [r0, #fcb_flags]                    ; store flags
        LDR     r2, [r0, #fcb_hash]                     ; find location of table
        STR     r1, [r0, #fcb_hash]                     ; mark unused whatever
        TEQ     r2, #0                                  ; got a hash table?
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module                              ; release hash table
        EXIT

HashTableAlloc ENTRY "r0-r11"
        ; Allocate space in the hash table.  R4 is our internal descriptor.
        ; Preserves all registers.  Corrupts NZC, V clear if OK, V set on error
        MOV     r0, r4
        BL      HashTableDelete
        LDR     r1, [r4, #fcb_flags]
        BIC     r1, r1, #flg_hashing
        TST     r1, #flg_worth_hashing                  ; worth the effort and space in descriptor?
        STR     r1, [r4, #fcb_flags]
        EXIT    EQ
        Debug   hash, "HashTableAlloc - constructing hash table"
        MOV     r0, r4                                  ; store descriptor in r0

        MOV     r2, #-1                                 ; get a foreground buffer
        BL      AllocateInternalBuffer                  ; abuse of internal buffers - but pretty safe
        MOV     r8, r2                                  ; for safekeeping - a temporary buffer for the tokens
        MOV     r9, r3                                  ; ditto
        MOV     r2, #-1                                 ; get a foreground buffer
        BL      AllocateInternalBuffer                  ; actually need a couple of them :-)
        MOV     r6, r2                                  ; for safekeeping - this one holds the counters
        MOV     r7, #0                                  ; number of wildcard tags
        MOV     r11, #0                                 ; total number of tags
        MOV     r4, #NumBuckets                         ; index for enumeration - will be zero at end of 10 loop
10      SUBS    r4, r4, #1
        STR     r7, [r6, r4, LSL #2]
        BNE     %BT10
        ; ASSERT r4 contains 0 here
20
        ADR     r1, StarToken                           ; we want everything
        MOV     r2, r8                                  ; Set buffer
        MOV     r3, r9                                  ; size of buffer
        Push    "r11"
        BL      SWIMessageTrans_EnumerateTokens         ; get next token
        Pull    "r11"
        EXIT    VS
        TEQ     r2, #0                                  ; done?
        BEQ     %FT30                                   ; completed the enumeration
        ADD     r11, r11, #1                            ; inc total
        BL      AllocHashR2R3toR1                       ; hash R2[0..R3] into R1
        CMP     r1, #NumBuckets                         ; Got a wildcard?
        ADDEQ   r7, r7, #1                              ; yes - increment wildcard bucket counter
        LDRNE   r2, [r6, r1, LSL #2]                    ; no - increment counter for bucket
        ADDNE   r2, r2, #1
        STRNE   r2, [r6, r1, LSL #2]
        B       %BT20
30
        Debug   hash, "Tokens in file",r11
        CMP     r11, #MinimumTokenCount                 ; enough tokens to be worthwhile? Instruction also clears V
        LDRLO   r11, [r0, #fcb_flags]
        BICLO   r11, r11, #flg_worth_hashing            ; not worth the effort - don't bother in future
        STRLO   r11, [r0, #fcb_flags]
        EXIT    LO
        ADD     r3, r11, #NumBuckets+2                  ; tag count + one per bucket + wildcard bucket + final terminator
        MOV     r3, r3, LSL #2                          ; convert to bytes
        Debug   hash, "Claiming memory", r3
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module                              ; let's go!
        EXIT    VS
        LDR     r0, [sp, #4*4]                          ; get descriptor back into R0 back again
        STR     r2, [r0, #fcb_hash]                     ; store the hash table memory
        MOV     r4, #0                                  ; ready the index for enumeration again
40      SUBS    r3, r3, #4
        STR     r4, [r2, r3]
        BNE     %BT40
        ADD     r1, r2, #(NumBuckets+2)*4               ; skip the bucket pointers and final terminator to find chain mem
        ; ASSERT r3 and r4 contain 0 here
50      LDR     r0, [r6, r3, LSL #2]                    ; get r3'th entry from counter table
        Debug   hash, "Bucket,Entries",r3,r0
        STR     r1, [r2, r3, LSL #2]                    ; write head pointer
        ADD     r1, r1, r0, LSL #2                      ; add number of entries
        ADD     r3, r3, #1                              ; increment r3
        TEQ     r3, #NumBuckets                         ; done?
        BNE     %BT50
        MOV     r11, r2                                 ; remember where the head pointer table is
        STR     r1, [r2, r3, LSL #2]!                   ; store final header pointer (for wildcard token chain)
        ADD     r1, r1, r7, LSL #2                      ; number of wildcard chain entries
        STR     r1, [r2, #4]                            ; store final terminator
        LDR     r0, [sp, #4*4]                          ; retrieve entry R4 - our internal descriptor
        LDR     r7, [r0, #fcb_fileptr]                  ; guaranteed valid!
        ADD     r7, r7, #4                              ; skip over the file size field
60      ADD     r6, r7, r4                              ; remember where we were at the moment
        ADR     r1, StarToken
        MOV     r2, r8
        MOV     r3, r9
        Push    "r11"
        BL      SWIMessageTrans_EnumerateTokens         ; we know what to do now
        Pull    "r11"
        TEQ     r2, #0
        BEQ     %FT70
        BL      HashAdvanceToRealToken                  ; updates R6 if necessary
        BL      AllocHashR2R3toR1
        Debug   hash, "Storing in bucket",r1
        LDR     r1, [r11, r1, LSL #2]                   ; get the pointer
65      LDR     r2, [r1], #4                            ; look for a space in the table
        TEQ     r2, #0
        BNE     %BT65
        DebugS  hash, "Storing token", r6
        STR     r6, [r1, #-4]!                          ; store in table
        B       %BT60                                   ; next!
70      LDR     r0, [sp, #4*4]                          ; retrieve client descriptor
        LDR     r1, [r0, #fcb_flags]                    ; mark the hash table valid
        ORR     r1, r1, #flg_hashing
        STR     r1, [r0, #fcb_flags]
        Debug   hash, "HashTableAlloc exiting having set up the hash table"
        CLRV
        EXIT

StarToken
        DCB     "*", 0
        ALIGN

        ROUT

HashAdvanceToRealToken ENTRY "r0,r8"
        ; R2 is the buffer into which the token has been copied
        ; R4 points to EOF or to the byte following this token's value
        ; R6 is a pointer into the messages file at or after which the token lives
        ; Routine updates R6 if it didn't actually point to the token pointed to by R2
        LDRB    r0, [r2]                ; what we were given
10      LDRB    r8, [r6]
        TEQ     r0, r8
        TEQNE   r8, #"?"
        TEQNE   r8, #"*"
        EXIT    EQ                      ; Found the token OK.
        ADD     r6, r6, #1
        CMP     r6, r4                  ; EOF or past token value?  Cannot possibly happen? Something is
        EXIT    EQ                      ; terribly wrong if this safety valve is used - paranoia?
        CMP     r8, #"#"                ; comment to end of line?
        BNE     %BT10
20
        CMP     r8, #&20
25      LDRCSB  r8, [r6], #1
        BCS     %BT20
30
        CMP     r8, #27
        ADDEQ   r6, r6, #1
        CMPNE   r8, #9
        CMPNE   r8, #31
        BNE     %BT10                   ; don't like this character - treat as end of comment
        LDRB    r8, [r6], #1
        B       %BT20

        ROUT

AllocHashR2R3toR1 ENTRY "r0,r2-r4"
        ; Generates the hash of the token at address R2 length R3 into R1
        ; R1 is NumBuckets if the symbol contains wildcards, else in the
        ; range 0 to (NumBuckets-1)
        MOV     r1, #0
10      LDRB    r4, [r2], #1
        TEQ     r4, #"?"
        TEQNE   r4, #"*"
        MOVEQ   r1, #NumBuckets
        EXIT    EQ
        SUBS    r3, r3, #1
        EORPL   r1, r4, r1, ROR #1
        BPL     %BT10
        EOR     r1, r1, r1, LSR #30
        EOR     r1, r1, r1, LSR #24
        EOR     r1, r1, r1, LSR #12
        EOR     r1, r1, r1, LSR #6
        AND     r1, r1, #(NumBuckets-1)
        EXIT

AllocateInternalBuffer ENTRY "r8"
        ; Allocate one of MessageTrans's internal buffers from IRQ or foreground pools
        ; depending on the kernel's IRQsema flag.  Returns buffer in R2, length in R3
        ; Used when client does not supply a buffer to *Lookup and in HashTableAlloc
        ; If R2=0 on entry, the IRQsema is checked
        ; If R2=-1 on entry, a foreground buffer is used
        ; R2 anything else will not work
        ; On exit: R2 points to buffer, R3 is buffer size
        MVNS    r3, r2                                  ; R3=0, Z set => force foreground pool
        LDRNE   r3, [ r2, #IRQsema ]                    ; If R3<>0 now, R2 must have been 0
        TEQNE   r3, #0                                  ; Z set => force foreground pool
        ADR     r2, ForegroundBuffers
        ADDNE   r2, r2, #Buffersize*ForegroundBuffersNo
        LDREQ   r14, current_ForegroundBuffer
        LDRNE   r14, current_IRQBuffer
        ADD     r2, r2, r14, LSL #8                     ; Point at correct buffer to use
        ADD     r14, r14, #1
        MOVEQ   r8, #ForegroundBuffersNo
        MOVNE   r8, #IRQBuffersNo
        CMP     r14, r8
        MOVGE   r14, #0
        TEQ     r3, #0
        STREQ   r14, current_ForegroundBuffer
        STRNE   r14, current_IRQBuffer                  ; And set new buffer number.
        MOV     r3, #Buffersize
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d1822 1
@


4.2.2.2
log
@Merge of Kevin's 0.35 32-bit compatibility onto development branch
@
text
@d48 1
a48 1
;;                      made wp constant through out the entire module (i.e.
d115 1
a115 1
debughash       SETL   debug :LAND: true
a178 1
   [ :LNOT: No32bitCode
a179 1
   ]
a188 7
; Module flags.  Bit 0 set means module is 32-bit aware and safe
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   [ :LNOT: No32bitCode
MyFlags DCD     ModuleFlag_32bit
   ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d418 5
d810 2
a811 1
        SavePSR r5
d819 1
a819 1
        RestPSR r5,,f
d903 3
a905 5
 [ :LNOT:No32bitCode
        mrs    ,lr, CPSR
        TST     lr, #2_11100
        Pull    "r0-r1, r4-r7, r8-r10, pc", NE          ; corrupt flags for 32-bit exit
 ]
d908 1
d1619 6
a1624 3
        BCS     getbyte
        CLRV
        MOV     pc, lr
d1636 1
a1637 3
 [ No32bitCode
        BICLOS  pc, lr, #VFlag                          ; Then return with V clear
 |
d1640 3
d1694 1
d1696 3
@


4.2.2.3
log
@Hash table fixes, debug version capability added
@
text
@d15 64
a78 5
;
; MsgTrans.s (MessageTrans)
;
; Copyright (C) Acorn Computers Ltd. 1989 - 2000
;
a106 7
        GBLL    debugstats

        GBLL    keepstats                               ; keep use counts on files - view with ShowMsgs
keepstats       SETL   true
    [ keepstats
        ! 0, "WARNING: Keeping usage count statistics"
    ]
d115 1
a115 2
debughash       SETL   debug :LAND: false
debugstats      SETL   debug :LAND: false :LAND: keepstats
a124 1
    [ :LNOT: :DEF: AltTitleAndSWI
a126 4
    ]

        GBLL    ChocolateProxies
ChocolateProxies  SETL false
d135 2
a136 8
current_ForegroundBuffer        #       1
current_IRQBuffer               #       1
ThreadNess                      #       1
    [ ChocolateProxies
ProxyCountdown                  #       1       ; don't use chocolate blocks until this gets to 0
    |
alignpadding                    #       5
    ]
d140 1
a140 2
DictionaryHash                  #       (4 * 256)

a142 9
    [ ChocolateProxies
ProxyBlockSize                  *       32      ; cannot change!
ProxyBlocks                     *       32      ; one bit per block in ProxyAlloc
ProxyAlloc                      #       4
ProxyMemorySize                 *       ProxyBlockSize * ProxyBlocks
ProxyMemory                     #       ProxyMemorySize
ChocolateCountdown              *       0
    ]

d159 1
a159 1
        AREA    |MsgTrans$$Code|, CODE, READONLY, PIC
d161 1
a161 1
Module_BaseAddr
a200 7
; Only the 32 byte blocks are ever linked into the MessageTrans chain.  MessageTrans always
; allocates blocks of 32 bytes long.  Clients will only pass 16 byte blocks normally, but
; can pass 32 byte blocks by specfiying R3 = FAST on the call to MessageTrans_OpenFile.  The
; client supplies certain guarantees by doing this too, notably: block will be safe (ie. in
; RMA/DA - specifically NOT in application space and NOT on the SVC stack); the client will call
; MessageTrans_CloseFile.  If the client fails to do the latter, the hash table will be leaked.

d208 1
a208 2
fcb_use_count   #       4                               ; usage counter (only if keepstats is true)
fcb_reserved    #       4                               ; reserved for future use
d215 1
a215 1
fcb_clnt_spare  #       4                               ; spare (but is initialised as pointer to filename)
d232 2
a233 2
MinimumHashableFileSize *       64                      ; minimum file size to enable hashing
MinimumTokenCount       *       3                       ; number of tokens required to enable hashing
d239 1
a239 1
Init    Entry
a252 6
    [ ChocolateProxies
        MVN     r0, #0
        STR     r0, ProxyAlloc
        MOV     r0, #ChocolateCountdown
        STRB    r0, ProxyCountdown
    ]
d255 2
a256 2
        STRB    r0, current_ForegroundBuffer
        STRB    r0, current_IRQBuffer
d260 1
a260 1
        STRB    r0, ThreadNess
d325 1
a325 1
Die     Entry
d388 1
a388 1
        Push    "r0-r2, lr"
d391 1
a391 1
        LDR     r2, link_header                         ; Look at the head of the chain
d393 1
a393 1
        TEQ     r2, #0
d395 1
a395 1
        LDR     r0, [ r2, #fcb_flags ]
a396 1
        BLNE    Service_CheckFileMoved                  ; has this change affected this file?
d399 2
a400 2
        STRNE   r0, [ r2, #fcb_fileptr ]                ; Mark data as 'not there'
        LDR     r2, [ r2, #fcb_link ]
d423 1
a423 1
        Pull    "r0-r2, pc"
a424 17
        ; This routine looks at the descriptor pointed to be R2 and determines
        ; whether the file has moved or not.  If it has not, then it returns with Z set.
        ; If it has, then it returns with Z clear.  All other flags are corrupted.
        ; The affect of this is that the service call Service_MessageFileClosed does not
        ; go around unnecessarily (ie. it only goes round if one of the message files
        ; currently open and buffered by MessageTrans from ResourceFS has actually changed).
        ; This optimisation will relieve RAMFSFiler of its need to commit suicide every time
        ; ResourceFS changes.  ShowMsgs will confirm that none of the data pointers are 0
        ; after a ResourceFS change.
Service_CheckFileMoved Entry "r1-r4"
        LDR     r4, [ r2, #fcb_fileptr ]
        LDR     r1, [ r2, #fcb_filename ]
        BL      internal_fileinfo
        TEQ     r0, #flg_inresourcefs                   ; error block won't be 1, will it? :)
        TEQEQ   r2, r4

        EXIT
d503 1
a503 1
SWIMessageTrans_FileInfo Entry "r3"
d526 1
a526 1
internal_fileinfo Entry "r1,r4-r7"
d528 1
a528 1
        LDRB    lr, ThreadNess
d533 1
a533 1
        STRB    lr, ThreadNess
d590 1
a590 1
        LDRB    lr, ThreadNess
d592 1
a592 1
        STRB    lr, ThreadNess
a665 3
    [ keepstats
        STREQ   lr, [r4, #fcb_use_count]                ; zero the usage counter
    ]
d745 1
a745 18
CopyDescriptorToRMA Entry "r0-r3,r5,r6-r8"
    [ ChocolateProxies
        LDRB    r3, ProxyCountdown
        TEQ     r3, #0
        BNE     %FT10
        LDR     r1, ProxyAlloc                          ; bit set = array entry available
        RSB     r3, r1, r3
        ANDS    r3, r3, r1
        BEQ     %FT10                                   ; none left!
        BIC     r1, r1, r3
        STR     r1, ProxyAlloc
        ADR     r2, ProxyMemory
01
        MOVS    r3, r3, LSR #1
        ADDNE   r2, r2, #ProxyBlockSize
        BNE     %BT01
10
    ]
a753 1
        STR     r3, [ r4, #fcb_clnt_spare ]             ; Store copy of filename pointer for now
d758 1
a758 1
        MOV     r7, r4                                  ; backwards pointer to client block
a759 3
    [ keepstats
        STR     r6, [r2, #fcb_use_count]                ; zero the usage counter
    ]
a822 3
    [ No32bitCode
        NOP
    ]
d1269 1
a1269 1
internal_lookup Entry "r0-r10"
a1278 9
    [ :DEF: deferhashcreation
        AND     r8, r1, #flg_hashing :OR: flg_worth_hashing
        TEQ     r8, #flg_worth_hashing
        MOVEQ   r4, r0
        BLEQ    HashTableAlloc
        LDR     r1, [r0, #fcb_flags]
        BICVS   r1, r1, #flg_worth_hashing :OR: flg_hashing
        STRVS   r1, [r0, #fcb_flags]
    ]
a1279 6
    [ keepstats
        ; We can only do stats when hashing as that's the only guaranteed case of having 32 byte block
        LDRNE   r8, [r0, #fcb_use_count]
        ADDNE   r8, r8, #1
        STRNE   r8, [r0, #fcb_use_count]
    ]
d1284 1
a1284 1
        DebugS   hash, "Looking up in hash table : ",r9
d1537 1
a1537 1
        ADDS    r0, r9, #0                              ; clear V
d1539 1
a1539 2
        LDMVSIA sp!, {r0, pc}                           ; didn't find it?
        MOV     r9, r0                                  ; R9 points to kernel dictionary
d1542 3
a1544 4
        ADRCS   r14, DictionaryHash + 4
        LDRCS   r0, [r14, r8, LSL #2]!                  ; check hash table
        TEQCS   r0, #0
        LDMEQIA sp!, {r0, pc}
d1684 1
a1684 1
SWIMessageTrans_CloseFile Entry "r0-r3"
a1689 10
    [ debugstats
        LDR     r2, [ r0, #fcb_flags ]
        TST     r2, #flg_hashing
        BEQ     %F09
        LDR     r1, [ r0, #fcb_filename ]
        LDR     r2, [ r0, #fcb_use_count ]
        DebugS  stats, "MessageTrans file closed", r1
        Debug   stats, "Use count", r2
09
    ]
a1711 15
    [ ChocolateProxies
        BEQ     %FT20
        ADR     r2, ProxyMemory
        SUBS    r2, r0, r2
        RSBCSS  r1, r2, #ProxyMemorySize
        LDRCS   r1, ProxyAlloc
        MOVCS   r2, r2, LSR #5
        MOVCS   r3, #1
        ORRCS   r1, r1, r3, LSL r2
        STRCS   r1, ProxyAlloc
        MOVCC   r2, r0
        MOVCC   r0, #ModHandReason_Free
        SWICC   XOS_Module
20
    |
a1714 1
    ]
a1715 1

d1737 1
a1737 1
SWIMessageTrans_MakeMenus Entry "r1, r4-r11"
d1862 1
a1862 1
skiptoken Entry
d1884 1
a1884 1
int_lookup_nopars Entry "r4-r7"
d1897 2
a1898 2
        ; Returns address of first byte of dictionary in R0 if V clear; error if V set
SWIMessageTrans_Dictionary Entry   "r0-r3"
d1903 4
a1906 19
        ADDVC   r0, r2, #4
        STR     r0, [sp]
        EXIT    VS
        LDR     r1, Dictionary
        STR     r2, Dictionary
        TEQ     r1, r2
        EXIT    EQ
        ADR     r3, DictionaryHash
        MOV     r1, #0
dichashloop
        LDRB    r2, [r0]              ; read length byte of R1'th entry
        TEQ     r2, #0                ; end of list?
        STRNE   r0, [r3, r1, LSR #22] ; store hash entry
        STREQ   r2, [r3, r1, LSR #22] ; store zero
        ADDNE   r0, r0, r2
        ADDS    r1, r1, #&01000000    ; count in top-byte so 256th loop => R1=0, Z set
        BNE     dichashloop

        EXIT
d1947 1
a1947 1
HashTableDelete Entry "r0-r3"
d1966 1
a1966 1
HashTableAlloc Entry "r0-r11"
d2053 1
a2053 1
        CMP     r2, #0                                  ; clears V!
d2070 1
a2070 1
        ; V must be clear - the only branch from above ensures this is the case
d2079 1
a2079 1
HashAdvanceToRealToken Entry "r0,r8"
d2110 1
a2110 1
AllocHashR2R3toR1 Entry "r0,r2-r4"
d2130 1
a2130 1
AllocateInternalBuffer Entry "r8"
d2143 2
a2144 2
        LDREQB  r14, current_ForegroundBuffer
        LDRNEB  r14, current_IRQBuffer
d2152 2
a2153 2
        STREQB  r14, current_ForegroundBuffer
        STRNEB  r14, current_IRQBuffer                  ; And set new buffer number.
@


4.1
log
@Initial revision
@
text
@d97 1
a97 1
        GET     Version
d106 1
d114 2
a115 1
debugFSW        SETL   debug :LAND: true
d133 3
d142 1
a142 1
IRQBuffersNo                    *       2
d174 5
a178 1
HelpString      DCB     "MessageTrans", 9, "$VString ($Date)", 0
d195 4
d201 4
d223 14
d332 13
d348 1
d353 1
d477 4
d482 1
d613 3
d664 49
d1002 4
d1119 3
d1221 4
d1226 1
d1228 4
d1585 3
d1602 12
d1615 1
d1618 1
d1621 1
d1643 4
@


4.1.8.1
log
@MessageTrans 0.33 (private branch experimental version)

* Includes Ursula service call table (copied in from Ursula branch)

* IRQ buffer count increased to 8 to solve problem reported with looking
  up unknown tokens from IRQ mode (causes a string copy with the source
  string 4 bytes further along than the destination due to buffer re-use)

* Includes code to stop aborts occurring when TaskWindow swaps the SVC
  stack away whilst MessageTrans has a linked block on that stack.
  The code to fix this behaviour is conditionally built based on the
  setting of the svcstkdescr switch in s.MsgTrans.
  IN THIS CHECK-IN, BY DEFAULT THIS OPTION IS SWITCHED OFF.
  I just want to commit the change to the repository.
@
text
@a105 1
	GBLL	svcstkdescr				; Copy SVC stack based descriptors to RMA if true
d113 1
a113 2
debugFSW        SETL   debug :LAND: false
svcstkdescr	SETL   false
a130 3
	[ svcstkdescr
SVCSTK_size			#	4
	]
d137 1
a137 1
IRQBuffersNo                    *       8
a185 4
	[ svcstkdescr
flg_freeblock  		*	1 :SHL: 29		; we allocated this descriptor in the RMA
flg_ourdescriptor	*	1 :SHL: 30		; indirect messageblock - fcb_fileptr points to RMA descriptor
	]
a187 4

	[ svcstkdescr
OldSVCStackSize		*	8192			; Ursula kernels will supply the correct absolute address
	]
a205 14
	[ svcstkdescr
	MOV	r0, #6
	MOV	r1, #0
	MOV	r2, #16				; Ursula: read top of SVC stack call
	SWI	XOS_ReadSysInfo
	MOV	r0, sp, LSR #20
	MOVVS	r2, #OldSVCStackSize
	ADDVSS	r2, r2, r0, LSL #20		; clears V
	TEQ	r2, #0
	MOVEQ	r2, #OldSVCStackSize
	SUBNE	r2, r2, r0, LSL #20		; calculate stack size
	STR	r2, SVCSTK_size
	]

a300 13
;Ursula format
;
        ASSERT  Service_ResourceFSStarted < Service_ResourceFSDying
        ASSERT  Service_ResourceFSDying   < Service_TerritoryStarted
;
UServTab
        DCD     0                              ;flags
        DCD     UService - Module_BaseAddr
        DCD     Service_ResourceFSStarted
        DCD     Service_ResourceFSDying
        DCD     Service_TerritoryStarted
        DCD     0                              ;terminator
        DCD     UServTab - Module_BaseAddr     ;anchor
a303 1
        MOV     r0,r0                          ;magic instruction
a307 1
UService
a430 4
	[ svcstkdescr
        BICVC   r0, r0, #(flg_ourdescriptor :OR: flg_freeblock :OR: flg_sqshinresourcefs)
              						; flags not for external consumption
	|
a431 1
	]
a561 3
	[ svcstkdescr
	BLVC	CopyDescriptorToRMA			; make duplicate of block in RMA if needed - updates R4
	]
a609 49
	[ svcstkdescr

	; This routine examines the position of the client's supplied 4-word buffer to make sure
 	; that it isn't on the SVC stack.  It if isn't then all is left alone.  Otherwise, a new
	; descriptor is grabbed from the RMA and the client's block is reset to be marked to point
	; to the (safe) proxy RMA block.  The client's flags have flg_ourdescriptor set.
	; Our real blocks have flg_freeblock set.

CopyDescriptorToRMA Entry "r0-r3,r6"

	MOV	r0, sp, LSR #20
	SUBS	r0, r4, r0, LSL #20			; subtract base of SVC stack from descriptor
	LDRHS	r3, SVCSTK_size				; get size of SVC mode stack
	RSBHSS	r0, r0, r3				; was it between that and the top of the stack?
	EXITS	LO					; it wasn't - so we won't bother copying this one


	MOV	r3, #fcb_size
	MOV	r0, #ModHandReason_Claim
	SWI	XOS_Module				; Try and get a new RMA block for descriptor
	EXITS	VS					; OK - leave it then

	Debug	xx,"CopyToRMA *PERFORMING COPY* to RMA block",r2

	LDMIA	r4, {r0,r1,r3,r5}			; get data from client's original descriptor block
 	ORR	r1, r1, #flg_ourdescriptor		; Set flag that we allocated this block
	STR	r1, [ r4, #fcb_flags ]
	STR	r2, [ r4, #fcb_fileptr ]		; link back to internal descriptor
	EOR	r1, r1, #flg_freeblock :OR: flg_ourdescriptor	; set flg_freeblock, clears flg_ourdescriptor
	STMIA	r2, {r0,r1,r3,r5}			; copy information to our own internal descriptor
	MOV	r4, r2					; replace caller's descriptor pointer
	EXITS						; and return.


TranslateFindDescriptor Entry "r1"

	; This routine checks a descriptor to see if it was a proxy that was set up previously
	; by CopyDescriptorToRMA.  If it was, then the proxy pointer is dereferenced to get the
	; real block 'saddress.

	TEQ	r0, #0					; a null pointer?
	LDRNE	r1, [ r0, #fcb_flags ]			; get flags from descriptor block
	TSTNE	r1, #flg_ourdescriptor			; was it a proxy?
	LDRNE	r0, [ r0, #fcb_fileptr ]		; It was - follow the proxy link
	EXITS

	]


a898 4
	[ svcstkdescr
	BL	TranslateFindDescriptor
	]

a1011 3
	[ svcstkdescr
	BL	TranslateFindDescriptor
	]
a1110 4
	[ svcstkdescr
        Push    "r0-r3"                                 ; Preserve the inputs in case it fails
	BL	TranslateFindDescriptor
	|
a1111 1
	]
a1112 4
	[ svcstkdescr
	LDRVC	r0, [sp], #4				; Restore old R0 on success to not confuse client
	ADDVS	sp, sp, #4				; Junk old R0 on failure - client will get error block
	]
a1465 3
	[ svcstkdescr
	BL	TranslateFindDescriptor
	]
a1479 12
	[ svcstkdescr
	LDR	r14, [ r0, #fcb_flags ]
	TST	r14, #flg_ourbuffer
	MOVEQ	r2, #0					; ensure R2 is set correctly to avoid later test
	TST	r14, #flg_freeblock
	STMFD	sp!, {r2}
	MOVNE	r2, r0
        MOVNE   r0, #ModHandReason_Free
	SWINE	XOS_Module
	LDMFD	sp!, {r2}
	ADDS	r2, r2, #0				; clears V and sets/clears Z appropriately
	|
a1480 1
	]
a1482 1
	[ :LNOT:svcstkdescr
a1484 1
	]
a1505 4

	[ svcstkdescr
	BL	TranslateFindDescriptor
	]
@


4.1.4.1
log
@update to Ursula service format
@
text
@a300 13
;Ursula format
;
        ASSERT  Service_ResourceFSStarted < Service_ResourceFSDying
        ASSERT  Service_ResourceFSDying   < Service_TerritoryStarted
;
UServTab
        DCD     0                              ;flags
        DCD     UService - Module_BaseAddr
        DCD     Service_ResourceFSStarted
        DCD     Service_ResourceFSDying
        DCD     Service_TerritoryStarted
        DCD     0                              ;terminator
        DCD     UServTab - Module_BaseAddr     ;anchor
a303 1
        MOV     r0,r0                          ;magic instruction
a307 1
UService
@


4.1.4.2
log
@* Includes code to stop aborts occurring when TaskWindow swaps the SVC
  stack away whilst MessageTrans has a linked block on that stack.
  The code to fix this behaviour is conditionally built based on the
  setting of the svcstkdescr switch in s.MsgTrans.  This switch is set
  to true by default.

* IRQ buffer count increased to 4 to solve problem reported with looking
  up unknown tokens from IRQ mode (causes a string copy with the source
  string 4 bytes further along than the destination due to buffer re-use)
@
text
@a105 1
        GBLL    svcstkdescr                             ; Copy SVC stack based descriptors to RMA if true
d113 1
a113 2
debugFSW        SETL   debug :LAND: false
svcstkdescr     SETL   true
a130 3
        [ svcstkdescr
SVCSTK_size                     #       4
        ]
d137 1
a137 1
IRQBuffersNo                    *       4
a185 4
        [ svcstkdescr
flg_freeblock           *       1 :SHL: 29              ; we allocated this descriptor in the RMA
flg_ourdescriptor       *       1 :SHL: 30              ; indirect messageblock - fcb_fileptr points to RMA descriptor
        ]
a187 4

        [ svcstkdescr
OldSVCStackSize         *       8192                    ; Ursula kernels will supply the correct absolute address
        ]
a205 14
        [ svcstkdescr
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #16                         ; Ursula: read top of SVC stack call
        SWI     XOS_ReadSysInfo
        MOV     r0, sp, LSR #20
        MOVVS   r2, #OldSVCStackSize
        ADDVSS  r2, r2, r0, LSL #20             ; clears V
        TEQ     r2, #0
        MOVEQ   r2, #OldSVCStackSize
        SUBNE   r2, r2, r0, LSL #20             ; calculate stack size
        STR     r2, SVCSTK_size
        ]

a445 4
        [ svcstkdescr
        BICVC   r0, r0, #(flg_ourdescriptor :OR: flg_freeblock :OR: flg_sqshinresourcefs)
                                                        ; flags not for external consumption
        |
a446 1
        ]
a576 3
        [ svcstkdescr
        BLVC    CopyDescriptorToRMA                     ; make duplicate of block in RMA if needed - updates R4
        ]
a624 49
        [ svcstkdescr

        ; This routine examines the position of the client's supplied 4-word buffer to make sure
        ; that it isn't on the SVC stack.  It if isn't then all is left alone.  Otherwise, a new
        ; descriptor is grabbed from the RMA and the client's block is reset to be marked to point
        ; to the (safe) proxy RMA block.  The client's flags have flg_ourdescriptor set.
        ; Our real blocks have flg_freeblock set.

CopyDescriptorToRMA Entry "r0-r3,r6"

        MOV     r0, sp, LSR #20
        SUBS    r0, r4, r0, LSL #20                     ; subtract base of SVC stack from descriptor
        LDRHS   r3, SVCSTK_size                         ; get size of SVC mode stack
        RSBHSS  r0, r0, r3                              ; was it between that and the top of the stack?
        EXITS   LO                                      ; it wasn't - so we won't bother copying this one


        MOV     r3, #fcb_size
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module                              ; Try and get a new RMA block for descriptor
        EXITS   VS                                      ; OK - leave it then

        Debug   xx,"CopyToRMA *PERFORMING COPY* to RMA block",r2

        LDMIA   r4, {r0,r1,r3,r5}                       ; get data from client's original descriptor block
        ORR     r1, r1, #flg_ourdescriptor              ; Set flag that we allocated this block
        STR     r1, [ r4, #fcb_flags ]
        STR     r2, [ r4, #fcb_fileptr ]                ; link back to internal descriptor
        EOR     r1, r1, #flg_freeblock :OR: flg_ourdescriptor   ; set flg_freeblock, clears flg_ourdescriptor
        STMIA   r2, {r0,r1,r3,r5}                       ; copy information to our own internal descriptor
        MOV     r4, r2                                  ; replace caller's descriptor pointer
        EXITS                                           ; and return.


TranslateFindDescriptor Entry "r1"

        ; This routine checks a descriptor to see if it was a proxy that was set up previously
        ; by CopyDescriptorToRMA.  If it was, then the proxy pointer is dereferenced to get the
        ; real block 'saddress.

        TEQ     r0, #0                                  ; a null pointer?
        LDRNE   r1, [ r0, #fcb_flags ]                  ; get flags from descriptor block
        TSTNE   r1, #flg_ourdescriptor                  ; was it a proxy?
        LDRNE   r0, [ r0, #fcb_fileptr ]                ; It was - follow the proxy link
        EXITS

        ]


a913 4
        [ svcstkdescr
        BL      TranslateFindDescriptor
        ]

a1026 3
        [ svcstkdescr
        BL      TranslateFindDescriptor
        ]
a1125 4
        [ svcstkdescr
        Push    "r0-r3"                                 ; Preserve the inputs in case it fails
        BL      TranslateFindDescriptor
        |
a1126 1
        ]
a1127 4
        [ svcstkdescr
        LDRVC   r0, [sp], #4                            ; Restore old R0 on success to not confuse client
        ADDVS   sp, sp, #4                              ; Junk old R0 on failure - client will get error block
        ]
a1480 3
        [ svcstkdescr
        BL      TranslateFindDescriptor
        ]
a1494 12
        [ svcstkdescr
        LDR     r14, [ r0, #fcb_flags ]
        TST     r14, #flg_ourbuffer
        MOVEQ   r2, #0                                  ; ensure R2 is set correctly to avoid later test
        TST     r14, #flg_freeblock
        STMFD   sp!, {r2}
        MOVNE   r2, r0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module
        LDMFD   sp!, {r2}
        ADDS    r2, r2, #0                              ; clears V and sets/clears Z appropriately
        |
a1495 1
        ]
a1497 1
        [ :LNOT:svcstkdescr
a1499 1
        ]
a1520 4

        [ svcstkdescr
        BL      TranslateFindDescriptor
        ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

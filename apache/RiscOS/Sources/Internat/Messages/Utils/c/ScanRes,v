head	4.10;
access;
symbols
	Messages-1_12:4.10
	Messages-1_11:4.10
	Messages-1_10:4.10
	Messages-1_09:4.10
	Messages-1_08:4.9
	Messages-1_07:4.9
	RO_5_07:4.9
	Messages-1_06:4.9
	Messages-1_05-4_25_2_3:4.9.2.1
	Messages-1_05-4_25_2_2:4.9.2.1
	Messages-1_05-4_25_2_1:4.9.2.1
	sbrodie_dev:4.9.0.2
	sbrodie_dev_bp:4.9
	Messages-1_05:4.9
	Messages-1_04:4.9
	Messages-1_03:4.9
	Messages-1_02:4.9
	Messages-1_01:4.9
	Messages-1_00:4.9
	Messages-0_99:4.9
	dellis_autobuild_BaseSW:4.9
	Messages-0_98:4.9
	Messages-0_97:4.8
	Messages-0_96:4.7
	Messages-0_95:4.7
	Messages-0_94:4.6
	dcotton_Messages_13062000:4.5
	dcotton_Messages_10062000:4.4
	Messages-0_93:4.2
	Messages-0_92:4.2
	Messages-0_91:4.2
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.9
	Messages-0_90:4.2
	Ursula_merge:4.1
	nturton_Messages-0_84:4.1
	Messages-0_89:4.2
	Messages-0_88:4.2
	Messages-0_87:4.2
	Messages-0_86:4.1
	Messages-0_85:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_Messages-0_79:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_Messages-0_85:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_Funai01-33:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2012.03.20.21.30.30;	author jlee;	state Exp;
branches;
next	4.9;
commitid	DNlk1u7X2Ic8wFXv;

4.9
date	2000.08.16.13.56.25;	author dcotton;	state Exp;
branches
	4.9.2.1;
next	4.8;

4.8
date	2000.08.13.15.53.01;	author dcotton;	state Exp;
branches;
next	4.7;

4.7
date	2000.06.20.12.57.07;	author dcotton;	state Exp;
branches;
next	4.6;

4.6
date	2000.06.15.10.39.17;	author dcotton;	state Exp;
branches;
next	4.5;

4.5
date	2000.06.13.16.53.49;	author dcotton;	state Exp;
branches;
next	4.4;

4.4
date	2000.06.10.10.31.04;	author dcotton;	state Exp;
branches;
next	4.3;

4.3
date	2000.06.07.16.53.30;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.04.30.15.24.23;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.40.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.9.2.1
date	2001.06.27.15.43.50;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.40.08;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.53.54;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.45.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.00.00;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Fix spurious assert in MsgTok2. Tidy other utils a bit and rebuild all binaries.
Detail:
  Utils/c/MskTok2 - Fix spurious assert when tokenising a message that runs up to end of buffer and isn't newline terminated
  Utils/Makefile - Tweaked to use CApp makefile fragment
  Utils/MkClean,fd7, Utils/MkCVSClean,fd7 - New scripts for cleaning everything, or for cleaning just the bits we don't want in CVS
  Utils/o - Removed folder, shouldn't be in CVS
  Utils/c/Old - Removed folder, we rely on CVS to store old versions of files
  Utils/c/MsgExt, Utils/c/ScanRes, Utils/c/TokGen, Utils/c/TokGen2 - Fixed dangerous-sounding warnings (potential use of uninitialised variables, wrong fscanf arg type for "%s")
  Utils/*,ff8 - Rebuilt all binaries with Norcroft 5.69
Admin:
  Tested with building/running Iyonix & OMAP3 ROMs


Version 1.09. Tagged as 'Messages-1_09'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#include "Global/Services.h"
#include "swis.h"

#define BUFSZ 512

char path[ BUFSZ ];
char buffer[ BUFSZ ];

typedef unsigned int word;

typedef struct
{
        word next;
        word loadaddr;
        word execaddr;
        word length;
        word access;
} resfile;

typedef struct
{
        word loadaddr;
        word execaddr;
        word length;
        word attr;
        word type;
        char name[1];
} object;

#define filetype( object )      (((object)->loadaddr>>8)&0xFFF)


/* Define some things needed to store exactly which territories we are storing. */
#define ENV_LOCALE_LIST "LocaleList"  /* name of env var holding the comma-seperated list of lcoales */
#define MAX_TERRITORIES 10            /* 10 is a value defined in the spec. */
char* supported_territories[MAX_TERRITORIES] = NULL; /* An array in which territories defined in the Env file can be stored. */
unsigned int num_of_territories = 0;                 /* The number of territories defined. */

/* Now something to store the territories we are saving */
char* terrritory_directories[MAX_TERRITORIES] = NULL; /* Stores the directory names */
unsigned int territory_numbers[MAX_TERRITORIES][MAX_TERRITORIES]; /*  Store the numeric representaion of each territory. Array is terminated by -1. */
unsigned int num_of_territory_dirs = 0;                 /* The number of territory directories scanned. */


/* Forward prototypes */
bool parse_territories(char* territory_line);
bool find_resource_directories(const char* const root_path);
bool convert_dir_to_numeric_form(const char* const dir_name);
int return_country_number(const char* const country);


/*****************************************************************************
* cstrcmp
*
* This routine compares two string caselessly.
*
* Assumptions
*  State any assumptions and side effects (eg. globals changed)
*
* Inputs
*  a:            The first string to be compared.
*  b:            The second string to be compared.
*
* Outputs
*  None.
*
* Returns
*  0 if both strings are NULL, or both strings are (ignoring case) identical.
*  -1 if one (but not both) of the strings are NULL.
*  Any other value if the strings are different.
*****************************************************************************/

int cstrcmp(const char *a, const char *b)
{
  int d;

  if (a == NULL && b == NULL)
    return (0);

  if (a == NULL || b == NULL)
    return (-1);

  while (*a || *b) {
    d = tolower(*(a++)) - tolower(*(b++));
    if (d)
      return (d);
  }
  return (0);
}



void error( const char *str, ... )
{
        va_list argp;

        sprintf( buffer, "ERROR: %s\n", str );

        va_start( argp, str );
        vprintf( buffer, argp );
        va_end( argp );

        exit(EXIT_FAILURE);
}


/*
 * malloc an area for a string and copy the string in
 */
char *strdup(const char *str)
{
  char *newstr = malloc(str == NULL ? 1 : (strlen(str) + 1));

  if (newstr != NULL) {
    if (str == NULL)
      *newstr = 0;
    else
      strcpy(newstr, str);
  }
  return (newstr);
}




/*
 * read an environment variable in to a malloced string
 */
char *read_env(char *variable)
{
  char *var = NULL;
  char *cp = NULL;

  if ((var = getenv(variable)) != NULL)
    cp = strdup(var);

  return (cp);
}



int
gettype( char *obj )
{
        int type;

        _swi( OS_File, _IN(0)|_IN(1)|_OUT(0), 17, obj, &type );

        return type;
}

void
clear( word *buf, int nwords )
{
        while ( nwords-- ) *(buf++)=0;
}

void
appendfile( object *op, char *path, char *respath, FILE *fp )
{
        int filelen = (op->length+3)&~3;                /* Aligned file length. */
        int pathlen = 0;
        int totallen;
        char *fbuf, *resp, *resendp = NULL;

        /* ResourceFS directories can contain more than 77 directory entries but ADFS
         * directories can't. To get round this any directory starting with "Resources"
         * (eg. Resources1, Resources2 etc.) will be reduced to "Resources" in the pathname
         * inside ResourceFS.
         */
        if ( (resp = strstr(respath, "Resources")) != NULL )
        {
                if ( (resendp = strchr(resp, '.')) != NULL )
                {
                        /* Adjustment for pathlen as Resources* will have * stripped out. */
                        pathlen = 9-(resendp-resp);
                }
                else
                {
                        resp = NULL;
                }
        }
        pathlen = (pathlen+strlen(respath)+4)&~3;       /* Aligned ResourceFS file name length. */

        totallen = sizeof(resfile)+pathlen+sizeof(int)+filelen;

        fbuf = (char *)malloc( totallen );

        if ( fbuf != NULL )
        {
                FILE *rp = fopen( path, "rb" );
                if ( rp != NULL )
                {
                        resfile *rf = (resfile *)fbuf;
                        char *path = fbuf+sizeof(resfile);

                        /* Clear fbuf. */
                        clear( (word *)fbuf, totallen>>2 );

                        /* Set up resource file header. */
                        rf->next = totallen;
                        rf->loadaddr = op->loadaddr;
                        rf->execaddr = op->execaddr;
                        rf->length = op->length;
                        rf->access = 3;

                        /* Copy ResourceFS file name. */
                        if ( resp != NULL )
                        {
                                /* Work out length of respath up to and including "Resources". */
                                int sublen = resp-respath+9;
                                strncpy( path, respath, sublen );

                                /* Strip out chars trailing after "Resources" up to next directory separator. */
                                strcpy( path+sublen, resendp );
                        }
                        else
                        {
                                strcpy( path, respath );
                        }

                        /* Store file length + 4 */
                        *(int *)(path+pathlen) = op->length+4;

                        /* Load resource file. */
                        if ( fread( fbuf+totallen-filelen, sizeof(char), op->length, rp ) != op->length )
                                error( "Error reading '%s'", path );

                        fclose( rp );

                        if ( fwrite( fbuf, sizeof(char), totallen, fp ) != totallen )
                                error( "Error writing to output file", NULL );
                }
                else
                {
                        error( "Can't open '%s' for read", path );
                }
                free( fbuf );
        }
        else
        {
                error( "Not enough memory to append '%s'", path );
        }
}

void
appendleaf( char *path, char *leaf )
{
        strcat( path, "." );
        strcat( path, leaf );
}

void
stripleaf( char *path )
{
        char *sep = strrchr( path, '.' );

        if ( sep != 0 ) *sep = '\0';
}

void
descend( char *path, char *respath, FILE *fp )
{
        char *buf = malloc( BUFSZ );
        int offset = 0;

//  printf("descend(): path=%s, respath=%s\n", path, respath);

        if ( buf != NULL )
        {
                do
                {
                        object *op = (object *)buf;
                        int nread;

                        _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
                                10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );

                        while ( nread > 0 )
                        {
                                appendleaf( path, op->name );
                                switch ( op->type )
                                {
                                        case 2:
                                                descend( path, respath, fp );
                                                break;

                                        default:
                                                appendfile( op, path, respath, fp );
                                                break;
                                }
                                stripleaf( path );
                                op = (object *)(((int)(op->name)+strlen(op->name)+4)&~3);
                                nread -= 1;
                        }
                } while ( offset != -1 );

                free( buf );
        }
        else
        {
                error( "Not enough memory to descend '%s'", path );
        }
}



/* This routine parses any territory line passed in and strips out all the
territories into an array.
   If the line is invalid, it retunrs false, otherwise it returns true. A
line is considered invalid if it is empty or contains whitespace.
 */

bool parse_territories(char* territory_line)
{
  char *territory = NULL;

  printf("Parsing territory line %s\n", territory_line);

  if (strlen(territory_line) < 1)
  {
    /* Line must contain something */
    return (false);
  }

  territory = strtok(territory_line, ",");
  while (territory)
  {
    printf ("territory is %s\n", territory);
    supported_territories[num_of_territories++] = strdup(territory);
    territory = strtok (NULL, ",");
  }

  printf ("%d territories detected in the territories list.\n", num_of_territories);

  return (true);
}




/* Write a number in word form toa file pointer. */
int
fwriteword( int n, FILE *fp )
{
        return fwrite( &n, sizeof n, 1, fp );
}



/* Under the new scheme, we wish to store each of the territory directories
    in the structure in the following way.
   Note that one resource block can be used by more than one country, eg.
    the USA and UK may share resource blocks as they may well be indentical.

      |-----------|
      |     1     | Header. One word per territory held in the following block. Each number
      |     4     |  is the corresponding country code for the territory, with 0 being the common block.
      |    -1     | The list is terminated with a -1.
      |-----------|
      | Resources |  The resources block for this country.
      |           |
      |           |
      |-----------|
      |     0     |  End of this resourcefs chain.
      |-----------|
      |     0     |  Another country (this one is the common one)
      |    -1     |
      |-----------|
      | Resources |  Another resources block
      |           |
      |           |
      |-----------|
      |     0     |  End of this resourcefs chain.
      |-----------|
      |    -1     |  Block terminator.
      |-----------|

     Hence we introduce a wrapper around the original code, calling it once
for each different territory block that we wish to add. Simple, eh?
*/

int main( int argc, char *argv[] )
{
  unsigned int loop;
  FILE *fp = NULL;
  char path2[BUFSZ];

  if ( argc != 3 )
  {
    error( "Syntax: scanres <directory> <file>", NULL );
  }

  printf("Scanning from directory %s\n", argv[1]);

  /* Canonicalise directory path. */
  _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
         37, argv[1], path, 0, 0, BUFSZ );

  /* Read all the directory names.
     If a directory is numeric, ten it contans 1 or more territories (eg. 0001 would have both Common (00) and UK (01) resource blocks
     If it is a string, then it is a country name. Pass it in to Territory_NumberToName to get te numeric value. If it does not exist, throw an error.
  */
  find_resource_directories(path);

  /* Canonicalise output file path. */
  _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
      37, argv[2], buffer, 0, 0, BUFSZ );

  /* Open the output file for writing the resource blocks to. */
  if ((fp=fopen( buffer, "wb" )) == 0)
  {
    error("Could not open %s for writing\n", buffer);
  }

  /* Parse through all the directories that have been stored, writing the
      relevant data to the block before appending the data. */
  for (loop=0; loop < num_of_territory_dirs; loop++)
  {
    unsigned int index = 0;
    printf("Directory %d is %s (territory numbers: ", loop, terrritory_directories[loop]);
    /* Write the list of territories this block is suitable for:
    * zero means any; list terminated by -1.
    */
    do
    {
      printf("%d ", territory_numbers[loop][index]);
      fwriteword(territory_numbers[loop][index++], fp);
    }
    while (territory_numbers[loop][index]!=-1);
    fwriteword(-1, fp); /* Terminate the header territory list. */
    printf(")\n");

    strcpy(path2, path);
    appendleaf(path2, terrritory_directories[loop]);
    printf ("Appending data for territory resource dir %s\n", path2);

    if ( gettype(path2) == 2 ) /* It must obviously be a directory */
    {
      descend( path2, path2+strlen(path2)+1, fp );

      /* Add on a zero-word to mark end of ResourceFS chain */
      fwriteword( 0, fp );
    }
    else
    {
      error( "'%s' is not a directory", path );
    }
  }

  /* And a -1 to mark end of block sequence */
  fwriteword( -1, fp );

  /* Close the output file. */
  fclose( fp );

  /* Tidy up the memory allocation */
  for (loop=0; loop < num_of_territory_dirs; loop++)
  {
    if (terrritory_directories[loop])
    {
      free (terrritory_directories[loop]);
      terrritory_directories[loop] = NULL;
    }
  }

}





/*
  This routine scans through root_path and places all directories held within
it into the territory_directories array. It then parses through the directory
entries and converts the entries into numeric form.
  It returns false if no valid resource directories were located in root_path.
*/

bool find_resource_directories(const char* const root_path)
{
  /* Recurse from path. */
  char *buf = malloc( BUFSZ );
  int offset = 0;

  if ( buf != NULL )
  {
    do
    {
      object *op = (object *)buf;
      int nread;

      _swi( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
              10, path, buf, 80, offset, BUFSZ, 0, &nread, &offset );

      while ( nread > 0 )
      {
        appendleaf( path, op->name );
        switch ( op->type )
        {
           case 2:
             printf("Directory is %s\n", path);
             convert_dir_to_numeric_form(op->name);
             break;
        }
        stripleaf( path );
        op = (object *)(((int)(op->name)+strlen(op->name)+4)&~3);
        nread -= 1;
      }
    } while ( offset != -1 );

    free( buf );
  }
  else
  {
    error( "Not enough memory to descend '%s'", path );
  }

  return (true);
}



/* Convert the directory name passed in to a numeric form.
   If the directory name is in numeric form, then it converts every two
digits into a unique territory number (eg. 0105 represents territories 1 and
5). Textual names (eg. UK or France) get sent to Service_International to be
converted to a numeric representation.
   The name 'Common' is a special case; if this is seen, then it is given the
territory number of 0 as expected within the specification.
   If there is an error, return false.
*/
bool convert_dir_to_numeric_form(const char* const dir_name)
{
  unsigned int loop=0;
  bool is_numeric = true;
  bool success = true;

  /* Firstly, is this a numeric filename? */
  for (loop=0; loop<strlen(dir_name); loop++)
  {
    if (!isdigit(dir_name[loop])) /* It is not a numeric digit */
    {
      is_numeric = false;
    }
  }

  if (is_numeric) /* Split this into a series of two-digit country codes. */
  {
    char tempstr[10];
    unsigned int length = strlen(dir_name);
    unsigned int index = 0;
    unsigned int count = 0;
    do
    {
      tempstr[0] = dir_name[index++];
      tempstr[1] = dir_name[index++];
      tempstr[2] = '\0';
      printf ("Index = %d  number=%d\n", index, atoi(tempstr));
      territory_numbers[num_of_territory_dirs][count++] = atoi(tempstr);
    }
    while (index < length); /* Until we reach the end of the string. */
    territory_numbers[num_of_territory_dirs][count++] = -1; /* Terminate the list. */
  }
  else /* Is a named country. Convert to a territory number. */
  {
    unsigned int territory_number;
    if (cstrcmp(dir_name, "Common") == 0) /* It is the common dir */
    {
      territory_number = 0; /* Country code representing the Common dir */
    }
    else
    {
      if ((territory_number = return_country_number(dir_name)) == -1)
      {
        /* Unrecognised country name */
        success = false;
      }
    }
    printf("Country code for %s is %d\n", dir_name, territory_number);
    territory_numbers[num_of_territory_dirs][0] = territory_number;
    territory_numbers[num_of_territory_dirs][1] = -1; /* Terminate the list. */
  }

  terrritory_directories[num_of_territory_dirs] = strdup(dir_name);
  /* Move onto the next part of the territory list. */
  num_of_territory_dirs++;

  return (success);
}





/*****************************************************************************
* return_country_number
*
* This routine returns the country code number of a passed in country.
*
* Assumptions
*  That the version of the International module has knowledge about the
*   country that is being requested.
*
* Inputs
*  country     : A string containing the name of the territory to be
*                 converted.
*
* Outputs
*  None
*
* Returns
*  This routine returns the numeric form of the territory name passed in, or
*   -1 if it is not a valid country. Note that build machines that wish
*   to use utilities that inclue this routine should ensure that they have
*   the latest version of the International module so that they can ensure
*   they are aware of all the latest Name->number mappings.
*
*****************************************************************************/
int return_country_number(const char* const country)
{
  _kernel_swi_regs reg;
  int return_value = 0;

  reg.r[1] = Service_International;
  reg.r[2] = 0;              /* sub-reason code 0 */
  reg.r[3] = (int)country;   /* The country we require (NULL terminated) */
  reg.r[4] = 0;
  _kernel_swi(OS_ServiceCall, &reg, &reg);

  if (reg.r[1] != 0)
    return_value = -1; /* Unrecognised country */
  else
    return_value = reg.r[4];

  return (return_value);
}


@


4.9
log
@	ResCommon now allows resource sets *not* to have UK in them.

Detail:
	On a delete-poweron, the default territory is set to UK (01). On
startup the messages module looks at all the registered ResourceFS blocks and
uses the ones containing the currently territory.
	Unfortunately if the territories in the build do not include the UK
resource set, this means that no resources are allocated, and hence the
machine does not boot up in varies weird and wonderful ways (usually by the
WIMP failing to initialise).
	To overcome this limitation, if the territory list in the ROM does
not include UK, then the UK territory code is added to the first territory's
resource blocks. This means that the country code 01 is present in the ROM,
but it does not point to the UK territory. This allows the ROM to boot up.
	The code in ResCommon and ScanRes have been tidied.
	Added a file explaining how the resource differencing within
ResCommon works into a Docs directory.

Admin:
	Tested in Bethany and Lazarus builds. Builds containing UK resource
blocks still work, and ones without it work, and default to the first
territory in the territory list after a delete-poweron.

Version 0.98. Tagged as 'Messages-0_98'
@
text
@d185 1
a185 1
        char *fbuf, *resp, *resendp;
@


4.9.2.1
log
@  Checkpoint check-in.
Detail:
  These are the initial portable versions of all these utilities.
  Most have not been tested and the rest have received cursory testing.
  They do all compile for me though.
Admin:
  Not for use - checked-in to provide a baseline only.
  Some notes on portability changes added too.


Version 1.05, 4.25.2.1. Tagged as 'Messages-1_05-4_25_2_1'
@
text
@d15 1
a15 8

/* ScanRes
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

/* Standard C headers */
d17 1
a17 1
#include <stdio.h>
a18 1
#include <stdarg.h>
a19 2
#include <stddef.h>
#include <errno.h>
a20 1
#include <time.h>
d22 2
a23 17
/* CLX heders */
#include "wholefls.h"
#include "err.h"
#include "host.h"
#include "prgname.h"
#include "bytesex.h"
#include "filestamp.h"

/* Local */
#include "shared.h"

#ifdef RISCOS
#  include "swis.h"
#else
#  include <sys/stat.h>
#  include <dirent.h>
#endif
a24 1
#ifdef RISCOS
a25 3
#else
#define BUFSZ 4096
#endif
d30 1
a30 1
typedef int32 word;
d51 1
a51 1
char dir_sep_char;
d55 3
d61 2
a62 2
char* territory_directories[MAX_TERRITORIES]; /* Stores the directory names */
unsigned long territory_numbers[MAX_TERRITORIES][MAX_TERRITORIES]; /*  Store the numeric representation of each territory. Array is terminated by -1. */
d67 1
d69 2
a70 2
static bool convert_dir_to_numeric_form(const char* const dir_name);
char *appendleaf( char *path, char *leaf );
d74 1
a74 1
* Strcmp_ci
d94 1
a94 1
int Strcmp_ci(const char *first_param, const char *second_param)
d96 1
a96 2
        const unsigned char *first = (const unsigned char *) first_param;
        const unsigned char *second = (const unsigned char *) second_param;
d98 2
a99 2
        if (first == second) return 0;
        if (first == NULL || second == NULL) return -1;
d101 9
a109 12
        for (;;) {
                unsigned int a = *first++;
                unsigned int b = *second++;

                if (a == 0) return -b;
                if (a != b) {
                        unsigned int c = (unsigned int) tolower(a);
                        unsigned int d = (unsigned int) tolower(b);
                        signed int result = c - d;
                        if (result != 0) return result;
                }
        }
d112 2
d118 1
a118 1
        fprintf( stderr, "ERROR: ");
d121 1
a121 1
        vfprintf( stderr, str, argp );
a123 2
        putc('\n', stderr);

d131 1
a131 2

char *strdup(const char *s1)
d133 1
a133 6
        if (s1 == NULL) {
                s1 = "";
        }
        {
                const size_t length = strlen(s1) + 1;
                char *const s2 = malloc(length);
d135 7
a141 3
                if (s2 == NULL) return NULL;
                return memcpy(s2, s1, length);
        }
a143 5
int
gettype( char *obj )
{
        return wf_objtype(obj);
}
a145 3
typedef struct {
  object op[2];
} align_test;
d147 4
a150 5
#define STRUCTURE_ALIGNMENT \
  ((offsetof(align_test, op[1]) - offsetof(align_test, op[0].name)) - 1)

#ifndef RISCOS
static void modgen_time_t_to_riscos(TimeStamp ts, int32 *load, int32 *exec)
d152 2
a153 11
        /* convert a time_t (seconds from 1 Jan 1970 00:00:00 UTC) to a RISC OS
         * date/time stamp (centiseconds from 1 Jan 1900 00:00:00 UTC)
         * The "load address" attribute used by RISCOS is equal to 0xFFFtttdd, where
         * ttt is a 12-bit file type and dd is bits 32..39 of the time stamp. This is
         * defined as the number of centiseconds since 01-Jan-1900.
         *
         * DOS and UNIX deal (in the main) with time as the number of seconds since
         * 01-Jan-1970, which is to be RISCOS time 0x33 6E99 6A00.  Hence the conversion
         * is relatively simple.   RISCOS time = 336E996A00h + 100*UNIX time
         */
        int32 t_hi, t_lo;
d155 2
a156 2
        t_hi = 0x336E99 + (ts >> 16) * 100;
        t_lo = 0x6A00 + (ts & 0xFFFF) * 100;
d158 1
a158 2
        *load = (*load & ~0xFF) | ((t_hi + (t_lo >> 16)) >> 16);
        *exec = (t_hi << 16) + t_lo;
a160 45
/* This routine may truncate 'leaf' as a result of deriving the filetye */
static void derive_riscos_attributes(object *op, struct stat *sb, char *leaf, char *fullname, FILE *fobj)
{
  TimeStamp ts = filestamp_get(fullname);
  char *last_comma = strrchr(leaf, ',');

  op->loadaddr = 0xFFF00000;
  op->execaddr = 0;
  op->length = (int32) (sb->st_size);
  op->attr = 3;
  op->type = (sb->st_mode & S_IFDIR) ? 2 : 1;

  if (last_comma && strlen(last_comma) == 4) {
    int32 type;
    int count = -1;
    if (strcmp(last_comma+1, "lxa") == 0) {
      /* need to load the last 8 bytes to get the load/exec address, then truncate */
      op->length -= 8;
      *last_comma = '\0';
      fseek(fobj, -8L, SEEK_END);
      fread(&op->loadaddr, 4, 1, fobj);
      fread(&op->execaddr, 4, 1, fobj);
      op->loadaddr = bytesex_hostval(op->loadaddr);
      op->execaddr = bytesex_hostval(op->execaddr);
      rewind(fobj);
    }
    else if (strcmp(last_comma+1, "xxx") == 0) {
      error("File is unstable! (%s is being updated whilst this utility is running)", fullname);
    }
    else if (sscanf(last_comma+1, "%x%n", &type, &count) > 0 && count == 3) {
      *last_comma = '\0';
      op->loadaddr = 0xFFF00000 | ((type & 0xFFF) << 8);
      modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
    }
    else {
      /* Not a filetype */
      op->loadaddr = 0xFFFFFF00;
      modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
    }
  }
  else {
    op->loadaddr = 0xFFFFFF00;
    modgen_time_t_to_riscos(ts, &op->loadaddr, &op->execaddr);
  }
}
d163 2
a164 25
/*****************************************************************************
* load_unix_directory
*
* This routine enumerates the contents of the specified directory and stores
* the results in 'buf'.  buf has size bufsize, *nread receives the number of
* entries in the directory.  'buf' is filled with structures as returned by
* OS_GBPB 10, although not all the data is filled in (only the name and
* the objct type)
*
* Assumptions
*  the buffer is large enough to receive the details on ALL items.
*
* Inputs
*  dir:     the directory to search (must be writable!)
*  buf:     to receive the output records
*  bufsize: size of buf
*
* Outputs
*  nread:   the number of items placed in buf.
*
* Returns
*  Nothing.
*****************************************************************************/

void load_unix_directory(char *dir, char *buf, size_t bufsize, int *nread)
d166 1
a166 43
  DIR *d = opendir(dir);
  char *const leaf = appendleaf(dir, "") + 1;

  *nread = 0;

  if (!d) {
    error("Unable to open directory '%s'\n", dir);
  }

  for (;;) {
    struct dirent *de;
    errno = 0;
    de = readdir(d);
    if (de == NULL) {
      if (errno == 0) {
        break;
      }
      else {
        error("Unable to read directory '%s': %s\n", dir, strerror(errno));
        break;
      }
    }
    else {
      object *op = (object *) buf;
      int namelen;

      if (de->d_name[0] == '.' && (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0'))) {
        continue;
      }

      /* Find length of leafname whilst copying it */
      namelen = sprintf(leaf, "%s", de->d_name);

      if (sizeof(*op) + namelen >= bufsize) {
        error("out of buffer space in load_unix_directory (directory %s)", dir);
      }
      else {
        struct stat sb;

        op->type = gettype(dir);
        if (op->type != 1 && op->type != 2) {
          continue;
        }
d168 1
a168 9
        buf = memcpy(op->name, de->d_name, namelen) + namelen;
        do {
          *buf++ = '\0';
        } while (((int)buf)&STRUCTURE_ALIGNMENT);
        bufsize -= (buf - (char *)op);
        ++(*nread);
      }
    }
  }
d170 1
a170 2
  (void) closedir(d);
  leaf[-1] = '\0';
a171 1
#endif
d173 2
a174 2
static
void riscosify_path( char *path )
d176 1
a176 4
  /* Invert the directory separator and '.' */
  for (; *path; ++path) {
    if (*path == dir_sep_char) *path = '.'; else if (*path == '.') *path = dir_sep_char;
  }
d179 1
a179 1
static void
d182 3
a184 3
        int32 filelen;
        int32 pathlen = 0;
        int32 totallen;
a185 1
        FILE *rp;
d187 6
a192 10
#ifndef RISCOS
        struct stat sb;

        if (stat(path, &sb) == -1) {
          error("error reading attributes of '%s': %s", path, strerror(errno));
        }
#endif

        rp = fopen( path, "rb" );
        if (rp != NULL)
d194 1
a194 12
#ifndef RISCOS
                derive_riscos_attributes(op, &sb, strrchr(path, dir_sep_char), path, rp);
#endif

                filelen = (op->length+3)&~3;                /* Aligned file length. */

                /* ResourceFS directories can contain more than 77 directory entries but ADFS
                 * directories can't. To get round this any directory starting with "Resources"
                 * (eg. Resources1, Resources2 etc.) will be reduced to "Resources" in the pathname
                 * inside ResourceFS.
                 */
                if ( (resp = strstr(respath, "Resources")) != NULL )
d196 6
a201 9
                        if ( (resendp = strchr(resp, dir_sep_char)) != NULL )
                        {
                                /* Adjustment for pathlen as Resources* will have * stripped out. */
                                pathlen = 9-(int32)(resendp-resp);
                        }
                        else
                        {
                                resp = NULL;
                        }
d203 2
a204 1
                pathlen = (pathlen+strlen(respath)+4)&~3;       /* Aligned ResourceFS file name length. */
d206 1
a206 1
                totallen = sizeof(resfile)+pathlen+sizeof(int)+filelen;
d208 1
a208 1
                fbuf = (char *)malloc( (size_t) totallen );
d210 4
a213 1
                if ( fbuf != NULL )
d218 2
a219 2
                        /* Clear fbuf.  SNB: Why?? */
                        memset(fbuf, 0, (size_t) totallen);
d222 5
a226 14
                        if (bytesex_reversing()) {
                          rf->next = bytesex_hostval(totallen);
                          rf->loadaddr = bytesex_hostval(op->loadaddr);
                          rf->execaddr = bytesex_hostval(op->execaddr);
                          rf->length = bytesex_hostval(op->length);
                          rf->access = bytesex_hostval(3);
                        }
                        else {
                          rf->next = totallen;
                          rf->loadaddr = op->loadaddr;
                          rf->execaddr = op->execaddr;
                          rf->length = op->length;
                          rf->access = 3;
                        }
a241 2
                        /* Re-convert the host directory separator to the RISC OS directory separator */
                        if (dir_sep_char != '.') riscosify_path(path);
d244 1
a244 1
                        *(int32 *)(path+pathlen) = bytesex_hostval(op->length+4);
d247 1
a247 1
                        if ( fread( fbuf+totallen-filelen, sizeof(char), (size_t) op->length, rp ) != op->length )
d250 3
a252 1
                        if ( fwrite( fbuf, sizeof(char), (size_t) totallen, fp ) != totallen )
d257 1
a257 1
                        error( "Not enough memory to append '%s'", path );
a259 1
                fclose( rp );
d263 1
a263 1
                error( "Can't open '%s' for reading", path );
d267 1
a267 4

/* Append leaf to path, returning truncation point to remove it again
 */
char *
d270 2
a271 4
        path = strchr(path, '\0');
        *path = dir_sep_char;
        (void) strcpy(path+1, leaf);
        return path;
a273 2
/* Strip leaf from path.
 */
d277 3
a279 1
        *path = '\0';
a296 1
#ifdef RISCOS
a298 4
#else
                        offset = -1;
                        load_unix_directory(path, buf, BUFSZ, &nread);
#endif
d302 1
a302 1
                                char *trunc_char = appendleaf( path, op->name );
d313 2
a314 2
                                stripleaf( trunc_char );
                                op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
d327 6
a332 1
/* Canonicalise the given file name.
d334 2
a335 2
void
canonicalise( char *src, char *dest, int bufsz )
d337 21
a357 7
#ifdef RISCOS
        _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
                37, src, dest, 0, 0, bufsz );
#else
        *dest = 0;
        strncat(dest, src, bufsz);
#endif
d361 2
d364 2
a365 2
void
fwriteword( unsigned long param_n, FILE *fp )
d367 1
a367 6
        const unsigned int n = (unsigned int) param_n;

        putc(((n >>  0) &0xFF), fp);
        putc(((n >>  8) &0xFF), fp);
        putc(((n >> 16) &0xFF), fp);
        putc(((n >> 24) &0xFF), fp);
d408 1
a408 1
  static char path2[BUFSZ];
a414 4
  host_init();
  dir_sep_char = host_dir_sep_char();
  bytesex_reverse_auto(bytesex_WANT_LITTLE_ENDIAN);

d418 2
a419 1
  canonicalise(argv[1], path, BUFSZ);
d428 2
a429 1
  canonicalise(argv[2], buffer, BUFSZ);
d442 1
a442 1
    printf("Directory %d is %s (territory numbers: ", loop, territory_directories[loop]);
d448 1
a448 1
      printf("%ld ", territory_numbers[loop][index]);
d456 1
a456 1
    (void) appendleaf(path2, territory_directories[loop]);
d476 10
a485 3
  if (fclose(fp) == EOF) {
    error( "Error writing output file!\n" );
    exit(EXIT_FAILURE);
a487 1
  exit(EXIT_SUCCESS);
d491 3
a513 1
#ifdef RISCOS
a515 4
#else
      offset = -1;
      load_unix_directory(path, buf, BUFSZ, &nread);
#endif
d519 1
a519 1
        char *const trunc_char = appendleaf( path, op->name );
d527 2
a528 2
        stripleaf( trunc_char );
        op = (object *)(((int)(op->name)+strlen(op->name)+STRUCTURE_ALIGNMENT+1)&~STRUCTURE_ALIGNMENT);
d554 1
a554 1
static bool convert_dir_to_numeric_form(const char* const dir_name)
d571 1
a571 1
    char tempstr[4];
a576 1
      unsigned int eval_result;
d580 2
a581 3
      eval_result = (int) strtol(tempstr, NULL, 10);
      territory_numbers[num_of_territory_dirs][count++] = eval_result;
      printf ("Index = %d  number=%d\n", index, eval_result);
d588 2
a589 2
    unsigned long territory_number;
    if (Strcmp_ci(dir_name, "Common") == 0) /* It is the common dir */
d601 1
a601 1
    printf("Country code for %s is %ld\n", dir_name, territory_number);
d606 1
a606 1
  territory_directories[num_of_territory_dirs] = strdup(dir_name);
d612 49
@


4.8
log
@	Uodated ScanRes and ResCommon.

Detail:
	ScanRes now uses Service_International rather than the
Territory_NameToNumber swi. Also added the caseless strcmp() routine to allow
certain string comparisons to work.
	ResCommon now places resources that are common between all the
resource sets into a 'Common' directory, rather than in a numeric form. This
allows ScanRes to place them in the '00' directory that the messages module
expects on start-up.

Admin:
	Tested in Bethany and Lazarus builds.

Version 0.97. Tagged as 'Messages-0_97'
@
text
@d548 1
a548 1
5). Textual names (eg. UK or France) get sent to Territory_NameToNumber to be
d550 2
d616 25
a640 7
/*
 Return the country code number of a passed in country.
 Returns -1 if it is not a valid country. Note that build machines that wish
  to use utilities that inclue this routine should ensure that they have the
  latest version of the Territory module so that they can ensure they are
aware of all the latest Name->number mappings.
*/
@


4.7
log
@	Minor changes to ResCommon and ScanRes
Detail:
	Added more comments to ResCommon and added a few more run-time checks
for incorect parameters. Corrected a comment in ScanRes.
Amin:
	Tested in a Bethany build.

Version 0.95. Tagged as 'Messages-0_95'
@
text
@d22 1
d73 39
d113 2
a114 2
void
error( const char *str, ... )
d587 1
a587 1
    if (strcmp(dir_name, "Common") == 0) /* It is the common dir */
d626 5
a630 4
  /* This should be altered to use OS_Service(Service_Territory 0) as that does not expect the territory to be converted to to be in any particular language. */
  reg.r[0] = -1;		/* no paths */
  reg.r[1] = (int)country;
  _kernel_swi(Territory_NameToNumber, &reg, &reg);
d632 2
a633 2
  if (reg.r[0] == 0)
    return_value = -1; /* Not a valid country */
d635 1
a635 1
    return_value = reg.r[0];
d639 1
@


4.6
log
@	Bug fixed and general tidying.

Detail:
	Some redundant code had been left in ResCommon, which caused the
resource sets to be incomplete. This code as been removed.
	ResCommon has had many comments added explaining what is going on,
along with associated code tidying.

Admin:
	Tested in Lazarus and Bethany builds. Requires srcbuild 0.21 or
later. Appears to be stable, but use with caution.

Version 0.94. Tagged as 'Messages-0_94'
@
text
@d55 1
a55 1
#define MAX_TERRITORIES 10            /* As defind in the spec. */
@


4.5
log
@	More changes.
Detail:
	* ResCommon no longer called with Verbose flag set.
	* A new Perl script, RemoveEmpt, added, that strips out any emtpy
directories in the processed directory.
	* ResCommon now deals correctly with squashed filed - it reads in the
header of the file and ignores the exec address.
	* get_filetype() now works correctly.
	* ResCommon has been generally tidied up.
Admin:
	Still under development. Should work more reliably than the previous
version.

Version 0.93. Not tagged
@
text
@d332 4
a335 3
  /* Under the new scheme, we wish to store each of the territory directories in the structure in the following way.
     Note that one resource block can be used by more than one country, eg.
      the USA and UK may share resource blocks as they may well be indentical.
@


4.4
log
@	Many changes. Warning, Danger! Danger!
	This version of the module deals with multiple territory blocks being
held in ResourceFS.

Detail:
	* Fixed a bug in TokGen2. MAX_TOKEN_LEN2 was set to 256, when it
actually should be 254 (to allow for 2 byte to hold length and status). This
was causing an overflow which meant that large messages were not being
correctly tokenised. Also added a check for tokens that are too long, to at
least make sure that the buildmaster is informed that something has gone
screwy with the token generation instead of continuing on regardless.
	* Created a simple Perl script, HelpApend, that appends common help
data onto the end of each of the individual territory blocks.
	* Bug fixed in s.Common: Pointer in list was not being advanced.
	* ScanRes altered to allow nested resorce blocks.
	* Bug fixed in ResCommon - the -simulate flag now works in the
correct manner, and not the inverse (ooops!)
	* MsgTok2 now gives a warning if the input file is not present.
	* The main MakeFile has been altered to go through the extra stages
needed by the multiple-resource system.
	* Added the ResCommon binary.

To be done:
	* Make ScanRes use Service_Territory 0 instead of
Territory_NameToNumber to work out territory number to name mappings.
	* Make ResCommon cope with Squash files.
	* Make ResCommon remove all empty directories from the resource
directories.
	* Tidy up the code.
	* Add documentation.
	* Thoroughly test on different builds.

Admin:
	Must be used with srcbuild 20 or later.
	Important notice: From this version onwards, the TerritoryManager
*must* be placed ahead of Messages in the ROM, but after ResourceFS.
	This module has not yet been tested without the LocaleList system
variable being set.
	Work in progress. Do not use for anything release-critical.

Version 0.93. Not tagged
@
text
@d333 2
a334 1
     Note that one resource block can be used by more than one country, eg. the USA and UK may share resource blocks as they may well be indentical.
d339 1
a339 1
      |     -1    | The list is terminated with a -1.
d356 1
a356 1
      |   -1      |  Block terminator.
@


4.3
log
@Changes to Messages module code to support message selection by territory.
Build work for this not done yet, but ScanRes modified to output new form
of data block.

Untested.

Version 0.93. Not tagged
@
text
@d19 2
d52 21
d84 35
a118 1
        exit( 1 );
d121 2
d172 1
a172 1
                FILE *rp = fopen( path, "r" );
d248 2
d287 37
a329 4
int
main( int argc, char *argv[] )
{
        if ( argc != 3 ) error( "Syntax: scanres <directory> <file>", NULL );
a330 3
        /* Canonicalise directory path. */
        _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
                37, argv[1], path, 0, 0, BUFSZ );
d332 115
a446 5
        if ( gettype(path) == 2 )
        {
                /* Canonicalise file path. */
                _swi( OS_FSControl, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5),
                        37, argv[2], buffer, 0, 0, BUFSZ );
a447 3
                if ( gettype(buffer) != 2 )
                {
                        FILE *fp = fopen( buffer, "w" );
a448 3
                        if ( fp != NULL )
                        {
                                int zero = 0, minusone = -1;
a449 9
                                /* List of territories this block is suitable for:
                                 * zero means any; list terminated by -1.
                                 */
                                fwriteword( 0, fp );
                                fwriteword( -1, fp );

                                descend( path, path+strlen(path)+1, fp );
                                /* Add on a zero-word to mark end of ResourceFS chain */
                                fwriteword( 0, fp );
a450 2
                                /* And a -1 to mark end of block sequence */
                                fwriteword( -1, fp );
d452 27
a478 13
                                fclose( fp );
                        }
                        else
                        {
                                error( "Can't open '%s' for write", buffer );
                        }
                }
                else
                {
                        error( "Destination is a directory", NULL );
                }
        }
        else
d480 4
a483 1
                error( "'%s' is not a directory", path );
d485 82
d568 29
@


4.2
log
@ScanRes utility modified to include trailing zero word in output file -
necessary for MessData export.
MessagesHI now expects to find resources at &04000000 - latest Kernel maps
top 8Mb of ROM there.

Version 0.87. Tagged as 'Messages-0_87'
@
text
@d227 6
d253 7
a259 1
                                int zero = 0;
d263 5
a267 1
                                fwrite( &zero, sizeof zero, 1, fp );
@


4.1
log
@Initial revision
@
text
@d247 2
d250 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

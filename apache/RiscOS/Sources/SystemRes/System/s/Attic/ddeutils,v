head	1.5;
access;
symbols
	System-0_05:1.4
	System-0_04:1.4
	System-0_03:1.4
	ROL_DDEUtils-1_61:1.4.2.1
	ROL:1.4.0.2
	ROL_bp:1.4
	sbrodie_DDEUtils-1_56:1.4
	mstphens_UrsulaRiscPCBuild_20Nov98:1.3
	Ursula_RiscPC:1.3.0.4
	rthornb_UrsulaBuild-19Aug1998:1.3
	UrsulaBuild_FinalSoftload:1.3
	rthornb_UrsulaBuild-12Aug1998:1.3
	Ursula:1.3.0.2
	Ursula_bp:1.3
	sbrodie_DDEUtils-1_55:1.3
	sbrodie_DDEUtils-1_54:1.1;
locks; strict;
comment	@# @;


1.5
date	2012.01.06.22.36.44;	author rsprowson;	state dead;
branches;
next	1.4;
commitid	XThX5jkpjaCigaOv;

1.4
date	99.01.06.10.26.16;	author sbrodie;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	98.08.10.14.27.01;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	98.08.10.14.19.37;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.08.10.13.12.28;	author sbrodie;	state Exp;
branches;
next	;

1.4.2.1
date	99.09.22.10.43.38;	author sbrodie;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	99.11.22.12.08.15;	author sbrodie;	state dead;
branches;
next	;


desc
@@


1.5
log
@Put some fossils in the museum.
Move the RMEnsures to the relevant CLib and CallASWI for RISC OS 5.18.

Version 0.06. Tagged as 'System-0_06'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Title:   s.ddeutils
; Purpose: Assembler source for DDEUtils module
; Author:
; History: Used to live on Aquarius SrcFiler
;
r0              RN      0
r1              RN      1
r2              RN      2
r3              RN      3
r4              RN      4
r5              RN      5
r6              RN      6
r7              RN      7
r8              RN      8
r9              RN      9
r10             RN      10
r11             RN      11
r12             RN      12
r13             RN      13
r14             RN      14
r15             RN      15

sl              RN      10
fp              RN      11
ip              RN      12
sp              RN      13

lr              RN      14
pc              RN      15

                GBLL    BOMB
BOMB            SETL    {FALSE}

		GBLL	readswi
readswi         SETL    {TRUE}
; if readswi is true, then SWI DDEUtils_ReadPrefix is available
; Input: R0: task handle or 0 for current task
; Output: R0: pointer to prefix dir for that task or 0 if none.

os_writec       EQU     0
os_writes       EQU     1
os_write0       EQU     2
os_newline      EQU     3

xos_module      EQU     &2001e
xos_claim       EQU     &2001f
xos_release     EQU     &20020
xos_changeenvironment EQU &20040
xos_enteros     EQU     &20016
os_exit         EQU     &11
os_generateerror EQU    &2b
xwimp_readsysinfo EQU   &600f2
xwimp_sendmessage EQU   &600e7
xos_setvarval   EQU     &20024
xos_word        EQU     &20007
os_converthex8  EQU     &d4

zp_wimpdomain   EQU     &ff8

n_module_claim  EQU     6
n_module_free   EQU     7

n_filev         EQU     &08
n_gbpbv         EQU     &0c
n_findv         EQU     &0d
n_fscontrolv    EQU     &0f

n_error_h       EQU     6
n_exit_h        EQU     11

ddeutils_swibase             EQU    &42580
ddeutils_prefix              EQU    0               ; + ddeutils_swibase
ddeutils_setclsize           EQU    1
ddeutils_setcl               EQU    2
ddeutils_getclsize           EQU    3
ddeutils_getcl               EQU    4
ddeutils_throwbackregister   EQU    5
ddeutils_throwbackunregister EQU    6
ddeutils_throwbackstart      EQU    7
ddeutils_throwbacksend       EQU    8
ddeutils_throwbackend        EQU    9
	[ readswi
ddeutils_readprefix          EQU    10
	]

reason_processing            EQU    0
reason_errordetails          EQU    1
reason_infodetails           EQU    2

overflow        EQU     &10000000
carry           EQU     &20000000

ddeutils_errbase    EQU &20600
unk_swi_error       EQU ddeutils_errbase + 0
no_cli_buffer_error EQU ddeutils_errbase + 1
not_desktop_error   EQU ddeutils_errbase + 2
no_task_error       EQU ddeutils_errbase + 3
already_reg_error   EQU ddeutils_errbase + 4
not_reg_error       EQU ddeutils_errbase + 5

ddeutils_msgbase             EQU ddeutils_swibase
ddeutils_msgbase_h           EQU &42000
ddeutils_msgbase_l           EQU &580
msg_throwback_start          EQU 0               ; + ddeutils_msgbase
msg_throwback_processingfile EQU 1
msg_throwback_errorsin       EQU 2
msg_throwback_errordetails   EQU 3
msg_throwback_end            EQU 4
msg_throwback_infoforfile    EQU 5
msg_throwback_infodetails    EQU 6

service_reset         EQU &27
service_wimpclosedown EQU &53

o_next          EQU     &00
o_wimpdomain    EQU     &04
o_prefix        EQU     &08

                IMPORT  |__RelocCode|

                AREA    |!|, CODE, READONLY

module_start    EQU     .

                DCD     0                         ; Run
                DCD     init - module_start       ; Init
                DCD     finish - module_start     ; Finish
                DCD     service - module_start    ; Service call
                DCD     title - module_start      ; Title
                DCD     help - module_start       ; Help
                DCD     cmd_table - module_start  ; *commands
                DCD     ddeutils_swibase          ; SWI Base
                DCD     do_swi - module_start     ; SWI Handler
                DCD     swi_table - module_start  ; SWI Table
                DCD     0

title           DCB     "DDEUtils", 0

help            DCB     "DDEUtils", 9
                DCB     "1.56 (05 Jan 1999)", 0

swi_table       DCB     "DDEUtils", 0
                DCB     "Prefix", 0
                DCB     "SetCLSize", 0
                DCB     "SetCL", 0
                DCB     "GetCLSize", 0
                DCB     "GetCl", 0
                DCB     "ThrowbackRegister", 0
                DCB     "ThrowbackUnRegister", 0
                DCB     "ThrowbackStart", 0
                DCB     "ThrowbackSend", 0
                DCB     "ThrowbackEnd", 0
	[ readswi
                DCB     "ReadPrefix", 0
	]
                DCB     0

cmd_table       DCB     "Prefix", 0
                ALIGN
                DCD     prefix_cmd - module_start
                DCB     0                          ; Min. parameters
                DCB     1                          ; GSTrans map
                DCB     1                          ; Max. parameters
                DCB     0                          ; Flags
                DCD     prefix_syn - module_start  ; Syntax message
                DCD     prefix_help - module_start ; Help message
                DCD     0                          ; End of command table

prefix_help     DCB     "*Prefix selects a directory as the current directory unique to the currently executing task. *Prefix with no arguments sets the current directory back to the systemwide default (as set with *Dir).", 13

prefix_syn      DCB     "Syntax: *Prefix [<directory>]", 0
                ALIGN

;Ursula format
;
                ASSERT  service_reset < service_wimpclosedown
;
UServTab
                DCD     0                              ;flags
                DCD     UService - module_start
                DCD     service_reset
                DCD     service_wimpclosedown
                DCD     0                              ;terminator
                DCD     UServTab - module_start        ;anchor
service
                MOV     r0,r0                          ;magic instruction
                TEQ     r1, #service_reset
                TEQNE   r1, #service_wimpclosedown
                MOVNES  pc,lr
UService
                TEQ     r1, #service_reset
                BEQ     recover_from_reset
                CMP     r0, #0
                MOVNES  pc, lr
                STMDB   sp!, {r0, r1, r2, r11, lr}
                LDR     r11, [r0, #zp_wimpdomain]
service1        LDR     r2, [r12]
                CMP     r2, #0
                LDMEQIA sp!, {r0, r1, r2, r11, pc}^
                LDR     r1, [r2, #o_wimpdomain]
                CMP     r1, r11
                MOVNE   r12, r2
                BNE     service1
                LDR     r0, [r2]
                STR     r0, [r12]
                MOV     r0, #n_module_free
                SWI     xos_module
                B       service1

recover_from_reset
                STMDB   sp!, {r0, r1, r2, r3, r4, r5, r6, lr}
                LDR     r2, [r12]
                MOV     r1, #0
                STR     r1, [r12]
recover_from_reset1
                CMP     r2, #0
                BEQ     recover_from_reset2
                LDR     r5, [r2]
                MOV     r0, #n_module_free
                SWI     xos_module
                MOV     r2, r5
                BVC     recover_from_reset1
recover_from_reset2
                BL      init
                LDMIA   sp!, {r0, r1, r2, r3, r4, r5, r6, pc}^

filetype_fd3    DCB     "File$Type_FD3", 0
debimage        DCB     "DebImage", 0
runtype_fd3     DCB     "Alias$@@RunType_FD3", 0
debugaif        DCB     "DebugAIF %*0", 0
loadtype_fd3    DCB     "Alias$@@LoadType_FD3", 0
loadaif         DCB     "Load %0 8000", 0
filetype_fe1    DCB     "File$Type_FE1", 0
makefile        DCB     "Makefile", 0
runtype_fe1     DCB     "Alias$@@RunType_FE1", 0
make            DCB     "DDE:!Make %*0", 0
prefix_dir      DCB     "Prefix$Dir", 0
                ALIGN
n_vartype_code  EQU     16

init            STMDB   sp!, {r7, r8, r9, r10, r11, lr}
                [ BOMB
                BL      time_bomb
                |
                BL      |__RelocCode|
                ]
                STR     r12, prefix_r12
                ADR     r0, filetype_fd3
                ADR     r1, debimage
                BL      initvar
                ADR     r0, runtype_fd3
                ADR     r1, debugaif
                BL      initvar
                ADR     r0, loadtype_fd3
                ADR     r1, loadaif
                BL      initvar
                ADR     r0, filetype_fe1
                ADR     r1, makefile
                BL      initvar
                ADR     r0, runtype_fe1
                ADR     r1, make
                BL      initvar
                MOV     r2, r12
                MOV     r0, #n_filev
                ADR     r1, file_handler
                SWI     xos_claim
                MOVVC   r0, #n_gbpbv
                ADRVC   r1, gbpb_handler
                SWIVC   xos_claim
                MOVVC   r0, #n_findv
                ADRVC   r1, find_handler
                SWIVC   xos_claim
                MOVVC   r0, #n_fscontrolv
                ADRVC   r1, fscontrol_handler
                SWIVC   xos_claim
                MOVVC   r0, #n_module_claim
                MOVVC   r3, #256
                SWIVC   xos_module
                STRVC   r2, fname_buffer
                ADRVC   r0, prefix_dir
                ADRVC   r1, prefix_dir_code
                MOVVC   r2, #prefix_dir_code_end - prefix_dir_code
                MOVVC   r3, #0
                MOVVC   r4, #n_vartype_code
                SWIVC   xos_setvarval
                LDMIA   sp!, {r7, r8, r9, r10, r11, lr}
xferv           ORRVS   lr, lr, #overflow
                MOVS    pc, lr

prefix_dir_code B       dir_code_write
                STMDB   sp!, {r11, r12, lr}
                LDR     r12, prefix_r12
                MOV     r11, #0
                LDR     r11, [r11, #zp_wimpdomain]
dir_code1       LDR     r2, [r12]
                CMP     r2, #0
                LDMEQIA sp!, {r11, r12, pc}^
                LDR     r1, [r2, #o_wimpdomain]
                CMP     r1, r11
                MOVNE   r12, r2
                BNE     dir_code1
                ADD     r0, r2, #o_prefix
                MOV     r2, #0
                MOV     r1, r0
dir_code2       LDRB    r11, [r1], #1
                CMP     r11, #' '+1
                ADDCS   r2, r2, #1
                BCS     dir_code2
                LDMIA   sp!, {r11, r12, pc}^
dir_code_write  STMDB   sp!, {r0, lr}
                MOV     r0, r1
                SWI     ddeutils_swibase + ddeutils_prefix
                LDMIA   sp!, {r0, pc}^
prefix_r12      DCD     0
prefix_dir_code_end

finish          MOV     r6, lr
                MOV     r0, #n_module_free
                LDR     r2, fname_buffer
                CMP     r2, #0
                SWINE   xos_module
                LDR     r2, cli_buffer
                CMP     r2, #0
                SWINE   xos_module
                LDR     r2, [r12]
                MOV     r1, #0
                STR     r1, [r12]
                STR     r1, fname_buffer
                STR     r1, cli_buffer
                STR     r1, cli_size
                STR     r1, receiver_id
finish1         CMP     r2, #0
                BEQ     finish2
                LDR     r5, [r2]
                MOV     r0, #n_module_free
                SWI     xos_module
                MOV     r2, r5
                BVC     finish1
finish2         MOV     r2, r12
                MOV     r0, #n_filev
                ADR     r1, file_handler
                SWI     xos_release
                MOV     r0, #n_gbpbv
                ADR     r1, gbpb_handler
                SWI     xos_release
                MOV     r0, #n_findv
                ADR     r1, find_handler
                SWI     xos_release
                MOV     r0, #n_fscontrolv
                ADR     r1, fscontrol_handler
                SWI     xos_release
                MOVS    pc, r6

fname_buffer    DCD     0
cli_buffer      DCD     0
cli_size        DCD     0

	[ readswi
do_readswi
		MOVS	r11, r0, lsl #16
		LDREQ	r11, [r11, #zp_wimpdomain]
		MOVEQ	r11, r11, ror #16
		MOV	r0, #0
		STMDB	sp!, {r1, r2, r3, lr}
do_readswi1
		LDR	r2, [r12]
		TEQ	r2, #0
		LDMEQIA	sp!, {r1, r2, r3, pc}^
		LDR	r1, [r2, #o_wimpdomain]
		TEQ	r11, r1, ror #16
		ADDEQ	r0, r2, #o_prefix
		LDMEQIA	sp!, {r1, r2, r3, pc}^
		MOV	r12, r2
		B	do_readswi1
	]

do_swi
	[ readswi
		TEQ	r11, #ddeutils_readprefix
		BEQ	do_readswi
	]
                CMP     r11, #ddeutils_prefix
                BNE     cli_swi
                MOV     r10, r0
                STMDB   sp!, {r1, r2, r3, lr}
                LDR     r11, [r11, #zp_wimpdomain]
do_swi1         LDR     r2, [r12]
                CMP     r2, #0
                BEQ     do_swi2
                LDR     r1, [r2, #o_wimpdomain]
                CMP     r1, r11
                MOVNE   r12, r2
                BNE     do_swi1
                LDR     r0, [r2]
                STR     r0, [r12]
                MOV     r0, #n_module_free
                SWI     xos_module
                BVC     do_swi1
                LDMIA   sp!, {r1, r2, r3, lr}
                ORRS    pc, lr, #overflow
do_swi2         MOVS    r0, r10
                LDMEQIA sp!, {r1, r2, r3, pc}^
                LDRB    r1, [r0]
                CMP     r1, #' ' + 1
                LDMCCIA sp!, {r1, r2, r3, pc}^
                MOV     r3, #0
do_swi3         LDRB    r1, [r0], #1
                ADD     r3, r3, #1
                CMP     r1, #' ' + 1
                BCS     do_swi3
                ADD     r3, r3, #o_prefix
                MOV     r0, #n_module_claim
                SWI     xos_module
                LDMVSIA sp!, {r1, r2, r3, lr}
                ORRVS   pc, lr, #overflow
                STR     r2, [r12]
                MOV     r0, #0
                STR     r0, [r2], #4
                STR     r11, [r2], #4
                MOV     r0, r10
do_swi4         LDRB    r1, [r10], #1
                STRB    r1, [r2], #1
                CMP     r1, #' ' + 1
                MOVCS   r3, r1
                BCS     do_swi4
                CMP     r3, #'.'
                STREQB  r1, [r2, #-2]
                LDMIA   sp!, {r1, r2, r3, pc}^

strip_hats      ORR     lr, lr, #carry
                B       strip_hats0

; Entry: VC
;        R1  = Filename
;        R11 = Filename buffer
;        R12 = Task block
; Exit:  R11, LR = ???
;        R1  = Preserved
;        R11 = Preserved
;        R12 = New Filename (R1 or R11 on entry)
;        CS => No prefix added (filename contained root char)
add_prefix      ORR     lr, lr, #carry
add_prefix0     STMDB   sp!, {r0, r1, r2, r3, r4, lr}
;                SWI     os_writes
;                DCB     "Before add_prefix: ", 0
;                MOV     r2, r1
;write_name0     LDRB    r0, [r2], #1
;                CMP     r0, #' '+1
;                SWICS   os_writec
;                CMP     r0, #' '+1
;                BCS     write_name0
;                SWI     os_newline
                MOV     r2, r1
add_prefix1     LDRB    r0, [r2], #1
                CMP     r0, #':'
                CMPNE   r0, #'$'
                CMPNE   r0, #'&'
                CMPNE   r0, #'%'
                CMPNE   r0, #'<'
                MOVEQ   r12, r1
                BEQ     add_prefix5
                CMP     r0, #' ' + 1
                BCS     add_prefix1
                MOV     r2, r1
                LDRB    r0, [r2]
                CMP     r0, #'@@'
                BNE     add_prefix2
                LDRB    r0, [r2, #1]!
                CMP     r0, #'.'
                ADDEQ   r2, r2, #1
add_prefix2     MOV     r3, r11
                ADD     r12, r12, #o_prefix
add_prefix3     LDRB    r0, [r12], #1
                CMP     r0, #' ' + 1
                STRCSB  r0, [r3], #1
                BCS     add_prefix3
                LDRB    r0, [r2]
                CMP     r0, #' ' + 1
                MOVCS   r0, #'.'
                STRCSB  r0, [r3], #1
add_prefix4     LDRB    r0, [r2], #1
                CMP     r0, #' ' + 1
                MOVCC   r0, #0
                STRB    r0, [r3], #1
                BCS     add_prefix4
                MOV     r12, r11
;                SWI     os_writes
;                DCB     "After add_prefix: ", 0
;                MOV     r2, r12
;write_name1     LDRB    r0, [r2], #1
;                CMP     r0, #' '+1
;                SWICS   os_writec
;                CMP     r0, #' '+1
;                BCS     write_name1
;                SWI     os_newline
                LDMIA   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
                BICS    lr, lr, #carry
strip_hats0     STMDB   sp!, {r0, r1, r2, r3, r4, lr}
add_prefix5     MOV     r2, r12
                MOV     r1, r11
                MOV     r3, r1
                MOV     r4, r3
add_prefix6     LDRB    r0, [r2], #1
                STRB    r0, [r1], #1
                CMP     r0, #'.'
                LDREQB  lr, [r2]
                CMPEQ   lr, #'^'
                BNE     add_prefix9
                LDRB    lr, [r3]
                CMP     lr, #'$'
                CMPNE   lr, #'@@'
                CMPNE   lr, #'%'
                CMPNE   lr, #'&'
                CMPNE   lr, #'<'
                CMPNE   lr, #'^'
                MOVEQ   r0, #'!'        ; R0 > ' ' and != '.'
                BEQ     add_prefix9
add_prefix7     LDRB    lr, [r2], #1
                CMP     lr, #'.'
                CMPNE   lr, #' '
                BHI     add_prefix7
                SUB     r2, r2, #1
                CMP     r3, r4
                STREQB  lr, [r3]
add_prefix8     LDRB    lr, [r2], #1
                STRNEB  lr, [r3], #1
                CMP     lr, #' '
                BHI     add_prefix8
                MOV     r12, r11
                LDMIA   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
                BICS    lr, lr, #carry
                STMDB   sp!, {r0, r1, r2, r3, r4, lr}
                B       add_prefix5
add_prefix9     CMP     r0, #':'
                MOVEQ   r4, r1
                MOVEQ   r3, r1
                CMP     r0, #'.'
                SUBEQ   r3, r1, #1
                CMP     r0, #' '
                BHI     add_prefix6
                [ 0 = 1
                SWI     os_writes
                DCB     "After stripping ^s ", 0
                SWI     os_newline
                MOV     r2, r12
write_name1     LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     write_name1
                SWI     os_newline
                ]
                LDMIA   sp!, {r0, r1, r2, r3, r4, pc}^

find_handler    CMP     r0, #&40
                MOVCCS  pc, lr
                B       file_handler

gbpb_handler    CMP     r0, #9
                MOVCCS  pc, lr
                CMP     r0, #13
                MOVCSS  pc, lr

file_handler    STMDB   sp!, {r11, lr}
file_handler1   LDR     r12, [r12]
                CMP     r12, #0
                BEQ     file_handler2
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]
                LDR     r11, [r12, #o_wimpdomain]
                CMP     r11, lr
                BNE     file_handler1
                LDR     r11, fname_buffer
                BL      add_prefix
file_handler3   LDMIA   sp!, {r11, lr}
                STRCC   r1, [sp, #-4]!
                MOVCC   r1, r12
                STRCC   pc, [sp, #-4]!   ;store PC+8 (Architecture 4) or PC+12
                MOVS    pc, lr
                NOP                      ;so that PC+8 is ok

file_upcall     LDMIA   sp!, {r1, lr}    ;target of stored PC
                BIC     lr, lr, #carry
                ORRCS   lr, lr, #carry
                B       xferv

file_handler2   LDR     r11, fname_buffer
                MOV     r12, r1
                BL      strip_hats
                B       file_handler3

fscontrol_handler
                CMP     r0, #25
                BCC     fscontrol_handler1
                CMP     r0, #27
                BCC     copy_or_rename
                CMPNE   r0, #28
                CMPNE   r0, #32
                CMPNE   r0, #37
                BEQ     file_handler
                MOVS    pc, lr
fscontrol_handler1
                CMP     r0, #5
                CMPNE   r0, #6
                CMPNE   r0, #9
                CMPNE   r0, #24
                BEQ     file_handler
                MOVS    pc, lr

copy_or_rename  STMDB   sp!, {r1, r2}
                STMDB   sp!, {r9, r10, r11, lr, pc}  ;PC saved just as a placeholder here
                STR     pc, [sp, #16]                ;store PC+8 (Architecture 4) or PC+12
                B       copy_or_rename1
                NOP                                  ;so that PC+8 is ok

copy_or_rename_upcall                                ;target of stored PC
                LDMIA   sp!, {r1, r2, lr}
                BIC     lr, lr, #carry
                ORRCS   lr, lr, #carry
                B       xferv

copy_or_rename1 LDR     r12, [r12]
                CMP     r12, #0
                BEQ     copy_or_rename2
                LDMEQIA sp!, {r9, r10, r11, lr}
                ADDEQ   sp, sp, #12
                MOVEQS  pc, lr
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]
                LDR     r11, [r12, #o_wimpdomain]
                CMP     r11, lr
                BNE     copy_or_rename1
                LDR     r11, fname_buffer
                MOV     r9, r12
                BL      add_prefix
                MOV     r10, r12
                MOV     r12, r9
                ADD     r11, r11, #128
                MOV     r9, r1
                MOV     r1, r2
                BL      add_prefix0
copy_or_rename3 MOV     r1, r9
                MOVCC   r2, r12
                MOVCC   r1, r10
                LDMIA   sp!, {r9, r10, r11, lr}
                ADDCS   sp, sp, #12
                MOVS    pc, lr

copy_or_rename2 LDR     r11, fname_buffer
                MOV     r12, r1
                BL      strip_hats
                MOV     r10, r12
                ADD     r11, r11, #128
                MOV     r9, r1
                MOV     r12, r2
                BL      strip_hats0
                B       copy_or_rename3

cli_swi         CMP     r11, #ddeutils_setcl
                BEQ     setcl
                BCC     setclsize
                CMP     r11, #ddeutils_getcl
                BEQ     getcl
                BCS     throwback_swi

getclsize       LDR     r0, cli_size
                MOVS    pc, lr

getcl           LDR     r11, cli_buffer
                CMP     r11, #0
                MOV     r12, #0
                STREQB  r12, [r0]
                MOVEQS  pc, lr
                STMDB   sp!, {r2, lr}
                STR     r12, cli_buffer
                STR     r12, cli_size
                MOV     r2, r11
                MOV     r12, r0
getcl1          LDRB    r10, [r11], #1
                STRB    r10, [r0], #1
                CMP     r10, #' '
                BCS     getcl1
                MOV     r10, #0
                STRB    r10, [r0, #-1]
                MOV     r0, #n_module_free
                SWI     xos_module
                MOVVC   r0, r12
                LDMIA   sp!, {r2, lr}
                B       xferv

setclsize       STMDB   sp!, {r1, r2, r3, lr}
                MOV     r3, r0
                LDR     r2, cli_buffer
                CMP     r2, #0
                MOVNE   r0, #n_module_free
                SWINE   xos_module
                LDMVSIA sp!, {r1, r2, r3, lr}
                ORRVSS  pc, lr, #overflow
                [ 0 = 1
                CMP     r3, #0
                LDMEQIA sp!, {r1, r2, r3, pc}^
                ]
                MOV     r0, #n_module_claim
                SWI     xos_module
                STRVC   r2, cli_buffer
                STRVC   r3, cli_size
                MOVVC   r0, r2
                LDMIA   sp!, {r1, r2, r3, lr}
                B       xferv

no_cli_buffer_msg
                DCD     no_cli_buffer_error
                DCB     "CLI buffer not set", 0

setcl           LDR     r11, cli_buffer
                CMP     r11, #0
                ADREQ   r0, no_cli_buffer_msg
                ORREQS  pc, lr, #overflow
                STMDB   sp!, {r0, lr}
setcl1          LDRB    r10, [r0], #1
                STRB    r10, [r11], #1
                CMP     r10, #' '
                BCS     setcl1
                LDMIA   sp!, {r0, pc}^

prefix_cmd      MOV     r6, lr
                SWI     ddeutils_prefix + ddeutils_swibase
                MOVS    pc, r6

unk_swi_msg     DCD     unk_swi_error
                DCB     "Unknown DDEUtils SWI", 0
                ALIGN

not_desktop_msg DCD     not_desktop_error
                DCB     "Throwback not available outside the desktop", 0
                ALIGN

no_task_msg     DCD     no_task_error
                DCB     "No task registered for throwback", 0
                ALIGN

already_reg_msg DCD     already_reg_error
                DCB     "Another task is registered for throwback", 0
                ALIGN

not_reg_msg     DCD     not_reg_error
                DCB     "Task not registered for throwback", 0
                ALIGN

receiver_id     DCD     0

; SNB 10/08/98: R4 now stacked to preserve it over a SWI call
throwback_swi   CMP     r11, #ddeutils_throwbackend + 1
                ADRCS   r0, unk_swi_msg
                ORRCSS  pc, lr, #overflow
                STMDB   sp!, {r0, r1, r2, r3, r4, r9, lr}
                MOV     r10, r0
                MOV     r0, #0
                SWI     xwimp_readsysinfo
                MOVVS   r0, #0
                CMP     r0, #0
                LDMEQIA sp!, {r0, r1, r2, r3, r4, r9, lr}
                ADREQ   r0, not_desktop_msg
                ORREQS  pc, lr, #overflow
                LDR     r0, [sp]
                LDR     r9, receiver_id
                CMP     r11, #ddeutils_throwbackunregister
                BCC     throwbackregister
                BEQ     throwbackunregister
                CMP     r9, #0
                LDMEQIA sp!, {r0, r1, r2, r3, r4, r9, lr}
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow
                CMP     r11, #ddeutils_throwbacksend
                BCC     throwbackstart
                BEQ     throwbacksend

throwbackend    MOV     r0, #msg_throwback_end
startorendmsg   MOV     r1, #0                  ; No string
stringonlymsg1  MVN     r3, #0                  ; No line no.
                MVN     r4, #0                  ; No error level
                BL      sendmessage
throwback_vsret ADDVS   sp, sp, #4
                LDRVC   r0, [sp], #4
                LDMIA   sp!, {r1, r2, r3, r4, r9, lr}
                B       xferv

stringonlymsg   STMDB   sp!, {r0, r1, r2, r3, r4, r9, lr}
                B       stringonlymsg1

throwback_err   DCB     "Throwback error", 13, 10, 0
                ALIGN

throwbackregister
                CMP     r9, #0
                LDMIA   sp!, {r0, r1, r2, r3, r4, r9, lr}
                ADRNE   r0, already_reg_msg
                ORRNES  pc, lr, #overflow
                STR     r0, receiver_id
                MOVS    pc, lr

throwbackunregister
                CMP     r9, r10
                LDMIA   sp!, {r0, r1, r2, r3, r4, r9, lr}
                ADRNE   r0, not_reg_msg
                ORRNES  pc, lr, #overflow
                MOVS    r10, #0
                STR     r10, receiver_id
                MOVS    pc, lr

throwbackstart  MOV     r0, #msg_throwback_start
                B       startorendmsg

throwback_add_prefix
                STMDB   sp!, {lr}
                MOV     r1, r2
                BL      file_handler
                STMDB   sp!, {r0, r3, r4}
                MOV     lr, r0
                CMP     lr, #reason_infodetails
                MOVEQ   r0, #msg_throwback_infoforfile
                CMP     lr, #reason_processing
                MOVEQ   r0, #msg_throwback_processingfile
                CMP     lr, #reason_errordetails
                MOVEQ   r0, #msg_throwback_errorsin
                BL      stringonlymsg
                LDRVC   r0, [sp], #4
                ADDVS   sp, sp, #4
                LDMIA   sp!, {r3, r4}
                BVS     throwback_add_prefix1
                CMP     r0, #reason_processing
                LDMEQIA sp!, {pc}^
                CMP     r0, #reason_infodetails
                MOVEQ   r0, #msg_throwback_infodetails
                MOVNE   r0, #msg_throwback_errordetails
                MOV     r1, r5
                BL      sendmessage
throwback_add_prefix1
                LDMIA   sp!, {lr}
                B       xferv

throwbacksend   BL      throwback_add_prefix
                B       throwback_vsret

                [ 1=0
hbuff           DCD     0, 0, 0
                ]

; R0 = message id
; R1 = string       0 => no string
; R3 = line no     -1 => no line no
; R4 = error level -1 => no errorlevel
sendmessage     STMDB   sp!, {lr}
                [ 1=0
                STMDB   sp!, {r0, r1, r2, r3}
                MOV     r3, r1
                SWI     os_writes
                DCB     4, "Message id = ", 0
                ADR     r1, hbuff
                MOV     r2, #12
                SWI     os_converthex8
                SWI     os_write0
                SWI     os_writes
                DCB     13, 10, 0
                MOV     r0, r3
                SWI     os_write0
                SWI     os_writes
                DCB     13, 10, 5, 0
                LDMIA   sp!, {r0, r1, r2, r3}
                ]
                MOV     r2, r1
                MOVS    lr, r1
                BEQ     sendmessage2
sendmessage1    LDRB    r2, [lr], #1
                CMP     r2, #0
                BNE     sendmessage1
                SUB     r2, lr, r1
sendmessage2    ADD     r2, r2, #31
                BIC     r2, r2, #3
                MOV     lr, sp
                SUB     sp, sp, r2
                STR     r2, [sp]
                ADD     r2, sp, #12
                STMDB   sp!, {lr}
                MOV     lr, #0
                STR     lr, [r2], #4
                ADD     r0, r0, #ddeutils_msgbase_l
                ADD     r0, r0, #ddeutils_msgbase_h
                STR     r0, [r2], #4
                CMN     r3, #1
                STRNE   r3, [r2], #4
                CMN     r4, #1
                STRNE   r4, [r2], #4
                CMP     r1, #0
                BEQ     sendmessage4
sendmessage3    LDRB    lr, [r1], #1
                STRB    lr, [r2], #1
                CMP     lr, #0
                BNE     sendmessage3
sendmessage4    MOV     r0, #17
                ADD     r1, sp, #4
                MOV     r2, r9
;               IDJ/NK 4-Jan-95: AQU-00756 - truncate if message text too long
                LDR     lr, [r1]   ; length of msg
                CMP     lr, #256
                MOVGT   lr, #256
                STRGT   lr, [r1]   ; 256 is max size of msg
                MOVGT   lr, #0
                STRGTB  lr, [r1, #255]
                SWI     xwimp_sendmessage
                LDR     sp, [sp]
                LDMIA   sp!, {lr}
                B       xferv

initvar         STMDB   sp!, {r4, lr}
                MOV     r3, r1
initvar1        LDRB    r2, [r3], #1
                CMP     r2, #' '
                BCS     initvar1
                SUB     r2, r3, r1
                MOV     r3, #0
                MOV     r4, #0
                SWI     xos_setvarval
                LDMIA   sp!, {r4, pc}^

                [ BOMB
time_dec91      DCD     &92a45cc9
                DCD     &43

time_now        DCD     3
                DCD     0

time_bomb       MOV     r7, lr
                MOV     r0, #14
                ADR     r1, time_now
                SWI     xos_word
                LDRB    r0, time_dec91 + 4
                LDRB    r1, time_now + 4
                CMP     r0, r1
                BCC     time_fail
                BNE     time_ok
                LDR     r0, time_dec91
                LDR     r1, time_now
                CMP     r0, r1
                BCC     time_fail
time_ok         BL      |__RelocCode|
                MOVS    pc, r7
time_fail       ADR     r0, time_msg
                LDMIA   sp!, {r7, r8, r9, r10, r11, lr}
                SWI     os_generateerror

time_msg        DCD     &840
                DCB     "Beta test expired, use product Desktop C or Desktop "
                DCB     "Assembler. Beta tools are no longer usable. Contact "
                DCB     "ISV support at Acorn for more details.", 0
                ALIGN
                ]

                END
@


1.4
log
@  Added ReadPrefix SWI to return a task's current prefix setting.
Detail:
  New SWI provides a method for callers to extract the current prefix
    directory setting for a given Wimp task without having to patch
    the DDEUtils module.  Several external people are known to be
    hacking this module to obtain the information.  No longer have to.
Admin:
  Tested with small test program and against test version of Zap.
@
text
@@


1.4.2.1
log
@  RISC OS Ltd version of DDEUtils.
Detail:
  Import from RISC OS Ltd.
Admin:
  Tagged as ROL_DDEUtils-1_61
@
text
@d45 2
d48 5
a52 42
                ^    0,r12
chain           #     4
fname_buffer    #     4
cli_buffer      #     4
cli_size        #     4
receiver_id     #     4
workspace_end   #     0

; JRF: Debugging
                GBLL    DEBUG ; turn this off for ROMing
DEBUG           SETL    {FALSE}

; JRF: Don't make it work on pre-RO4
                GBLL    RO4Only
RO4Only         SETL    {TRUE}

; JRF: Switch added to allow longer filenames to be 'handled'. This may
;      not necessarily fix all the problems that DDEUtils has with them,
;      but will alleviate the majority. Problems may still lie in the
;      throwback handler.
                GBLL    LongFilenames
LongFilenames   SETL    {TRUE}

; JRF: Set this to the length of filenames that is the maximum you wish
;      to handle
LongFilenameLength EQU    1024

; JRF: Turn this on and all prefixes passed will be canonicalised for you
                  GBLL    CanonicalisePath
CanonicalisePath  SETL    {TRUE}

; JRF: We should /really/ be checking the strings fit our CL buffer!
                  GBLL    CheckBufferSize
CheckBufferSize   SETL    {TRUE}

                        GBLL   AllowDirectoryChanging
AllowDirectoryChanging  SETL   {TRUE}

; JRF: Allow a lot of the later image file extensions
;      This has NOT been tested and it's a little too late to add them
                        GBLL   HandleImages
HandleImages            SETL   {FALSE}
a61 2
xos_fscontrol   EQU     &20029
xos_file        EQU     &20008
a62 1
xos_readsysinfo EQU     &20058
a67 1
xmessagetrans_errorlookup EQU &61506
a85 1
xddeutils_swibase            EQU    &62580
d96 1
d98 1
a113 1
buffer_too_short    EQU ddeutils_errbase + 6
a129 1
                ASSERT :INDEX: o_next = 0
d151 1
d154 1
a154 1
                DCB     "1.61 (20 Sep 1999)", 0
a155 1
title           ; DCB     "DDEUtils", 0
d167 1
d169 1
a199 7
 [ RO4Only
                MOV     r0,r0                          ;magic instruction
                TEQNE   r1,#service_reset
                TEQNE   r1,#service_wimpclosedown
                MOVNES  pc,lr
                B       service
 |
a203 1
 ]
d205 2
a206 3
                TEQ     r1,#service_reset
                LDREQ   r12,[r12]
                BEQ     reset
d209 14
a222 4
                STMFD   sp!, {r0, lr}
                MOV     r0, #0
                SWI     xddeutils_swibase + ddeutils_prefix
                LDMFD   sp!, {r0, pc}^
d224 16
a239 5
; Really should clear the chain here...
reset
                STMFD   sp!, {r0, lr}
                BL      claimvectors
                LDMFD   sp!, {r0, pc}^
d255 7
a261 7
init            STMFD   sp!, {r7, r8, r9, r10, r11, lr}
  [ RO4Only
                MOV     r0,#9
                MOV     r1,#0
                SWI     xos_readsysinfo
                MOVVS   pc,#0
  ]
d277 13
a289 15

                MOV     r0, #n_module_claim
                MOV     r3, #:INDEX: workspace_end
                SWI     xos_module            ; claim our module workspace
                STRVC   r2,[r12]
                MOVVC   r12,r2

                MOVVC   r0,#0
                STRVC   r0, chain
                STRVC   r0, cli_buffer
                STRVC   r0, cli_size
                STRVC   r0, receiver_id

                BLVC    claimvectors
;                MOVVC   r2, r12
a290 3
   [ LongFilenames
                MOVVC   r3, #LongFilenameLength * 2
   |
a291 1
   ]
d300 1
a300 1
                LDMFD   sp!, {r7, r8, r9, r10, r11, lr}
a303 50
; JRF: I didn't write this - it /should/ release the handlers if something's
; up, but doesn't
claimvectors
                STMFD   sp!, {r2,r3,lr}
                MOV     r2,r12
                MOV     r0, #n_filev
                ADRL    r1, file_handler
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT01
                MOV     r0, #n_gbpbv
                ADRL    r1, gbpb_handler
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT02
                MOV     r0, #n_findv
                ADRL    r1, find_handler
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT03
                MOV     r0, #n_fscontrolv
                ADRL    r1, fscontrol_handler
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT04
                LDMFD   sp!, {r2,r3,pc}

; these are the failure cases
01
                MOV     r0, #n_fscontrolv
                ADRL    r1, fscontrol_handler
                SWI     xos_release
02
                MOV     r0, #n_findv
                ADRL    r1, find_handler
                SWI     xos_release
03
                MOV     r0, #n_gbpbv
                ADRL    r1, gbpb_handler
                SWI     xos_release
04
                MOV     r0, #n_filev
                ADRL    r1, file_handler
                SWI     xos_release

                LDMFD   sp!, {r2,r3,lr}
                MOV     r0,r3
                ORRS    pc,lr,#overflow


d305 20
a324 21
; prefix_dir read code
; <= r0-> value
                STMFD   sp!, {lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix
                MOVVS   r0,#0
                TEQ     r0,#0     ; was it invalid ?
                MOVEQ   r0,#0
                MOVEQ   r2,#0
                LDMEQFD sp!, {pc}^ ; oh dear
; now we need to find the length of the directory
                MOV     r1,r0
01
                LDRB    r2,[r1],#1
                CMP     r2,#31
                BGT     %BT01
                SUB     r2,r1,r0
                SUB     r2,r2,#1 ; and we increased over the terminator
                LDMFD   sp!, {pc}^

dir_code_write  STMFD   sp!, {r0, lr}
d326 3
a328 2
                SWI     xddeutils_swibase + ddeutils_prefix
                LDMFD   sp!, {r0, pc}^
a331 1
                LDR     r12, [r12]
a335 1

d339 1
a339 2

                LDR     r2, chain
d341 1
a341 1
                STR     r1, chain
a345 1

d348 1
a348 1
                LDR     r5, [r2,#o_next]
a352 1

d355 1
a355 1
                ADRL    r1, file_handler
d364 1
a364 1
                ADRL    r1, fscontrol_handler
a365 3
                MOV     r2, r12               ; free our main workspace
                MOV     r0, #n_module_free
                SWI     xos_module
d368 6
a373 3
; Input: R0: task handle or 0 for current task
; Output: R0: pointer to prefix dir for that task or 0 if none.
doswi_readprefix
d378 6
a383 7
		STMFD	sp!, {r1, r2, r3, r8, lr}
		LDR     r8, chain
doswi_readprefix1
		TEQ	r8, #0
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}^
		LDR	r2, [r8,#o_next]
		LDR	r1, [r8, #o_wimpdomain]
d385 5
a389 4
		ADDEQ	r0, r8, #o_prefix
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}^
		MOV	r8, r2
		B	doswi_readprefix1
d392 6
a397 34
   LDR     r12,[r12] ; read workspace pointer
   CMP     r11,#11
   ADDLT   pc,pc,r11,LSL #2
   B       module_swierror
; ***** SWI jump table
   B       doswi_prefix
   B       doswi_setclsize
   B       doswi_setcl
   B       doswi_getclsize
   B       doswi_getcl
   B       doswi_throwbackregister
   B       doswi_throwbackunregister
   B       doswi_throwbackstart
   B       doswi_throwbacksend
   B       doswi_throwbackend
   B       doswi_readprefix

module_swierror
   STMFD   sp!,{r1-r4,lr}
   ADR     r0,msg_swierror
   MOV     r1,#0
   MOV     r2,#0
   ADRL    r4,title
   SWI     xmessagetrans_errorlookup
   LDMFD   sp!,{r1-r4,lr}
   ORRS    pc,lr,#overflow        ; set V flag and return

msg_swierror
   DCD     &1E6
   DCB     "BadSWI",0
   ALIGN


doswi_prefix
d399 1
a399 40
                STMFD   sp!, {r1, r2, r3, r8, lr}
                TEQ     r0,#0
                BEQ     %FT01       ; they gave 0
                LDRB    r0,[r10]
                CMP     r0,#32
                BLO     %FT01       ; it was a null command

  [ CanonicalisePath
                STMFD   sp!, { r4, r5 }
                MOV     r0,#37
                MOV     r1,r10
                LDR     r2,fname_buffer
                MOV     r3,#0 ; no path var
                MOV     r4,#0 ; 0
  [ LongFilenames
                MOV     r5,#LongFilenameLength
  |
                MOV     r5,#256
  ]
                SWI     xos_fscontrol ; canonicalise it!
                LDRVC   r10,fname_buffer
                LDMFD   sp!, { r4, r5 }
01
  ]

  [ DEBUG
                STMFD   sp!,{r0,r2}            ; Stack registers
                SWI     os_writes
                DCB     4, "attempting to set prefix: ", 0
                MOV     r2, r10
01              LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     %BT01
                SWI     os_newline
                LDMFD   sp!,{r0,r2}            ; Unstack registers
  ]

                ASSERT  ddeutils_prefix = 0
d401 2
a402 3
                ADR     r8, chain
                LDR     r2, chain
do_swi1         TEQ     r2, #0
d405 2
a406 3
                TEQ     r1, r11
                ADDNE   r8, r2, #o_next       ; r8 = last next pointer addr
                LDRNE   r2, [r2, #o_next]     ; r2 = this pointer
d408 2
a409 2
                LDR     r3, [r2, #o_next]     ; read this next
                STR     r3, [r8]              ; store as last next
a411 1
                MOVVC   r2,r3
d413 1
a413 1
                LDMFD   sp!, {r1, r2, r3, r8, lr}
a414 1

d416 1
a416 1
                LDMEQFD sp!, {r1, r2, r3, r8, pc}^
d419 1
a419 1
                LDMLOFD sp!, {r1, r2, r3, r8, pc}^
d428 1
a428 1
                LDMVSFD sp!, {r1, r2, r3, r8, lr}
d430 1
a430 1
                STR     r2, [r8]      ; store over last next pointer (!)
d432 2
a433 3
                STR     r0, [r2], #4  ; next
                STR     r11, [r2], #4 ; domain
                                      ; prefix follows
d438 2
a439 2
                MOVHS   r3, r1
                BHS     do_swi4
d442 1
a442 3
                MOV     r3,#0
                STRB    r3, [r2, #-1] ; store it as terminated
                LDMFD   sp!, {r1, r2, r3, r8, pc}^
d450 1
a450 1
;        R8 = Task block
d454 1
a454 1
;        R8 = New Filename (R1 or R11 on entry)
d457 10
a466 14
add_prefix0     STMFD   sp!, {r0, r1, r2, r3, r4, lr}
  [ DEBUG
                STMFD   sp!, {r0-r2}
                SWI     os_writes
                DCB     "Before add_prefix: ", 0
                MOV     r2, r1
write_name0     LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     write_name0
                SWI     os_newline
                LDMFD   sp!,{r0-r2}
  ]
d474 1
a474 1
                MOVEQ   r8, r1
d486 2
a487 2
                ADD     r8, r8, #o_prefix
add_prefix3     LDRB    r0, [r8], #1
d500 11
a510 15
                MOV     r8, r11

  [ DEBUG
                SWI     os_writes
                DCB     4, "After add_prefix: ", 0
                MOV     r2, r8
01              LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     %BT01
                SWI     os_newline
  ]

                LDMFD   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
d512 2
a513 3

strip_hats0     STMFD   sp!, {r0, r1, r2, r3, r4, lr}
add_prefix5     MOV     r2, r8
d543 2
a544 2
                MOV     r8, r11
                LDMFD   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
d546 1
a546 1
                STMFD   sp!, {r0, r1, r2, r3, r4, lr}
d555 1
a555 1
  [ DEBUG
d557 1
a557 1
                DCB     4, "After stripping ^s ", 0
d559 1
a559 1
                MOV     r2, r8
d566 2
a567 2
  ]
                LDMFD   sp!, {r0, r1, r2, r3, r4, pc}^
d571 1
a571 1
                B       file_handler_external_entry
d574 1
a574 1
                MOVLOS  pc, lr
d576 1
a576 1
                MOVHSS  pc, lr
d578 4
a581 23
  [ DEBUG
file_handler_external_entry
                STMFD   sp!, {r8, r11, lr}
                B       %FT02
file_handler
                STMFD   sp!, {r8, r11, lr}
                STMFD   sp!, {r0,r1}
                SWI     os_writes
                DCB     4, "file_handler: ", 0
01              LDRB    r0, [r1], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BHS     %BT01
                SWI     os_newline
                LDMFD   sp!, {r0,r1}
02
  |
file_handler_external_entry
file_handler
                STMFD   sp!, {r8, r11, lr}
  ]
                LDR     r8, chain
d583 2
a584 4
                LDR     lr, [lr, #zp_wimpdomain]    ; lr = domainid
file_handler1   CMP     r8, #0
                BEQ     file_handler2
                LDR     r11, [r8, #o_wimpdomain]
a585 1
                LDRNE   r8, [r8, #o_next]
d589 1
a589 2
file_handler3   MOV     r12,r8 ; hold dir block otherwise this gets very icky
                LDMFD   sp!, {r8, r11, lr}
d596 1
a596 1
file_upcall     LDMFD   sp!, {r1, lr}    ;target of stored PC
d602 1
a602 1
                MOV     r8, r1
d607 8
a614 29
                CMP     r0, #25             ; Rename objects
                BLO     fscontrol_handler1
                CMP     r0, #27             ; Copy objects
                BLO     copy_or_rename
                CMPNE   r0, #28             ; Count objects
                CMPNE   r0, #32             ; *FileInfo
                CMPNE   r0, #37             ; Canonicalise
  [ HandleImages
                CMPNE   r0, #41             ; return defects for image
                CMPNE   r0, #42             ; map out defects for image
                CMPNE   r0, #46             ; return used space map for image
                CMPNE   r0, #47             ; read boot for disc/image
                CMPNE   r0, #48             ; write boot for disc/image
                CMPNE   r0, #49             ; read free space for disc/image
                CMPNE   r0, #50             ; rename disc/image
; (should already be canonical, I think - JRF)
;                CMPNE   r0, #51             ; update stamp
                CMPNE   r0, #52             ; find object at offset
                CMPNE   r0, #55             ; read freespace (large)
                CMPNE   r0, #56             ; read defects (large)
                CMPNE   r0, #57             ; map out defect (large)
  ]
                BEQ     file_handler_external_entry
  [ AllowDirectoryChanging
                CMP     r0, #53
                BEQ     set_given_dir
                CMP     r0, #43
                BEQ     unset_dir
  ]
d617 5
a621 9
                CMP     r0, #5              ; *.
                CMPNE   r0, #6              ; *Ex
                CMPNE   r0, #9              ; *Info
                CMPNE   r0, #24             ; *Access
                BEQ     file_handler_external_entry
  [ AllowDirectoryChanging
                CMP     r0, #0
                BEQ     change_dir
  ]
d624 3
a626 61
  [ AllowDirectoryChanging
unset_dir
                STMFD   sp!, {r0,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                TEQ     r0,#0
                LDMEQFD sp!, {r0,pc}^
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_prefix
01
                LDMVCFD sp!, {r0,lr,pc}^
                ADDVS   sp,sp,#4
                LDMFD   sp!, {lr,pc}^

set_given_dir
                TEQ     r2,#0
                MOVNES  pc,lr  ; only process if 'set CSD'

                STMFD   sp!, {r0,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                TEQ     r0,#0
                LDMEQFD sp!, {r0,pc}^
                MOV     r0,r1
                SWI     xddeutils_swibase + ddeutils_prefix
01
                LDMVCFD sp!, {r0,lr,pc}^
                ADDVS   sp,sp,#4
                LDMFD   sp!, {lr,pc}^

change_dir
                STMFD   sp!, {r0-r5,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                TEQ     r0,#0
                LDMEQFD sp!, {r0-r5,pc}^
                MOV     r0,#5
                SWI     xos_file
                TST     r0,#2
                BEQ     %FT02
                MOV     r0,r1
                SWI     xddeutils_swibase + ddeutils_prefix
01
                LDMVCFD sp!, {r0-r5,lr,pc}^
                ADDVS   sp,sp,#4
                LDMFD   sp!, {r1-r5,lr,pc}
02
                MOV     r0,#19
                MOV     r2,#&100 ; Directory 'wibble' not found
                SWI     xos_file
                ADD     sp,sp,#4 ; skip r0
                LDMFD   sp!, {r1-r5,lr,pc}

  ]

copy_or_rename  STMFD   sp!, {r1, r2}
                STMFD   sp!, {r8, r9, r10, r11, lr, pc}  ;PC saved just as a placeholder here
                STR     pc, [sp, #20]                ;store PC+8 (Architecture 4) or PC+12
d631 1
a631 1
                LDMFD   sp!, {r1, r2, lr}
d636 2
a637 16
copy_or_rename1
;   [ DEBUG
;                 STMFD   sp!, {r0,r1}
;                 SWI     os_writes
;                 DCB     4, "copy_or_rename1: ", 0
; 01              LDRB    r0, [r1], #1
;                 CMP     r0, #' '+1
;                 SWICS   os_writec
;                 CMP     r0, #' '+1
;                 BCS     %BT01
;                 SWI     os_newline
;                 LDMFD   sp!, {r0,r1}
;   ]
                ADR     r8, chain
copy_or_rename1b LDR    r8, [r8]
                CMP     r8, #0
d639 1
a639 1
                LDMEQFD sp!, {r8, r9, r10, r11, lr}
d644 1
a644 1
                LDR     r11, [r8, #o_wimpdomain]
d646 1
a646 1
                BNE     copy_or_rename1b
d648 1
a648 1
                MOV     r9, r8
d650 2
a651 5
                MOV     r10, r8
                MOV     r8, r9
   [ LongFilenames
                ADD     r11, r11, #LongFilenameLength
   |
a652 1
   ]
d657 1
a657 1
                MOVCC   r2, r8
d659 1
a659 1
                LDMFD   sp!, {r8, r9, r10, r11, lr}
d664 1
a664 1
                MOV     r8, r1
d666 1
a666 4
                MOV     r10, r8
   [ LongFilenames
                ADD     r11, r11, #LongFilenameLength
   |
a667 1
   ]
d669 1
a669 1
                MOV     r8, r2
d673 8
a680 2
; SWI DDEUtils_GetClSize
doswi_getclsize LDR     r0, cli_size
d683 1
a683 3

; SWI DDEUtils_GetCl
doswi_getcl     LDR     r11, cli_buffer
d685 1
a685 1
                MOVEQ   r12, #0
d688 3
a690 4
                STMFD   sp!, {r2, r8, lr}
                MOV     r8, #0
                STR     r8, cli_buffer
                STR     r8, cli_size
d692 1
a692 1
                MOV     r8, r0
d696 1
a696 1
                BHS     getcl1
d701 2
a702 2
                MOVVC   r0, r8
                LDMFD   sp!, {r2, r8, lr}
d705 1
a705 3

; SWI DDEUtils_SetClSize
doswi_setclsize STMFD   sp!, {r1, r2, r3, lr}
d711 1
a711 1
                LDMVSFD sp!, {r1, r2, r3, lr}
d713 1
a713 1
  [ 0 = 1
d715 2
a716 2
                LDMEQFD sp!, {r1, r2, r3, pc}^
  ]
a718 3
                MOVVS   r1, #0
                STRVS   r1, cli_buffer
                STRVS   r1, cli_size
d722 1
a722 1
                LDMFD   sp!, {r1, r2, r3, lr}
d729 1
a729 3

; SWI DDEUtils_SetCl
doswi_setcl     LDR     r11, cli_buffer
d733 1
a733 2
                STMFD   sp!, {r0, r1, lr}
                LDR     r1, cli_size
a735 4
  [ CheckBufferSize
                SUBS    r1,r1,#1
                BMI     do_buffer_too_short
  ]
d738 1
a738 11
                LDMFD   sp!, {r0, r1, pc}^
  [ CheckBufferSize
do_buffer_too_short
                LDMFD   sp!, {r0, r1, lr}
                ADR     r0, buffer_too_short_msg
                ORRS    pc,lr,#overflow

buffer_too_short_msg
                DCD     buffer_too_short
                DCB     "CLI buffer too short", 0
  ]
d741 2
a742 3
                SWI     xddeutils_swibase + ddeutils_prefix
                MOV     pc, r6

d744 3
d764 1
d766 6
a771 4

; check if we're in the desktop or not
checkactivetasks
                STMFD   sp!, {r0, lr}
d775 2
a776 2
                TEQ     r0, #0
                LDMFD   sp!, {r0, lr}
d779 1
a779 8
                BICNES  pc, lr, #overflow

; SWI DDEUtils_ThrowbackEnd
doswi_throwbackend
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
d781 3
d785 1
a785 1
                LDMEQFD sp!, {r0-r4, r9, lr}
d788 3
d792 1
a792 1
                MOV     r0, #msg_throwback_end
d799 1
a799 1
                LDMFD   sp!, {r1-r4, r9, lr}
d802 1
a802 3

stringonlymsg
                STMFD   sp!, {r0-r4, r9, lr}
d808 1
a808 8

; SWI DDEUtils_ThrowbackRegister
doswi_throwbackregister
                STMFD   sp!, {r0, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r9, pc}
                LDR     r9, receiver_id
d810 1
a810 1
                LDMFD   sp!, {r0, r9, lr}
d816 3
a818 11
; SWI DDEUtils_ThrowbackUnregister
doswi_throwbackunregister
                STMFD   sp!, {r0, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r9, pc}
                LDR     r9, receiver_id
                CMP     r9, r0
                MOVEQ   r0, #0
                STREQ   r0, receiver_id
                LDMFD   sp!, {r0, r9, lr}
d821 2
d825 1
a825 13
; SWI DDEUtils_ThrowbackStart
doswi_throwbackstart
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMEQFD sp!, {r0-r4, r9, lr}
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow

                MOV     r0, #msg_throwback_start
a827 1
; support for ThrowbackSend
d829 1
a829 1
                STMFD   sp!, {lr}
d831 2
a832 2
                BL      file_handler_external_entry
                STMFD   sp!, {r0, r3, r4}
d843 1
a843 1
                LDMFD   sp!, {r3, r4}
d846 1
a846 1
                LDMEQFD sp!, {pc}^
d853 1
a853 1
                LDMFD   sp!, {lr}
d856 1
a856 15

; DDEUtils_ThrowbackSend
doswi_throwbacksend
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMEQFD sp!, {r0-r4, r9, lr}
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow

                BL      throwback_add_prefix

d859 3
d867 3
a869 3
sendmessage     STMFD   sp!, {lr}
  [ DEBUG
                STMFD   sp!, {r0, r1, r2, r3}
d883 2
a884 6
                LDMFD   sp!, {r0, r1, r2, r3}
                B       %FT01
hbuff
                %       256
01
  ]
d898 1
a898 1
                STMFD   sp!, {lr}
d926 1
a926 1
                LDMFD   sp!, {lr}
d929 1
a929 1
initvar         STMFD   sp!, {r4, lr}
d938 1
a938 1
                LDMFD   sp!, {r4, pc}^
d940 6
a945 1
                END
d947 25
d973 1
@


1.4.2.2
log
@  Removed DDEUtils
Detail:
  DDEUtils now exists as a separate entity in the build.
Admin:
  RiscOS/Sources/Programmer/DDEUtils contains the DDEUtils module.

Version 0.02. Tagged as 'System-0_02'
@
text
@@


1.3
log
@  Nothing changed except one comment
Detail:
  Comment altered to allow new commit with correct tag information.
  Revision 1.2 of ddeutils is sbrodie_DDEUtils-1_55 and not ...1_65.
Admin:
  Source tag in previous checkin should have read sbrodie_DDEUtils-1_55
  and not 1_65.
@
text
@d17 1
a17 1
; Author:  original author unknown
d48 6
d96 3
d154 1
a154 1
                DCB     "1.55 (10 Aug 1998)", 0
d167 3
d372 25
a396 1
do_swi          CMP     r11, #ddeutils_prefix
@


1.2
log
@   Added Ursula service call table.
   Fixed R4 corruptions on SWI calls.
Detail:
   DDEUtils corrupts R4 on some SWI calls (the throwback related ones),
   contrary to documentation.  This register is now preserved correctly.
Admin:
   Source tagged as sbrodie_DDEUtils-1_65
@
text
@d17 1
a17 1
; Author:
@


1.1
log
@Binaries of DDEUtils removed.  Sources of DDEUtils added and Makefile
adapted to build the module as part of the build process.

This is DDEUtils 1.54 (03 Jul 1996)
@
text
@d15 5
d145 1
a145 1
                DCB     "1.54 (03 Jul 1996)", 0
d174 1
d176 18
a193 1
service         CMP     r1, #service_reset
a194 2
                CMP     r1, #service_wimpclosedown
                MOVNES  pc, lr
d730 1
d734 1
a734 1
                STMDB   sp!, {r0, r1, r2, r3, r9, lr}
d740 1
a740 1
                LDMEQIA sp!, {r0, r1, r2, r3, r9, lr}
d745 1
a745 1
                CMP     r11, #ddeutils_throwbackunregister;
d749 1
a749 1
                LDMEQIA sp!, {r0, r1, r2, r3, r9, lr}
d763 1
a763 1
                LDMIA   sp!, {r1, r2, r3, r9, lr}
d766 1
a766 1
stringonlymsg   STMDB   sp!, {r0, r1, r2, r3, r9, lr}
d774 1
a774 1
                LDMIA   sp!, {r0, r1, r2, r3, r9, lr}
d782 1
a782 1
                LDMIA   sp!, {r0, r1, r2, r3, r9, lr}
@

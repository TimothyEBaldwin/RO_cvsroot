head	1.5;
access;
symbols
	Boot-1_26:1.5
	Boot-1_25:1.4
	Boot-1_24:1.4
	Boot-1_23:1.4
	Boot-1_22:1.4
	Boot-1_21:1.4
	Boot-1_20:1.4
	Boot-1_19:1.4
	Boot-1_18:1.4
	Boot-1_17:1.3
	Boot-1_16:1.3
	Boot-1_15:1.3
	Boot-1_14:1.3
	Boot-1_13:1.3
	Boot-1_12:1.3
	Boot-1_11:1.3
	Boot-1_10:1.3
	Boot-1_09:1.3
	Boot-1_08:1.3
	Boot-1_07:1.3
	Boot-1_06:1.3
	Boot-1_05:1.3
	Boot-1_04:1.3
	Boot-1_03:1.3
	Boot-1_02:1.3
	Boot-1_01:1.3
	Boot-1_00:1.3
	Boot-0_99:1.3
	Boot-0_98:1.3
	Boot-0_97:1.3
	Boot-0_96:1.3
	Boot-0_95:1.3
	Boot-0_94:1.2
	Boot-0_93:1.2
	Boot-0_92:1.2
	Boot-0_91:1.2
	Boot-0_90:1.2
	Boot-0_89:1.2
	Boot-0_88:1.2
	Boot-0_87:1.2
	Boot-0_86:1.2
	Boot-0_85:1.2
	Boot-0_84:1.2
	Boot-0_83:1.2
	Boot-0_82:1.2
	Boot-0_81:1.2
	Boot-0_80:1.2
	Boot-0_79:1.2
	Boot-0_78:1.2
	Boot-0_77:1.2
	Boot-0_76:1.2
	Boot-0_75:1.2
	Boot-0_74:1.2
	Boot-0_73:1.2
	Boot-0_72:1.2
	Boot-0_71:1.2
	Boot-0_70:1.2
	Boot-0_69:1.2
	Boot-0_68:1.2
	Boot-0_67:1.2
	nbingham_boot_991007:1.2
	mstphens_UrsulaRiscPCBuild_20Nov98:1.2
	Ursula_RiscPC:1.2.0.6
	rthornb_UrsulaBuild-19Aug1998:1.2
	UrsulaBuild_FinalSoftload:1.2
	rthornb_UrsulaBuild-12Aug1998:1.2
	aglover_UrsulaBuild-05Aug1998:1.2
	rthornb_UrsulaBuild-29Jul1998:1.2
	rthornb_UrsulaBuild-22Jul1998:1.2
	rthornb_UrsulaBuild-15Jul1998:1.2
	rthornb_UrsulaBuild-07Jul1998:1.2
	rthornb_UrsulaBuild-17Jun1998:1.2
	rthornb_UrsulaBuild-03Jun1998:1.2
	rthornb_UrsulaBuild-27May1998:1.2
	rthornb_UrsulaBuild-21May1998:1.2
	rthornb_UrsulaBuild_01May1998:1.2
	Daytona:1.2.0.4
	Daytona_bp:1.2
	Ursula:1.2.0.2
	Ursula_bp:1.2
	StrongARM:1.1.0.4
	RO_3_71:1.1.4.1;
locks; strict;
comment	@# @;


1.5
date	2018.02.02.21.35.45;	author jlee;	state Exp;
branches;
next	1.4;
commitid	jlvtBOT0SmsaBkpA;

1.4
date	2013.05.27.20.37.42;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	vUwSuxHXx7U7jjRw;

1.3
date	2012.07.26.07.31.02;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	OlF6qJCeal42L2ew;

1.2
date	97.05.06.11.27.41;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.04.30.18.19.40;	author kbracey;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	97.04.30.18.19.40;	author kbracey;	state Exp;
branches;
next	;

1.1.4.1
date	97.05.06.09.24.42;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Add ROM patches for the ADFS "disc error 20" fix
Detail:
  This set of changes adds a "disc error 20" fix to ADFS for RISC OS 3.50 thru 4.02, using similar code to that used for the fix that was applied to ADFS itself (in ADFS 3.54). This is to resolve issues with modern IDE devices which don't adhere to the DRQ timeout that old versions of the ATA spec mandated.
  File changes (all within Source/ROMPatch):
  - patches/s/ADFS354 - Generic assembler source for the disc error 20 fix
  - ihf2c/c/ihf2c - Source for a C utility that was used to help produce the ROM patch data
  - patches/adfs354,feb - Utility script for building the different versions of the ADFS patch and converting to ROMPatch form
  - patches/350/h/ADFSpatch, patches/360/h/ADFSpatch, patches/370/h/ADFSpatch, patches/371/h/ADFSpatch, patches/402/h/ADFSpatch - Added/updated ADFS patches
  - patches/350/h/patch, patches/371/h/patch, patches/402/h/patch - Include new ADFSpatch files where relevant
  - UK/h/messages - Update ROMPatch version numbers
  - c/rompatch, s/module - Add a word of writable workspace to the module which the ADFS patch can use
  - patches/402/h/CDSFTpatch - Remove duplicate patch (duplicate of RESLVpatch)
  - patches/402/h/MSGSpatch - Document the patches
  - ReadMe, Install/ROMPatch/!RunImage,ff8 - Remove redundant/outdated files (the main Boot makefile will build and install ROMPatch for us)
Admin:
  Tested on a RISC OS 3.70 StrongARM RiscPC with a CF-IDE adapter, disc error 20 is no more
  3.50/3.60/3.70/3.71/4.02 also tested under RPCEmu, manually provoking the different code paths to check hook points are correct


Version 1.26. Tagged as 'Boot-1_26'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* rompatch.c */

/*
  17-Oct-96 2.00 MJS originated (version 1 is different mapping
                     strategy, in BASIC)
  25-Oct-96 2.01 MJS no longer relies on growing screen memory in order to
                     avoid taking future screen pages; instead does
                     something much more like BASIC version (ahem, thanks Tim)
  24-Feb-97 2.02 MJS Enhanced to allow patches for more than one ROM version.
                     Added some patches for 3.70:
                       - Wimp_TransferBlock (fixes as for RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                     Created patches for 3.60:
                       - Wimp_TransferBlock (fixes to equivalent of RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                       - FSLock (SP's patch - allow floppy format when hard drive locked)
                     (see patches directory for details)
*/

/* version string is maintained in module.s */

#include <stdio.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"
#include "Global/OSRSI6.h"

#include "defs.h"
#include "debug.h"
#include "UK/messages.h"

/* implemented in assembler */
extern uint32 module,moduleend,myflush,adfs354_word;
extern uint32 modDAhandler,moddata;
extern uint32 svcarmid(void);
extern void   svccopy(uint32 *src, uint32 *dest, int bytes);
extern uint32 svcpeek(uint32 *addr);
extern void   svcpoke(uint32 *addr, uint32 val);
extern void   svcsetROML1PT(uint32 *L1PTaddr, uint32 *L1PTvals, int count, void *flushfn);

/* currently considered ROM size in bytes */
uint32 ROMsize;

/* Patched up once module inserted */
uint32 adfs354_word_addr = 0;

/* ROMs and their patches */
#include "patches/patch.h"

/* ------------------------------------------------------------------------ */

uint32 logtophys(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0x2200,&block,1); /* log provided, fill in phys */
  return block.physaddr; 
}

uint32 logtopagenum(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0xa00,&block,1); /* log provided, fill in pnum */
  return block.pagenumber; 
}

static uint32 phystopagenum(uint32 phys)
{
  osmemoryblock_t block;

  block.physaddr = phys;
  _swix(OS_Memory,_INR(0,2),0xc00,&block,1); /* phys provided, fill in pnum */
  return block.pagenumber; 
}

/* ------------------------------------------------------------------------ */

static int match_romcrc(ROMentry_t *definition)
{
  int   i, match, limit;
  const uint32 *this_romcrc = (const uint32 *)(ROMstart+ROMsize-12);
  const uint32 *romcrc = definition->romcrc;

  match = 1;
  limit = definition->trustsum ? 3 : 2;
  for (i=0; i<limit; i++) match &= (this_romcrc[i] == romcrc[i]);

  return match;
}

/* ------------------------------------------------------------------------ */

static int scan_patches(patchlist_proc patchlist[],
                        int *romsection,int *romlpage,int *rompage)
{
  /* checks patch status, updates romsection,romlpage,rompage,
     returns no. of patch pages */

  int          i, j, Npatchpages;
  uint32       *la, ila;
  patchentry_t *pl;

  /* initialise hit tables */
  for (i=0; i<ROMsections(ROMsize); i++) romsection[i] = 0;
  for (i=0; i<ROMlpages(ROMsize); i++)   romlpage[i]   = 0;
  for (i=0; i<ROMpages(ROMsize); i++)    rompage[i]    = 0;

  for (Npatchpages=i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        la = pl[j].logaddr;
        ila = (uint32)la;
        if (*la == pl[j].newval)
        {
          fprintf(stderr,E_ROMpatched);
          exit(ErrorReturnCode);
        }
        if (*la != pl[j].oldval)
        {
          fprintf(stderr,E_badROMpatch);
          fprintf(stderr,"  at %8.8x: wanted=%8.8x found=%8.8x\n",ila,pl[j].oldval,*la);
          exit(ErrorReturnCode);
        }
        /* mark section and large page hits with 1 */
        romsection[ROMsections(ila - ROMstart)] = 1;
        romlpage[ROMlpages(ila - ROMstart)] = 1;
        if (rompage[ROMpages(ila - ROMstart)] == 0)
        {
          /* count newly hit pages, and mark with 1 for now */
          Npatchpages++;
          rompage[ROMpages(ila - ROMstart)] = 1;
        }
      }
    }
  }

  /* now rescan page hit table, and mark with ascending sequence of
     hit number */
  for (i=j=0; i<ROMpages(ROMsize); i++) if (rompage[i]) rompage[i] = ++j;

  return Npatchpages;
}

/* ------------------------------------------------------------------------ */

static uint32 find_ARMA_flipflop(void)
{
  uint32 sandals = 0;

  _swix(OS_ReadSysInfo, _INR(0,2) | _OUT(2), 6, 0, OSRSI6_ARMA_Cleaner_flipflop, &sandals);
  return sandals ? sandals : ARMA_Cleaner_flipflop;
}

/* ------------------------------------------------------------------------ */

static uint32 find_L1PT(void)
{
  uint32 table = 0;

  _swix(OS_ReadSysInfo, _INR(0,2) | _OUT(2), 6, 0, OSRSI6_L1PT, &table);
  return table ? table : L1PT;
}

/* ------------------------------------------------------------------------ */

#define pagetype(pap,table) ((pap)&1) ? (table[(pap)>>1] >> 4) : (table[(pap)>>1] & 15)

#define pt_availableDRAM 1

static int find_DA_first_pagenum(int pagesneeded, uint32 *first_pagenum)
{
  /* find a suitable block of sequential page numbers for dynamic area; ie.
     not pages currently unavailable and not pages that may later be
     needed for screen
     - return 1 for success 0 for failure (if success, first_pagenum is
       first page number in found block) */

  _kernel_oserror *e;
  uint8           *table;
  uint32          L1PTphys,firstpagepap;
  int             tablesize, L1PTpap,pap,pt,pagestofind,foundfirstpage;

  /* find size of memory physical arrangement table (bytes) */
  e = _swix(OS_Memory,_IN(0)|_OUT(1),6,&tablesize);
  if (e) return 0;

#if DEBUG
    fprintf(stderr,"physical arrangement tablesize=%1d\n",tablesize);
#endif
  table = malloc(tablesize);
  if (table == NULL) return 0;

  /* read memory physical arrangement table (two entries per byte) */ 
  e = _swix(OS_Memory,_INR(0,1),7,table);
  if (e) return 0;

  /* RAM used for start of L1PT is good start point for scan of table;
     mainly, avoids DRAM that could be used for screen in no-VRAM
     system  */
  L1PTphys = logtophys(find_L1PT());
  L1PTpap  = L1PTphys >> 12; /* physical arrangement (4k) page index, into table */

#if DEBUG
    fprintf(stderr,"L1PTpap=%1d end=%1d\n",L1PTpap,tablesize*2);
#endif

  foundfirstpage = 0;
  firstpagepap   = 0;
  pagestofind    = pagesneeded - 1;
  for (pap=L1PTpap; (pap<tablesize*2) && pagestofind; pap++)
  {
    pt = pagetype(pap,table);
#if DEBUG
      fprintf(stderr,"pap=0x%5.5x pt=0x%2.2x\n",pap,pt);
#endif
    if (foundfirstpage)
    {
      /* we must collect subsequent pages that are DRAM and not marked Unavailable */
      if (pt == pt_availableDRAM) pagestofind--; else foundfirstpage = 0;
#if DEBUG
        fprintf(stderr,"  - %1d %5d\n",foundfirstpage,pagestofind);
#endif
    }
    else
    {
      if (pt == pt_availableDRAM)
      {
        /* found a possible first page, (DRAM that is not marked Unavailable) */
        pagestofind  = pagesneeded - 1;
        firstpagepap = pap;
        foundfirstpage = 1;
#if DEBUG
          fprintf(stderr,"  > %1d %5d\n",foundfirstpage,pagestofind);
#endif
      }      
    }
  }

  *first_pagenum = phystopagenum(firstpagepap << 12);
  return foundfirstpage && (pagestofind == 0);
}

/* ------------------------------------------------------------------------ */

static void create_patchDA(uint32 RMAaddr, int DAsize, uint32 DAhandler_addr,
                           const char *patchname,
                           int *patchDAN, uint32 *patchDAbase)
{
  /* create dynamic area for patches (plus 1 page - the first - for
     MMU L2PT), return DA number and base */
 
  _kernel_oserror *e;
  moduledata_t    *md;
  int             ok;
  uint32          first_pagenum;

  /* non-draggable area, user read only, bufferable,cacheable,
     has handler, specific pages required, initial size 0 */

  e = _swix(OS_DynamicArea,_INR(0,8)|_OUT(1)|_OUT(3),
            0,-1,0,-1,0x181,DAsize,DAhandler_addr,0,
            patchname,patchDAN,patchDAbase);

  if (!e)
  {
    /* find block of pages to use (starting at first_pagenum) */
    ok = find_DA_first_pagenum(DAsize>>12,&first_pagenum);
    if (ok)
    {
      /* set values required by pregrow handler, in module in RMA */
      md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
      md->nextpageneeded     = first_pagenum;
      md->firstpagenotneeded = first_pagenum + (DAsize >> 12);
#if DEBUG
      fprintf(stderr,"DA page numbers 0x%1.1x..0x%1.1x\n",
              md->nextpageneeded,md->firstpagenotneeded-1);
#endif
      /* grow the area to DAsize */
      e = _swix(OS_ChangeDynamicArea,_INR(0,1),*patchDAN,DAsize);
    }
  }

  if (e || !ok)
  {
    fprintf(stderr,E_patchmem);
    exit(ErrorReturnCode);
  }
}

/* ------------------------------------------------------------------------ */

static void fill_patchpages(patchlist_proc patchlist[],uint32 patchDAbase,
                            int *romsection,int *romlpage,int *rompage)
{
  /* fill in code (with patches) for patch pages in dynamic area (0'th
     page of dynamic area reserved for L2PT stuff */

  int          i,j, ppage;
  patchentry_t *pl;
  uint32       addr, *waddr, ppaddr;

  /* negate rompage entries to flag 'not copied yet' */
  for (i=0; i<ROMpages(ROMsize); i++) if (rompage[i]) rompage[i] = -rompage[i];

  for (i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        addr  = (uint32)pl[j].logaddr;
        ppage = (addr - ROMstart) >> 12;
        if (rompage[ppage] < 0)
        {
          /* first time this page hit - copy from ROM to dynamic area */
          rompage[ppage] = -rompage[ppage]; /* mark as now copied (unnegate) */
          ppaddr = addr & 0xfffff000;
          svccopy((uint32 *)ppaddr,
                  (uint32 *)(patchDAbase + (rompage[ppage] << 12)),0x1000);
        }
        waddr = (uint32 *)(patchDAbase + (rompage[ppage]<<12) + (addr&0xfff));
#if DEBUG
          fprintf(stderr,"  %8.8x %8.8x --> %8.8x %8.8x\n",
                  addr,pl[j].oldval,(int)waddr,pl[j].newval);
#endif
        svcpoke(waddr,pl[j].newval);
      }
    }
  }
  UNUSED(romlpage);
  UNUSED(romsection);
}

/* ------------------------------------------------------------------------ */

static void fill_patchL2PTpage(int writeprotect, uint32 armid, uint32 patchDAbase,
                               int *romsection,int *romlpage,int *rompage)
{
  /* fill in 1st page of dynamic area with MMU level2 page table info for
     patches  */

  int    i,s,p,lp, ppage;            
  uint32 *patchL2PT,ppage_physaddr,lpage_physaddr, mmu_lp,mmu_sp;

  if (writeprotect && ((armid & 0xf000) >= 0x7000))
  {
    /* ROM supports write protection, and processor supports ROM bit (ie.
       ROM is presumed to have set ROM bit for this processor)
       => mark patched areas as read only, bufferable,cacheable */
    mmu_lp = 0x00d;
    mmu_sp = 0x00e;
  }
  else
  {
    /* ROM does not support write protection, or processor (ARM6) has no ROM bit
       (ie. there will not be a ROM bit set)
        => mark patched areas as read only (user), bufferable,cacheable */
    mmu_lp = 0xaad;
    mmu_sp = 0xaae;
  }

  patchL2PT = (uint32 *)patchDAbase; /* 0'th page is used for L2PT stuff */

  for (p=lp=s=0; s<ROMsections(ROMsize); s++)
  {    
    if (romsection[s])
    {
      /* must break down this section, and L2PT map it */
      for (lp=s*16; lp<(s+1)*16; lp++)
      {
        if (romlpage[lp])
        {
          /* must break down this large page into (small) pages */
          for (p=lp*16; p<(lp+1)*16; p++)
          {
            if (rompage[p])
            {
              /* patched page, in dynamic area */
              ppage = rompage[p];
              ppage_physaddr = logtophys(patchDAbase + (ppage << 12));
            }
            else
            {
              /* unpatched page, in ROM */
              ppage_physaddr = ROMphysstart + (p << 12);
            }
            svcpoke(patchL2PT+p,ppage_physaddr | mmu_sp); 
#if DEBUG
              fprintf(stderr,"SPG %8.8x %8.8x\n",
                      (int)patchL2PT+p,ppage_physaddr | mmu_sp);
#endif
          }
        }
        else
        {
          /* map as large page (MMU requires 16 entries repeated) */
          lpage_physaddr = ROMphysstart + (lp << 16);
          for (i=lp*16; i<(lp+1)*16; i++)
            svcpoke(patchL2PT+i,lpage_physaddr | mmu_lp);
#if DEBUG
              fprintf(stderr,"LPG %8.8x %8.8x\n",
                      (int)patchL2PT+i,lpage_physaddr | mmu_lp);
#endif
        }
      }
    }
    else
    {
      /* section map can remain, set unused L2PT to Fault */
      for (i=s*256; i<(s+1)*256; i++) svcpoke(patchL2PT+i,0);
#if DEBUG
        fprintf(stderr,"SEC %8.8x %8.8x\n",(int)patchL2PT+i,0);
#endif
    }
  }

}

/* ------------------------------------------------------------------------ */

static uint32 insert_ROMPatches_module(void)
{
  /* returns address of (start of) module in RMA as a uint32 */

  uint32 RMAaddr;

  _kernel_oserror *e;

  /* insert module into RMA */
  e = _swix(OS_Module,_INR(0,2),11,&module,(int)(&moduleend)-(int)(&module));
  if (!e)
  {
    /* find start of module in RMA */
    e = _swix(OS_Module,_INR(0,1)|_OUT(3),18,"ROMPatches",&RMAaddr);
  }

  if (e)
  {
    fprintf(stderr,"%s\n",e->errmess);
    fprintf(stderr,E_nomodule);
    exit(ErrorReturnCode);
  }

  return RMAaddr;
}

/* ------------------------------------------------------------------------ */

static void set_ROM_L1PT(uint32 RMAaddr, int patchDAN, uint32 patchDAbase,
                         int *romsection)
{
  /* - set required data values in ROMPatches module, in RMA
     - set ROM L1PT entries to apply patches; do this via assembler call
       so that it happens cleanly, while ROM code is not executing
  */

  int             i;
  uint32          ROM_L1PTvalues[ROMsections(ROMsize)];
  uint32          L1PTlog = find_L1PT();
  moduledata_t    *md;
  void            *flushfn;

#define MMU_L1PR 0x11  /* flag L1 descriptor as page reference */

  /* current L1PT settings */
  for (i=0; i<ROMsections(ROMsize); i++) 
    ROM_L1PTvalues[i] = svcpeek((uint32 *)(L1PTlog + (ROMstart >> 18) + (i<<2)));

  /* now poke all required values into module data space, in RMA */
  md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
  md->DAN      = patchDAN;
  md->flipflop = find_ARMA_flipflop();
  md->sections = ROMsections(ROMsize);
  md->kernL1PT = L1PTlog + (ROMstart >> 18);
  for (i=0; i<ROMsections(ROMsize); i++) md->L1PTentries[i] = ROM_L1PTvalues[i];

  /* work out where 'myflush' is (so relative addressing on md->flipflop works */
  flushfn = (void *)((uint32)(&myflush)-(uint32)(&module)+RMAaddr);

  /* new settings, for any sections hit by patches */
  for (i=0; i<ROMsections(ROMsize); i++)
  {
    if (romsection[i])
      ROM_L1PTvalues[i] = logtophys(patchDAbase + (i << 10)) | MMU_L1PR;
  }

#if DEBUG
   for (i=0; i<ROMsections(ROMsize); i++)
     printf("  romsection %1d %8.8x\n",i,ROM_L1PTvalues[i]);

#endif

#if REALLY_DO_REMAP
    svcsetROML1PT((uint32 *)(L1PTlog + (ROMstart >> 18)),ROM_L1PTvalues,ROMsections(ROMsize),flushfn);
#else
    fprintf(stderr,"** svcsetROML1PT skipped **\n");
#endif

}

/* ------------------------------------------------------------------------ */

static ROMentry_t *identify_ROM(void)
{
  int        r;
  ROMentry_t *rom;

  for (rom=knownROMs[r=0]; rom != NULL; rom=knownROMs[++r])
  {
#if DEBUG
    fprintf(stderr,"check %s\n",rom->patchname);
#endif
    ROMsize = rom->romsize << 20;
    if (match_romcrc(rom)) break;
  }

#if DEBUG
    if (rom == NULL) fprintf(stderr,E_ROMunknown);
#endif

  return rom;
}

/* ------------------------------------------------------------------------ */

int main(int argc, char *argv[])
{
  int        Npatchpages, patchDAN, patchDAsize;
  uint32     armid, patchDAbase, RMAaddr, DAhandler_addr;
  ROMentry_t *rom;

  /* marked in order to construct best mapping granularity
     allowed by patches (to minimise stress on processor TLB(s)) */
  static int romsection[ROMsections(ROMlimit)];
  static int romlpage[ROMlpages(ROMlimit)];
  static int rompage[ROMpages(ROMlimit)];

  UNUSED(argc);
  UNUSED(argv);
  
  rom = identify_ROM();
  if (!rom) exit(0); /* not classed as error */

  armid = svcarmid();
#if DEBUG
  fprintf(stderr,"ARM ID = %8.8x\n",armid);
#endif

  /* sets hit tables, calculates number of pages required for patches */
  Npatchpages = scan_patches(rom->patchlist,romsection,romlpage,rompage);
  if (Npatchpages == 0) exit(0); /* not classed as error */

#if DEBUG
  dbtrace_patchhits(romsection,romlpage,rompage);
#endif

  /* insert module first, since DAhandler code there */
  RMAaddr = insert_ROMPatches_module();
  DAhandler_addr = (uint32)(&modDAhandler) - (uint32)(&module) + RMAaddr;
  adfs354_word_addr = (uint32)(&adfs354_word) - (uint32)(&module) + RMAaddr;

  /* 1 extra page required for L2PT entries */
  patchDAsize = (Npatchpages + 1) << 12;
  create_patchDA(RMAaddr,patchDAsize,DAhandler_addr,rom->patchname,
                 &patchDAN,&patchDAbase);

#if DEBUG
  dbtrace_DApages(patchDAN,patchDAbase,patchDAsize);
#endif

  /* rescans patches, and sets patch pages in DA */
  fill_patchpages(rom->patchlist,patchDAbase,romsection,romlpage,rompage);

  /* sets MMU level 2 mapping page in DA */
  fill_patchL2PTpage(rom->writeprotect,armid,patchDAbase,
                     romsection,romlpage,rompage);

  /* also sets required data values in ROMpatches module, in RMA */
  set_ROM_L1PT(RMAaddr,patchDAN,patchDAbase,romsection);

  /* ROM is now patched! */
  return 0;
}
@


1.4
log
@Update ROM patcher to understand Ursula kernels
The ROM patcher relied on lots of grubby internal knowledge of kernel addresses, some of which moved for Ursula
* L1PT now discovered with OS_ReadSysInfo 6
* CAM now discovered with OS_ReadSysInfo 6
* The StrongARM cleaner flipflop now discovered with OS_ReadSysInfo 6
* Option to ignore the ROM checksum where it is known to be duff (eg. personalised copies of RISC OS 4)

Also
* Remove RO430Hook from the output pending more testing
* Readd SoundDMA for RISC OS 3.60


Version 1.18. Tagged as 'Boot-1_18'
@
text
@d49 1
a49 1
extern uint32 module,moduleend,myflush;
d60 3
d584 1
@


1.3
log
@Generate ROM patches from source
It looks like the source to the ROM patches got lost in one of the numerous reorganisations, so while "ROMPatch2" was here "ROMPatch3" including the crucial > 2GB drive lockup fix were lost.
* Reverse engineered ROMPatch3, see userdocs/v204/!ReadMe
* Added support to the patch tool for 2MB ROMs as used in RISC OS 3.50
* Convert the BASIC patch for 3.50 (in Sources/ROMPatch4M) into patch tool format, unfortunately it's not clear what all the patches actually do so they're mostly grouped by module with little explanation
* Removed source attribution from obey files copied to the user
* Use Push/Pull macros
Tested by applying the original patch to a ROM, saving it, then applying this patch, and diffing the result.

Version 0.95. Tagged as 'Boot-0_95'
@
text
@d42 1
d49 1
a49 1
extern uint32 module,moduleend;
d55 1
a55 1
extern void   svcsetROML1PT(uint32 *L1PTaddr, uint32 *L1PTvals, int count);
a64 12
static int match_romcrc(uint32 *romcrc)
{
  int    i, match;
  uint32 *this_romcrc = (uint32 *)(ROMstart+ROMsize-12);

  for (match=1,i=0; i<3; i++) match &= (this_romcrc[i] == romcrc[i]);

  return match;
}

/* ------------------------------------------------------------------------ */

d92 14
d166 20
d220 1
a220 1
  L1PTphys = logtophys(L1PT);
d266 1
a266 1
                           char *patchname,
d290 1
a290 1
      /* set values reguired by pregrow handler, in module in RMA */
d480 1
d482 1
d488 1
a488 1
    ROM_L1PTvalues[i] = svcpeek((uint32 *)(L1PT + (ROMstart >> 18) + (i<<2)));
d493 1
d495 1
a495 1
  md->kernL1PT = L1PT + (ROMstart >> 18);
d498 3
d515 1
a515 1
    svcsetROML1PT((uint32 *)(L1PT + (ROMstart >> 18)),ROM_L1PTvalues,ROMsections(ROMsize));
d535 1
a535 1
    if (match_romcrc(rom->romcrc)) break;
a571 1

@


1.2
log
@Version RO_3_71 merged
@
text
@d35 1
a35 1
/* version string is maintained in s.module */
d56 3
d117 3
a119 3
  for (i=0; i<ROMsections; i++) romsection[i] = 0;
  for (i=0; i<ROMlpages; i++)   romlpage[i]   = 0;
  for (i=0; i<ROMpages; i++)    rompage[i]    = 0;
d142 3
a144 3
        romsection[(ila - ROMstart) >> 20] = 1;
        romlpage[(ila - ROMstart) >> 16]   = 1;;
        if (rompage[(ila - ROMstart) >> 12] == 0)
d148 1
a148 1
          rompage[(ila - ROMstart) >> 12] = 1;
d156 1
a156 1
  for (i=j=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = ++j;
d184 1
a184 1
# if Debug
d186 1
a186 1
#  endif
d200 1
a200 1
# if Debug
d202 1
a202 1
# endif
d210 1
a210 1
#   if Debug
d212 1
a212 1
#   endif
d217 1
a217 1
#     if Debug
d219 1
a219 1
#     endif
d229 1
a229 1
#       if Debug
d231 1
a231 1
#       endif
d271 1
a271 1
#     if Debug
d274 1
a274 1
#     endif
d300 1
a300 1
  for (i=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = -rompage[i];
d320 1
a320 1
#       if Debug
d323 1
a323 1
#       endif
d328 2
a329 1

d362 1
a362 1
  for (p=lp=s=0; s<ROMsections; s++)
d386 1
a386 1
#           if Debug
d389 1
a389 1
#           endif
d398 1
a398 1
#         if Debug
d401 1
a401 1
#         endif
d409 1
a409 1
#     if Debug
d411 1
a411 1
#     endif
d456 1
a456 1
  uint32          ROM_L1PTvalues[ROMsections];
d459 1
a459 1
# define MMU_L1PR 0x11  /* flag L1 descriptor as page reference */
d462 1
a462 1
  for (i=0; i<ROMsections; i++) 
d467 2
a468 1
  md->DAN  = patchDAN;
d470 1
a470 1
  for (i=0; i<ROMsections; i++) md->L1PTentries[i] = ROM_L1PTvalues[i];
d473 1
a473 1
  for (i=0; i<ROMsections; i++)
d479 2
a480 2
# if Debug
   for (i=0; i<ROMsections; i++)
d483 1
a483 1
# endif
d485 3
a487 3
# if ReallyDoRemap
    svcsetROML1PT((uint32 *)(L1PT + (ROMstart >> 18)),ROM_L1PTvalues,ROMsections);
# else
d489 1
a489 1
# endif
d502 1
a502 1
#   if Debug
d504 2
a505 1
#   endif
d509 1
a509 1
# if Debug
d526 7
a532 4
  static int romsection[ROMsections];
  static int romlpage[ROMlpages];
  static int rompage[ROMpages];

d537 1
a537 1
# if Debug
d539 1
a539 1
# endif
d546 1
a546 1
# if Debug
d548 1
a548 1
# endif
d559 1
a559 1
# if Debug
d561 1
a561 1
# endif
@


1.1
log
@file rompatch was initially added on branch RO_3_70_to_3_71.
@
text
@d1 566
@


1.1.4.1
log
@Version RO_3_71 taken
@
text
@a0 566
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* rompatch.c */

/*
  17-Oct-96 2.00 MJS originated (version 1 is different mapping
                     strategy, in BASIC)
  25-Oct-96 2.01 MJS no longer relies on growing screen memory in order to
                     avoid taking future screen pages; instead does
                     something much more like BASIC version (ahem, thanks Tim)
  24-Feb-97 2.02 MJS Enhanced to allow patches for more than one ROM version.
                     Added some patches for 3.70:
                       - Wimp_TransferBlock (fixes as for RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                     Created patches for 3.60:
                       - Wimp_TransferBlock (fixes to equivalent of RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                       - FSLock (SP's patch - allow floppy format when hard drive locked)
                     (see patches directory for details)
*/

/* version string is maintained in s.module */

#include <stdio.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"

#include "defs.h"
#include "debug.h"
#include "UK/messages.h"

/* implemented in assembler */
extern uint32 module,moduleend;
extern uint32 modDAhandler,moddata;
extern uint32 svcarmid(void);
extern void   svccopy(uint32 *src, uint32 *dest, int bytes);
extern uint32 svcpeek(uint32 *addr);
extern void   svcpoke(uint32 *addr, uint32 val);
extern void   svcsetROML1PT(uint32 *L1PTaddr, uint32 *L1PTvals, int count);

/* ROMs and their patches */
#include "patches/patch.h"

/* ------------------------------------------------------------------------ */

static int match_romcrc(uint32 *romcrc)
{
  int    i, match;
  uint32 *this_romcrc = (uint32 *)(ROMstart+ROMsize-12);

  for (match=1,i=0; i<3; i++) match &= (this_romcrc[i] == romcrc[i]);

  return match;
}

/* ------------------------------------------------------------------------ */

uint32 logtophys(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0x2200,&block,1); /* log provided, fill in phys */
  return block.physaddr; 
}

uint32 logtopagenum(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0xa00,&block,1); /* log provided, fill in pnum */
  return block.pagenumber; 
}

static uint32 phystopagenum(uint32 phys)
{
  osmemoryblock_t block;

  block.physaddr = phys;
  _swix(OS_Memory,_INR(0,2),0xc00,&block,1); /* phys provided, fill in pnum */
  return block.pagenumber; 
}


/* ------------------------------------------------------------------------ */

static int scan_patches(patchlist_proc patchlist[],
                        int *romsection,int *romlpage,int *rompage)
{
  /* checks patch status, updates romsection,romlpage,rompage,
     returns no. of patch pages */

  int          i, j, Npatchpages;
  uint32       *la, ila;
  patchentry_t *pl;

  /* initialise hit tables */
  for (i=0; i<ROMsections; i++) romsection[i] = 0;
  for (i=0; i<ROMlpages; i++)   romlpage[i]   = 0;
  for (i=0; i<ROMpages; i++)    rompage[i]    = 0;

  for (Npatchpages=i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        la = pl[j].logaddr;
        ila = (uint32)la;
        if (*la == pl[j].newval)
        {
          fprintf(stderr,E_ROMpatched);
          exit(ErrorReturnCode);
        }
        if (*la != pl[j].oldval)
        {
          fprintf(stderr,E_badROMpatch);
          fprintf(stderr,"  at %8.8x: wanted=%8.8x found=%8.8x\n",ila,pl[j].oldval,*la);
          exit(ErrorReturnCode);
        }
        /* mark section and large page hits with 1 */
        romsection[(ila - ROMstart) >> 20] = 1;
        romlpage[(ila - ROMstart) >> 16]   = 1;;
        if (rompage[(ila - ROMstart) >> 12] == 0)
        {
          /* count newly hit pages, and mark with 1 for now */
          Npatchpages++;
          rompage[(ila - ROMstart) >> 12] = 1;
        }
      }
    }
  }

  /* now rescan page hit table, and mark with ascending sequence of
     hit number */
  for (i=j=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = ++j;

  return Npatchpages;
}

/* ------------------------------------------------------------------------ */

#define pagetype(pap,table) ((pap)&1) ? (table[(pap)>>1] >> 4) : (table[(pap)>>1] & 15)

#define pt_availableDRAM 1

static int find_DA_first_pagenum(int pagesneeded, uint32 *first_pagenum)
{
  /* find a suitable block of sequential page numbers for dynamic area; ie.
     not pages currently unavailable and not pages that may later be
     needed for screen
     - return 1 for success 0 for failure (if success, first_pagenum is
       first page number in found block) */

  _kernel_oserror *e;
  uint8           *table;
  uint32          L1PTphys,firstpagepap;
  int             tablesize, L1PTpap,pap,pt,pagestofind,foundfirstpage;

  /* find size of memory physical arrangement table (bytes) */
  e = _swix(OS_Memory,_IN(0)|_OUT(1),6,&tablesize);
  if (e) return 0;

# if Debug
    fprintf(stderr,"physical arrangement tablesize=%1d\n",tablesize);
#  endif
  table = malloc(tablesize);
  if (table == NULL) return 0;

  /* read memory physical arrangement table (two entries per byte) */ 
  e = _swix(OS_Memory,_INR(0,1),7,table);
  if (e) return 0;

  /* RAM used for start of L1PT is good start point for scan of table;
     mainly, avoids DRAM that could be used for screen in no-VRAM
     system  */
  L1PTphys = logtophys(L1PT);
  L1PTpap  = L1PTphys >> 12; /* physical arrangement (4k) page index, into table */

# if Debug
    fprintf(stderr,"L1PTpap=%1d end=%1d\n",L1PTpap,tablesize*2);
# endif

  foundfirstpage = 0;
  firstpagepap   = 0;
  pagestofind    = pagesneeded - 1;
  for (pap=L1PTpap; (pap<tablesize*2) && pagestofind; pap++)
  {
    pt = pagetype(pap,table);
#   if Debug
      fprintf(stderr,"pap=0x%5.5x pt=0x%2.2x\n",pap,pt);
#   endif
    if (foundfirstpage)
    {
      /* we must collect subsequent pages that are DRAM and not marked Unavailable */
      if (pt == pt_availableDRAM) pagestofind--; else foundfirstpage = 0;
#     if Debug
        fprintf(stderr,"  - %1d %5d\n",foundfirstpage,pagestofind);
#     endif
    }
    else
    {
      if (pt == pt_availableDRAM)
      {
        /* found a possible first page, (DRAM that is not marked Unavailable) */
        pagestofind  = pagesneeded - 1;
        firstpagepap = pap;
        foundfirstpage = 1;
#       if Debug
          fprintf(stderr,"  > %1d %5d\n",foundfirstpage,pagestofind);
#       endif
      }      
    }
  }

  *first_pagenum = phystopagenum(firstpagepap << 12);
  return foundfirstpage && (pagestofind == 0);
}

/* ------------------------------------------------------------------------ */

static void create_patchDA(uint32 RMAaddr, int DAsize, uint32 DAhandler_addr,
                           char *patchname,
                           int *patchDAN, uint32 *patchDAbase)
{
  /* create dynamic area for patches (plus 1 page - the first - for
     MMU L2PT), return DA number and base */
 
  _kernel_oserror *e;
  moduledata_t    *md;
  int             ok;
  uint32          first_pagenum;

  /* non-draggable area, user read only, bufferable,cacheable,
     has handler, specific pages required, initial size 0 */

  e = _swix(OS_DynamicArea,_INR(0,8)|_OUT(1)|_OUT(3),
            0,-1,0,-1,0x181,DAsize,DAhandler_addr,0,
            patchname,patchDAN,patchDAbase);

  if (!e)
  {
    /* find block of pages to use (starting at first_pagenum) */
    ok = find_DA_first_pagenum(DAsize>>12,&first_pagenum);
    if (ok)
    {
      /* set values reguired by pregrow handler, in module in RMA */
      md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
      md->nextpageneeded     = first_pagenum;
      md->firstpagenotneeded = first_pagenum + (DAsize >> 12);
#     if Debug
      fprintf(stderr,"DA page numbers 0x%1.1x..0x%1.1x\n",
              md->nextpageneeded,md->firstpagenotneeded-1);
#     endif
      /* grow the area to DAsize */
      e = _swix(OS_ChangeDynamicArea,_INR(0,1),*patchDAN,DAsize);
    }
  }

  if (e || !ok)
  {
    fprintf(stderr,E_patchmem);
    exit(ErrorReturnCode);
  }
}

/* ------------------------------------------------------------------------ */

static void fill_patchpages(patchlist_proc patchlist[],uint32 patchDAbase,
                            int *romsection,int *romlpage,int *rompage)
{
  /* fill in code (with patches) for patch pages in dynamic area (0'th
     page of dynamic area reserved for L2PT stuff */

  int          i,j, ppage;
  patchentry_t *pl;
  uint32       addr, *waddr, ppaddr;

  /* negate rompage entries to flag 'not copied yet' */
  for (i=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = -rompage[i];

  for (i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        addr  = (uint32)pl[j].logaddr;
        ppage = (addr - ROMstart) >> 12;
        if (rompage[ppage] < 0)
        {
          /* first time this page hit - copy from ROM to dynamic area */
          rompage[ppage] = -rompage[ppage]; /* mark as now copied (unnegate) */
          ppaddr = addr & 0xfffff000;
          svccopy((uint32 *)ppaddr,
                  (uint32 *)(patchDAbase + (rompage[ppage] << 12)),0x1000);
        }
        waddr = (uint32 *)(patchDAbase + (rompage[ppage]<<12) + (addr&0xfff));
#       if Debug
          fprintf(stderr,"  %8.8x %8.8x --> %8.8x %8.8x\n",
                  addr,pl[j].oldval,(int)waddr,pl[j].newval);
#       endif
        svcpoke(waddr,pl[j].newval);
      }
    }
  }

}

/* ------------------------------------------------------------------------ */

static void fill_patchL2PTpage(int writeprotect, uint32 armid, uint32 patchDAbase,
                               int *romsection,int *romlpage,int *rompage)
{
  /* fill in 1st page of dynamic area with MMU level2 page table info for
     patches  */

  int    i,s,p,lp, ppage;            
  uint32 *patchL2PT,ppage_physaddr,lpage_physaddr, mmu_lp,mmu_sp;

  if (writeprotect && ((armid & 0xf000) >= 0x7000))
  {
    /* ROM supports write protection, and processor supports ROM bit (ie.
       ROM is presumed to have set ROM bit for this processor)
       => mark patched areas as read only, bufferable,cacheable */
    mmu_lp = 0x00d;
    mmu_sp = 0x00e;
  }
  else
  {
    /* ROM does not support write protection, or processor (ARM6) has no ROM bit
       (ie. there will not be a ROM bit set)
        => mark patched areas as read only (user), bufferable,cacheable */
    mmu_lp = 0xaad;
    mmu_sp = 0xaae;
  }

  patchL2PT = (uint32 *)patchDAbase; /* 0'th page is used for L2PT stuff */

  for (p=lp=s=0; s<ROMsections; s++)
  {    
    if (romsection[s])
    {
      /* must break down this section, and L2PT map it */
      for (lp=s*16; lp<(s+1)*16; lp++)
      {
        if (romlpage[lp])
        {
          /* must break down this large page into (small) pages */
          for (p=lp*16; p<(lp+1)*16; p++)
          {
            if (rompage[p])
            {
              /* patched page, in dynamic area */
              ppage = rompage[p];
              ppage_physaddr = logtophys(patchDAbase + (ppage << 12));
            }
            else
            {
              /* unpatched page, in ROM */
              ppage_physaddr = ROMphysstart + (p << 12);
            }
            svcpoke(patchL2PT+p,ppage_physaddr | mmu_sp); 
#           if Debug
              fprintf(stderr,"SPG %8.8x %8.8x\n",
                      (int)patchL2PT+p,ppage_physaddr | mmu_sp);
#           endif
          }
        }
        else
        {
          /* map as large page (MMU requires 16 entries repeated) */
          lpage_physaddr = ROMphysstart + (lp << 16);
          for (i=lp*16; i<(lp+1)*16; i++)
            svcpoke(patchL2PT+i,lpage_physaddr | mmu_lp);
#         if Debug
              fprintf(stderr,"LPG %8.8x %8.8x\n",
                      (int)patchL2PT+i,lpage_physaddr | mmu_lp);
#         endif
        }
      }
    }
    else
    {
      /* section map can remain, set unused L2PT to Fault */
      for (i=s*256; i<(s+1)*256; i++) svcpoke(patchL2PT+i,0);
#     if Debug
        fprintf(stderr,"SEC %8.8x %8.8x\n",(int)patchL2PT+i,0);
#     endif
    }
  }

}

/* ------------------------------------------------------------------------ */

static uint32 insert_ROMPatches_module(void)
{
  /* returns address of (start of) module in RMA as a uint32 */

  uint32 RMAaddr;

  _kernel_oserror *e;

  /* insert module into RMA */
  e = _swix(OS_Module,_INR(0,2),11,&module,(int)(&moduleend)-(int)(&module));
  if (!e)
  {
    /* find start of module in RMA */
    e = _swix(OS_Module,_INR(0,1)|_OUT(3),18,"ROMPatches",&RMAaddr);
  }

  if (e)
  {
    fprintf(stderr,"%s\n",e->errmess);
    fprintf(stderr,E_nomodule);
    exit(ErrorReturnCode);
  }

  return RMAaddr;
}

/* ------------------------------------------------------------------------ */

static void set_ROM_L1PT(uint32 RMAaddr, int patchDAN, uint32 patchDAbase,
                         int *romsection)
{
  /* - set required data values in ROMPatches module, in RMA
     - set ROM L1PT entries to apply patches; do this via assembler call
       so that it happens cleanly, while ROM code is not executing
  */

  int             i;
  uint32          ROM_L1PTvalues[ROMsections];
  moduledata_t    *md;

# define MMU_L1PR 0x11  /* flag L1 descriptor as page reference */

  /* current L1PT settings */
  for (i=0; i<ROMsections; i++) 
    ROM_L1PTvalues[i] = svcpeek((uint32 *)(L1PT + (ROMstart >> 18) + (i<<2)));

  /* now poke all required values into module data space, in RMA */
  md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
  md->DAN  = patchDAN;
  md->kernL1PT = L1PT + (ROMstart >> 18);
  for (i=0; i<ROMsections; i++) md->L1PTentries[i] = ROM_L1PTvalues[i];

  /* new settings, for any sections hit by patches */
  for (i=0; i<ROMsections; i++)
  {
    if (romsection[i])
      ROM_L1PTvalues[i] = logtophys(patchDAbase + (i << 10)) | MMU_L1PR;
  }

# if Debug
   for (i=0; i<ROMsections; i++)
     printf("  romsection %1d %8.8x\n",i,ROM_L1PTvalues[i]);

# endif

# if ReallyDoRemap
    svcsetROML1PT((uint32 *)(L1PT + (ROMstart >> 18)),ROM_L1PTvalues,ROMsections);
# else
    fprintf(stderr,"** svcsetROML1PT skipped **\n");
# endif

}

/* ------------------------------------------------------------------------ */

static ROMentry_t *identify_ROM(void)
{
  int        r;
  ROMentry_t *rom;

  for (rom=knownROMs[r=0]; rom != NULL; rom=knownROMs[++r])
  {
#   if Debug
    fprintf(stderr,"check %s\n",rom->patchname);
#   endif
    if (match_romcrc(rom->romcrc)) break;
  }

# if Debug
    if (rom == NULL) fprintf(stderr,E_ROMunknown);
#endif

  return rom;
}

/* ------------------------------------------------------------------------ */

int main(int argc, char *argv[])
{
  int        Npatchpages, patchDAN, patchDAsize;
  uint32     armid, patchDAbase, RMAaddr, DAhandler_addr;
  ROMentry_t *rom;

  /* marked in order to construct best mapping granularity
     allowed by patches (to minimise stress on processor TLB(s)) */
  static int romsection[ROMsections];
  static int romlpage[ROMlpages];
  static int rompage[ROMpages];

  rom = identify_ROM();
  if (!rom) exit(0); /* not classed as error */

  armid = svcarmid();
# if Debug
  fprintf(stderr,"ARM ID = %8.8x\n",armid);
# endif

  /* sets hit tables, calculates number of pages required for patches */
  Npatchpages = scan_patches(rom->patchlist,romsection,romlpage,rompage);

  if (Npatchpages == 0) exit(0); /* not classed as error */

# if Debug
  dbtrace_patchhits(romsection,romlpage,rompage);
# endif

  /* insert module first, since DAhandler code there */
  RMAaddr = insert_ROMPatches_module();
  DAhandler_addr = (uint32)(&modDAhandler) - (uint32)(&module) + RMAaddr;

  /* 1 extra page required for L2PT entries */
  patchDAsize = (Npatchpages + 1) << 12;
  create_patchDA(RMAaddr,patchDAsize,DAhandler_addr,rom->patchname,
                 &patchDAN,&patchDAbase);

# if Debug
  dbtrace_DApages(patchDAN,patchDAbase,patchDAsize);
# endif

  /* rescans patches, and sets patch pages in DA */
  fill_patchpages(rom->patchlist,patchDAbase,romsection,romlpage,rompage);

  /* sets MMU level 2 mapping page in DA */
  fill_patchL2PTpage(rom->writeprotect,armid,patchDAbase,
                     romsection,romlpage,rompage);

  /* also sets required data values in ROMpatches module, in RMA */
  set_ROM_L1PT(RMAaddr,patchDAN,patchDAbase,romsection);

  /* ROM is now patched! */
  return 0;
}
@


1.1.2.1
log
@Merged from 3.71 CD
@
text
@a0 566
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* rompatch.c */

/*
  17-Oct-96 2.00 MJS originated (version 1 is different mapping
                     strategy, in BASIC)
  25-Oct-96 2.01 MJS no longer relies on growing screen memory in order to
                     avoid taking future screen pages; instead does
                     something much more like BASIC version (ahem, thanks Tim)
  24-Feb-97 2.02 MJS Enhanced to allow patches for more than one ROM version.
                     Added some patches for 3.70:
                       - Wimp_TransferBlock (fixes as for RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                     Created patches for 3.60:
                       - Wimp_TransferBlock (fixes to equivalent of RISC OS 3.71)
                       - RTCAdjust (remove duplicate request to CallEvery)
                       - FSLock (SP's patch - allow floppy format when hard drive locked)
                     (see patches directory for details)
*/

/* version string is maintained in s.module */

#include <stdio.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"

#include "defs.h"
#include "debug.h"
#include "UK/messages.h"

/* implemented in assembler */
extern uint32 module,moduleend;
extern uint32 modDAhandler,moddata;
extern uint32 svcarmid(void);
extern void   svccopy(uint32 *src, uint32 *dest, int bytes);
extern uint32 svcpeek(uint32 *addr);
extern void   svcpoke(uint32 *addr, uint32 val);
extern void   svcsetROML1PT(uint32 *L1PTaddr, uint32 *L1PTvals, int count);

/* ROMs and their patches */
#include "patches/patch.h"

/* ------------------------------------------------------------------------ */

static int match_romcrc(uint32 *romcrc)
{
  int    i, match;
  uint32 *this_romcrc = (uint32 *)(ROMstart+ROMsize-12);

  for (match=1,i=0; i<3; i++) match &= (this_romcrc[i] == romcrc[i]);

  return match;
}

/* ------------------------------------------------------------------------ */

uint32 logtophys(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0x2200,&block,1); /* log provided, fill in phys */
  return block.physaddr; 
}

uint32 logtopagenum(uint32 log)
{
  osmemoryblock_t block;

  block.logaddr = log;
  _swix(OS_Memory,_INR(0,2),0xa00,&block,1); /* log provided, fill in pnum */
  return block.pagenumber; 
}

static uint32 phystopagenum(uint32 phys)
{
  osmemoryblock_t block;

  block.physaddr = phys;
  _swix(OS_Memory,_INR(0,2),0xc00,&block,1); /* phys provided, fill in pnum */
  return block.pagenumber; 
}


/* ------------------------------------------------------------------------ */

static int scan_patches(patchlist_proc patchlist[],
                        int *romsection,int *romlpage,int *rompage)
{
  /* checks patch status, updates romsection,romlpage,rompage,
     returns no. of patch pages */

  int          i, j, Npatchpages;
  uint32       *la, ila;
  patchentry_t *pl;

  /* initialise hit tables */
  for (i=0; i<ROMsections; i++) romsection[i] = 0;
  for (i=0; i<ROMlpages; i++)   romlpage[i]   = 0;
  for (i=0; i<ROMpages; i++)    rompage[i]    = 0;

  for (Npatchpages=i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        la = pl[j].logaddr;
        ila = (uint32)la;
        if (*la == pl[j].newval)
        {
          fprintf(stderr,E_ROMpatched);
          exit(ErrorReturnCode);
        }
        if (*la != pl[j].oldval)
        {
          fprintf(stderr,E_badROMpatch);
          fprintf(stderr,"  at %8.8x: wanted=%8.8x found=%8.8x\n",ila,pl[j].oldval,*la);
          exit(ErrorReturnCode);
        }
        /* mark section and large page hits with 1 */
        romsection[(ila - ROMstart) >> 20] = 1;
        romlpage[(ila - ROMstart) >> 16]   = 1;;
        if (rompage[(ila - ROMstart) >> 12] == 0)
        {
          /* count newly hit pages, and mark with 1 for now */
          Npatchpages++;
          rompage[(ila - ROMstart) >> 12] = 1;
        }
      }
    }
  }

  /* now rescan page hit table, and mark with ascending sequence of
     hit number */
  for (i=j=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = ++j;

  return Npatchpages;
}

/* ------------------------------------------------------------------------ */

#define pagetype(pap,table) ((pap)&1) ? (table[(pap)>>1] >> 4) : (table[(pap)>>1] & 15)

#define pt_availableDRAM 1

static int find_DA_first_pagenum(int pagesneeded, uint32 *first_pagenum)
{
  /* find a suitable block of sequential page numbers for dynamic area; ie.
     not pages currently unavailable and not pages that may later be
     needed for screen
     - return 1 for success 0 for failure (if success, first_pagenum is
       first page number in found block) */

  _kernel_oserror *e;
  uint8           *table;
  uint32          L1PTphys,firstpagepap;
  int             tablesize, L1PTpap,pap,pt,pagestofind,foundfirstpage;

  /* find size of memory physical arrangement table (bytes) */
  e = _swix(OS_Memory,_IN(0)|_OUT(1),6,&tablesize);
  if (e) return 0;

# if Debug
    fprintf(stderr,"physical arrangement tablesize=%1d\n",tablesize);
#  endif
  table = malloc(tablesize);
  if (table == NULL) return 0;

  /* read memory physical arrangement table (two entries per byte) */ 
  e = _swix(OS_Memory,_INR(0,1),7,table);
  if (e) return 0;

  /* RAM used for start of L1PT is good start point for scan of table;
     mainly, avoids DRAM that could be used for screen in no-VRAM
     system  */
  L1PTphys = logtophys(L1PT);
  L1PTpap  = L1PTphys >> 12; /* physical arrangement (4k) page index, into table */

# if Debug
    fprintf(stderr,"L1PTpap=%1d end=%1d\n",L1PTpap,tablesize*2);
# endif

  foundfirstpage = 0;
  firstpagepap   = 0;
  pagestofind    = pagesneeded - 1;
  for (pap=L1PTpap; (pap<tablesize*2) && pagestofind; pap++)
  {
    pt = pagetype(pap,table);
#   if Debug
      fprintf(stderr,"pap=0x%5.5x pt=0x%2.2x\n",pap,pt);
#   endif
    if (foundfirstpage)
    {
      /* we must collect subsequent pages that are DRAM and not marked Unavailable */
      if (pt == pt_availableDRAM) pagestofind--; else foundfirstpage = 0;
#     if Debug
        fprintf(stderr,"  - %1d %5d\n",foundfirstpage,pagestofind);
#     endif
    }
    else
    {
      if (pt == pt_availableDRAM)
      {
        /* found a possible first page, (DRAM that is not marked Unavailable) */
        pagestofind  = pagesneeded - 1;
        firstpagepap = pap;
        foundfirstpage = 1;
#       if Debug
          fprintf(stderr,"  > %1d %5d\n",foundfirstpage,pagestofind);
#       endif
      }      
    }
  }

  *first_pagenum = phystopagenum(firstpagepap << 12);
  return foundfirstpage && (pagestofind == 0);
}

/* ------------------------------------------------------------------------ */

static void create_patchDA(uint32 RMAaddr, int DAsize, uint32 DAhandler_addr,
                           char *patchname,
                           int *patchDAN, uint32 *patchDAbase)
{
  /* create dynamic area for patches (plus 1 page - the first - for
     MMU L2PT), return DA number and base */
 
  _kernel_oserror *e;
  moduledata_t    *md;
  int             ok;
  uint32          first_pagenum;

  /* non-draggable area, user read only, bufferable,cacheable,
     has handler, specific pages required, initial size 0 */

  e = _swix(OS_DynamicArea,_INR(0,8)|_OUT(1)|_OUT(3),
            0,-1,0,-1,0x181,DAsize,DAhandler_addr,0,
            patchname,patchDAN,patchDAbase);

  if (!e)
  {
    /* find block of pages to use (starting at first_pagenum) */
    ok = find_DA_first_pagenum(DAsize>>12,&first_pagenum);
    if (ok)
    {
      /* set values reguired by pregrow handler, in module in RMA */
      md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
      md->nextpageneeded     = first_pagenum;
      md->firstpagenotneeded = first_pagenum + (DAsize >> 12);
#     if Debug
      fprintf(stderr,"DA page numbers 0x%1.1x..0x%1.1x\n",
              md->nextpageneeded,md->firstpagenotneeded-1);
#     endif
      /* grow the area to DAsize */
      e = _swix(OS_ChangeDynamicArea,_INR(0,1),*patchDAN,DAsize);
    }
  }

  if (e || !ok)
  {
    fprintf(stderr,E_patchmem);
    exit(ErrorReturnCode);
  }
}

/* ------------------------------------------------------------------------ */

static void fill_patchpages(patchlist_proc patchlist[],uint32 patchDAbase,
                            int *romsection,int *romlpage,int *rompage)
{
  /* fill in code (with patches) for patch pages in dynamic area (0'th
     page of dynamic area reserved for L2PT stuff */

  int          i,j, ppage;
  patchentry_t *pl;
  uint32       addr, *waddr, ppaddr;

  /* negate rompage entries to flag 'not copied yet' */
  for (i=0; i<ROMpages; i++) if (rompage[i]) rompage[i] = -rompage[i];

  for (i=0; patchlist[i] != NULL; i++)
  {
    pl = (patchlist[i])(NULL);
    if (pl)
    {
      for (j=0; pl[j].newval != pl[j].oldval; j++)
      {
        addr  = (uint32)pl[j].logaddr;
        ppage = (addr - ROMstart) >> 12;
        if (rompage[ppage] < 0)
        {
          /* first time this page hit - copy from ROM to dynamic area */
          rompage[ppage] = -rompage[ppage]; /* mark as now copied (unnegate) */
          ppaddr = addr & 0xfffff000;
          svccopy((uint32 *)ppaddr,
                  (uint32 *)(patchDAbase + (rompage[ppage] << 12)),0x1000);
        }
        waddr = (uint32 *)(patchDAbase + (rompage[ppage]<<12) + (addr&0xfff));
#       if Debug
          fprintf(stderr,"  %8.8x %8.8x --> %8.8x %8.8x\n",
                  addr,pl[j].oldval,(int)waddr,pl[j].newval);
#       endif
        svcpoke(waddr,pl[j].newval);
      }
    }
  }

}

/* ------------------------------------------------------------------------ */

static void fill_patchL2PTpage(int writeprotect, uint32 armid, uint32 patchDAbase,
                               int *romsection,int *romlpage,int *rompage)
{
  /* fill in 1st page of dynamic area with MMU level2 page table info for
     patches  */

  int    i,s,p,lp, ppage;            
  uint32 *patchL2PT,ppage_physaddr,lpage_physaddr, mmu_lp,mmu_sp;

  if (writeprotect && ((armid & 0xf000) >= 0x7000))
  {
    /* ROM supports write protection, and processor supports ROM bit (ie.
       ROM is presumed to have set ROM bit for this processor)
       => mark patched areas as read only, bufferable,cacheable */
    mmu_lp = 0x00d;
    mmu_sp = 0x00e;
  }
  else
  {
    /* ROM does not support write protection, or processor (ARM6) has no ROM bit
       (ie. there will not be a ROM bit set)
        => mark patched areas as read only (user), bufferable,cacheable */
    mmu_lp = 0xaad;
    mmu_sp = 0xaae;
  }

  patchL2PT = (uint32 *)patchDAbase; /* 0'th page is used for L2PT stuff */

  for (p=lp=s=0; s<ROMsections; s++)
  {    
    if (romsection[s])
    {
      /* must break down this section, and L2PT map it */
      for (lp=s*16; lp<(s+1)*16; lp++)
      {
        if (romlpage[lp])
        {
          /* must break down this large page into (small) pages */
          for (p=lp*16; p<(lp+1)*16; p++)
          {
            if (rompage[p])
            {
              /* patched page, in dynamic area */
              ppage = rompage[p];
              ppage_physaddr = logtophys(patchDAbase + (ppage << 12));
            }
            else
            {
              /* unpatched page, in ROM */
              ppage_physaddr = ROMphysstart + (p << 12);
            }
            svcpoke(patchL2PT+p,ppage_physaddr | mmu_sp); 
#           if Debug
              fprintf(stderr,"SPG %8.8x %8.8x\n",
                      (int)patchL2PT+p,ppage_physaddr | mmu_sp);
#           endif
          }
        }
        else
        {
          /* map as large page (MMU requires 16 entries repeated) */
          lpage_physaddr = ROMphysstart + (lp << 16);
          for (i=lp*16; i<(lp+1)*16; i++)
            svcpoke(patchL2PT+i,lpage_physaddr | mmu_lp);
#         if Debug
              fprintf(stderr,"LPG %8.8x %8.8x\n",
                      (int)patchL2PT+i,lpage_physaddr | mmu_lp);
#         endif
        }
      }
    }
    else
    {
      /* section map can remain, set unused L2PT to Fault */
      for (i=s*256; i<(s+1)*256; i++) svcpoke(patchL2PT+i,0);
#     if Debug
        fprintf(stderr,"SEC %8.8x %8.8x\n",(int)patchL2PT+i,0);
#     endif
    }
  }

}

/* ------------------------------------------------------------------------ */

static uint32 insert_ROMPatches_module(void)
{
  /* returns address of (start of) module in RMA as a uint32 */

  uint32 RMAaddr;

  _kernel_oserror *e;

  /* insert module into RMA */
  e = _swix(OS_Module,_INR(0,2),11,&module,(int)(&moduleend)-(int)(&module));
  if (!e)
  {
    /* find start of module in RMA */
    e = _swix(OS_Module,_INR(0,1)|_OUT(3),18,"ROMPatches",&RMAaddr);
  }

  if (e)
  {
    fprintf(stderr,"%s\n",e->errmess);
    fprintf(stderr,E_nomodule);
    exit(ErrorReturnCode);
  }

  return RMAaddr;
}

/* ------------------------------------------------------------------------ */

static void set_ROM_L1PT(uint32 RMAaddr, int patchDAN, uint32 patchDAbase,
                         int *romsection)
{
  /* - set required data values in ROMPatches module, in RMA
     - set ROM L1PT entries to apply patches; do this via assembler call
       so that it happens cleanly, while ROM code is not executing
  */

  int             i;
  uint32          ROM_L1PTvalues[ROMsections];
  moduledata_t    *md;

# define MMU_L1PR 0x11  /* flag L1 descriptor as page reference */

  /* current L1PT settings */
  for (i=0; i<ROMsections; i++) 
    ROM_L1PTvalues[i] = svcpeek((uint32 *)(L1PT + (ROMstart >> 18) + (i<<2)));

  /* now poke all required values into module data space, in RMA */
  md = (moduledata_t *)((uint32)(&moddata)-(uint32)(&module)+RMAaddr);
  md->DAN  = patchDAN;
  md->kernL1PT = L1PT + (ROMstart >> 18);
  for (i=0; i<ROMsections; i++) md->L1PTentries[i] = ROM_L1PTvalues[i];

  /* new settings, for any sections hit by patches */
  for (i=0; i<ROMsections; i++)
  {
    if (romsection[i])
      ROM_L1PTvalues[i] = logtophys(patchDAbase + (i << 10)) | MMU_L1PR;
  }

# if Debug
   for (i=0; i<ROMsections; i++)
     printf("  romsection %1d %8.8x\n",i,ROM_L1PTvalues[i]);

# endif

# if ReallyDoRemap
    svcsetROML1PT((uint32 *)(L1PT + (ROMstart >> 18)),ROM_L1PTvalues,ROMsections);
# else
    fprintf(stderr,"** svcsetROML1PT skipped **\n");
# endif

}

/* ------------------------------------------------------------------------ */

static ROMentry_t *identify_ROM(void)
{
  int        r;
  ROMentry_t *rom;

  for (rom=knownROMs[r=0]; rom != NULL; rom=knownROMs[++r])
  {
#   if Debug
    fprintf(stderr,"check %s\n",rom->patchname);
#   endif
    if (match_romcrc(rom->romcrc)) break;
  }

# if Debug
    if (rom == NULL) fprintf(stderr,E_ROMunknown);
#endif

  return rom;
}

/* ------------------------------------------------------------------------ */

int main(int argc, char *argv[])
{
  int        Npatchpages, patchDAN, patchDAsize;
  uint32     armid, patchDAbase, RMAaddr, DAhandler_addr;
  ROMentry_t *rom;

  /* marked in order to construct best mapping granularity
     allowed by patches (to minimise stress on processor TLB(s)) */
  static int romsection[ROMsections];
  static int romlpage[ROMlpages];
  static int rompage[ROMpages];

  rom = identify_ROM();
  if (!rom) exit(0); /* not classed as error */

  armid = svcarmid();
# if Debug
  fprintf(stderr,"ARM ID = %8.8x\n",armid);
# endif

  /* sets hit tables, calculates number of pages required for patches */
  Npatchpages = scan_patches(rom->patchlist,romsection,romlpage,rompage);

  if (Npatchpages == 0) exit(0); /* not classed as error */

# if Debug
  dbtrace_patchhits(romsection,romlpage,rompage);
# endif

  /* insert module first, since DAhandler code there */
  RMAaddr = insert_ROMPatches_module();
  DAhandler_addr = (uint32)(&modDAhandler) - (uint32)(&module) + RMAaddr;

  /* 1 extra page required for L2PT entries */
  patchDAsize = (Npatchpages + 1) << 12;
  create_patchDA(RMAaddr,patchDAsize,DAhandler_addr,rom->patchname,
                 &patchDAN,&patchDAbase);

# if Debug
  dbtrace_DApages(patchDAN,patchDAbase,patchDAsize);
# endif

  /* rescans patches, and sets patch pages in DA */
  fill_patchpages(rom->patchlist,patchDAbase,romsection,romlpage,rompage);

  /* sets MMU level 2 mapping page in DA */
  fill_patchL2PTpage(rom->writeprotect,armid,patchDAbase,
                     romsection,romlpage,rompage);

  /* also sets required data values in ROMpatches module, in RMA */
  set_ROM_L1PT(RMAaddr,patchDAN,patchDAbase,romsection);

  /* ROM is now patched! */
  return 0;
}
@

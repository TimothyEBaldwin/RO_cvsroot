head	1.5;
access;
symbols
	SndSetup-2_08:1.5
	SndSetup-2_07:1.4
	SndSetup-2_06:1.3
	SndSetup-2_05:1.3
	SndSetup-2_04:1.3
	SndSetup-2_03:1.2
	SndSetup-2_02:1.2
	SndSetup-2_01:1.2
	SndSetup-2_00:1.2
	SndSetup-1_00:1.2
	SndSetup-0_06:1.1.1.3
	SndSetup-0_05:1.1.1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.2
	Ursula_RiscPC:1.1.1.2.0.2
	rleggett_SndSetup-0_04b:1.1.1.3
	rthornb_UrsulaBuild-19Aug1998:1.1.1.2
	UrsulaBuild_FinalSoftload:1.1.1.2
	rthornb_UrsulaBuild-29Jul1998:1.1.1.2
	rthornb_UrsulaBuild-22Jul1998:1.1.1.2
	rthornb_UrsulaBuild-15Jul1998:1.1.1.2
	rthornb_UrsulaBuild-07Jul1998:1.1.1.2
	rthornb_UrsulaBuild-17Jun1998:1.1.1.2
	rleggett_SndSetup-0_03:1.1.1.2
	rthornb_UrsulaBuild-03Jun1998:1.1.1.2
	rthornb_UrsulaBuild-27May1998:1.1.1.2
	rthornb_UrsulaBuild-21May1998:1.1.1.1
	rthornb_UrsulaBuild_01May1998:1.1.1.1
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2016.06.08.22.00.53;	author jlee;	state Exp;
branches;
next	1.4;
commitid	OjqsgzPB8RRw9I9z;

1.4
date	2013.07.20.14.39.42;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	siN8EGpUAUgHAdYw;

1.3
date	2012.01.21.19.31.18;	author jlee;	state Exp;
branches;
next	1.2;
commitid	S2B7wm85L3fSK4Qv;

1.2
date	2003.02.28.16.15.27;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.41.55;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.41.55;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.05.26.17.03.58;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.08.28.13.01.41;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Allow configuration of default audio controller device
Detail:
  If SndSetup detects that a version of SoundDMA is in use which supports controller enumeration & selection, the plugin display will have an extra string set gadget which can be used to select which device should be used
  When switching between devices the list of mixer controllers will update accordingly
  The controller selection will be saved to the SndSetup choices file, along with the mixer settings - with mixer settings being saved for all mxiers that are present, not just the selected one.
  File changes:
  - Resources/UK/Res,fae, h/defines - Updated to add the new string set and tweak the layout a bit
  - h/sound, c/sound - Added linked list of controller devices. Mixer channel detail arrays are now allocated on demand and stored as part of the controller details. Channel details now also tracks the currently selected mute & gain settings, since we can no longer rely on the UI to store those values for us if we're recreating gadgets when switching device.
  - c/main - Mixer volume slider setup separated out into its own function, so it can be repeated whenever we switch device.
  - h/common - Forward-declare of new function
Admin:
  Tested on Raspberry Pi, iMx6, Iyonix, RiscPC
  Requires Sound0HAL-1_84 / Sound0Trid-1_69 / Sound0-1_72


Version 2.08. Tagged as 'SndSetup-2_08'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    sound.c                                                          */
/* Purpose: Sound specific code                                              */
/* Author:  Richard Leggett                                                  */
/* History: 29-Jan-98: RML: Begun.                                           */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "Global/OsBytes.h"
#include "Global/FileTypes.h"
#include "Global/CMOS.h"
#include "Interface/HighFSI.h"
#include "Interface/MixerDevice.h"
#include "Interface/Sound.h"
#include "swis.h"
#include "toolbox.h"
#include "gadgets.h"
#include "common.h"
#include "defines.h"
#include "sound.h"

#ifndef SoundCtrl_ExamineMixer
#define SoundCtrl_ExamineMixer (0x50000)
#endif
#ifndef SoundCtrl_SetMix
#define SoundCtrl_SetMix       (0x50001)
#endif
#ifndef SoundCtrl_GetMix
#define SoundCtrl_GetMix       (0x50002)
#endif

controller_list_entry_t *original_controller = NULL;
controller_list_entry_t *configured_controller = NULL;
controller_list_entry_t *selected_controller = NULL;
controller_list_entry_t *controllers = NULL;
BOOL vidcmix;
BOOL multidevice;
unsigned int maxchannels = 0;

static int   menu_to_voice_map[16];
static int   cmos_sound, cmos_loud;

typedef struct
{
    unsigned short flags;
    signed short category;
    int mingain;
    int maxgain;
    int step;
} mixer_features;



/*---------------------------------------------------------------------------*
 * sound_detect_mix_mode                                                     *
 *                                                                           *
 * Find if this is an old style VIDC system or a full mixing desk.           *
 *---------------------------------------------------------------------------*/

void sound_detect_mix_mode(void)
{
    multidevice = FALSE;
    if (_swix(OS_CLI, _IN(0), "RMEnsure SoundControl 1.00") == NULL)
    {
        vidcmix = FALSE;
        int result,flags;
        if (!_swix(Sound_ReadSysInfo, _IN(0)|_OUTR(0,1), Sound_RSI_Features, &result, &flags))
        {
            if (!result && (flags & Sound_RSI_Feature_ControllerSelection))
            {
                multidevice = TRUE;
            }
        }
    }
    else
    {
        int dummy;

        if ((_swix(OS_Memory, _INR(0,1) | _OUT(1), 9, 3<<8, &dummy) == NULL) &&
            (dummy != 0))
        {
            vidcmix = TRUE;
        }
        else
        {
            /* No sound mixer module and no VIDC, that's fatal */
            error_trap(common_error(messages_lookup("NoSoundCtl")), 1);
        }
    }
}


/*---------------------------------------------------------------------------*
 * sound_db_to_volume                                                        *
 *                                                                           *
 * Translate a dB*16 setting into a volume.                                  *
 *---------------------------------------------------------------------------*/

static int sound_db_to_volume(int db)
{
    int volume;

    /* Round down to nearest step multiple of 3dB*16 */
    db = (db - 47) / 48;

    /* Every 3dB is a volume step of 16 */
    volume = 127 + (16 * db);
    if (volume <= 0) volume = 1;
    if (volume > 127) volume = 127;

    return volume;
}


/*---------------------------------------------------------------------------*
 * sound_volume_to_db                                                        *
 *                                                                           *
 * Translate a volume setting into dB*16s.                                   *
 *---------------------------------------------------------------------------*/

static int sound_volume_to_db(int volume)
{
    int db;

    /* Round down to nearest step of 16 */
    volume = (volume - 15) / 16;

    /* Every 16 is a step of -3dB*16 */
    db = 0 - (48 * (7 - volume));

    return db;
}


/*---------------------------------------------------------------------------*
 * sound_read_channel_info                                                   *
 *                                                                           *
 * Read the fixed characteristics of the mixer into the controller struct    *
 *---------------------------------------------------------------------------*/

static void sound_read_channel_info(controller_list_entry_t *controller)
{
    size_t space_needed;
    size_t block_size;

    if (vidcmix)
    {
        static channel_t vidcchannel = { VIDC_CHANNEL };
        const char *name;
        char nametoken[10] = "name";
        int  volume;
        
        /* Just fill in the one static channel */
        controller->nchannels = maxchannels = 1;
        controller->channels = &vidcchannel;
        strcat(nametoken, controller->channels[0].token_suffix);
        name = messages_lookup_withparam(nametoken, "");
        if ((controller->channels[0].name = malloc(strlen(name) + 1)) != NULL)
        {
            strcpy(controller->channels[0].name, name);
        }

        /* Original state retrieved from *VOLUME setting */
        error_trap(_swix(Sound_Volume, _IN(0) | _OUT(0), 0, &volume), 0);
        controller->channels[0].original_gain = sound_volume_to_db(volume);
        controller->channels[0].original_mute = FALSE;

        return;
    }

    /* Query the mixable channels and levels */
    error_trap(_swix(SoundCtrl_ExamineMixer, _INR(0,2)|_OUTR(2,3),
                     controller->mixer_id,
                     NULL,
                     0,
                     &space_needed,
                     &block_size), 1);
    controller->nchannels = -space_needed / block_size;
    if (controller->nchannels > MAX_CHANNELS) controller->nchannels = MAX_CHANNELS;
    if (controller->nchannels > maxchannels) maxchannels = controller->nchannels;
    controller->channels = (channel_t *) malloc(sizeof(channel_t)*controller->nchannels);
    if (!controller->channels)
    {
        error_trap(common_error(messages_lookup("NotEnoughMemory")), 1);
    }
    char buffer[controller->nchannels*block_size];
    error_trap(_swix(SoundCtrl_ExamineMixer, _INR(0,2)|_OUT(4),
                     controller->mixer_id,
                     buffer,
                     sizeof buffer,
                     &controller->nchannels), 1);
    for (int i = 0; i < controller->nchannels; i++)
    {
        mixer_features *info = (mixer_features *) (buffer+(block_size*i));
        controller->channels[i].category = info->category;
        controller->channels[i].index = -1;
        controller->channels[i].muted_by_default = info->flags & 4;
        controller->channels[i].fixed = info->flags & 1;
        controller->channels[i].mono = info->flags & 2;
        if (block_size >= 16)
        {
            controller->channels[i].mingain = info->mingain;
            controller->channels[i].maxgain = info->maxgain;
            controller->channels[i].step = info->step;
        }
        else
        {
            /* Use old limits of +0/-34.5, step 24 */
            controller->channels[i].mingain = (int) (-34.5*16);
            controller->channels[i].maxgain = 0;
            controller->channels[i].step = 24;
        }
        if (controller->channels[i].step <= 0)
            controller->channels[i].step = 1;
        /* Limit minimum gain to arbitrarily chosen value of -40dB
           This is to avoid too much of the bar being taken up by negative
           values if the mixer is capable of high attenuation (e.g. OMAP3 can
           go from -80 to +24, but the +ve range is the one we're interested in
           since it's a quiet system overall) */
        if (controller->channels[i].mingain < -40*16)
        {
            /* Ensure new value is still a multiple of the step size */
            int steps = (40*16+controller->channels[i].step-1)/controller->channels[i].step;
            controller->channels[i].mingain = -steps*controller->channels[i].step;
        }
        /* Sanity check */
        if (controller->channels[i].mingain >= controller->channels[i].maxgain)
            controller->channels[i].mingain = controller->channels[i].maxgain-16;
    }
    while (controller->nchannels > 0)
    {
        int i = 0;
        while (i < controller->nchannels && controller->channels[i].index != -1) i++;
        if (i == controller->nchannels) break;
        int category = controller->channels[i].category;
        unsigned int index = 0;
        for (int j = i; j < controller->nchannels; j++)
        {
            if (controller->channels[j].category == category)
            {
                controller->channels[j].index = index++;
                unsigned int mute;
                error_trap(_swix(SoundCtrl_GetMix, _INR(0,2)|_OUTR(3,4),
                                 controller->mixer_id,
                                 controller->channels[j].category,
                                 controller->channels[j].index,
                                 &mute,
                                 &controller->channels[j].original_gain), 1);
                controller->channels[j].original_mute = mute;
            }
        }
        for (int j = i; j < controller->nchannels; j++)
        {
            if (controller->channels[j].category == category)
            {
                controller->channels[j].token_suffix[0] = category < 0 ? 'O' : 'I';
                controller->channels[j].token_suffix[1] = abs(category) + '0';
                controller->channels[j].token_suffix[2] = controller->channels[j].mono ? 'm' : 's';
                controller->channels[j].token_suffix[3] = controller->channels[j].index + '0';
                controller->channels[j].token_suffix[4] = index + '0';
                controller->channels[j].token_suffix[5] = '\0';
                char nametoken[10] = "name";
                strcat(nametoken, controller->channels[j].token_suffix);
                char param[4];
                if (index == 1)
                {
                    param[0] = '\0';
                }
                else
                {
                    sprintf(param, " %d", controller->channels[j].index + 1);
                }
                const char *name = messages_lookup_withparam(nametoken, param);
                if ((controller->channels[j].name = malloc(strlen(name) + 1)) != NULL)
                {
                    strcpy(controller->channels[j].name, name);
                }
            }
        }
    }
}


/*---------------------------------------------------------------------------*
 * sound_switch_device                                                       *
 *                                                                           *
 * Switch the current device selection to selected_controller                *
 *---------------------------------------------------------------------------*/

static void sound_switch_device(void)
{
    if (!multidevice || !selected_controller)
    {
        return;
    }
    error_trap(_swix(Sound_SelectDefaultController, _IN(0), selected_controller->config_id), 0);
}

/*---------------------------------------------------------------------------*
 * sound_enumerate_devices                                                   *
 *                                                                           *
 * Enumerate the available devices and read their state                      *
 *---------------------------------------------------------------------------*/

void sound_enumerate_devices(void)
{
    if (!multidevice)
    {
        original_controller = configured_controller = selected_controller = controllers = (controller_list_entry_t *) malloc(sizeof(controller_list_entry_t) + 1);
        if (!selected_controller)
        {
            error_trap(common_error(messages_lookup("NotEnoughMemory")), 1);
        }
        memset(selected_controller,0,sizeof(controller_list_entry_t));
        strcpy(selected_controller->config_id, "0");
        sound_read_channel_info(selected_controller);
        return;
    }

    char *current = NULL;

    _kernel_swi_regs r;
    r.r[0] = Sound_RSI_DefaultController;
    r.r[1] = 0;
    r.r[2] = 0;
    _kernel_swi(Sound_ReadSysInfo, &r, &r);
    if (!r.r[0] && r.r[2] && ((current = (char *) malloc(r.r[2])) != NULL))
    {
        r.r[0] = Sound_RSI_DefaultController;
        r.r[1] = (int)current;
        _kernel_swi(Sound_ReadSysInfo, &r, &r);
        if (r.r[0])
        {
            free(current);
            current = NULL;
        }
    }

    const char *cont = NULL;

    do
    {
        r.r[0] = (int) cont;
        r.r[1] = 0;
        r.r[2] = 0;
        _kernel_swi(Sound_EnumerateControllers, &r, &r);
        if (r.r[2] <= 1)
        {
            break;
        }
        controller_list_entry_t *entry = (controller_list_entry_t *) malloc(sizeof(controller_list_entry_t) + r.r[2]);
        if (!entry)
        {
            error_trap(common_error(messages_lookup("NotEnoughMemory")), 1);
        }
        memset(entry, 0, sizeof(controller_list_entry_t));
        entry->index = -1;
        entry->next = controllers;
        entry->mixer_id = entry->config_id;
        r.r[0] = (int) cont;
        r.r[1] = (int) entry->config_id;
        error_trap(_kernel_swi(Sound_EnumerateControllers, &r, &r), 1);
        controllers = entry;
        cont = entry->config_id;

        sound_read_channel_info(entry);

        if (!original_controller)
        {
            if (!current || !strcmp(current, entry->config_id))
            {
                original_controller = selected_controller = entry;
            }
        }
    } while (true);

    free(current);
}


/*---------------------------------------------------------------------------*
 * sound_make_voices_menu                                                    *
 *                                                                           *
 * Make a menu of voice modules available.                                   *
 *                                                                           *
 * In: window_id - Toolbox ID of the configuration window                    *
 *---------------------------------------------------------------------------*/

void sound_make_voices_menu(int window_id)
{
    char  strings[1024];
    char* name;
    char* first = 0;
    char* name_local;
    int   i, m;
    
    memset(strings, 0, sizeof(strings));

    /* menu_to_voice_map maps from menu item number to internal voice number */
    for (m=15; m>=0; m--) menu_to_voice_map[m] = -1;

    /* Only read first 16 voices, as 16 is maximum value which can be stored in 4 CMOS bits */
    m=0;
    for (i=1; i<=16; i++)
    {
        _swix(Sound_InstallVoice, _INR(0,1)|_OUTR(2,3), 2, i, &name, &name_local);
        if (name!=0)
        {
            if (strlen(strings) > 0) strcat(strings, ",");
            if (strlen(strings) == 0) first = name_local;
            strcat(strings, name_local);
            menu_to_voice_map[m++] = i;
        }
    }
    
    error_trap(stringset_set_available(0, window_id, VoicesStringSet, strings), 0);
}


/*---------------------------------------------------------------------------*
 * sound_make_devices_menu                                                   *
 *                                                                           *
 * Make a menu of audio devices available.                                   *
 *                                                                           *
 * In: window_id - Toolbox ID of the configuration window                    *
 *---------------------------------------------------------------------------*/

void sound_make_devices_menu(int window_id)
{
    char  strings[1024];
    int   ofs = 0, idx = 0, len;

    if (!multidevice)
    {
        return;
    }
    
    memset(strings, 0, sizeof(strings));

    controller_list_entry_t *cont = controllers;

    while (cont)
    {
        /* Read display name into stringset buffer */
        if (ofs)
        {
          strings[ofs-1] = ',';
        }

        error_trap(_swix(Sound_ControllerInfo, _INR(0,3)|_OUT(2), cont->config_id, strings + ofs, sizeof(strings) - ofs, Sound_CtlrInfo_DisplayName, &len), 1);
        ofs += len;

        cont->index = idx++;
        cont = cont->next;
    }
    
    error_trap(stringset_set_available(0, window_id, DeviceStringSet, strings), 0);

    /* Set current selection */
    if (selected_controller)
    {
        error_trap(stringset_set_selected(1, window_id, DeviceStringSet, (char*) selected_controller->index), 0);
    } 
}


/*---------------------------------------------------------------------------*
 * sound_read_write_cmos_settings                                            *
 *                                                                           *
 * Read or write the CMOS settings for volume and voice, then update the     *
 * appropriate window gadgets.                                               *
 *                                                                           *
 * In: condition_code = ReadCMOSSettings or WriteCMOSSettings                *
 *     window_id = toolbox ID of the configuration window                    *
 *---------------------------------------------------------------------------*/

void sound_read_write_cmos_settings(int condition_code, int window_id)
{
    int voice = -1;
    int n = -1;
    int cmos_errors = read_cmos_value(WimpFlagsCMOS);
    int cmos_soundsys = read_cmos_value(PrintSoundCMOS);

    /* Are we reading or writing CMOS? */
    if (condition_code == ReadCMOSSettings)
    {
        cmos_sound = read_cmos_value(SoundCMOS);
        cmos_loud = read_cmos_value(DBTBCMOS);

        voice = 1 + (cmos_sound & 0x0f);
        
        /* Try to find the name in the stringset to match the CMOS-set channel */
        error_trap(stringset_set_selected(0, window_id, VoicesStringSet, ""), 0);
        for (n=0; n<15; n++)
        {
            if (menu_to_voice_map[n] == voice)
            {
                error_trap(stringset_set_selected(1, window_id, VoicesStringSet, (char*)n), 0);
            }
        }
        
        /* Is beep quiet or loud? */
        error_trap(radiobutton_set_state(0, window_id, cmos_loud & 2 ? LoudRadio : QuietRadio, 1), 0);

        /* Error boxes go beep? */
        error_trap(optionbutton_set_state(0, window_id, BeepingErrorsOption, cmos_errors & 16 ? 0 : 1), 0);

        if (vidcmix)
        {
            /* Extra hardware options */
            error_trap(optionbutton_set_state(0, window_id, OversamplingOption, cmos_soundsys & 0x80 ? 1 : 0), 0);
            error_trap(optionbutton_set_state(0, window_id, SixteenBitOption, cmos_soundsys & 0x60 ? 1 : 0), 0);
        }
    }
    else if (condition_code == WriteCMOSSettings)
    {
        char command[32];

        error_trap(stringset_get_selected(1, window_id, VoicesStringSet, &n), 0);
        if (n != -1) voice = menu_to_voice_map[n] - 1;
        if (voice >= 0)
        {
            cmos_sound &= ~0x0f;
            cmos_sound |= voice;
            write_cmos_value(SoundCMOS, cmos_sound);
        }
        
        error_trap(radiobutton_get_state(0, window_id, LoudRadio, &n, NULL), 0);
        cmos_loud &= ~2;
        cmos_loud |= 2 * n;
        write_cmos_value(DBTBCMOS, cmos_loud);

        error_trap(optionbutton_get_state(0, window_id, BeepingErrorsOption, &n), 0);
        cmos_errors &= ~16;
        cmos_errors |= 16 * (1 - n);
        sprintf(command, "CONFIGURE WIMPFLAGS %d", cmos_errors);
        _swix(OS_CLI, _IN(0), command); /* This gives an instant effect, unlike poking CMOS */

        if (vidcmix)
        {
            error_trap(optionbutton_get_state(0, window_id, OversamplingOption, &n), 0);
            cmos_soundsys &= ~0x80;
            cmos_soundsys |= 0x80 * n;
            error_trap(optionbutton_get_state(0, window_id, SixteenBitOption, &n), 0);
            cmos_soundsys &= ~0x60;
            cmos_soundsys |= 0x20 * n; /* DAC clk slave, use ext clk, per Risc PC & A7000(+) */
            write_cmos_value(PrintSoundCMOS, cmos_soundsys);
        }
    }
}


/*---------------------------------------------------------------------------*
 * sound_read_choices                                                        *
 *                                                                           *
 * Read the sound choices from the Choices file.                             *
 *---------------------------------------------------------------------------*/

void sound_read_choices(void)
{
    FILE *fp;
    char  buffer[256], id[256];
    bool more = true;
    int category;
    unsigned int index;
    unsigned char mute;
    int gain;

    if (vidcmix)
    {
        int volume;

        /* Comes from CMOS rather than Choices: */
        volume = 1 + (18 * ((cmos_sound >> 4) & 7));
        configured_controller->channels[0].selected_gain = configured_controller->channels[0].configured_gain = sound_volume_to_db(volume + 15);
        configured_controller->channels[0].selected_mute = configured_controller->channels[0].configured_mute = FALSE;

        return;
    }

    /* Start with hard defaults */
    for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
    {
        for (int i = 0; i < controller->nchannels; i++)
        {
            controller->channels[i].selected_gain = controller->channels[i].configured_gain = 0;
            controller->channels[i].selected_mute = controller->channels[i].configured_mute = controller->channels[i].muted_by_default;
        }
    }
    configured_controller = controllers;

    fp = fopen(ChoicesRead, "r");
    if (fp != NULL)
    {
        while (more)
        {
            /* Get next string */
            more = fgets(buffer, sizeof(buffer), fp);
            if (more)
            {
                /* Check for a suitable looking line */
                if (sscanf(buffer, "MixVolume %s %d %u %c %d", id, &category, &index, &mute, &gain) == 5 && (mute -= '0') <= 1)
                {
                    controller_list_entry_t *controller = controllers;
                    while (controller && strcmp(id, controller->config_id))
                    {
                        controller = controller->next;
                    }
                    if (multidevice && !controller && !strcmp(id, "0"))
                    {
                        /* Attempt to recover settings from old files */
                        controller = configured_controller;
                    }
                    if (controller)
                    {
                        /* Apply it to the channel array */
                        for (int i = 0; i < controller->nchannels; i++)
                        {
                            if (controller->channels[i].category == category && index-- == 0)
                            {
                                if (gain < controller->channels[i].mingain)
                                {
                                   gain = controller->channels[i].mingain;
                                }
                                else if (gain > controller->channels[i].maxgain)
                                {
                                   gain = controller->channels[i].maxgain;
                                }
                                controller->channels[i].selected_gain = controller->channels[i].configured_gain = gain;
                                controller->channels[i].selected_mute = controller->channels[i].configured_mute = mute;
                                break;
                            }
                        }
                    }
                }
                else if (sscanf(buffer, "X Audio %s", id) == 1)
                {
                    controller_list_entry_t *controller = controllers;
                    while (controller && strcmp(id, controller->config_id))
                    {
                        controller = controller->next;
                    }
                    if (controller)
                    {
                        configured_controller = controller;
                    }
                }
            }
        }
        
        fclose(fp);
    }

    selected_controller = configured_controller;
}


/*---------------------------------------------------------------------------*
 * sound_save_choices                                                        *
 *                                                                           *
 * Write the volume levels choices file.                                     *
 *---------------------------------------------------------------------------*/

void sound_save_choices(void)
{
    FILE *fp;
    FILE *fp2;
    char buffer[256];
    
    if (vidcmix)
    {
        int volume;
        
        /* Turn dB*16 back into 3dB per 16 volume */
        configured_controller->channels[0].original_gain = configured_controller->channels[0].selected_gain;
        volume = sound_db_to_volume(configured_controller->channels[0].original_gain);

        /* Cram into 3 sound CMOS bits */
        volume = (volume - 1) / 18;
        cmos_sound &= ~0x70;
        cmos_sound |= (volume << 4);
        write_cmos_value(SoundCMOS, cmos_sound);

        return;
    }

    fp = fopen(ChoicesWrite, "w");
    if (fp != NULL)
    {
        fp2 = fopen(BlankChoices, "r");
        if (fp2 != NULL)
        {
            bool more;
            do
            {
                more = fgets(buffer, sizeof buffer, fp2);
                if (more) fputs(buffer, fp);
            }
            while (more);
            fclose(fp2);
        }
        if (multidevice && selected_controller)
        {
            original_controller = selected_controller;
            fprintf(fp, "X Audio %s\n", original_controller->config_id);
        }
        for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
        {
            for (int i = 0; i < controller->nchannels; i++)
            {
                controller->channels[i].original_gain = controller->channels[i].selected_gain;
                controller->channels[i].original_mute = controller->channels[i].selected_mute;
                fprintf(fp, "MixVolume %s %d %u %c %d\n", controller->config_id, controller->channels[i].category, controller->channels[i].index, controller->channels[i].original_mute + '0', controller->channels[i].original_gain);
            }
        }
        fclose(fp);
    }
    _swix(OS_File, _INR(0,2),
          OSFile_SetType,
          ChoicesWrite,
          FileType_Obey);
}


/*-------------------------------------------------------------------------------*
 * sound_reflect_gadget_state                                                    *
 *                                                                               *
 * Fade muted sliders, change help messages and set volumes etc to match display *
 *                                                                               *
 * In: window_id = toolbox ID of sound configuration window.                     *
 *-------------------------------------------------------------------------------*/

int sound_reflect_gadget_state(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int window_id = id_block->self_id;
    (void)handle;
    (void)event_code;
    (void)event_block;

    int voiceindex = -1;
    error_trap(stringset_get_selected(1, window_id, VoicesStringSet, &voiceindex), 0);
    int voiceslot;
    if (voiceindex != -1 && (voiceslot = menu_to_voice_map[voiceindex]) != -1)
    {
        _swix(Sound_AttachVoice, _INR(0,1), 1, voiceslot);
    }
    int quiet;
    error_trap(radiobutton_get_state(0, window_id, QuietRadio, &quiet, NULL), 0);
    int old_volume;
    _swix(OS_Byte, _INR(0,2)|_OUT(1),
          OsByte_RW_BELLVolume,
          0,
          255,
          &old_volume);
    if (quiet && old_volume != 0xD0)
    {
        _swix(OS_Byte, _INR(0,2),
              OsByte_RW_BELLVolume,
              0xD0,
              0);
    }
    else if (!quiet && old_volume != 0x90)
    {
        _swix(OS_Byte, _INR(0,2),
              OsByte_RW_BELLVolume,
              0x90,
              0);
    }

    if (multidevice)
    {
        int controllerindex = -1;
        error_trap(stringset_get_selected(1, window_id, DeviceStringSet, &controllerindex), 0);
        if ((controllerindex != -1) && (!selected_controller || (selected_controller->index != controllerindex)))
        {
            selected_controller = controllers;
            while (selected_controller && (selected_controller->index != controllerindex))
            {
                selected_controller = selected_controller->next;
            }
            sound_switch_device();
            /* Set up sliders for this new controller */
            setup_sliders();
            return 1;
        }
    }
        
    /* Controller not changed, so make controller state match sliders */
    if (!selected_controller)
    {
        return 1;
    }
    for (int i = 0; i < selected_controller->nchannels; i++)
    {
        int gain;
        int mute;
        unsigned int slider_flags;
        error_trap(slider_get_value(0, window_id, 2 + i * 4, &gain), 0);
        error_trap(optionbutton_get_state(0, window_id, 3 + i * 4, &mute), 0);
        error_trap(gadget_get_flags(0, window_id, 2 + i * 4, &slider_flags), 0);
        if (!selected_controller->channels[i].fixed && (slider_flags & Gadget_Faded) && !mute)
        {
            slider_flags &= ~Gadget_Faded;
            error_trap(gadget_set_flags(0, window_id, 2 + i * 4, slider_flags), 0);
            char token[11] = "HelpS";
            strcat(token, selected_controller->channels[i].token_suffix);
            char *help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
            error_trap(gadget_set_help_message(0, window_id, 2 + i * 4, help_message), 0);
        }
        else if (!(slider_flags & Gadget_Faded) && mute)
        {
            slider_flags |= Gadget_Faded;
            error_trap(gadget_set_flags(0, window_id, 2 + i * 4, slider_flags), 0);
            char token[12] = "HelpSM";
            strcat(token, selected_controller->channels[i].token_suffix);
            char *help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
            error_trap(gadget_set_help_message(0, window_id, 2 + i * 4, help_message), 0);
        }
        if (!selected_controller->channels[i].fixed)
        {
            selected_controller->channels[i].selected_gain = gain;
            selected_controller->channels[i].selected_mute = mute;
        }
    }

    /* Apply settings for all controllers, not just the visible one (required when e.g. restoring defaults) */
    for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
    {
        for (int i = 0; i < controller->nchannels; i++)
        {        
            if (!controller->channels[i].fixed)
            {
                if (vidcmix)
                {
                    error_trap(_swix(Sound_Volume, _IN(0), sound_db_to_volume(controller->channels[0].selected_gain)), 0);
                }
                else
                {
                    error_trap(_swix(SoundCtrl_SetMix, _INR(0,4),
                                     controller->mixer_id,
                                     controller->channels[i].category,
                                     controller->channels[i].index,
                                     controller->channels[i].selected_mute,
                                     controller->channels[i].selected_gain), 0);
                }
            }
        }
    }

    return 1;
}


/*-------------------------------------------------------------------------------*
 * sound_reset_to_configured                                                     *
 *                                                                               *
 * Sets window to reflect the configured settings                                *
 *                                                                               *
 * In: window_id = toolbox ID of sound configuration window.                     *
 *-------------------------------------------------------------------------------*/

void sound_reset_to_configured(int window_id)
{
    sound_read_write_cmos_settings(ReadCMOSSettings, window_id);
    sound_read_choices();

    if (selected_controller)
    {
        if (multidevice)
        {
            error_trap(stringset_set_selected(1, window_id, DeviceStringSet, (char*) selected_controller->index), 0);
            sound_switch_device();
        }

        setup_sliders();
    }

    sound_reflect_gadget_state(0, NULL, &(IdBlock){ .self_id = window_id }, NULL);
}


/*-------------------------------------------------------------------------------*
 * sound_reset_to_defaults                                                       *
 *                                                                               *
 * Sets window to reflect the default settings                                   *
 *                                                                               *
 * In: window_id = toolbox ID of sound configuration window.                     *
 *-------------------------------------------------------------------------------*/

void sound_reset_to_defaults(int window_id)
{
    for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
    {
        for (int i = 0; i < controller->nchannels; i++)
        {
            if (!controller->channels[i].fixed)
            {
                controller->channels[i].selected_gain = 0;
                controller->channels[i].selected_mute = controller->channels[i].muted_by_default;
            }
        }
    }

    setup_sliders();

    error_trap(stringset_set_selected(1, window_id, VoicesStringSet, 0), 0);
    error_trap(radiobutton_set_state(0, window_id, QuietRadio, 1), 0);
    sound_reflect_gadget_state(0, NULL, &(IdBlock){ .self_id = window_id }, NULL);
}


/*-------------------------------------------------------------------------------*
 * sound_restore_original_settings                                               *
 *                                                                               *
 * Sets sound system back how it was before we started, or when the user last    *
 * clicked Set. For use when the user clicks Cancel                              *
 *-------------------------------------------------------------------------------*/

void sound_restore_original_settings(void)
{
    if (vidcmix)
    {
        _swix(Sound_Volume, _IN(0), sound_db_to_volume(original_controller->channels[0].original_gain));
    }
    else
    {
        if (multidevice)
        {
            selected_controller = original_controller;
            sound_switch_device();
        }
        for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
        {
            for (int i = 0; i < controller->nchannels; i++)
            {
                if (!controller->channels[i].fixed)
                {
                    _swix(SoundCtrl_SetMix, _INR(0,4),
                          controller->mixer_id,
                          controller->channels[i].category,
                          controller->channels[i].index,
                          controller->channels[i].original_mute,
                          controller->channels[i].original_gain);
                }
            }
        }
    }
    _swix(Sound_AttachVoice, _INR(0,1),
          1,
          1 + (cmos_sound & 0x0f));
    _swix(OS_Byte, _INR(0,2),
          OsByte_RW_BELLVolume,
          cmos_loud & 2 ? 0x90 : 0xD0,
          0);
}


@


1.4
log
@Move beep on error option into Sound Setup
Part of simplification of the window setup plugin.
Also, to avoid having to maintain two similar plugins, the differences from the former VIDC oriented Sound Setup are integrated
* If SoundControl module is running behave as before
* If no SoundControl but there is a VIDC, adapt to add
  + 16b/8b hardware option
  + oversampling option
  + don't permit muting of the (one and only) mixing channel
  + the mixing channel governs the *VOLUME and corresponding CMOS bits
* Updated common functions from other plugins
* Use definitions from HighFSI, OsBytes, CMOS in place of local ones

Tested on a Risc PC (ie. VIDC style) and Beagleboard xM (ie. mixer style).

Version 2.07. Tagged as 'SndSetup-2_07'
@
text
@d32 1
d50 4
a53 2
struct channel channel[MAX_CHANNELS];
unsigned int nchannels;
d55 2
d71 1
d80 1
d84 8
d156 1
a156 1
 * Read the fixed characteristics of the mixer into channel[].               *
d159 1
a159 1
void sound_read_channel_info(void)
d166 1
a166 1
        static const struct channel vidcchannel = { VIDC_CHANNEL };
d172 3
a174 3
        nchannels = 1;
        channel[0] = vidcchannel;
        strcat(nametoken, channel[0].token_suffix);
d176 1
a176 1
        if ((channel[0].name = malloc(strlen(name) + 1)) != NULL)
d178 1
a178 1
            strcpy(channel[0].name, name);
d183 2
a184 2
        channel[0].original_gain = sound_volume_to_db(volume);
        channel[0].original_mute = FALSE;
d191 1
a191 1
                     0,
d196 9
a204 3
    nchannels = -space_needed / block_size;
    if (nchannels > MAX_CHANNELS) nchannels = MAX_CHANNELS;
    char buffer[nchannels*block_size];
d206 1
a206 1
                     0,
d209 2
a210 2
                     &nchannels), 1);
    for (int i = 0; i < nchannels; i++)
d213 5
a217 5
        channel[i].category = info->category;
        channel[i].index = -1;
        channel[i].muted_by_default = info->flags & 4;
        channel[i].fixed = info->flags & 1;
        channel[i].mono = info->flags & 2;
d220 3
a222 3
            channel[i].mingain = info->mingain;
            channel[i].maxgain = info->maxgain;
            channel[i].step = info->step;
d227 3
a229 3
            channel[i].mingain = (int) (-34.5*16);
            channel[i].maxgain = 0;
            channel[i].step = 24;
d231 2
a232 2
        if (channel[i].step <= 0)
            channel[i].step = 1;
d238 1
a238 1
        if (channel[i].mingain < -40*16)
d241 2
a242 2
            int steps = (40*16+channel[i].step-1)/channel[i].step;
            channel[i].mingain = -steps*channel[i].step;
d245 2
a246 2
        if (channel[i].mingain >= channel[i].maxgain)
            channel[i].mingain = channel[i].maxgain-16;
d248 1
a248 1
    while (nchannels > 0)
d251 3
a253 3
        while (i < nchannels && channel[i].index != -1) i++;
        if (i == nchannels) break;
        int category = channel[i].category;
d255 1
a255 1
        for (int j = i; j < nchannels; j++)
d257 1
a257 1
            if (channel[j].category == category)
d259 1
a259 1
                channel[j].index = index++;
d262 3
a264 3
                                 0,
                                 channel[j].category,
                                 channel[j].index,
d266 2
a267 2
                                 &channel[j].original_gain), 1);
                channel[j].original_mute = mute;
d270 1
a270 1
        for (int j = i; j < nchannels; j++)
d272 1
a272 1
            if (channel[j].category == category)
d274 6
a279 6
                channel[j].token_suffix[0] = category < 0 ? 'O' : 'I';
                channel[j].token_suffix[1] = abs(category) + '0';
                channel[j].token_suffix[2] = channel[j].mono ? 'm' : 's';
                channel[j].token_suffix[3] = channel[j].index + '0';
                channel[j].token_suffix[4] = index + '0';
                channel[j].token_suffix[5] = '\0';
d281 1
a281 1
                strcat(nametoken, channel[j].token_suffix);
d289 1
a289 1
                    sprintf(param, " %d", channel[j].index + 1);
d292 1
a292 1
                if ((channel[j].name = malloc(strlen(name) + 1)) != NULL)
d294 1
a294 1
                    strcpy(channel[j].name, name);
d303 97
d439 47
a574 2
 *                                                                           *
 * In: window_id = toolbox ID of sound configuration window.                 *
d577 1
a577 1
void sound_read_choices(int window_id)
d580 1
a580 1
    char  buffer[256];
d593 2
a594 2
        channel[0].configured_gain = sound_volume_to_db(volume + 15);
        channel[0].configured_mute = FALSE;
d600 1
a600 1
    for (int i = 0; i < nchannels; i++)
d602 5
a606 2
        channel[i].configured_gain = 0;
        channel[i].configured_mute = channel[i].muted_by_default;
d608 2
d620 1
a620 1
                if (sscanf(buffer, "MixVolume 0 %d %u %c %d", &category, &index, &mute, &gain) == 4 && (mute -= '0') <= 1)
d622 2
a623 2
                    /* Apply it to the channel array */
                    for (int i = 0; i < nchannels; i++)
d625 11
a635 1
                        if (channel[i].category == category && index-- == 0)
d637 14
a650 3
                            channel[i].configured_gain = gain;
                            channel[i].configured_mute = mute;
                            break;
d654 12
d671 2
a679 2
 *                                                                           *
 * In: window_id = Toolbox ID of the sound configure window.                 *
d682 1
a682 1
void sound_save_choices(int window_id)
a686 1
    int  mute;
d693 2
a694 2
        error_trap(slider_get_value(0, window_id, 2 + 0 * 4, &channel[0].original_gain), 0);
        volume = sound_db_to_volume(channel[0].original_gain);
d720 6
a725 1
        for (int i = 0; i < nchannels; i++)
d727 6
a732 4
            error_trap(slider_get_value(0, window_id, 2 + i * 4, &channel[i].original_gain), 0);
            error_trap(optionbutton_get_state(0, window_id, 3 + i * 4, &mute), 0);
            channel[i].original_mute = mute;
            fprintf(fp, "MixVolume 0 %d %u %c %d\n", channel[i].category, channel[i].index, mute + '0', channel[i].original_gain);
d758 1
a758 44
    for (int i = 0; i < nchannels; i++)
    {
        int gain;
        int mute;
        unsigned int slider_flags;
        error_trap(slider_get_value(0, window_id, 2 + i * 4, &gain), 0);
        error_trap(optionbutton_get_state(0, window_id, 3 + i * 4, &mute), 0);
        error_trap(gadget_get_flags(0, window_id, 2 + i * 4, &slider_flags), 0);
        if (!channel[i].fixed && (slider_flags & Gadget_Faded) && !mute)
        {
            slider_flags &= ~Gadget_Faded;
            error_trap(gadget_set_flags(0, window_id, 2 + i * 4, slider_flags), 0);
            char token[11] = "HelpS";
            strcat(token, channel[i].token_suffix);
            char *help_message = (char *)messages_lookup_withparam(token, channel[i].name);
            error_trap(gadget_set_help_message(0, window_id, 2 + i * 4, help_message), 0);
        }
        else if (!(slider_flags & Gadget_Faded) && mute)
        {
            slider_flags |= Gadget_Faded;
            error_trap(gadget_set_flags(0, window_id, 2 + i * 4, slider_flags), 0);
            char token[12] = "HelpSM";
            strcat(token, channel[i].token_suffix);
            char *help_message = (char *)messages_lookup_withparam(token, channel[i].name);
            error_trap(gadget_set_help_message(0, window_id, 2 + i * 4, help_message), 0);
        }
        if (!channel[i].fixed)
        {
            if (vidcmix)
            {
                error_trap(_swix(Sound_Volume, _IN(0), sound_db_to_volume(gain)), 0);
            }
            else
            {
                error_trap(_swix(SoundCtrl_SetMix, _INR(0,4),
                                 0,
                                 channel[i].category,
                                 channel[i].index,
                                 mute,
                                 gain), 0);
            }
        }
    }
    int voiceindex;
d787 81
d883 1
a883 1
    sound_read_choices(window_id);
d885 1
a885 2
    /* Set up UI */
    for (int i = 0; i < nchannels; i++)
d887 7
a893 2
        error_trap(slider_set_value(0, window_id, 2 + i * 4, channel[i].configured_gain), 0);
        error_trap(optionbutton_set_state(0, window_id, 3 + i * 4, channel[i].configured_mute), 0);
d895 1
d901 1
a901 1
 * sound_reset_to_configured                                                     *
d910 1
a910 1
    for (int i = 0; i < nchannels; i++)
d912 8
a919 2
        error_trap(slider_set_value(0, window_id, 2 + i * 4, 0), 0);
        error_trap(optionbutton_set_state(0, window_id, 3 + i * 4, channel[i].muted_by_default), 0);
d921 3
d941 1
a941 1
        _swix(Sound_Volume, _IN(0), sound_db_to_volume(channel[0].original_gain));
d944 2
a945 2
    {    
        for (int i = 0; i < nchannels; i++)
d947 17
a963 6
            _swix(SoundCtrl_SetMix, _INR(0,4),
                  0,
                  channel[i].category,
                  channel[i].index,
                  channel[i].original_mute,
                  channel[i].original_gain);
@


1.3
log
@Adjust volume slider min/max values to match range supported by hardware
Detail:
  c/main, c/sound, h/sound - Now uses the additional gain data returned by SoundCtrl_ExamineMixer to alter the volume slider min, max and step values.
  If SoundCtrl_ExamineMixer doesn't return any additional gain data, the sliders will have properties that match those of previous versions of the plugin.
Admin:
  Tested on Iyonix & BB-xM, both with and without the new gain data being available.
  Note that a bug in previous versions of SndSetup will cause it to crash/malfunction if it encounters the new gain data (i.e. SoundCtrl 1.01+ used with a mixer device which implements HAL mixer API 0.1+)


Version 2.04. Tagged as 'SndSetup-2_04'
@
text
@d16 1
a16 1
/* File:    c.sound                                                          */
d27 5
d51 1
d54 1
a54 1
static int   cmos_voice, cmos_volume;
d65 73
d148 27
d297 1
a297 1
    memset(strings, 0, 1024);
d316 1
a316 1
    error_trap(stringset_set_available(0, window_id, VoicesStringset, strings), 0);
a331 1
    static int cmos_voice, cmos_volume;
d334 3
a336 1
    
d340 4
a343 4
        cmos_voice = read_cmos_value(CMOS_Voice);
        cmos_volume = read_cmos_value(CMOS_BellVolume);
        
        voice = 1 + (cmos_voice & 0x0f);
d346 1
a346 1
        error_trap(stringset_set_selected(0, window_id, VoicesStringset, ""), 0);
d351 1
a351 1
                error_trap(stringset_set_selected(1, window_id, VoicesStringset, (char*)n), 0);
d356 11
a366 1
        error_trap(radiobutton_set_state(0, window_id, cmos_volume & 2 ? LoudRadio : QuietRadio, 1), 0);
d370 3
a372 1
        error_trap(stringset_get_selected(1, window_id, VoicesStringset, &n), 0);
d376 3
a378 3
            cmos_voice &= ~0x0f;
            cmos_voice |= voice;
            write_cmos_value(CMOS_Voice, cmos_voice);
d382 21
a402 4
        cmos_volume &= ~2;
        cmos_volume |= 2 * n;
        write_cmos_value(CMOS_BellVolume, cmos_volume);
    }        
d423 13
a435 1
    
d443 1
a443 1
    if (fp)
d448 1
a448 1
            more = fgets(buffer, 256, fp);
a469 6
    /* Set up UI */
    for (int i = 0; i < nchannels; i++)
    {
        error_trap(slider_set_value(0, window_id, 2 + i * 4, channel[i].configured_gain), 0);
        error_trap(optionbutton_set_state(0, window_id, 3 + i * 4, channel[i].configured_mute), 0);
    }
d486 1
d488 17
d506 1
a506 1
    if (fp)
d509 1
a509 1
        if (fp2)
a522 1
            int mute;
d530 1
a530 1
          18,
d532 1
a532 1
          0xFEB);
d546 2
d550 1
a550 2
    int window_id = id_block->self_id;
    (void)handle;
d579 13
a591 6
            error_trap(_swix(SoundCtrl_SetMix, _INR(0,4),
                             0,
                             channel[i].category,
                             channel[i].index,
                             mute,
                             gain), 0);
d595 1
a595 1
    error_trap(stringset_get_selected(1, window_id, VoicesStringset, &voiceindex), 0);
d605 1
a605 1
          OSBYTE_ReadWriteBellVolume,
d612 1
a612 1
              OSBYTE_ReadWriteBellVolume,
d619 1
a619 1
              OSBYTE_ReadWriteBellVolume,
d637 1
d639 7
a645 1
    sound_read_write_cmos_settings(ReadCMOSSettings, window_id);
d665 1
a665 1
    error_trap(stringset_set_selected(1, window_id, VoicesStringset, 0), 0);
d680 1
a680 1
    for (int i = 0; i < nchannels; i++)
d682 13
a694 6
        _swix(SoundCtrl_SetMix, _INR(0,4),
              0,
              channel[i].category,
              channel[i].index,
              channel[i].original_mute,
              channel[i].original_gain);
d698 1
a698 1
          1 + (cmos_voice & 0x0f));
d700 2
a701 2
          OSBYTE_ReadWriteBellVolume,
          cmos_volume & 2 ? 0x90 : 0xD0,
@


1.2
log
@Given a major overhaul to work with the HAL version of the SoundControl
module. Slider list is now dynamically generated to reflect hardware
capabilities. Configuration of beep voice and volume is now consistent with
the rest of !Configure (ie doesn't happen until you click 'Set').

Version 1.00. Tagged as 'SndSetup-1_00'
@
text
@d50 9
d77 1
a77 1
    struct { unsigned short flags; signed short category; } info[nchannels];
d80 2
a81 2
                     info,
                     sizeof info,
d85 2
a86 1
        channel[i].category = info[i].category;
d88 32
a119 3
        channel[i].muted_by_default = info[i].flags & 4;
        channel[i].fixed = info[i].flags & 1;
        channel[i].mono = info[i].flags & 2;
@


1.1
log
@Initial revision
@
text
@d34 13
a46 16
#define SoundCtrl_SetVolume   0x50002
#define SoundCtrl_ChannelInfo 0x50004
#define Flag_LeftMuted     1u<<0
#define Flag_RightMuted    2u<<1

/* SndSetup numbers channels from 0 to NumberOfChannels. The toolbox ID of the slider
   gadget equals this channel number. However, SoundCtrl adopts different numbering, so
   the array channel_no maps between SndSetup and SoundCtrl's numbering. The array
   channel_name contains the name of each channel as specified in the Sound configuration
   file in <Choices$Write>.Sound. */

static char *channel_name[NumberOfChannels] = { "Master",  "System",   "CD",       "Line",
                                                "Mic",     "Capture",  "Playback", "Wavetable" };
static int   channel_no[NumberOfChannels] =   {  0,         11,         2,          1,
                                                 5,         12,         8,         10 };
static int   min_volume[NumberOfChannels];                                                 
d53 1
a53 4
 * Read the min volume, max volume and step for each channel and set the     *
 * sliders accordingly.                                                      *
 *                                                                           *
 * In: window_id = ID of the Sound configure window.                         *
d56 76
a131 19
void sound_read_channel_info(int window_id)
{    
    int n;
    int min_i, max_i, step_i;
    float min_f, max_f, step_f;

    /* Read in min, max & volume settings for the channels */
    for (n=0; n<NumberOfChannels; n++)
    {
        /* Read the min, max and step of the volume for this channel */
        error_trap(_swix(SoundCtrl_ChannelInfo, _INR(0,1)|_OUTR(4,6),
                                                0, channel_no[n], &min_i, &max_i, &step_i), 1);

        /* Convert the values we read back (32bit, 16bit for fraction) into floats */
        min_f  = 10 * ((float)min_i) / (1<<16);
        max_f  = 10 * ((float)max_i) / (1<<16);
        step_f = 10 * ((float)step_i) / (1<<16);
        min_volume[n] = (int)min_f;
        error_trap(numberrange_set_bounds(15, window_id, n, (int)min_f, (int)max_f, (int)step_f, 1), 0);
a132 10
    
    /* Set up the sliders -                             min   max  step */
    //error_trap(numberrange_set_bounds(15, window_id, 0, -465, 0,   15, 1), 0);   /* Master */
    //error_trap(numberrange_set_bounds(15, window_id, 1, -945, 0,   15, 1), 0);   /* I²S 1 = VIDC */
    //error_trap(numberrange_set_bounds(15, window_id, 2, -345, 120, 15, 1), 0);   /* CD */
    //error_trap(numberrange_set_bounds(15, window_id, 3, -345, 120, 15, 1), 0);   /* Line */
    //error_trap(numberrange_set_bounds(15, window_id, 4, -450, 0,   30, 1), 0);   /* Mic */
    //error_trap(numberrange_set_bounds(15, window_id, 5,    0, 225, 15, 1), 0);   /* Playback */
    //error_trap(numberrange_set_bounds(15, window_id, 6, -945, 0,   15, 1), 0);   /* Capture */
    //error_trap(numberrange_set_bounds(15, window_id, 7, -945, 0,   15, 1), 0);   /* I²S 0 = Wavetable */
d137 1
a137 1
 * sound_set_volume                                                          *
d139 1
a139 1
 * Set the volume for a given channel.                                       *
d141 1
a141 5
 * In: channel = channel whose volume we wish to change. This number is our  *
 *               internal number (between 0 and 7), rather than the channel  *
 *               number held by SoundCtrl. The channel_no array maps between *
 *               the two.                                                    *
 *     volume = volume, in db, times 10.                                     *
d144 1
a144 1
void sound_set_volume(int channel, int volume)
d146 7
a152 2
    float db;
    int   flags;
d154 2
a155 3
    /* If volume is minimum value, then mute instead */
    if (volume == min_volume[channel]) flags = Flag_LeftMuted + Flag_RightMuted;
    else flags = 0;
d157 15
a171 5
    /* Convert a volume integer (db*10 eg. -125 means -12.5db) into 32bit with 16bit fraction */
    db = (1<<16) * ((float)volume) / 10;

    /* Set the volume */
    error_trap(_swix(SoundCtrl_SetVolume, _INR(0,4), flags, channel_no[channel], 0, (int)db, (int)db), 0);
d187 3
a189 1
    int voice, n;
d196 15
d214 3
a216 11
        write_cmos_value(CMOS_Voice, cmos_voice);
        write_cmos_value(CMOS_BellVolume, cmos_volume);
    }        

    voice = 1 + (cmos_voice & 0x0f);
        
    /* Try and find the name in the stringset to match the CMOS-set channel */
    error_trap(stringset_set_selected(0, window_id, VoicesStringset, "*** None ***"), 0);
    for (n=0; n<15; n++)
    {
        if (menu_to_voice_map[n] == voice)
d218 3
a220 2
            error_trap(stringset_set_selected(1, window_id, VoicesStringset, (char*)n), 0);
            _swix(Sound_AttachVoice, _INR(0,1), 1, voice);
a221 23
    }

    /* Is beep quiet or loud? */
    error_trap(radiobutton_set_state(0, window_id, cmos_volume & 2 ? LoudRadio : QuietRadio, 1), 0);
    _kernel_osbyte(OSBYTE_ReadWriteBellVolume, cmos_volume & 2 ? 0x80 : 0xd0, 0);
}


/*---------------------------------------------------------------------------*
 * sound_set_unused                                                          *
 *                                                                           *
 * Set 16bit sound and volume settings stored in CMOS. These are no longer   *
 * configurable.                                                             *
 *---------------------------------------------------------------------------*/

void sound_set_cmos_defaults(void)
{
    int byte;

    /* Set 16bit sound (bits 5-6 of CMOS_PrintSound byte) */
    byte = read_cmos_value(CMOS_PrintSound);
    byte = (byte & 0x9f) | (1<<5);
    write_cmos_value(CMOS_PrintSound, byte);
d223 5
a227 15
    /* Sound default CMOS byte, composed of:
       bits 0-3: channel 0 default voice (0)
       bits 4-6: loudness, 0 - 7 (7)
       bit 7:    loudspeaker enable (1) */
    byte = 0 + (7<<4) + (1<<7);
    write_cmos_value(CMOS_SoundDefault, byte);
    
    /* Set bell volume to loud (bit 1) of Miscellaneous flags byte */
    byte = read_cmos_value(CMOS_BellVolume);
    byte = (byte & 0xFD) | 1;
    write_cmos_value(CMOS_BellVolume, byte);

    /* Set voice and loud bell volume */
    _swix(Sound_AttachVoice, _INR(0,1), 1, 1);
    _kernel_osbyte(OSBYTE_ReadWriteBellVolume, 0x80, 0);
a241 2
    char *item;
    char *value;
d243 5
a247 1
    int   n, colon, more=1;
d249 7
a255 1
    fp = fopen(ChoicesFile, "r");
d261 1
a261 1
            more = (int)fgets(buffer, 256, fp);
d264 2
a265 3
                /* Check for a colon in this line */                
                colon = strstr(buffer, ":") - buffer;
                if (colon>0)
d267 2
a268 8
                    /* Break the string into item eg. ("Master") and value (eg. "-45") */
                    buffer[colon] = 0;
                    item = buffer;
                    value = item + colon + 1;
                    value[strlen(value)-1] = 0;
                    
                    /* Is this item one of the names of channels? */
                    for (n=0; n<NumberOfChannels; n++)
d270 1
a270 1
                        if (strcmp(channel_name[n], item)==0)
d272 3
a274 5
                            /* The item corresponds to channel n in our array */
                            int v = (int) (atof(value)*10);
                            /* Update slider and set volume */
                            error_trap(numberrange_set_value(0, window_id, n, v), 0);
                            sound_set_volume(n, v);
a278 1
            
d283 6
d303 4
a306 10
    int   type, n, v;
    char  dbstring[16];
    char  string[32];

    /* Ensure choices directory exists */
    _swix(OS_File, _INR(0,1)|_OUT(0), 17, ChoicesDir, &type);
    if (type==0) error_trap(_swix(OS_CLI, _IN(0), "CDir "ChoicesDir), 0);

    /* Write the file */
    fp = fopen(ChoicesFile, "w");
d309 13
a321 9
        /* Write the comment lines */
        fputs(SoundConfigurationString, fp);
        fputc(NewLine, fp);
        fputc(NewLine, fp);
        fputs(VolumeLevelsString, fp);
        fputc(NewLine, fp);
        
        /* Loop through all the channels and make a string for their volumes */
        for (n=0; n<NumberOfChannels; n++)
d323 5
a327 6
            error_trap(numberrange_get_value(0, window_id, n, &v), 0);
            sprintf(dbstring, "%f", (float)((float)v / 10));
            *(strstr(dbstring, ".")+2) = 0;
            sprintf(string, "%s:%s", channel_name[n], dbstring);
            fputs(string, fp);
            fputc(NewLine, fp);
a328 1
      
d331 4
d338 90
a427 7
/*---------------------------------------------------------------------------*
 * sound_make_voices_menu                                                    *
 *                                                                           *
 * Make a menu of voice modules available.                                   *
 *                                                                           *
 * In: window_id - Toolbox ID of the configuration window                    *
 *---------------------------------------------------------------------------*/
d429 1
a429 1
void sound_make_voices_menu(int window_id)
d431 5
a435 7
    char  strings[1024];
    char* name;
    char* first = 0;
    char* name_local;
    int   i, m;
    
    memset(strings, 0, 1024);
d437 7
a443 2
    /* menu_to_voice_map maps from menu item number to internal voice number */
    for (m=15; m>=0; m--) menu_to_voice_map[m] = -1;
d445 3
a447 3
    /* Only read first 16 voices, as 16 is maximum value which can be stored in 4 CMOS bits */
    m=0;
    for (i=1; i<=16; i++)
d449 2
a450 8
        _swix(Sound_InstallVoice, _INR(0,1)|_OUTR(2,3), 2, i, &name, &name_local);
        if (name!=0)
        {
            if (strlen(strings) > 0) strcat(strings, ",");
            if (strlen(strings) == 0) first = name_local;
            strcat(strings, name_local);
            menu_to_voice_map[m++] = i;
        }
d452 3
a454 3
    
    error_trap(stringset_set_available(0, window_id, VoicesStringset, strings), 0);
    error_trap(stringset_set_selected(0, window_id, VoicesStringset, first), 0);
d458 6
a463 7
/*---------------------------------------------------------------------------*
 * sound_change_voice                                                        *
 *                                                                           *
 * Change the system beep (channel 1) voice                                  *
 *                                                                           *
 * In: n = selection number from voices menu                                 *
 *---------------------------------------------------------------------------*/
d465 1
a465 1
void sound_change_voice(int n)
d467 1
a467 4
    int byte;
    int voice = menu_to_voice_map[n];
    
    if ((voice>=1) && (voice<=16))
d469 6
a474 3
        byte = read_cmos_value(CMOS_Voice);
        write_cmos_value(CMOS_Voice, (byte & 0xf0) | (voice-1));
        _swix(Sound_AttachVoice, _INR(0,1), 1, voice);
d476 7
a482 3
    
    /* Beep */
    printf("\07");
d484 1
a484 1
    
@


1.1.1.1
log
@Initial import of SndSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Added SetVolumes application and a Try button.
@
text
@d367 1
a367 1
    //printf("\07");
@


1.1.1.3
log
@!Run file change.
@
text
@d36 2
a37 2
#define Flag_LeftMuted     1
#define Flag_RightMuted    2
d48 1
a48 1
                                                 5,         12,         8,          3 };
d113 2
a114 8
    if (volume == min_volume[channel])
    {
        flags = Flag_LeftMuted + Flag_RightMuted;
    }
    else
    {
        flags = 0;
    }
@

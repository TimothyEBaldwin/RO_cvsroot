head	1.6;
access;
symbols
	SndSetup-2_08:1.6
	SndSetup-2_07:1.5
	SndSetup-2_06:1.4
	SndSetup-2_05:1.4
	SndSetup-2_04:1.3
	SndSetup-2_03:1.2
	SndSetup-2_02:1.2
	SndSetup-2_01:1.2
	SndSetup-2_00:1.2
	SndSetup-1_00:1.2
	SndSetup-0_06:1.1.1.2
	SndSetup-0_05:1.1.1.2
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.2
	Ursula_RiscPC:1.1.1.2.0.2
	rleggett_SndSetup-0_04b:1.1.1.2
	rthornb_UrsulaBuild-19Aug1998:1.1.1.2
	UrsulaBuild_FinalSoftload:1.1.1.2
	rthornb_UrsulaBuild-29Jul1998:1.1.1.2
	rthornb_UrsulaBuild-22Jul1998:1.1.1.2
	rthornb_UrsulaBuild-15Jul1998:1.1.1.2
	rthornb_UrsulaBuild-07Jul1998:1.1.1.2
	rthornb_UrsulaBuild-17Jun1998:1.1.1.2
	rleggett_SndSetup-0_03:1.1.1.2
	rthornb_UrsulaBuild-03Jun1998:1.1.1.2
	rthornb_UrsulaBuild-27May1998:1.1.1.2
	rthornb_UrsulaBuild-21May1998:1.1.1.1
	rthornb_UrsulaBuild_01May1998:1.1.1.1
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2016.06.08.22.00.53;	author jlee;	state Exp;
branches;
next	1.5;
commitid	OjqsgzPB8RRw9I9z;

1.5
date	2013.07.20.14.39.42;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	siN8EGpUAUgHAdYw;

1.4
date	2012.06.26.23.43.14;	author jlee;	state Exp;
branches;
next	1.3;
commitid	GlNgmA7gjKho6haw;

1.3
date	2012.01.21.19.31.17;	author jlee;	state Exp;
branches;
next	1.2;
commitid	S2B7wm85L3fSK4Qv;

1.2
date	2003.02.28.16.15.27;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.41.55;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.41.55;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.05.26.17.03.56;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Allow configuration of default audio controller device
Detail:
  If SndSetup detects that a version of SoundDMA is in use which supports controller enumeration & selection, the plugin display will have an extra string set gadget which can be used to select which device should be used
  When switching between devices the list of mixer controllers will update accordingly
  The controller selection will be saved to the SndSetup choices file, along with the mixer settings - with mixer settings being saved for all mxiers that are present, not just the selected one.
  File changes:
  - Resources/UK/Res,fae, h/defines - Updated to add the new string set and tweak the layout a bit
  - h/sound, c/sound - Added linked list of controller devices. Mixer channel detail arrays are now allocated on demand and stored as part of the controller details. Channel details now also tracks the currently selected mute & gain settings, since we can no longer rely on the UI to store those values for us if we're recreating gadgets when switching device.
  - c/main - Mixer volume slider setup separated out into its own function, so it can be repeated whenever we switch device.
  - h/common - Forward-declare of new function
Admin:
  Tested on Raspberry Pi, iMx6, Iyonix, RiscPC
  Requires Sound0HAL-1_84 / Sound0Trid-1_69 / Sound0-1_72


Version 2.08. Tagged as 'SndSetup-2_08'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    main.c                                                           */
/* Purpose: Main WIMP shell for Sound configuration                          */
/* Author:  Richard Leggett                                                  */
/* History: 29-Jan-98: RML: Begun.                                           */
/*          20-Mar-98: RML: Minor modifications.                             */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "toolbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "wimplib.h"
#include "defines.h"
#include "sound.h"

static MessagesFD messages_desc;
static IdBlock    idb;
static char       messages_string[255];
static ObjectId   config_window_id;
static unsigned int stretch_width;
static int        adjustment = 0;


/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * try_system_beep                                                           *
 *                                                                           *
 * Go 'toot'.                                                                *
 *---------------------------------------------------------------------------*/

static void try_system_beep(void)
{
    printf("\07");
}


/*-----------------------------------------------------------------------------------------------*/
/*                                          Event handlers                                       */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case SetButton:
            sound_read_write_cmos_settings(WriteCMOSSettings, config_window_id);
            sound_save_choices();
            if ((block->hdr.flags & 1) == 0) program_exit();            /* Return or left button pressed */
            sound_reset_to_configured(config_window_id);
            break;
            
        case CancelButton:
            if ((block->hdr.flags & 1) == 0)                            /* Escape or left button pressed */
            {
                sound_restore_original_settings();
                program_exit();
            }
            sound_reset_to_configured(config_window_id);
            break;
            
        case DefaultButton:
            sound_reset_to_defaults(config_window_id);
            break;
            
        case TryButton:
            try_system_beep();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/
 
static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, config_window_id, 0, 0, 0, 0), 0);

    return 1;
}


/*----------------------------------------------------------------------------------------------*/
/*                               Program startup & polling loop                                 */
/*----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * setup_sliders                                                             *
 *                                                                           *
 * Recreate sliders so that their state matches selected_controller          *
 *---------------------------------------------------------------------------*/

void setup_sliders(void)
{
    /* Delete current sliders */
    for (int i = 0; i < maxchannels*4; i++)
    {
        window_remove_gadget(0, config_window_id, i);
    }

    if (!selected_controller)
    {
        return;
    }

    ObjectTemplateHeader *object_template;
    error_trap(toolbox_template_lookup(0, "Window", (void **)&object_template), 0);
    
    const char *gadget_template[4];
    size_t gadget_template_size[4];
    error_trap(window_extract_gadget_info(0, object_template, TemplateLabel,  (void **)&gadget_template[0], (int *)&gadget_template_size[0]), 0);
    error_trap(window_extract_gadget_info(0, object_template, TemplateButton, (void **)&gadget_template[1], (int *)&gadget_template_size[1]), 0);
    error_trap(window_extract_gadget_info(0, object_template, TemplateSlider, (void **)&gadget_template[2], (int *)&gadget_template_size[2]), 0);
    error_trap(window_extract_gadget_info(0, object_template, TemplateOption, (void **)&gadget_template[3], (int *)&gadget_template_size[3]), 0);

    /* Work out memory footprint of largest gadget which we need to dynamically create */
    size_t max_template_size = (gadget_template_size[0] > gadget_template_size[1]) ? gadget_template_size[0] : gadget_template_size[1];
    if (gadget_template_size[2] > max_template_size) max_template_size = gadget_template_size[2];
    if (gadget_template_size[3] > max_template_size) max_template_size = gadget_template_size[3];
    char gadget[max_template_size];

    int my_adjustment = maxchannels * SLIDER_HEIGHT;

    if (!vidcmix)
    {
        /* Adjust for the 2 gadget height equivalent of OversamplingOption & SixteenBitOption */
        my_adjustment -= 2 * SLIDER_HEIGHT;
    }

    /* 1) Name field */
    memcpy(gadget, gadget_template[0], gadget_template_size[0]);
    ((Gadget *)gadget)->hdr.box.ymax += my_adjustment;
    ((Gadget *)gadget)->hdr.box.ymin += my_adjustment;
    for (int i = 0; i < selected_controller->nchannels; i++)
    {
        char token[11] = "Name";
        strcat(token, selected_controller->channels[i].token_suffix);
        char param[4];
        if (selected_controller->channels[i].token_suffix[4] == '1')
        {
            param[0] = '\0';
        }
        else
        {
            sprintf(param, " %d", selected_controller->channels[i].index + 1);
        }
        const char *name = messages_lookup_withparam(token, param);
        char label[strlen(name) + 1];
        strcpy(label, name);
        ((Gadget *)gadget)->hdr.box.xmin -= stretch_width;
        ((Gadget *)gadget)->hdr.box.ymax -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.box.ymin -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.component_id = i * 4;
        sprintf(token, "HelpL%s", selected_controller->channels[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
        ((Gadget *)gadget)->data.label.label = label;
        error_trap(window_add_gadget(0, config_window_id, (Gadget *)gadget, NULL), 0);
    }
    
    /* 2) Mono/stereo tote */
    memcpy(gadget, gadget_template[1], gadget_template_size[1]);
    ((Gadget *)gadget)->hdr.box.ymax += my_adjustment;
    ((Gadget *)gadget)->hdr.box.ymin += my_adjustment;
    for (int i = 0; i < selected_controller->nchannels; i++)
    {
        ((Gadget *)gadget)->hdr.box.ymax -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.box.ymin -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.component_id = 1 + i * 4;
        char token[11] = "HelpB";
        strcat(token, selected_controller->channels[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
        ((Gadget *)gadget)->data.button.validation = selected_controller->channels[i].mono ? "R2;Smono" : "R2;Sstereo";
        error_trap(window_add_gadget(0, config_window_id, (Gadget *)gadget, NULL), 0);
    }
    
    /* 3) Slider */
    memcpy(gadget, gadget_template[2], gadget_template_size[2]);
    ((Gadget *)gadget)->hdr.box.ymax += my_adjustment;
    ((Gadget *)gadget)->hdr.box.ymin += my_adjustment;
    for (int i = 0; i < selected_controller->nchannels; i++)
    {
        ((Gadget *)gadget)->hdr.box.ymax -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.box.ymin -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.component_id = 2 + i * 4;
        char token[12] = "HelpS";
        if (selected_controller->channels[i].fixed) strcpy(token, "HelpSF");
        strcat(token, selected_controller->channels[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
        ((Gadget *)gadget)->hdr.flags &= ~(Gadget_Faded | Slider_BarColour);
        ((Gadget *)gadget)->hdr.flags |= (selected_controller->channels[i].category >= 0 ? 10 : 11) << Slider_BarColourShift;
        if (selected_controller->channels[i].fixed) ((Gadget *)gadget)->hdr.flags |= Gadget_Faded;
        error_trap(window_add_gadget(0, config_window_id, (Gadget *)gadget, NULL), 0);
        error_trap(slider_set_bounds(7, config_window_id, 2+i*4, selected_controller->channels[i].mingain, selected_controller->channels[i].maxgain, selected_controller->channels[i].step), 0);
        error_trap(slider_set_value(0, config_window_id, 2 + i * 4, selected_controller->channels[i].selected_gain), 0);
    }
    
    /* 4) Mute option */
    memcpy(gadget, gadget_template[3], gadget_template_size[3]);
    ((Gadget *)gadget)->hdr.box.ymax += my_adjustment;
    ((Gadget *)gadget)->hdr.box.ymin += my_adjustment;
    for (int i = 0; i < selected_controller->nchannels; i++)
    {
        ((Gadget *)gadget)->hdr.box.ymax -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.box.ymin -= SLIDER_HEIGHT;
        ((Gadget *)gadget)->hdr.component_id = 3 + i * 4;
        char token[12] = "HelpO";
        if (selected_controller->channels[i].fixed) strcpy(token, "HelpOF");
        strcat(token, selected_controller->channels[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, selected_controller->channels[i].name);
        ((Gadget *)gadget)->hdr.flags &= ~Gadget_Faded;
        if (vidcmix) ((Gadget *)gadget)->hdr.flags |= Gadget_Faded; /* Unmutable */
        if (selected_controller->channels[i].fixed) ((Gadget *)gadget)->hdr.flags |= Gadget_Faded;
        error_trap(window_add_gadget(0, config_window_id, (Gadget *)gadget, NULL), 0);
        error_trap(optionbutton_set_state(0, config_window_id, 3 + i * 4, selected_controller->channels[i].selected_mute), 0);
    }
}

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    BBox bbox;
    int  screenx;
    int  screeny;
    WindowShowObjectBlock buffer;
    const ComponentId stretch_gadgets[] = { BeepGroup, VoicesStringSet };
    const ComponentId move_gadgets[] = { DefaultButton, VoicesLabel, QuietRadio, LoudRadio, BeepingErrorsOption };

    /* Create window */
    error_trap(toolbox_create_object(0, "Window", &config_window_id), 1);

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(config_window_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, OptionButton_StateChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, RadioButton_StateChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, Slider_ValueChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, StringSet_ValueChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);
    
    error_trap(gadget_get_bbox(0, config_window_id, TemplateLabel, &bbox), 0);
    stretch_width = bbox.xmax - bbox.xmin;

    /* Do dynamic gadget creation and resizing */
    error_trap(window_remove_gadget(0, config_window_id, TemplateLabel), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateButton), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateSlider), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateOption), 0);

    if (!vidcmix)
    {
        /* Adjust for the 2 gadget height equivalent of OversamplingOption & SixteenBitOption */
        adjustment = 2 * SLIDER_HEIGHT;

        /* And get rid of them */
        error_trap(window_remove_gadget(0, config_window_id, OversamplingOption), 0);
        error_trap(window_remove_gadget(0, config_window_id, SixteenBitOption), 0);
    }

    if (!multidevice)
    {
        /* Adjust for the height equivalent of DeviceStringSet */
        adjustment += STRINGSET_HEIGHT;

        /* And get rid of them */
        error_trap(window_remove_gadget(0, config_window_id, DeviceLabel), 0);
        error_trap(window_remove_gadget(0, config_window_id, DeviceStringSet), 0);
    }

    /* Calculate width of widest name */
    unsigned int widest_label = 0;
    for (controller_list_entry_t *controller = controllers; controller; controller = controller->next)
    {
        for (int i = 0; i < controller->nchannels; i++)
        {
            char token[11] = "Name";
            strcat(token, controller->channels[i].token_suffix);
            char param[4];
            if (controller->channels[i].token_suffix[4] == '1')
            {
                param[0] = '\0';
            }
            else
            {
                sprintf(param, " %d", controller->channels[i].index + 1);
            }
            const char *name = messages_lookup_withparam(token, param);
            char label[strlen(name) + 1];
            strcpy(label, name);
            unsigned int this_width = 0;
            _swix(Wimp_TextOp, _INR(0,2)|_OUT(0),
                 1,
                 label,
                 0,
                 &this_width);
            if (this_width > widest_label) widest_label = this_width;
        }
    }

    stretch_width = widest_label + /* fudge factor */ 16 - stretch_width;
    adjustment -= (maxchannels - 1) * SLIDER_HEIGHT;
    error_trap(window_get_extent(0, config_window_id, &bbox), 0);
    bbox.xmin -= stretch_width;
    bbox.ymax -= adjustment;
    error_trap(window_set_extent(0, config_window_id, &bbox), 0);

    error_trap(gadget_get_bbox(0, config_window_id, HardwareBox, &bbox), 0);
    bbox.xmin -= stretch_width;
    bbox.ymax -= adjustment;
    error_trap(gadget_move_gadget(0, config_window_id, HardwareBox, &bbox), 0);
    
    for (int i = 0; i < (sizeof stretch_gadgets / sizeof *stretch_gadgets); i++)
    {
        error_trap(gadget_get_bbox(0, config_window_id, stretch_gadgets[i], &bbox), 0);
        bbox.xmin -= stretch_width;
        error_trap(gadget_move_gadget(0, config_window_id, stretch_gadgets[i], &bbox), 0);
    }
    for (int i = 0; i < (sizeof move_gadgets / sizeof *move_gadgets); i++)
    {
        error_trap(gadget_get_bbox(0, config_window_id, move_gadgets[i], &bbox), 0);
        bbox.xmin -= stretch_width;
        bbox.xmax -= stretch_width;
        error_trap(gadget_move_gadget(0, config_window_id, move_gadgets[i], &bbox), 0);
    }
    if (multidevice)
    {
        error_trap(gadget_get_bbox(0, config_window_id, DeviceLabel, &bbox), 0);
        bbox.xmin -= stretch_width;
        bbox.xmax -= stretch_width;
        bbox.ymin -= adjustment;
        bbox.ymax -= adjustment;
        error_trap(gadget_move_gadget(0, config_window_id, DeviceLabel, &bbox), 0);

        error_trap(gadget_get_bbox(0, config_window_id, DeviceStringSet, &bbox), 0);
        bbox.xmin -= stretch_width;
        bbox.ymin -= adjustment;
        bbox.ymax -= adjustment;
        error_trap(gadget_move_gadget(0, config_window_id, DeviceStringSet, &bbox), 0);
    }

    error_trap(window_get_extent(0, config_window_id, &bbox), 0);

    /* Work out positioning (unless it was supplied in the command line) */
    if ((at_x==-1) && (at_y==-1))
    {
        error_trap(common_read_screensize(&screenx, &screeny), 0);
        at_y = (screeny + bbox.ymax - bbox.ymin) / 2;
        at_x = (screenx - bbox.xmax + bbox.xmin) / 2;
    }

    /* Show the window */
    buffer.visible_area.xmin = at_x;
    buffer.visible_area.ymax = at_y;
    buffer.visible_area.xmax = at_x + bbox.xmax - bbox.xmin;
    buffer.visible_area.ymin = at_y - bbox.ymax + bbox.ymin;
    buffer.xscroll = 0;
    buffer.yscroll = 0;
    buffer.behind = -1;
    error_trap(toolbox_show_object(0, config_window_id, 1, &buffer, 0, 0), 0);
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * In: Nothing.                                                              *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                RadioButton_StateChanged,
                                Slider_ValueChanged,
                                StringSet_ValueChanged,
                                0};
    int        task_handle;
                                
    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<SndSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, 0) ,1);
    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);    
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);

    return 1;
}
                                  

/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat")==0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;
    sound_detect_mix_mode();
    sound_enumerate_devices();
    open_configure_window(openat_x, openat_y);
    sound_make_voices_menu(config_window_id);
    sound_make_devices_menu(config_window_id);
    sound_reset_to_configured(config_window_id);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }
    
    return 0;
}         

@


1.5
log
@Move beep on error option into Sound Setup
Part of simplification of the window setup plugin.
Also, to avoid having to maintain two similar plugins, the differences from the former VIDC oriented Sound Setup are integrated
* If SoundControl module is running behave as before
* If no SoundControl but there is a VIDC, adapt to add
  + 16b/8b hardware option
  + oversampling option
  + don't permit muting of the (one and only) mixing channel
  + the mixing channel governs the *VOLUME and corresponding CMOS bits
* Updated common functions from other plugins
* Use definitions from HighFSI, OsBytes, CMOS in place of local ones

Tested on a Risc PC (ie. VIDC style) and Beagleboard xM (ie. mixer style).

Version 2.07. Tagged as 'SndSetup-2_07'
@
text
@d41 2
d123 1
a123 1
            sound_save_choices(config_window_id);
d184 1
a184 1
 * open_configure_window                                                     *
d186 1
a186 1
 * Called to open the configure window on screen and register handlers.      *
d189 1
a189 1
static void open_configure_window(int at_x, int at_y)
d191 5
a195 7
    BBox bbox;
    int  adjustment = 0;
    int  screenx;
    int  screeny;
    WindowShowObjectBlock buffer;
    const ComponentId stretch_gadgets[] = { BeepGroup, VoicesStringSet };
    const ComponentId move_gadgets[] = { DefaultButton, VoicesLabel, QuietRadio, LoudRadio, BeepingErrorsOption };
d197 4
a200 2
    /* Create window */
    error_trap(toolbox_create_object(0, "Window", &config_window_id), 1);
a201 13
    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(config_window_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, OptionButton_StateChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, RadioButton_StateChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, Slider_ValueChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, StringSet_ValueChanged, sound_reflect_gadget_state, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);
    
    /* Do dynamic gadget creation and resizing */
    error_trap(window_remove_gadget(0, config_window_id, TemplateLabel), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateButton), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateSlider), 0);
    error_trap(window_remove_gadget(0, config_window_id, TemplateOption), 0);
d204 1
d211 2
d217 3
d223 1
a223 10
        for (int i = 0; i < 4; i++)
        {
            ((Gadget *)gadget_template[i])->hdr.box.ymax -= 2 * SLIDER_HEIGHT;
            ((Gadget *)gadget_template[i])->hdr.box.ymin -= 2 * SLIDER_HEIGHT;
        }
        adjustment = 2;
        
        /* And get rid of them */
        error_trap(window_remove_gadget(0, config_window_id, OversamplingOption), 0);
        error_trap(window_remove_gadget(0, config_window_id, SixteenBitOption), 0);
d228 3
a230 4
    ((Gadget *)gadget)->hdr.box.ymax += nchannels * SLIDER_HEIGHT;
    ((Gadget *)gadget)->hdr.box.ymin += nchannels * SLIDER_HEIGHT;
    unsigned int widest_label = 0;
    for (int i = 0; i < nchannels; i++)
d233 1
a233 1
        strcat(token, channel[i].token_suffix);
d235 1
a235 1
        if (channel[i].token_suffix[4] == '1')
d241 1
a241 1
            sprintf(param, " %d", channel[i].index + 1);
d246 1
a246 7
        unsigned int this_width = 0;
        _swix(Wimp_TextOp, _INR(0,2)|_OUT(0),
             1,
             label,
             0,
             &this_width);
        if (this_width > widest_label) widest_label = this_width;
d250 2
a251 2
        sprintf(token, "HelpL%s", channel[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, channel[i].name);
d258 3
a260 3
    ((Gadget *)gadget)->hdr.box.ymax += nchannels * SLIDER_HEIGHT;
    ((Gadget *)gadget)->hdr.box.ymin += nchannels * SLIDER_HEIGHT;
    for (int i = 0; i < nchannels; i++)
d266 3
a268 3
        strcat(token, channel[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, channel[i].name);
        ((Gadget *)gadget)->data.button.validation = channel[i].mono ? "R2;Smono" : "R2;Sstereo";
d274 3
a276 3
    ((Gadget *)gadget)->hdr.box.ymax += nchannels * SLIDER_HEIGHT;
    ((Gadget *)gadget)->hdr.box.ymin += nchannels * SLIDER_HEIGHT;
    for (int i = 0; i < nchannels; i++)
d282 3
a284 3
        if (channel[i].fixed) strcpy(token, "HelpSF");
        strcat(token, channel[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, channel[i].name);
d286 2
a287 2
        ((Gadget *)gadget)->hdr.flags |= (channel[i].category >= 0 ? 10 : 11) << Slider_BarColourShift;
        if (channel[i].fixed) ((Gadget *)gadget)->hdr.flags |= Gadget_Faded;
d289 2
a290 1
        error_trap(slider_set_bounds(7, config_window_id, 2+i*4, channel[i].mingain, channel[i].maxgain, channel[i].step), 0);
d295 3
a297 3
    ((Gadget *)gadget)->hdr.box.ymax += nchannels * SLIDER_HEIGHT;
    ((Gadget *)gadget)->hdr.box.ymin += nchannels * SLIDER_HEIGHT;
    for (int i = 0; i < nchannels; i++)
d303 3
a305 3
        if (channel[i].fixed) strcpy(token, "HelpOF");
        strcat(token, channel[i].token_suffix);
        ((Gadget *)gadget)->hdr.help_message = (char *)messages_lookup_withparam(token, channel[i].name);
d308 1
a308 1
        if (channel[i].fixed) ((Gadget *)gadget)->hdr.flags |= Gadget_Faded;
d310 87
a398 1
    unsigned int stretch_width = ((Gadget *)gadget_template[0])->hdr.box.xmax - ((Gadget *)gadget_template[0])->hdr.box.xmin;
d400 1
d403 1
a403 1
    bbox.ymax += (nchannels - 1 - adjustment) * SLIDER_HEIGHT;
d405 5
a410 7
    for (ComponentId g = 0; g < 4 * nchannels; g+= 4)
    {
        BBox bbox;
        error_trap(gadget_get_bbox(0, config_window_id, g, &bbox), 0);
        bbox.xmin -= stretch_width;
        error_trap(gadget_move_gadget(0, config_window_id, g, &bbox), 0);
    }
a412 1
        BBox bbox;
a418 1
        BBox bbox;
d424 17
a445 1
        error_trap(window_get_extent(0, config_window_id, &bbox), 0);
d524 1
a524 1
    sound_read_channel_info();
d527 1
@


1.4
log
@Fix null pointer dereference on startup. Pass command line options through to VIDC plugin.
Detail:
  c/main - Command line parsing now checks if enough arguments exist before attempting to look for an -openat option
  Resources/UK/!Run,feb - Now passes any command line options through to the VIDC-era plugin if we decide to launch that instead of ourselves
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 2.05. Tagged as 'SndSetup-2_05'
@
text
@d16 1
a16 1
/* File:    c.main                                                           */
d40 1
a40 1
static int        config_window_id;
d58 1
a58 1
 * Restore original choices.                                                 *
d120 1
a121 1
            sound_read_write_cmos_settings(WriteCMOSSettings, config_window_id);
d190 1
d194 2
a195 2
    const ComponentId stretch_gadgets[] = { BeepGroup, VoicesStringset };
    const ComponentId move_gadgets[] = { DefaultButton, VoicesLabel, QuietRadio, LoudRadio };
d225 16
a240 1
    
d277 1
d293 1
d313 1
d327 1
d331 1
a331 1
    
d336 1
a336 1
    bbox.ymax += (nchannels - 1) * SLIDER_HEIGHT;
d361 1
a361 1
    
d444 1
@


1.3
log
@Adjust volume slider min/max values to match range supported by hardware
Detail:
  c/main, c/sound, h/sound - Now uses the additional gain data returned by SoundCtrl_ExamineMixer to alter the volume slider min, max and step values.
  If SoundCtrl_ExamineMixer doesn't return any additional gain data, the sliders will have properties that match those of previous versions of the plugin.
Admin:
  Tested on Iyonix & BB-xM, both with and without the new gain data being available.
  Note that a bug in previous versions of SndSetup will cause it to crash/malfunction if it encounters the new gain data (i.e. SoundCtrl 1.01+ used with a mixer device which implements HAL mixer API 0.1+)


Version 2.04. Tagged as 'SndSetup-2_04'
@
text
@d416 1
a416 1
    if (strcmp(argv[1], "-openat")==0)
@


1.2
log
@Given a major overhaul to work with the HAL version of the SoundControl
module. Slider list is now dynamically generated to reflect hardware
capabilities. Configuration of beep voice and volume is now consistent with
the rest of !Configure (ie doesn't happen until you click 'Set').

Version 1.00. Tagged as 'SndSetup-1_00'
@
text
@d292 1
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
 * set_default_choices                                                       *
d58 1
a58 1
 * Fill in the default choices in the dialogue box.                          *
d61 1
a61 1
static void set_default_choices(void)
d63 1
a63 13
    int n;
    
    /* Default volume level is 0 for each channel */
    for (n=0; n<NumberOfChannels; n++)
    {
        error_trap(numberrange_set_value(0, config_window_id, n, 0), 0);
        sound_set_volume(n, 0);
    }

    sound_set_cmos_defaults();

    error_trap(stringset_set_selected(1, config_window_id, VoicesStringset, (char*)0), 0);
    error_trap(radiobutton_set_state(0, config_window_id, LoudRadio, 1), 0);
a66 13
/*---------------------------------------------------------------------------*
 * restore_choices                                                           *
 *                                                                           *
 * Restore original choices.                                                 *
 *---------------------------------------------------------------------------*/

static void restore_choices(void)
{
    sound_read_choices(config_window_id);
    sound_read_write_cmos_settings(WriteCMOSSettings, config_window_id);
}    


a106 67
 * radio_changed                                                             *
 *                                                                           *
 * The quiet/loud radio button has changed state.                            *
 *---------------------------------------------------------------------------*/

static int radio_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int state;
    int selected;
    int byte;

    byte = read_cmos_value(CMOS_BellVolume);
    error_trap(radiobutton_get_state(0, config_window_id, QuietRadio, &state, &selected), 0);

    switch(selected)
    {
        case QuietRadio:
            if (byte & 2) byte = byte^2;
            break;
        case LoudRadio:
            if (!(byte & 2)) byte = byte^2;
            break;
    }

    /* Beep */
    write_cmos_value(CMOS_BellVolume, byte);
    _kernel_osbyte(OSBYTE_ReadWriteBellVolume, selected == LoudRadio ? 0x80 : 0xd0, 0);
    printf("\07");

    return 1;
}


/*---------------------------------------------------------------------------*
 * voice_changed                                                             *
 *---------------------------------------------------------------------------*/

static int voice_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int index;
    
    error_trap(stringset_get_selected(1, config_window_id, VoicesStringset, &index), 0);
    sound_change_voice(index);
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * slider_value_changed                                                      *
 *                                                                           *
 * The user has dragged a slider and changed it's value.                     *
 *---------------------------------------------------------------------------*/

static int slider_value_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    NumberRangeValueChangedEvent *event = (NumberRangeValueChangedEvent*)event_block;
    int                           value = event->new_value;
    int                           icon = id_block->self_component;
    
    sound_set_volume(icon, value);
    
    return 1;
}


/*---------------------------------------------------------------------------*
d121 3
a123 2
            if ((block->hdr.flags & 7)==0) program_exit();              /* Return pressed */
            if (block->hdr.flags & 4) program_exit();                   /* Left button */
d125 1
a125 1

d127 6
a132 3
            restore_choices();
            if ((block->hdr.flags & 7)==0) program_exit();              /* Escape pressed */
            if (block->hdr.flags & 4) program_exit();                   /* Left button */
d136 5
a140 1
            set_default_choices();
a176 14
/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();
    
    return 1;
}


d192 3
a194 1
    int  buffer[2];
d201 4
a204 4
    error_trap(event_register_toolbox_handler(config_window_id, NumberRange_ValueChanged, slider_value_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, RadioButton_StateChanged, radio_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_window_id, StringSet_ValueChanged, voice_changed, NULL), 0);
    error_trap(event_register_wimp_handler(config_window_id, Wimp_ECloseWindow, close_window, NULL), 0);
d206 135
a340 1

d346 2
a347 2
        at_y = screeny - ((screeny+bbox.ymin)/2);
        at_x = (screenx - bbox.xmax)/2;
d351 8
a358 3
    buffer[0] = at_x;
    buffer[1] = at_y;
    error_trap(toolbox_show_object(0, config_window_id, 2, buffer, 0, 0), 0);
d379 1
a379 1
                                NumberRange_ValueChanged,
d381 1
d387 1
a387 1
                                  "<SoundConfig$Dir>", &messages_desc, &idb,
d423 1
d426 1
a426 3
    sound_read_channel_info(config_window_id);
    sound_read_choices(config_window_id);
    sound_read_write_cmos_settings(ReadCMOSSettings, config_window_id);
@


1.1.1.1
log
@Initial import of SndSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Added SetVolumes application and a Try button.
@
text
@d89 1
a89 6
}

static void try_system_beep(void)
{
        printf("\07");
}
d159 1
a224 4
            break;
            
        case TryButton:
            try_system_beep();
@

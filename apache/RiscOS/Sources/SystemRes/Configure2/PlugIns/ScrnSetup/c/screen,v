head	1.13;
access;
symbols
	ScrnSetup-0_43:1.13
	ScrnSetup-0_42:1.11
	ScrnSetup-0_41:1.11
	ScrnSetup-0_40:1.11
	ScrnSetup-0_39:1.10
	ScrnSetup-0_38:1.9
	ScrnSetup-0_37:1.8
	ScrnSetup-0_36:1.8
	ScrnSetup-0_35:1.8
	ScrnSetup-0_34:1.7
	ScrnSetup-0_33:1.7
	ScrnSetup-0_32:1.7
	ScrnSetup-0_31:1.6
	ScrnSetup-0_30:1.6
	ScrnSetup-0_29:1.6
	ScrnSetup-0_28:1.6
	ScrnSetup-0_27:1.6
	ScrnSetup-0_26:1.6
	ScrnSetup-0_25:1.6
	ScrnSetup-0_24:1.5
	ScrnSetup-0_23:1.5
	ScrnSetup-0_22:1.5
	ScrnSetup-0_21:1.4
	ScrnSetup-0_20:1.3
	ScrnSetup-0_19:1.3
	ScrnSetup-0_18:1.2
	ScrnSetup-0_17:1.1.1.5
	ScrnSetup-0_16:1.1.1.5
	ScrnSetup-0_15:1.1.1.5
	ScrnSetup-0_14:1.1.1.5
	ScrnSetup-0_13:1.1.1.5
	ScrnSetup-0_12:1.1.1.5
	ScrnSetup-0_11:1.1.1.5
	ScrnSetup-0_10:1.1.1.5
	ScrnSetup-0_09:1.1.1.5
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.5
	Ursula_RiscPC:1.1.1.5.0.2
	rthornb_UrsulaBuild-19Aug1998:1.1.1.5
	UrsulaBuild_FinalSoftload:1.1.1.5
	rthornb_UrsulaBuild-29Jul1998:1.1.1.5
	rthornb_UrsulaBuild-22Jul1998:1.1.1.5
	rleggett_ScrnSetup-0_08:1.1.1.5
	rthornb_UrsulaBuild-15Jul1998:1.1.1.5
	rthornb_UrsulaBuild-07Jul1998:1.1.1.5
	rthornb_UrsulaBuild-17Jun1998:1.1.1.5
	rleggett_ScrnSetup-0_07:1.1.1.4
	rthornb_UrsulaBuild-03Jun1998:1.1.1.4
	rthornb_UrsulaBuild-27May1998:1.1.1.4
	rthornb_UrsulaBuild-21May1998:1.1.1.4
	rthornb_UrsulaBuild_01May1998:1.1.1.3
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2018.08.27.19.31.40;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	q20Wi4Z6RRohFEPA;

1.11
date	2017.03.05.15.35.50;	author rool;	state Exp;
branches;
next	1.10;
commitid	pXgDBRq60MdmlnIz;

1.10
date	2016.08.04.08.06.01;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	Vu6lBW12jz6xHXgz;

1.9
date	2016.08.02.17.54.26;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	O1Nr1KXUCG5o1Lgz;

1.8
date	2016.05.18.21.19.20;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	HMZqYtNJWkx7B07z;

1.7
date	2014.10.15.08.08.58;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	Sqz3279VmgsRTgUx;

1.6
date	2013.01.17.21.24.05;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	oUFvl5G78V97KBAw;

1.5
date	2012.08.22.16.58.27;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	jOeRqWIJpSkX1zhw;

1.4
date	2012.07.22.09.46.33;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	h015P4FWeP2zDxdw;

1.3
date	2012.02.12.15.46.30;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	AITMkVfdGV9SNSSv;

1.2
date	2012.02.11.18.26.20;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	Tn70qsPfKA3JILSv;

1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.16.14.56.19;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.04.23.13.06.57;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.05.01.13.42.23;	author rleggett;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.06.10.08.47.26;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Fix handle and memory leaks on error
screen.c: if the destination file couldn't be opened, don't leak the source file; and when there are no disc based screen savers don't leak menustring (since the built in DPMS saver name doesn't need allocating - it can go straight into the stringset gadget).
Found by cppcheck static analysis.

Version 0.43. Tagged as 'ScrnSetup-0_43'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.screen                                                         */
/* Purpose: Non WIMP, but screen specific code                               */
/* Author:  Richard Leggett                                                  */
/* History: 18-Nov-97: RML: Begun.                                           */
/*          25-Mar-98: RML: Added get_wimpslot_min code.                     */
/*          16-Apr-98: RML: Fixed crash if ScrSavers directory not present.  */
/*          23-Apr-98: RML: Changed order of resolutions to match display    */
/*                          manager.                                         */
/*          03-Jun-98: RML: Added code to read screensaver information from  */
/*                          their messages files.                            */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "gadgets.h"
#include "wimplib.h"
#include "window.h"
#include "menu.h"
#include "common.h"
#include "defines.h"

#define MAX_PATHNAME_LENGTH 256

typedef struct
{
    int load_address;
    int exec_address;
    int length;
    int attributes;
    int type;
    int filetype;
    char name[4];
} record;    

typedef struct saver_ref
{
    struct saver_ref *next;
    char             *saver_name;
    char             *saver_purpose;
    char             *saver_author;
    char             *saver_version;
    char             *file_name;
} saver_ref;


static saver_ref  *savers_list = NULL;
static saver_ref **savers_list_tail = NULL;

extern int  main_window_id, dpms_window_id, res_menu_id, col_menu_id, current_colours, current_res, hz_menu_id, current_hz, hz_menu_entries;

/*---------------------------------------------------------------------------*
 * get_saver_filename                                                        *
 *                                                                           *
 * Given an index, return the filename of the nth screen saver.              *
 *                                                                           *
 * In: n = index of saver.                                                   *
 *                                                                           *
 * Returns: Pointer to filename, or NULL if doesn't exist.                   *
 *---------------------------------------------------------------------------*/

char* get_saver_filename(int n)
{
    saver_ref *ref;
    int        i;

    ref = savers_list;
    for (i=1; i<n; i++)
    {
        ref = ref->next;
        if (ref==0) return NULL;
    }

    return ref->file_name;
}


/*---------------------------------------------------------------------------*
 * check_has_settings                                                        *
 *                                                                           *
 * Given the name of a screen blanker, check if there is a settings app/file *
 * to go with it.                                                            *
 *                                                                           *
 * In: blankername -> name of blanker.                                       *
 *                                                                           *
 * Returns: 1 if there is a settings app, 0 if not.                          *
 *---------------------------------------------------------------------------*/

int check_has_settings(int n)
{
    saver_ref *ref;
    char       filename[1024];
    int        i;
    int        type;

    if (n==0) return 1;

    ref = savers_list;
    for (i=1; i<n; i++)
    {
        ref=ref->next;
        if (ref==0) return 0;
    }
    
    strcpy(filename, ref->file_name);
    strcat(filename,".!SvrSetup");
    
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, filename, &type), 0);
    if ((type==2) || (type==1)) return 1;
     
    return 0;
}


/*---------------------------------------------------------------------------*
 * check_saver_path                                                          *
 *                                                                           *
 * Given a screensaver path, check it's in our list of savers.               *
 *                                                                           *
 * In: path -> pathname                                                      *
 *                                                                           *
 * Returns: 0 = saver not recognised.                                        *
 *          else pointer to saver name.                                      *
 *---------------------------------------------------------------------------*/

char* check_saver_path(char *path)
{
    saver_ref *ref;
    
    if (savers_list==0) return 0;

    ref = savers_list;
    while (ref->next)
    {
        if (strncmp(path, ref->file_name, strlen(path)-2)==0) return ref->saver_name;
        ref = ref->next;
    }
    if (strncmp(path, ref->file_name, strlen(path)-2)==0) return ref->saver_name;
    
    return 0;
}


/*---------------------------------------------------------------------------*
 * get_leafname                                                              *
 *                                                                           *
 * Find the leafname from a path (actually this will typically be leafname   *
 * plus a '.')                                                               *
 *                                                                           *
 * In: path -> pathname                                                      *
 *                                                                           *
 * Returns: pointer to leafname                                              *
 *---------------------------------------------------------------------------*/

char* get_leafname(char* path)
{
    int n;
        
    for (n=strlen(path)-3; n>=0; n--)
    {
        if (path[n]=='.') return path+n+1;
    }
        
    return path;
}


/*---------------------------------------------------------------------------*
 * ignore_string                                                             *
 *                                                                           *
 * Decide if a string in the choices file should be ignored (because we're   *
 * going to output an updated version)                                       *
 *                                                                           *
 * In: string -> the string                                                  *
 *                                                                           *
 * Returns: 1 if ignore, 0 not to ignore                                     *
 *---------------------------------------------------------------------------*/

static int ignore_string(char *string)
{
    if (strncmpa(string, "Set ScrSaver$Dir", 16)==0) return 1;
    if (strncmpa(string, "Unset ScrSaver$Dir", 18)==0) return 1;
    if (strncmpa(string, "SetEval ScrSaver$MinMem", 23)==0) return 1;
    if (strncmpa(string, "Blanktime",9)==0) return 1;
    
    return 0;
}


/*---------------------------------------------------------------------------*
 * write_screen_choices                                                      *
 *                                                                           *
 * Given a some commands to write, ammend the choices file.                  *
 *                                                                           *
 * In: set_command -> *Set ScrSaver$Dir or *Unset ScrSaver$Dir command.      *
 *     mem_command -> *SetEval ScrSaver$MinMem command (or NULL string).     *
 *     bt_command -> *Blanktime command (or NULL string).                    *
 *---------------------------------------------------------------------------*/

_kernel_oserror *write_screen_choices(const char *set_command, const char *mem_command, const char *bt_command)
{
    FILE *source_fp;
    FILE *dest_fp;
    char  string[256];
    int   more = 1;
    
    source_fp = fopen(ChoicesFileRO, "r");
    dest_fp = fopen(ScrapFile, "w");
    if (!dest_fp)
    {
        if (source_fp) fclose(source_fp);
        return common_error(messages_lookup("ChoicesFileNotOpen"));
    }

    /* Write the commands into the choices file */
    fputs(set_command, dest_fp);
    fputc(NewLine, dest_fp);

    if (strlen(mem_command) > 0)
    {
        fputs(mem_command, dest_fp);
        fputc(NewLine, dest_fp);
    }
    
    if (strlen(bt_command) > 0)
    {
        fputs(bt_command, dest_fp);
        fputc(NewLine, dest_fp);
    }

    /* Write out any other commands that were in the file */
    if (source_fp)
    {
        while(more)
        {
            more = (int)fgets(string, 256, source_fp);
            if (more)
            {
                if (!ignore_string(string)) fputs(string, dest_fp);
            }
        }
        fclose(source_fp);
    }

    /* Set filetype of the new file and move it into place */
    fclose(dest_fp);
    error_trap(_swix(OS_File, _INR(0, 2), OSFile_SetType, ScrapFile, FileType_Obey), 0);
    error_trap(_swix(OS_FSControl, _INR(0, 3),               /*  A        D        F */
                     FSControl_Copy, ScrapFile, ChoicesFile, (1<<9) | (1<<7) | (1<<1)), 0);

    return NULL;
}


/*---------------------------------------------------------------------------*
 * read_saver_messages_file                                                  *
 *                                                                           *
 * Read the purpose, author and version of a screensaver from its messages   *
 * file.                                                                     *
 *                                                                           *
 * In: ref -> saver_ref structure of the saver whose data we're reading.     *
 *---------------------------------------------------------------------------*/

static void read_saver_messages_file(saver_ref *ref)
{
    _kernel_oserror *e;
    char  purpose[128] = " ";
    char  author[128] = " ";
    char  version[128] = " ";
    char  string[128];
    char  filename[MAX_PATHNAME_LENGTH];
    char *buffer;
    int   messblk[4];
    int   type;
    int   buffsize;
    int   territory = _swi(Territory_Number, _RETURN(0));

    sprintf(filename, "%s.Message%d", ref->file_name, territory);
    e = _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, filename, &type);
    if ((e != NULL) || (type != object_file))
    {
        /* No territory specific messages, try default ones */
        sprintf(filename, "%s.Messages", ref->file_name);
        e = _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, filename, &type);
    }

    if ((e == NULL) && (type == object_file))
    {
        _swix(MessageTrans_FileInfo, _IN(1)|_OUT(2), filename, &buffsize);
        buffer = malloc(buffsize);
        if (buffer != NULL)
        {
            _swix(MessageTrans_OpenFile, _INR(0, 2), messblk, filename, buffer);

            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Purpose", string, sizeof(string), 0, 0, 0, 0))
            {
                strcpy(purpose, string);
            }
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Author", string, sizeof(string), 0, 0, 0, 0))
            {
                strcpy(author, string);
            }
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Version", string, sizeof(string), 0, 0, 0, 0))
            {
                strcpy(version, string);
            }

            _swix(MessageTrans_CloseFile, _IN(0), messblk);
            free(buffer);
        }
    }
    
    ref->saver_purpose = malloc(strlen(purpose) + 1);
    ref->saver_author = malloc(strlen(author) + 1);
    ref->saver_version = malloc(strlen(version) + 1);

    strcpy(ref->saver_purpose, purpose);
    strcpy(ref->saver_author, author);
    strcpy(ref->saver_version, version);
}


/*---------------------------------------------------------------------------*
 * construct_savers_list                                                     *
 *                                                                           *
 * Build a structure with the details of all screen savers.                  *
 *                                                                           *
 * In: dirname -> name of directory to scan.                                 *
 *     buffer_end -> end of buffer (buffer begins at dirname)                *
 *---------------------------------------------------------------------------*/

static void construct_savers_list(char *dirname, char *buffer_end)
{
    _kernel_oserror *e = NULL;
    saver_ref       *new_ref;
    char            *dirname_end;
    char            *leafname;
    int              pos = 0;
    int              num, type;
        
    dirname_end = dirname + strlen(dirname);
    
    while ((e == NULL) && (pos != -1))
    {
        /* Get next entry from directory */
        e = _swix(OS_GBPB, _INR(0,6)|_OUTR(3,4),
                           OSGBPB_ReadDirEntries, dirname, dirname_end+1, 1, pos,
                           buffer_end - (dirname_end+1), 0,
                           &num, &pos);

        if ((e == NULL) && (num > 0))
        {
            *dirname_end = '.';

            /* Find the type of the entry we've just read */
            e = _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, dirname, &type);

            if ((e == NULL) && (type == object_directory))
            {
                /* It was a directory, so see if it's an app */
                leafname = get_leafname(dirname);
                if (leafname[0]!='!')
                {
                    /* Not an application, so scan this directory too */
                    construct_savers_list(dirname, buffer_end);
                }
                else
                {                
                    /* Found an application - assume it's a screen saver */
                    new_ref = malloc(sizeof(saver_ref));
                    new_ref->file_name = malloc(strlen(dirname)+1);
                    new_ref->saver_name = malloc(strlen(leafname));
                    new_ref->next = 0;
                    strcpy(new_ref->file_name, dirname);
                    strcpy(new_ref->saver_name, leafname+1);
                    read_saver_messages_file(new_ref);
                    *savers_list_tail = new_ref;
                    savers_list_tail = &new_ref->next;
                }
            }
            e = NULL; /* On error, carry on with the enumeration */
            *dirname_end = '\0';
        }
    }
}


/*---------------------------------------------------------------------------*
 * read_savers_list                                                          *
 *                                                                           *
 * Read list of screen savers.                                               *
 *                                                                           *
 * Returns: Memory required to construct a comma seperated string of all the *
 *          screen saver titles (useful for stringset_set_available).        *
 *---------------------------------------------------------------------------*/

static int read_savers_list(void)
{
    saver_ref *ref;
    char       buffer[1024];
    int        size = 0;
    int        type;
    
    savers_list = NULL;
    savers_list_tail = &savers_list;
    strcpy(buffer, SaversDirectory);
    
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, SaversDirectory, &type), 0);

    if (type) construct_savers_list(buffer, buffer+1024);

    if (savers_list==NULL) return 0;

    ref = savers_list;
    while (ref->next)
    {
        size += strlen(ref->saver_name)+1;
        ref = ref->next;
    }
    size += strlen(ref->saver_name)+1;
    size += 16;

    return size;
}   
  

/*---------------------------------------------------------------------------*
 * create_savers_menu                                                     *
 *                                                                           *
 * Build a menu string with the details of all available screen savers       *
 *                                                                           *
 *---------------------------------------------------------------------------*/

void create_savers_menu(void)
{
    saver_ref *ref;
    char *menustring;
    int   listsize;
    
    listsize = read_savers_list(); 
    if (savers_list==NULL)
    {
        error_trap(stringset_set_available(0, main_window_id, SaverTypeStringSet, DPMSString), 0);
        return;
    }

    menustring = malloc(listsize+16);
    if (!menustring) error_trap(common_error(messages_lookup("NotEnoughMemory")), 0);

    sprintf(menustring, "%s,", DPMSString);

    ref = savers_list;
    while (ref->next)
    {
        strcat(menustring, ref->saver_name);
        strcat(menustring, ",");
        ref=ref->next;
    }
    strcat(menustring, ref->saver_name);

    error_trap(stringset_set_available(0, main_window_id, SaverTypeStringSet, menustring), 0);
    free(menustring);
}


/*---------------------------------------------------------------------------*
 * parse_wimpslot_command                                                    *
 *                                                                           *
 * Given a WimpSlot command, find the value of -min.                         *
 * Called by get_wimpslot_min.                                               *
 *                                                                           *
 * In: cmd -> Wimpslot command tail (ie. excluding WimpSlot at start)        *
 *                                                                           *
 * Returns: value of min, else 0.                                            *
 *---------------------------------------------------------------------------*/

int parse_wimpslot_command(char *cmd)
{
    char *ptr;
    static const char args[] = "min,max,next";
    int   buffer[64];
    int   min;

    _swix(OS_ReadArgs, _INR(0,3), args, cmd, buffer, 256);
    _swix(OS_ReadUnsigned, _INR(0,1)|_OUT(2), 10, buffer[0], &min);
    
    if (!buffer[0]) return 0;
    
    ptr = (char*)buffer[0];
    ptr = ptr + strlen(ptr) - 1;
    if ((*ptr == 'K') || (*ptr == 'k')) min = min * 1024;
    min = min/1024;

    return min;
}

 
/*---------------------------------------------------------------------------*
 * get_wimpslot_min                                                          *
 *                                                                           *
 * Given the name of an obey file, search through and find a Wimpslot        *
 * command, then find the value of -min for that command.                    *
 *                                                                           *
 * In: filename -> name of obey file.                                        *
 *                                                                           *
 * Returns: value of min, else 0.                                            *
 *---------------------------------------------------------------------------*/

int get_wimpslot_min(char *filename)
{
    FILE *fp;
    char  string[1024];
    int   more = 1;
    
    fp = fopen(filename, "r");
    if (fp)
    {
        while (more)
        {
            /* Get the next line */
            more = (int)fgets(string, 1024, fp);
            if (more)
            {
                string[strlen(string)-1] = 0;
                /* Is it a WimpSlot command? */
                if (strncmpa(string, "WimpSlot", 8)==0)
                {
                     /* Yes, then parse it */
                     fclose(fp);
                     return parse_wimpslot_command(string+8);
                }
            }
        }
        
        fclose(fp);
    }

    return 0;
}


/*---------------------------------------------------------------------------*
 * warning_box                                                               *
 *                                                                           *
 * Pop up a wimp warning box.                                                *
 *---------------------------------------------------------------------------*/

void warning_box(char *string)
{
    _kernel_oserror e;
    e.errnum = 0;
    strcpy(e.errmess, string);
    wimp_report_error(&e, 0, messages_lookup("_TaskName"), 0, 0, 0);
}


/*---------------------------------------------------------------------------*
 * build_info_menu                                                           *
 *                                                                           *
 * Make the screensaver information menu.                                    *
 *                                                                           *
 * In: main_id = toolbox id of the main menu (from which Info comes)         *
 *     menu_id = toolbox id of the screensaver info menu.                    *
 *     window_id = toolbox id of the screensaver info window.                *
 *---------------------------------------------------------------------------*/

void build_info_menu(int main_id, int menu_id, int window_id)
{
    MenuTemplateEntry *entry;
    saver_ref   *ref;
    static char *menudata;
    char        *menuptr;
    int          n = 1;
    int          i;

    ref = savers_list;
    if (!ref)
    {
        error_trap(menu_set_fade(0, main_id, MainInfoSubMenu, 1), 0);
        return;
    }

    while (ref->next)
    {
        n+=1;
        ref = ref->next;
    }
    
    menudata = malloc(sizeof(MenuTemplateEntry) * n);
    menuptr = menudata;
    
    ref = savers_list;
    for (i=0; i<n; i++)
    {
        entry = (MenuTemplateEntry*)menuptr;
        entry->flags = Menu_Entry_SubMenu + Menu_Entry_GenerateSubMenuEvent;
        entry->component_id = i; 
        entry->text = ref->saver_name;
        entry->max_text = 255;
        entry->click_show = 0;
        entry->submenu_show = NULL;
        entry->submenu_event = 0;
        entry->click_event = 0;
        entry->help_message = NULL;
        entry->max_entry_help = 0;

        error_trap(menu_add_entry(0, menu_id, Menu_AddEntryAtEnd, menuptr, NULL), 0);
        error_trap(menu_set_sub_menu_show(0, menu_id, i, window_id), 0);
        
        ref = ref->next;
        menuptr = menuptr + sizeof(MenuTemplateEntry);
    }
}


/*---------------------------------------------------------------------------*
 * fill_in_saver_info                                                        *
 *                                                                           *
 * Fill in the screensaver information window.                               *
 *---------------------------------------------------------------------------*/
 
void fill_in_saver_info(int window_id, int entry)
{
    saver_ref *ref = savers_list;
    int        n;
    
    for (n=0; n<entry; n++)
    {
        if (ref->next) ref = ref->next;
    }
    
    error_trap(displayfield_set_value(0, window_id, InfoNameDisplay, ref->saver_name), 0);
    error_trap(displayfield_set_value(0, window_id, InfoPurposeDisplay, ref->saver_purpose), 0);
    error_trap(displayfield_set_value(0, window_id, InfoAuthorDisplay, ref->saver_author), 0);
    error_trap(displayfield_set_value(0, window_id, InfoVersionDisplay, ref->saver_version), 0);
}
@


1.11
log
@Add support for EDID monitors in the system
Detail:
  Upgrade the MDF directory enumeration to minimally parse EDID data blobs. Add these to the list of known monitors. This allows a disc based MDF to override faulty data in the monitor, or on systems such as IOMD that don't support EDID, for them to benefit from a library of blobs rather than needing a parallel set of MDFs creating.
  Add the path of EDID blobs exported by ScrModes to those scanned for monitor definitions. EDID data is always placed in the top level manufacturer menu below 'Auto'.
  Add interactive help to clarify what 'Auto' means and how it differs from the EDID data.

  common.c: Relocate [un]grey_gadget() from screen.c.
  main.c: Simplify unnecessary memset(). Create a flag based on ScreenModes_Features whether the host OS supports EDID or not.
  monitor.c: Extra scanning. Conflict resolution if duplicate monitor definitions exist from differing sources. Simple EDID parser to get the monitor name (else default string) and DPMS flags.
Admin:
  Submission for the EDID bounty.
  Tested with ScrModes-0_61, and also on earlier versions, on RISC OS 5.23.
  Briefly tested on RISC OS 3.70 with !Boot.Resources.Configure.Monitors containing EDID data (should be ignored).

Version 0.40. Tagged as 'ScrnSetup-0_40'
@
text
@d230 5
a234 1
    if (!dest_fp) return common_error(messages_lookup("ChoicesFileNotOpen"));
d459 1
d461 8
a468 1
    menustring = malloc(read_savers_list()+16);
a471 5
    if (savers_list==0)
    {
        menustring[strlen(menustring)]=0;
        return;
    }
@


1.10
log
@Fix for Auto setting not being stored
3rd time's a charm: in changing from a stringset changed to a menu selection event, nothing was updating the globals holding the monitor details for the Auto case calling switch_monitor(). Move that call so it is.
Change menus_are_grey to a boolean.

Version 0.39. Tagged as 'ScrnSetup-0_39'
@
text
@d221 1
a221 1
_kernel_oserror* write_screen_choices(char *set_command, char *mem_command, char *bt_command)
d242 1
a242 1
    if (strlen(bt_command) > 9)
a571 38
 * grey_gadget                                                               *
 *                                                                           *
 * Grey a gadget.                                                            *
 *                                                                           *
 * In: objectid = ID of the object containing the gadget.                    *
 *     gadgetid = ID of the gadget.                                          *
 *---------------------------------------------------------------------------*/

void grey_gadget(int objectid, int gadgetid)
{
    unsigned int flags;

    error_trap(gadget_get_flags(0, objectid, gadgetid, &flags), 0);
    flags = flags | Gadget_Faded;
    error_trap(gadget_set_flags(0, objectid, gadgetid, flags), 0);
}


/*---------------------------------------------------------------------------*
 * ungrey_gadget                                                             *
 *                                                                           *
 * Ungrey a gadget.                                                          *
 *                                                                           *
 * In: objectid = ID of the object containing the gadget.                    *
 *     gadgetid = ID of the gadget.                                          *
 *---------------------------------------------------------------------------*/

void ungrey_gadget(int objectid, int gadgetid)
{
    unsigned int flags;

    error_trap(gadget_get_flags(0, objectid, gadgetid, &flags), 0);
    flags &= ~Gadget_Faded;
    error_trap(gadget_set_flags(0, objectid, gadgetid, flags), 0);
}


/*---------------------------------------------------------------------------*
@


1.9
log
@Fix for thinking 0th model is Auto type
The current_montype variable now holds the entry number within the menu for the selected manufacturer, whereas it used to be the current entry for the 1 (and only) models menu.
So, when selecting any 0th model from a submenu this would be mistaken as the former 'Auto' entry, and the PreDesk$Configure file wiped out.

Rescope current_montype to be static so it can only be used for its intended purpose, and derive 'Auto' or not in set_monitor_choices() by whether the filename is NULL like elsewhere.
Use defines when calling OS_ScreenMode rather than magic numbers.
Should fix issue described in https://www.riscosopen.org/forum/forums/11/topics/6370 introduced in ScrnSetup-0_36.

Version 0.38. Tagged as 'ScrnSetup-0_38'
@
text
@d71 1
a71 1
extern int  main_window_id, dpms_window_id, res_menu_id, col_menu_id, current_colours, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
@


1.8
log
@Make monitor type into a display field + popup menu
Was previously a StringSet, but these are limited to only one level of menu tree.
Turned off "Deliver event before showing" for the popups in the main window, since nothing registered events against them.
No longer spends an eternity rebuilding the monitors menu when adjust clicking on 'Cancel', because the read_choices() function also used to scan the MDFs to make the menu. Now it really does just read the choices back in.
Correction to interactive help for the "Resolution" menu - the guidance about square and rectangular pixels was back to front.

Version 0.35. Tagged as 'ScrnSetup-0_35'
@
text
@d71 1
a71 1
extern int  main_window_id, dpms_window_id, res_menu_id, col_menu_id, current_colours, current_montype, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
d265 1
a265 1
    error_trap(_swix(OS_FSControl, _INR(0, 3),   /*  A        D        F */
@


1.7
log
@Look for territory specific messages before falling back to en-gb
To build the screen saver 'Info' menu this plugin reaches into the screensaver to get the purpose/author/version fields from its messages, however was not respecting any territory selection.
This change emulates how Toolbox_Initialise would look and is essentially a repeat of ticket #367.
Also - the return registers for MessageTrans_FileInfo were wrong, R0 and R2 (not R1 and R2) but since the flags were never used, this is easier to delete.

Version 0.32. Tagged as 'ScrnSetup-0_32'
@
text
@d71 1
d414 1
a414 1
int read_savers_list(void)
d445 1
a445 1
 * construct_savers_menu                                                     *
a448 1
 * In: menustring -> memory to construct string in.                          *
d451 1
a451 1
void make_savers_menu(char *menustring)
d454 1
d456 3
d474 3
d653 1
a653 1
        entry->submenu_show = 0;
d656 1
a656 1
        entry->help_message = 0;
d659 1
a659 1
        error_trap(menu_add_entry(0, menu_id, -2, menuptr, 0), 0);
@


1.6
log
@Minor ScrnSetup improvements
* Get OS_Byte/OS_File/filetypes/CMOS/OS_Module defs from header files.
* Fix ticket #312 (misuse of OS_GBPB means enumerating dirs on a non FileCore filing system could get stuck).
* Simplify the steps in the mode 'Try' sequence, now the mouse is bounded in the 'Keep/Cancel' message box (with the same 5s timeout) so that you can't click elsewhere on the main window. Previously, you could click 'Set', then the 5s would elapse and the mode revert to not the one you set.
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed.

Note that in reviewing the plugins the minimum resolution considered to fit without scroll bars is 640x480, a special case is made of the screen setup plugin in case it starts in some mode less than that and you can't reach the 'OK' button to set it to anything else.

Version 0.25. Tagged as 'ScrnSetup-0_25'
@
text
@d274 1
a274 1
 * Read the purpose, author and version of a screensaver from it's messages  *
d282 1
a290 1
    int   flags;
d292 1
a292 2
    
    sprintf(filename, "%s.Messages", ref->file_name);
d294 8
a301 1
    _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, filename, &type);
d303 1
a303 1
    if (type==1)
d305 1
a305 1
        _swix(MessageTrans_FileInfo, _IN(1)|_OUTR(1, 2), filename, &flags, &buffsize);
d307 1
a307 2

        if (buffer)
d311 1
a311 1
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Purpose", string, 128, 0, 0, 0, 0))
d315 1
a315 1
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Author", string, 128, 0, 0, 0, 0))
d319 1
a319 1
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Version", string, 128, 0, 0, 0, 0))
@


1.5
log
@Only create ScrSavers in choices when the plugin needs it
Really, the screen saver setup apps should do this themselves, but this plugin can at least defer the create until it's reasonably sure it's needed.

Version 0.22. Tagged as 'ScrnSetup-0_22'
@
text
@d34 2
d128 1
a128 1
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, filename, &type), 0);
d263 1
a263 1
    error_trap(_swix(OS_File, _INR(0, 2), 18, ScrapFile, 0xFEB), 0);
d265 1
a265 1
                     26, ScrapFile, ChoicesFile, (1<<9) | (1<<7) | (1<<1)), 0);
d295 1
a295 1
    _swix(OS_File, _INR(0,1)|_OUT(0), 17, filename, &type);
a348 2
    int              num = 0;
    int              last_item_read = 0;
d350 1
a350 1
    int              type;
d354 1
a354 1
    while(last_item_read!=-1)
d357 4
a360 4
        _swix(OS_GBPB, _INR(0,6)|_OUTR(3,4),
                         9, dirname, dirname_end+1, 1, pos,
                         buffer_end - (dirname_end+1), 0,
                         &num, &last_item_read);
d362 1
a362 1
        if (!e && num>0)
a364 1
            pos += num;
d367 1
a367 1
            e = _swix(OS_File, _INR(0,1)|_OUT(0), 17, dirname, &type);
d369 1
a369 1
            if (type==2)
d392 1
a392 1
            
d417 1
a417 1
    sprintf(buffer, SaversDirectory);
d419 1
a419 1
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, SaversDirectory, &type), 0);
d482 1
a482 1
    char  args[] = "min,max,next";
@


1.4
log
@Enable hourglass while scanning monitor directories.
Check return result from malloc() and don't dereference NULL on failure.
Pointers initialised to NULL not 0.

Version 0.21. Tagged as 'ScrnSetup-0_21'
@
text
@d77 1
a77 1
 * Returns: Pointer to filename, or zero if doesn't exist.                   *
d89 1
a89 1
        if (ref==0) return 0;
@


1.3
log
@Internationalised the screensaver blank times.
When reading choices, read from Choices:.
If no screensaver is set then adjustclicking on 'Cancel' now correctly restores the DPMS saver as the default.
Use OS_FSControl instead of OS_CLI(*COPY).
'Auto' and 'Unknown' put in messages file.

Version 0.19. Tagged as 'ScrnSetup-0_19'
@
text
@d66 2
a67 2
static saver_ref  *savers_list=0;
static saver_ref **savers_list_tail=0;
@


1.2
log
@Get error box title from "_TaskName" token in messages file.
Use Mask_NoNullEvents/Gadget_Faded flag from toolbox headers.
Use OSFile 8 to create directories not OS_CLI.
Code in 'common.[c|h]' made more common.

Version 0.18. Tagged as 'ScrnSetup-0_18'
@
text
@d213 1
a213 1
 * In: set_command -> *Set ScrSaver$Dir or *UnsetScrSaver$Dir command.       *
d222 1
a222 1
    char  string[1024];
d225 1
a225 1
    source_fp = fopen(ChoicesFile, "r");
d259 1
a259 1
    /* Set filetype of the new file */
d262 2
a263 3
    sprintf(string,"Copy %s %s A~CDF~L~N~P~Q~R~S~T~V", ScrapFile, ChoicesFile);
    error_trap(_swix(OS_CLI, _IN(0), string), 0);
    _swix(OS_File, _INR(0,1), 6, ScrapFile);
d563 1
a563 1
 * Grey a a gadget.                                                          *
d582 1
a582 1
 * Ungrey a a gadget.                                                        *
@


1.1
log
@Initial revision
@
text
@d21 5
d35 4
d42 2
d59 3
d65 1
d124 1
a124 1
    strcat(filename,".!Settings");
d271 63
d358 1
a358 1
        _swi(OS_GBPB, _INR(0,6)|_OUTR(3,4),
d389 1
d415 1
d420 4
a423 1
    construct_savers_list(buffer, buffer+1024);
a470 17
 * check_scrsaver_choices_dir                                                *
 *                                                                           *
 * Check the choices directory exists for the screensavers.                  *
 *---------------------------------------------------------------------------*/

void check_scrsaver_choices_dir(void)
{
    int type;

    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, SaverChoicesDir, &type), 0);
    if (type!=0) return;
    
    error_trap(_swix(OS_CLI, _IN(0), "CDir "SaverChoicesDir), 0);
}


/*---------------------------------------------------------------------------*
d488 1
a488 1
    _swi(OS_ReadArgs, _INR(0,3), args, cmd, buffer, 256);
d533 1
d544 135
@


1.1.1.1
log
@Initial import of ScrnSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Fixed crash which can occur if ScrSavers directory doesn't exist.
A click on Set now actually sets the screen for the current session
(ie. not just on re-boot)
@
text
@a20 1
/*          16-Apr-98: RML: Fixed crash if ScrSavers directory not present.  */
a335 1
    int        type;
d340 1
a340 4
    
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, SaversDirectory, &type), 0);

    if (type) construct_savers_list(buffer, buffer+1024);
@


1.1.1.3
log
@Resolution menu now same order as display manager.
@
text
@a21 2
/*          23-Apr-98: RML: Changed order of resolutions to match display    */
/*                          manager.                                         */
@


1.1.1.4
log
@Screensaver settings plug-ins now called SvrSetup.
@
text
@d112 1
a112 1
    strcat(filename,".!SvrSetup");
@


1.1.1.5
log
@An Info menu is provided for screensavers author, version etc.
Clicks on Cancel only re-read settings if click was with adjust.
Bug fix: Screensaver !Run files were left open after reading Wimpslot size.
@
text
@a23 2
/*          03-Jun-98: RML: Added code to read screensaver information from  */
/*                          their messages files.                            */
a32 2
#include "window.h"
#include "menu.h"
a35 2
#define MAX_PATHNAME_LENGTH 256

a50 3
    char             *saver_purpose;
    char             *saver_author;
    char             *saver_version;
a53 1

a258 63
 * read_saver_messages_file                                                  *
 *                                                                           *
 * Read the purpose, author and version of a screensaver from it's messages  *
 * file.                                                                     *
 *                                                                           *
 * In: ref -> saver_ref structure of the saver whose data we're reading.     *
 *---------------------------------------------------------------------------*/

static void read_saver_messages_file(saver_ref *ref)
{
    char  purpose[128] = " ";
    char  author[128] = " ";
    char  version[128] = " ";
    char  string[128];
    char  filename[MAX_PATHNAME_LENGTH];
    char *buffer;
    int   messblk[4];
    int   type;
    int   flags;
    int   buffsize;
    
    sprintf(filename, "%s.Messages", ref->file_name);

    _swix(OS_File, _INR(0,1)|_OUT(0), 17, filename, &type);

    if (type==1)
    {
        _swix(MessageTrans_FileInfo, _IN(1)|_OUTR(1, 2), filename, &flags, &buffsize);
        buffer = malloc(buffsize);

        if (buffer)
        {
            _swix(MessageTrans_OpenFile, _INR(0, 2), messblk, filename, buffer);

            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Purpose", string, 128, 0, 0, 0, 0))
            {
                strcpy(purpose, string);
            }
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Author", string, 128, 0, 0, 0, 0))
            {
                strcpy(author, string);
            }
            if (!_swix(MessageTrans_Lookup, _INR(0,7), messblk, "_Version", string, 128, 0, 0, 0, 0))
            {
                strcpy(version, string);
            }

            _swix(MessageTrans_CloseFile, _IN(0), messblk);
            free(buffer);
        }
    }
    
    ref->saver_purpose = malloc(strlen(purpose) + 1);
    ref->saver_author = malloc(strlen(author) + 1);
    ref->saver_version = malloc(strlen(version) + 1);

    strcpy(ref->saver_purpose, purpose);
    strcpy(ref->saver_author, author);
    strcpy(ref->saver_version, version);
}


/*---------------------------------------------------------------------------*
d283 1
a283 1
        _swix(OS_GBPB, _INR(0,6)|_OUTR(3,4),
a313 1
                    read_saver_messages_file(new_ref);
d429 1
a429 1
    _swix(OS_ReadArgs, _INR(0,3), args, cmd, buffer, 256);
a473 1
                     fclose(fp);
a482 82
}


/*---------------------------------------------------------------------------*
 * build_info_menu                                                           *
 *                                                                           *
 * Make the screensaver information menu.                                    *
 *                                                                           *
 * In: main_id = toolbox id of the main menu (from which Info comes)         *
 *     menu_id = toolbox id of the screensaver info menu.                    *
 *     window_id = toolbox id of the screensaver info window.                *
 *---------------------------------------------------------------------------*/

void build_info_menu(int main_id, int menu_id, int window_id)
{
    MenuTemplateEntry *entry;
    saver_ref   *ref;
    static char *menudata;
    char        *menuptr;
    int          n = 1;
    int          i;

    ref = savers_list;
    if (!ref)
    {
        error_trap(menu_set_fade(0, main_id, MainInfoSubMenu, 1), 0);
        return;
    }

    while (ref->next)
    {
        n+=1;
        ref = ref->next;
    }
    
    menudata = malloc(sizeof(MenuTemplateEntry) * n);
    menuptr = menudata;
    
    ref = savers_list;
    for (i=0; i<n; i++)
    {
        entry = (MenuTemplateEntry*)menuptr;
        entry->flags = Menu_Entry_SubMenu + Menu_Entry_GenerateSubMenuEvent;
        entry->component_id = i; 
        entry->text = ref->saver_name;
        entry->max_text = 255;
        entry->click_show = 0;
        entry->submenu_show = 0;
        entry->submenu_event = 0;
        entry->click_event = 0;
        entry->help_message = 0;
        entry->max_entry_help = 0;

        error_trap(menu_add_entry(0, menu_id, -2, menuptr, 0), 0);
        error_trap(menu_set_sub_menu_show(0, menu_id, i, window_id), 0);
        
        ref = ref->next;
        menuptr = menuptr + sizeof(MenuTemplateEntry);
    }
}


/*---------------------------------------------------------------------------*
 * fill_in_saver_info                                                        *
 *                                                                           *
 * Fill in the screensaver information window.                               *
 *---------------------------------------------------------------------------*/
 
void fill_in_saver_info(int window_id, int entry)
{
    saver_ref *ref = savers_list;
    int        n;
    
    for (n=0; n<entry; n++)
    {
        if (ref->next) ref = ref->next;
    }
    
    error_trap(displayfield_set_value(0, window_id, InfoNameDisplay, ref->saver_name), 0);
    error_trap(displayfield_set_value(0, window_id, InfoPurposeDisplay, ref->saver_purpose), 0);
    error_trap(displayfield_set_value(0, window_id, InfoAuthorDisplay, ref->saver_author), 0);
    error_trap(displayfield_set_value(0, window_id, InfoVersionDisplay, ref->saver_version), 0);
@

head	1.20;
access;
symbols
	ScrnSetup-0_43:1.20
	ScrnSetup-0_42:1.20
	ScrnSetup-0_41:1.20
	ScrnSetup-0_40:1.19
	ScrnSetup-0_39:1.18
	ScrnSetup-0_38:1.17
	ScrnSetup-0_37:1.16
	ScrnSetup-0_36:1.15
	ScrnSetup-0_35:1.14
	ScrnSetup-0_34:1.13
	ScrnSetup-0_33:1.13
	ScrnSetup-0_32:1.13
	ScrnSetup-0_31:1.13
	ScrnSetup-0_30:1.13
	ScrnSetup-0_29:1.12
	ScrnSetup-0_28:1.12
	ScrnSetup-0_27:1.12
	ScrnSetup-0_26:1.11
	ScrnSetup-0_25:1.11
	ScrnSetup-0_24:1.10
	ScrnSetup-0_23:1.10
	ScrnSetup-0_22:1.9
	ScrnSetup-0_21:1.8
	ScrnSetup-0_20:1.8
	ScrnSetup-0_19:1.7
	ScrnSetup-0_18:1.6
	ScrnSetup-0_17:1.5
	ScrnSetup-0_16:1.5
	ScrnSetup-0_15:1.4
	ScrnSetup-0_14:1.3
	ScrnSetup-0_13:1.3
	ScrnSetup-0_12:1.3
	ScrnSetup-0_11:1.3
	ScrnSetup-0_10:1.2
	ScrnSetup-0_09:1.1.1.4
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.4
	Ursula_RiscPC:1.1.1.4.0.2
	rthornb_UrsulaBuild-19Aug1998:1.1.1.4
	UrsulaBuild_FinalSoftload:1.1.1.4
	rthornb_UrsulaBuild-29Jul1998:1.1.1.4
	rthornb_UrsulaBuild-22Jul1998:1.1.1.4
	rleggett_ScrnSetup-0_08:1.1.1.4
	rthornb_UrsulaBuild-15Jul1998:1.1.1.4
	rthornb_UrsulaBuild-07Jul1998:1.1.1.4
	rthornb_UrsulaBuild-17Jun1998:1.1.1.4
	rleggett_ScrnSetup-0_07:1.1.1.3
	rthornb_UrsulaBuild-03Jun1998:1.1.1.3
	rthornb_UrsulaBuild-27May1998:1.1.1.3
	rthornb_UrsulaBuild-21May1998:1.1.1.3
	rthornb_UrsulaBuild_01May1998:1.1.1.2
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.20
date	2017.04.08.20.14.38;	author rool;	state Exp;
branches;
next	1.19;
commitid	dMN8yIo9bZlfNLMz;

1.19
date	2017.03.05.15.35.50;	author rool;	state Exp;
branches;
next	1.18;
commitid	pXgDBRq60MdmlnIz;

1.18
date	2016.08.04.08.06.01;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	Vu6lBW12jz6xHXgz;

1.17
date	2016.08.02.17.54.25;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	O1Nr1KXUCG5o1Lgz;

1.16
date	2016.05.19.19.59.39;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	2IeQPndzgzxO787z;

1.15
date	2016.05.18.21.26.40;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	ZXaRZP5oar7ED07z;

1.14
date	2016.05.18.21.19.20;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	HMZqYtNJWkx7B07z;

1.13
date	2014.02.09.13.02.12;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	ureZvxROBfkGuqox;

1.12
date	2013.07.31.07.13.11;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	JnHIm805T7MzLAZw;

1.11
date	2013.01.17.21.24.05;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	oUFvl5G78V97KBAw;

1.10
date	2012.08.28.20.57.43;	author jlee;	state Exp;
branches;
next	1.9;
commitid	4NuHSXS9qPu4amiw;

1.9
date	2012.08.22.16.58.26;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	jOeRqWIJpSkX1zhw;

1.8
date	2012.06.26.23.40.33;	author jlee;	state Exp;
branches;
next	1.7;
commitid	qPBJ2veAN8Fu5haw;

1.7
date	2012.02.12.15.46.29;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	AITMkVfdGV9SNSSv;

1.6
date	2012.02.11.18.26.19;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	Tn70qsPfKA3JILSv;

1.5
date	2011.04.13.22.45.03;	author jlee;	state Exp;
branches;
next	1.4;
commitid	usaqYFvcXuqiVIfv;

1.4
date	2010.01.27.19.31.41;	author srevill;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.02.23.00.30;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.19.22.50.48;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.23.13.06.53;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.05.01.13.42.20;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.06.10.08.47.24;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Minor UI improvements
Detail:
  Move the resolution picker menu after the monitor type picker menu, so the logical order flows better.
  Fix for failure to unshade menus after cancelling a 'Try' operation with the Auto monitor type.
  Improve the clarity of the magic EDID entry by using the text 'Auto (BrandX 123GTI)' in the menu so it stands out from other non-Auto detected types.
Admin:
  Submission for the EDID bounty.

Version 0.41. Tagged as 'ScrnSetup-0_41'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.main                                                           */
/* Purpose: Main WIMP shell for Screen configuration                         */
/* Author:  Richard Leggett                                                  */
/* History: 17-Nov-97: RML: Begun.                                           */
/*          20-Mar-98: RML: Minor updates.                                   */
/*          24-Mar-98: RML: ScrSaver$Path is now ScrSaver$Dir.               */
/*          25-Mar-98: RML: Added setting of ScrSaver$MinMem.                */
/*          23-Apr-98: RML: Fixed bug with menu selections of resolutions.   */
/*          03-Jun-98: RML: Added Info menu for screensavers.                */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/CMOS.h"
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
#include "Interface/ScrModes.h"
#include "toolbox.h"
#include "menu.h"
#include "colourdbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "wimplib.h"
#include "defines.h"
#include "screen.h"
#include "monitor.h"

#define BlankTimeBits     7<<3
#define Flag_EscapeKey    7
#define Flag_ReturnKey    7
#define Flag_LeftButton   4
#define Flag_RightButton  1


static MessagesFD messages_desc;
static IdBlock    idb;
static char       messages_string[255];
static char       orig_saver[1000];
static int        settings_handle = 0;
static int        blanktime = 0;
static int        unblank_on_writes = 0;
static int        current_montype_menu_id;
static int        current_montype;
int               main_window_id;
int               dpms_window_id;
int               montype_menu_id;
int               montype_menu_entries;
int               res_menu_id;
int               col_menu_id;
int               info_menu_id;
int               main_menu_id;
int               hz_menu_id;
int               saver_info_id;
int               current_res = 0;
int               current_colours = -1;
int               current_hz = -1;
int               hz_menu_entries=1;
bool              menus_are_grey = false;
bool              support_edid = false;

/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    /* Discard screenmodes instantiation */
    discard_screenmodes_instantiation();

    /* If there's a settings plug-in open, shut it down too. */
    if (settings_handle!=0)
    {
        WimpMessage msg;

        msg.hdr.size = 20;
        msg.hdr.your_ref = 0;
        msg.hdr.action_code = Wimp_MQuit;
        error_trap(wimp_send_message(Wimp_EUserMessage, &msg, settings_handle, 0, 0), 0);
    }

    exit(0);
}


/*---------------------------------------------------------------------------*
 * update_settings_icon                                                      *
 *                                                                           *
 * Grey or ungrey the 'Settings' icon according to if there is a settings    *
 * app for the current screen blanker.                                       *
 *---------------------------------------------------------------------------*/

static void update_settings_icon(void)
{
    int index;

    error_trap(stringset_get_selected(1, main_window_id, SaverTypeStringSet, &index), 0);

    if (check_has_settings(index))
    {
        ungrey_gadget(main_window_id, SaverSettingsButton);
    }
    else
    {
        grey_gadget(main_window_id, SaverSettingsButton);
    }
}


/*---------------------------------------------------------------------------*
 * update_montype_tick                                                       *
 *                                                                           *
 * Tick the given monitor selection, and any menus higher up the heirarchy,  *
 * untick the previous selection. Note this selection for next time.         *
 *---------------------------------------------------------------------------*/

void update_montype_tick(ObjectId menu, ComponentId entry)
{
    ObjectId parent = 0, group;
    int      topentry;

    /* Untick previous */
    error_trap(menu_set_tick(0, current_montype_menu_id, current_montype, 0), 0);

    /* Untick everything at the top level */
    for (topentry = 0; topentry < montype_menu_entries; topentry++)
    {
        error_trap(menu_set_tick(0, montype_menu_id, topentry, 0), 0);

        /* Is the new entry in a submenu too? */
        error_trap(menu_get_sub_menu_show(0, montype_menu_id, topentry, &group), 0);
        if ((group != 0) && (group == menu))
        {
            parent = topentry;
        }
    }

    /* Tick the new one */
    error_trap(menu_set_tick(0, menu, entry, 1), 0);
    current_montype = entry;
    current_montype_menu_id = menu;

    /* Tick its parent */
    if (parent != 0) error_trap(menu_set_tick(0, montype_menu_id, parent, 1), 0);
}

/*---------------------------------------------------------------------------*
 * try_it                                                                    *
 *                                                                           *
 * Try the currently selected screen saver.                                  *
 *---------------------------------------------------------------------------*/

static void try_it(void)
{
    char command[1024];
    int  selected;
    int  time;
    int  end_time;
    int  min;
    int  free_mem;

    error_trap(stringset_get_selected(1, main_window_id, SaverTypeStringSet, &selected), 0);

    /* Set MinMem */
    if (selected)
    {
        /* Find the memory required for the saver */
        sprintf(command, "%s.!Run", get_saver_filename(selected));
        min = get_wimpslot_min(command);

        /* Check we've enough free memory to try the saver */
        _swix(Wimp_SlotSize, _INR(0,1)|_OUT(2), -1, -1, &free_mem);
        if ( (free_mem / 1024) < (min + 16) )
        {
            warning_box(messages_lookup("SaverNoMemory"));
            return;
        }

        sprintf(command, "SetEval ScrSaver$MinMem %d", min);
        if (min) _swix(OS_CLI, _IN(0), command);
    }

    /* Set the screen blanker dir for the currently selected one */
    if (selected==0) sprintf(command, "Unset ScrSaver$Dir");
    else sprintf(command, "Set ScrSaver$Dir %s", get_saver_filename(selected));
    error_trap(_swix(OS_CLI, _IN(0), command), 0);

    /* Do a slight delay before starting the blanker (to allow for extra mouse movement) */
    _swix(OS_ReadMonotonicTime, _OUT(0), &time);
    end_time = time + 100;
    while (time < end_time) _swix(OS_ReadMonotonicTime, _OUT(0), &time);

    /* Now start the blanker */
    error_trap(_swix(ScreenBlanker_Control, _IN(0), 0), 0);
}


/*---------------------------------------------------------------------------*
 * restore_choices                                                           *
 *                                                                           *
 * Ensure we put stuff back to the way it was before this applet started.    *
 *---------------------------------------------------------------------------*/

static void restore_choices(void)
{
    char set_string[1024];

    if (orig_saver[0])
      sprintf(set_string, "Set ScrSaver$Dir %s", orig_saver);
    else
      sprintf(set_string, "Unset ScrSaver$Dir");
    error_trap(_swix(OS_CLI, _IN(0), set_string), 0);
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char set_string[1024] = { 0 };
    char blanktime_string[32] = { 0 };
    char mem_string[64] = { 0 };
    int  cmosvalue;
    int  selected;
    int  min;
    static const int blanktime_to_seconds[8] = {0, 30, 60, 120, 300, 600, 900, 1800};

    /* Write BlankTime CMOS bit */
    cmosvalue = read_cmos_value(Misc1CMOS);
    cmosvalue = cmosvalue &~ (BlankTimeBits);
    cmosvalue = cmosvalue | (blanktime<<3);
    write_cmos_value(Misc1CMOS, cmosvalue);

    /* Issue a *Blanktime command so we're up to date */
    sprintf(set_string, "Blanktime %d", blanktime_to_seconds[blanktime]);
    error_trap(_swix(OS_CLI, _IN(0), set_string), 0);
    error_trap(stringset_get_selected(1, main_window_id, SaverTypeStringSet, &selected), 0);

    /* Deal with ScrSaver$Dir & ScrSaver$MinMem setting */
    if (selected==0)
    {
        /* DPMS is always 0th entry */
        sprintf(set_string, "Unset ScrSaver$Dir");
        if (unblank_on_writes) sprintf(blanktime_string, "Blanktime -W");
    }
    else
    {
        sprintf(set_string, "%s.!Run", get_saver_filename(selected));
        min = get_wimpslot_min(set_string);
        if (min) sprintf(mem_string, "SetEval ScrSaver$MinMem %d", min);
        sprintf(set_string, "Set ScrSaver$Dir %s", get_saver_filename(selected));
    }

    /* Write settings to screen choices file */
    write_screen_choices(set_string, mem_string, blanktime_string);
    set_monitor_choices(FTW_CONFIG);

    /* Do the commands */
    error_trap(_swix(OS_CLI, _IN(0), set_string), 0);
    error_trap(_swix(OS_CLI, _IN(0), mem_string), 0);
}


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Fill in the default choices in the dialogue box.                          *
 *                                                                           *
 * Globals: blanktime                                                        *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    blanktime = 1;
    error_trap(stringset_set_selected(0, main_window_id, SaverTypeStringSet, DPMSString), 0);
    error_trap(displayfield_set_value(0, main_window_id, BlankDelayDisplay, messages_lookup("BTime1")), 0);
    update_settings_icon();
}


/*---------------------------------------------------------------------------*
 * parse_blanktime_command                                                   *
 *                                                                           *
 * What useful stuff can we get from the Blanktime command?                  *
 *                                                                           *
 * In: string -> *Blanktime command string.                                  *
 *---------------------------------------------------------------------------*/

static void parse_blanktime_command(char *string)
{
    char *switches = string+10;

    if (strstr(switches, "-W")) unblank_on_writes=1;

    optionbutton_set_state(0, dpms_window_id, DPMSUnblankButton, unblank_on_writes);
}


/*---------------------------------------------------------------------------*
 * parse_set_command                                                         *
 *                                                                           *
 * Find the screensaver path from a Set ScrSaver$Dir command.                *
 *---------------------------------------------------------------------------*/

static void parse_set_command(char *string)
{
    char *path = string + 17;
    char *name;

    name = check_saver_path(path);

    if (!name)
    {
        warning_box(messages_lookup("SaverNotRecognised"));
    }
    else
    {
        error_trap(stringset_set_selected(0, main_window_id, SaverTypeStringSet, name), 0);
        error_trap(_swix(OS_CLI, _IN(0), string), 0);
    }

    update_settings_icon();
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the choices file.                                                    *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[1024];
    int   more = 1;

    /* Read in choices from file */
    fp=fopen(ChoicesFileRO, "r");
    if (fp)
    {
        while (more)
        {
            more=(int)fgets(string, sizeof(string), fp);
            if (more)
            {
                if (strncmpa(string, "Set ScrSaver$Dir", 16)==0)
                {
                    parse_set_command(string);
                }

                else if (strncmpa(string, "Unset ScrSaver$Dir", 18)==0)
                {
                    error_trap(stringset_set_selected(0, main_window_id, SaverTypeStringSet, DPMSString), 0);
                }

                else if (strncmpa(string, "Blanktime", 9)==0)
                {
                    parse_blanktime_command(string);
                }

                else if (strncmpa(string, "Set ScrSaver$MinMem", 19)==0)
                {
                    error_trap(_swix(OS_CLI, _IN(0), string), 0);
                }
            }
        }
        fclose(fp);
    }

    blanktime = (read_cmos_value(Misc1CMOS) & BlankTimeBits) >> 3;
    sprintf(string, "BTime%d", blanktime);
    error_trap(displayfield_set_value(0, main_window_id, BlankDelayDisplay,
                                      messages_lookup(string)), 0);
}


/*---------------------------------------------------------------------------*
 * load_settings_app                                                         *
 *                                                                           *
 * User has clicked on 'Settings' - load the settings app.                   *
 *---------------------------------------------------------------------------*/

static void load_settings_app(void)
{
    WimpGetWindowStateBlock  block;
    char                    *savername;
    char                     pathname[960];
    char                     command_string[1024];
    int                      type;
    int                      openx;
    int                      openy;
    int                      index;

    /* Decide which openat to give to the settings app */
    error_trap(window_get_wimp_handle(0, main_window_id, &block.window_handle), 0);
    error_trap(wimp_get_window_state(&block),0);
    openx=block.visible_area.xmin+200;
    openy=block.visible_area.ymax-400;

    /* Find out which blanker is selected */
    error_trap(stringset_get_selected(1, main_window_id, SaverTypeStringSet, &index), 0);

    /* DPMS blanker */
    if (index==0)
    {
        error_trap(toolbox_show_object(0, dpms_window_id, 0, 0, 0, 0), 0);
        return;
    }

    /* Something other than DPMS */
    savername = get_saver_filename(index);
    if (savername == NULL) return;
    sprintf(pathname, "%s.!SvrSetup",savername);
    _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, pathname, &type);

    /* Check the choices directory exists for the screensaver setup to write into */
    error_trap(_swix(OS_File, _INR(0,1)|_IN(4), OSFile_CreateDir, ChoicesDir, 0), 0);

    switch (type)
    {
        case 2:
            sprintf(command_string, "Run %s -openat %d %d",pathname, openx, openy);
            error_trap(wimp_start_task(command_string, &settings_handle), 0);
            break;

        case 1:
            settings_handle = 0;
            sprintf(command_string, "Filer_Run %s",pathname);
            error_trap(_swix(OS_CLI, _IN(0), command_string), 0);
            break;
    }
}

/*---------------------------------------------------------------------------*
 * try_display_settings                                                      *
 *                                                                           *
 * User has clicked on 'Try' in the display settings section.                *
 *---------------------------------------------------------------------------*/

#define NULL_MASK 0xE3FFE
static void try_display_settings(void)
{
    int event, button;
    int now, time;
    char *message;
    char wimp_blk[256];
    char taskname[64];
    char buttons[32];
    _kernel_oserror err_blk = {0, ""};

    /* Warn the user that the mode is about to change for a short period */
    message = messages_lookup("DispPre");
    strcpy(err_blk.errmess, message);
    message = messages_lookup("_TaskName");
    strcpy(taskname, message);
    error_trap(_swix(Wimp_ReportError, _INR(0,5) | _OUT(1),
                     &err_blk,
                     Wimp_ReportError_Category(1) | Wimp_ReportError_UseCategory |
                     Wimp_ReportError_NoBeep | Wimp_ReportError_NoAppName | Wimp_ReportError_NoPrompt |
                     Wimp_ReportError_OK | Wimp_ReportError_Cancel,
                     taskname, "co_screen", 1, NULL,
                     &button), 1);
    if (button == 2) return;

    /* Change MDF and mode as specified, and save the settings to a temporary file */
    if (!set_monitor_choices(FTW_SCRAP)) return;

    /* Redraw the desktop at the new resolution */
    do
    {
        error_trap(_swix(Wimp_PollIdle, _INR(0,3)|_OUT(0), NULL_MASK, wimp_blk, 0, 0, &event), 1);
    } while (event);

    /* Open a prompt to see if the user was happy with the new mode (timing out
     * and cancelling in the case when they can't see anything any more!).
     */
    message = messages_lookup("DispPost");
    strcpy(err_blk.errmess, message);
    message = messages_lookup("DispBtn");
    strcpy(buttons, message);
    error_trap(_swix(OS_ReadMonotonicTime, _OUT(0), &time), 1);
    time += DisplayTestDuration;
    do
    {
        error_trap(_swix(Wimp_ReportError, _INR(0,5) | _OUT(1),
                         &err_blk,
                         Wimp_ReportError_Category(4) | Wimp_ReportError_UseCategory |
                         Wimp_ReportError_NoBeep | Wimp_ReportError_NoAppName | Wimp_ReportError_NoPrompt |
                         Wimp_ReportError_LeaveOpen,
                         taskname, "co_screen", 1, buttons,
                         &button), 1);
        if (button != 0) break;
        error_trap(_swix(OS_ReadMonotonicTime, _OUT(0), &now), 1);
    } while (now < time);

    /* Dispense with the prompt */
    error_trap(_swix(Wimp_ReportError, _INR(0,5),
                     &err_blk,
                     Wimp_ReportError_Close,
                     0, "", NULL, NULL), 1);

    if (button == 3)
    {
        /* Go with the new settings */
        read_current_mode_settings(FTR_SCRAP);
    }
    else
    {
        /* Restore the original settings */
        read_current_mode_settings(FTR_CONFIG);
    }

    discard_screenmodes_instantiation();
    create_screenmodes_instantiation();

    /* Make sure our icons contain the right details (required for set_monitor_choices) */
    create_resolutions_menu();
    update_monitor_displayfields();

    set_monitor_choices(FTW_NONE);
    
    /* Remove our temporary configuration file (if it exists) */
    _swix(OS_File, _INR(0,1), OSFile_Delete, ScrapConfigFile);
}


/*-----------------------------------------------------------------------------------------------*/
/*                                          Event handlers                                       */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum=error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * string_changed                                                            *
 *                                                                           *
 * Handle stringset changed events.                                          *
 *---------------------------------------------------------------------------*/

static int string_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int gadget = id_block->self_component;

    switch (gadget)
    {
        case SaverTypeStringSet:
            update_settings_icon();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * menu_select                                                               *
 *                                                                           *
 * Handle menu selections.                                                   *
 *---------------------------------------------------------------------------*/

int montype_menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    monitor_ref *rover;
    char *name, origin[32], string[256];
    int  namelen, originlen;
    ComponentId gadget = id_block->self_component;
    ObjectId    group, menu = id_block->self_id;

    error_trap(menu_get_sub_menu_show(0, menu, gadget, &group), 0);
    if (group != 0)
    {
        /* Pick the preferred entry in that group, like a font menu would */
        menu = group;
        gadget = 0;
    }
    
    /* Update the displayfield to show the new choice */
    error_trap(menu_get_entry_text(0, menu, gadget, string, sizeof(string), &namelen), 0);
    originlen = sprintf(origin, "%s (", messages_lookup("Auto"));
    name = string;
    if ((strncmp(name, origin, originlen) == 0) && (name[namelen - 2] == ')'))
    {
        /* Origin was live data, matched on "Auto (Model)", reduce to "Model" */
        name[namelen - 2] = '\0';
        name = name + originlen;
    }

    /* Find the monitor that's just been selected in our array */
    for (rover = monitors_list; rover; rover = rover->next)
    {
        if (strcmp(rover->monitor_name, name) == 0) break;
    }

    if (rover)
    {
        if (menus_are_grey)
        {
            ungrey_gadget(main_window_id, ColourMenu);
            ungrey_gadget(main_window_id, ColourDisplay);
            ungrey_gadget(main_window_id, ResolutionMenu);
            ungrey_gadget(main_window_id, ResolutionDisplay);
            ungrey_gadget(main_window_id, FrameRateMenu);
            ungrey_gadget(main_window_id, FrameRateDisplay);
        }
    }
    else
    {
        /* Auto */
        grey_gadget(main_window_id, ColourMenu);
        grey_gadget(main_window_id, ColourDisplay);
        grey_gadget(main_window_id, ResolutionMenu);
        grey_gadget(main_window_id, ResolutionDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
        grey_gadget(main_window_id, FrameRateDisplay);
        menus_are_grey = true;
    }
    
    switch_monitor(rover);
    update_montype_tick(menu, gadget);

    return 1;
}

static int res_menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    char string[256];
    int  gadget = id_block->self_component;

    /* Update the displayfield to show the new choice */
    error_trap(menu_get_entry_text(0, res_menu_id, gadget, string, sizeof(string), 0), 0);
    error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, string), 0);
    switch_resolution();
    error_trap(menu_set_tick(0, res_menu_id, current_res, 0), 0);
    error_trap(menu_set_tick(0, res_menu_id, gadget, 1), 0);

    current_res = gadget;

    return 1;
}

static int col_menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    char string[256];
    int  gadget = id_block->self_component;

    /* Update the displayfield to show the new choice */
    error_trap(menu_get_entry_text(0, col_menu_id, gadget, string, sizeof(string), 0), 0);
    error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, string), 0);
    switch_colour(gadget);
    error_trap(menu_set_tick(0, col_menu_id, current_colours, 0), 0);
    error_trap(menu_set_tick(0, col_menu_id, gadget, 1), 0);

    current_colours = gadget;

    return 1;
}

static int hz_menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    char string[256];
    int  gadget = id_block->self_component;

    /* Update the displayfield to show the new choice */
    error_trap(menu_get_entry_text(0, hz_menu_id, gadget, string, sizeof(string), 0), 0);
    error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, string), 0);
    current_hz = atoi(string);
    for (int i=0; i<hz_menu_entries; i++)
    {
        error_trap(menu_set_tick(0, hz_menu_id, i, (i==gadget?1:0)), 0);
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * menu_submenu                                                              *
 *                                                                           *
 * Event raised before the screensaver info submenus are opened.             *
 *---------------------------------------------------------------------------*/

static int menu_submenu(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int gadget = id_block->self_component;

    fill_in_saver_info(saver_info_id, gadget);

    return 1;
}


/*---------------------------------------------------------------------------*
 * adjuster_clicked                                                          *
 *                                                                           *
 * Handle events caused by clicks on adjuster arrows.                        *
 *---------------------------------------------------------------------------*/

static int adjuster_clicked(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    AdjusterClickedEvent *block = (AdjusterClickedEvent*) event_block;
    int                   gadget = id_block->self_component;
    char                  string[16];

    if ((gadget!=TimeAdjusterDown) && (gadget!=TimeAdjusterUp)) return 1;

    if (block->direction) blanktime++;
    else blanktime--;

    if (blanktime>7) blanktime = 7;
    if (blanktime<0) blanktime = 0;

    sprintf(string, "BTime%d", blanktime);
    error_trap(displayfield_set_value(0, main_window_id, BlankDelayDisplay, messages_lookup(string)), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        gadget = id_block->self_component;

    switch (gadget)
    {
        case SetButton:
            save_choices();
            if ( ((block->hdr.flags & Flag_ReturnKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
                program_exit();
            }
            break;

        case CancelButton:
            restore_choices();
            if ( ((block->hdr.flags & Flag_EscapeKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
                program_exit();
            }
            else if (block->hdr.flags & Flag_RightButton)
            {
                /* Right click, so restore original settings */
                read_choices();
                read_current_mode_settings(FTR_CONFIG);
                discard_screenmodes_instantiation();
                create_screenmodes_instantiation();
                create_resolutions_menu();
                update_monitor_displayfields();
                update_dpms_status();
            }
            break;

        case DefaultButton:
            set_default_choices();
            break;

        case DisplayTryButton:
            try_display_settings();
            break;

        case SaverSettingsButton:
            load_settings_app();
            break;

        case SaverTryButton:
            try_it();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * dpms_action_selected                                                      *
 *                                                                           *
 * Handler for when action buttons are clicked on in the dpms saver settings *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int dpms_action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        gadget = id_block->self_component;

    switch(gadget)
    {
        case DPMSDefaultButton:
            error_trap(optionbutton_set_state(0, dpms_window_id, DPMSUnblankButton, 0), 0);
            break;

        case DPMSCancelButton:
            if ( ((block->hdr.flags & Flag_EscapeKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
                error_trap(toolbox_hide_object(0, dpms_window_id), 0);
            }
            else if (block->hdr.flags & Flag_RightButton)
            {
                error_trap(optionbutton_set_state(0, dpms_window_id, DPMSUnblankButton, unblank_on_writes), 0);
            }
            break;

        case DPMSSetButton:
            error_trap(optionbutton_get_state(0, dpms_window_id, DPMSUnblankButton, &unblank_on_writes), 0);
            if (unblank_on_writes)
            {
                _swix(OS_CLI, _IN(0), "Blanktime -W");
            }
            else
            {
                _swix(OS_CLI, _IN(0), "Blanktime -O");
            }
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/

static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, main_window_id, 0, 0, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_closedown                                                         *
 *                                                                           *
 * Handler for message_closedown, sent when a task exits. Check the exiting  *
 * task isn't a screensaver settings plug-in.                                *
 *---------------------------------------------------------------------------*/

static int message_closedown(WimpMessage *event, void *handler)
{
    if (event->hdr.sender==settings_handle) settings_handle = 0;

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();

    return 1;
}


/*-----------------------------------------------------------------------------------------------*/
/*                               Program startup & polling loop                                  */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    int  screenx;
    int  screeny;
    int  flags;
    ObjectTemplateHeader *objtemplate;
    WindowTemplate       *wintemplate;
    WimpWindow           *windef;

    /* Read the window object in by hand */
    error_trap(toolbox_template_lookup(0, "Window", (void **)&objtemplate), 1);
    if (objtemplate->object_class != Window_ObjectClass)
    {
        error_trap(common_error(messages_lookup("BadClass")), 1);
    }
    wintemplate = objtemplate->body;
    windef = &wintemplate->window;
    if (common_read_screensize(&screenx, &screeny) == NULL)
    {
        /* Calculate the window height compared with the screen and
         * turn the vertical scrollbar on if it doesn't fit
         */
        if ((windef->visible_area.ymax - windef->visible_area.ymin) >= screeny)
        {
            windef->flags |= WimpWindow_VScroll;
        }
        else
        {
            windef->flags &= ~WimpWindow_VScroll;
        }
    }
    error_trap(toolbox_create_object(Toolbox_CreateObject_InCore, objtemplate, &main_window_id), 1);

    /* Create sub-window/gadgets */
    error_trap(toolbox_create_object(0, "Window", &main_window_id), 1);
    error_trap(toolbox_create_object(0, "ColMenu", &col_menu_id), 1);
    error_trap(toolbox_create_object(0, "MonTypeMenu", &montype_menu_id), 1);
    error_trap(toolbox_create_object(0, "ResMenu", &res_menu_id), 1);
    error_trap(toolbox_create_object(0, "InfoMenu", &info_menu_id), 1);
    error_trap(toolbox_create_object(0, "SaverInfo", &saver_info_id), 1);
    error_trap(toolbox_create_object(0, "MainMenu", &main_menu_id), 1);
    error_trap(toolbox_create_object(0, "HzMenu", &hz_menu_id), 1);
    error_trap(toolbox_create_object(0, "DPMS", &dpms_window_id), 1);
    error_trap(popup_set_menu(0, main_window_id, MonitorTypeMenu, montype_menu_id), 1);
    error_trap(popup_set_menu(0, main_window_id, ResolutionMenu, res_menu_id), 1);
    error_trap(popup_set_menu(0, main_window_id, ColourMenu, col_menu_id), 1);
    error_trap(popup_set_menu(0, main_window_id, FrameRateMenu, hz_menu_id), 1);
    error_trap(window_set_menu(0, main_window_id, main_menu_id), 1);
    error_trap(menu_set_sub_menu_show(0, main_menu_id, 0, info_menu_id), 1);

    /* Register handlers */
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);
    error_trap(event_register_toolbox_handler(main_window_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window_id, Adjuster_Clicked, adjuster_clicked, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window_id, StringSet_ValueChanged, string_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(montype_menu_id, Menu_Selection, montype_menu_select, NULL), 0);
    error_trap(event_register_toolbox_handler(res_menu_id, Menu_Selection, res_menu_select, NULL), 0);
    error_trap(event_register_toolbox_handler(col_menu_id, Menu_Selection, col_menu_select, NULL), 0);
    error_trap(event_register_toolbox_handler(hz_menu_id, Menu_Selection, hz_menu_select, NULL), 0);
    error_trap(event_register_toolbox_handler(dpms_window_id, ActionButton_Selected, dpms_action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(info_menu_id, Menu_SubMenu, menu_submenu, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MTaskCloseDown, message_closedown, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);
    error_trap(event_register_wimp_handler(main_window_id, Wimp_ECloseWindow, close_window, NULL), 0);

    /* Check OS support for EDID */
    flags = 0; /* In case of error */
    _swix(ScreenModes_Features, _OUT(0), &flags);
    support_edid = (flags & ScreenModes_Features_EDID) != 0;

    /* Make monitor choice invariant menus */
    create_monitors_menu();
    current_montype_menu_id = montype_menu_id; current_montype = 0; /* Auto */
    create_savers_menu();
    build_info_menu(main_menu_id, info_menu_id, saver_info_id);
    update_settings_icon();
    
    /* Read in the choices, populate and show dialogue */
    read_choices();
    read_current_mode_settings(FTR_CONFIG);
    create_screenmodes_instantiation();
    create_resolutions_menu();
    create_hz_menu();
    update_monitor_displayfields();
    update_dpms_status();
    if ((at_x==-1) && (at_y==-1))
    {
        /* No position supplied in the command line, just centre it */
        error_trap(toolbox_show_object(0, main_window_id, Toolbox_ShowObject_Centre, NULL, 0, 0), 0);
    }
    else
    {
        int  buffer[2];

        buffer[0] = at_x;
        buffer[1] = at_y;
        error_trap(toolbox_show_object(0, main_window_id, Toolbox_ShowObject_TopLeft, buffer, 0, 0), 0);
    }
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * In: Nothing.                                                              *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MOpenConfigWindow,
                                Wimp_MTaskCloseDown,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
            	                ActionButton_Selected,
            	                StringSet_ValueChanged,
                                Adjuster_Clicked,
                                Menu_Selection,
                                Menu_SubMenu,
                                0};
    int        task_handle;

    messages_register(&messages_desc, messages_string);
    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<ScrnSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, 0) ,1);


    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MTaskCloseDown, message_closedown, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;
    char         *var;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat")==0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;

    /* Make a note of the current setting for ScrSaver$Dir */
    var = getenv("ScrSaver$Dir");
    if (!var)
      orig_saver[0] = '\0';
    else
    {
      if (sizeof(orig_saver) <= snprintf(orig_saver, sizeof(orig_saver), "%s", var)) return 0;
    }

    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }

    return 0;
}
@


1.19
log
@Add support for EDID monitors in the system
Detail:
  Upgrade the MDF directory enumeration to minimally parse EDID data blobs. Add these to the list of known monitors. This allows a disc based MDF to override faulty data in the monitor, or on systems such as IOMD that don't support EDID, for them to benefit from a library of blobs rather than needing a parallel set of MDFs creating.
  Add the path of EDID blobs exported by ScrModes to those scanned for monitor definitions. EDID data is always placed in the top level manufacturer menu below 'Auto'.
  Add interactive help to clarify what 'Auto' means and how it differs from the EDID data.

  common.c: Relocate [un]grey_gadget() from screen.c.
  main.c: Simplify unnecessary memset(). Create a flag based on ScreenModes_Features whether the host OS supports EDID or not.
  monitor.c: Extra scanning. Conflict resolution if duplicate monitor definitions exist from differing sources. Simple EDID parser to get the monitor name (else default string) and DPMS flags.
Admin:
  Submission for the EDID bounty.
  Tested with ScrModes-0_61, and also on earlier versions, on RISC OS 5.23.
  Briefly tested on RISC OS 3.70 with !Boot.Resources.Configure.Monitors containing EDID data (should be ignored).

Version 0.40. Tagged as 'ScrnSetup-0_40'
@
text
@d622 2
a623 1
    char string[256];
d636 9
a644 2
    error_trap(menu_get_entry_text(0, menu, gadget, string, sizeof(string), 0), 0);
    error_trap(displayfield_set_value(0, main_window_id, MonitorTypeDisplay, string), 0);
d649 1
a649 1
        if (strcmp(rover->monitor_name, string) == 0) break;
@


1.18
log
@Fix for Auto setting not being stored
3rd time's a charm: in changing from a stringset changed to a menu selection event, nothing was updating the globals holding the monitor details for the Auto case calling switch_monitor(). Move that call so it is.
Change menus_are_grey to a boolean.

Version 0.39. Tagged as 'ScrnSetup-0_39'
@
text
@d36 1
d79 1
d245 3
a247 3
    char set_string[1024];
    char blanktime_string[32];
    char mem_string[64];
a252 4
    memset(set_string, 0, 1024);
    memset(mem_string, 0, 64);
    memset(blanktime_string, 0, 32);

d948 1
d1009 5
@


1.17
log
@Fix for thinking 0th model is Auto type
The current_montype variable now holds the entry number within the menu for the selected manufacturer, whereas it used to be the current entry for the 1 (and only) models menu.
So, when selecting any 0th model from a submenu this would be mistaken as the former 'Auto' entry, and the PreDesk$Configure file wiped out.

Rescope current_montype to be static so it can only be used for its intended purpose, and derive 'Auto' or not in set_monitor_choices() by whether the filename is NULL like elsewhere.
Use defines when calling OS_ScreenMode rather than magic numbers.
Should fix issue described in https://www.riscosopen.org/forum/forums/11/topics/6370 introduced in ScrnSetup-0_36.

Version 0.38. Tagged as 'ScrnSetup-0_38'
@
text
@a72 1
int               menus_are_grey = 0;
d77 1
d269 1
a656 1
        switch_monitor(rover);
d667 1
a667 1
        menus_are_grey = 1;
d670 1
@


1.16
log
@Make the previous selection more obvious
Having chosen a monitor type from within a group, it wasn't very obvious from which group it came.
Follow the same behaviour as a font menu: tick the parent when an exclusive selection is made from its child.

Version 0.37. Tagged as 'ScrnSetup-0_37'
@
text
@d62 1
a73 1
int               current_montype;
@


1.15
log
@Group manufacturers together in the type menu
The plugin scans all the subdirectories of BootResources:Configure.Monitors but then presents the findings unsorted in a huge menu. Now there are lots of MDFs the menu is so big it has a scrollbox too.
To simplify this, and make finding the right one easier, collect up the monitors by manufacturer (inferred from name of the topmost directory) into submenus.
Tested on a Risc PC with a mix of complexities of subdirectories from a default !Boot.

Version 0.36. Tagged as 'ScrnSetup-0_36'
@
text
@d61 1
d65 1
a72 1
int               current_montype_menu_id;
d130 37
d630 3
a632 2
        /* Don't accept selections on the group manufacturer name */
        return 0;
d669 2
a670 5
    error_trap(menu_set_tick(0, current_montype_menu_id, current_montype, 0), 0);
    error_trap(menu_set_tick(0, menu, gadget, 1), 0);

    current_montype = gadget;
    current_montype_menu_id = menu;
@


1.14
log
@Make monitor type into a display field + popup menu
Was previously a StringSet, but these are limited to only one level of menu tree.
Turned off "Deliver event before showing" for the popups in the main window, since nothing registered events against them.
No longer spends an eternity rebuilding the monitors menu when adjust clicking on 'Cancel', because the read_choices() function also used to scan the MDFs to make the menu. Now it really does just read the choices back in.
Correction to interactive help for the "Resolution" menu - the guidance about square and rectangular pixels was back to front.

Version 0.35. Tagged as 'ScrnSetup-0_35'
@
text
@d71 2
a72 1
int               current_montype = 0;
d582 1
a582 1
static int montype_menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
d586 2
a587 1
    int  gadget = id_block->self_component;
d589 7
d597 1
a597 1
    error_trap(menu_get_entry_text(0, montype_menu_id, gadget, string, sizeof(string), 0), 0);
d630 2
a631 2
    error_trap(menu_set_tick(0, montype_menu_id, current_montype, 0), 0);
    error_trap(menu_set_tick(0, montype_menu_id, gadget, 1), 0);
d634 1
d975 1
@


1.13
log
@Leave the selected monitor type correct after hitting 'Set'
When the monitor type is Auto at startup (type=3) and the user selects a monitor from an MDF (type=7) when pressing 'Set' the temporary instance of the ScreenModes module is killed off (in program_exit()) which restores the monitor type back to what it was when starting (type=3). That leaves DisplayManager thinking there's an MDF loaded, but the base instance of ScreenModes thinking not.
main.c/defines.h:
Minor unrelated clean ups.
monitor.c:
When saving the settings, kill off the temporary instance, apply the setting, then create a new one - this is much like adjust clicking on cancel does.
Complete a TODO with an error message if the settings file wont open.
Messages;
New error token for the TODO.

Fixes ticket #372.

Version 0.30. Tagged as 'ScrnSetup-0_30'
@
text
@d63 1
d71 2
a72 1
int               currently_ticked = 0;
d263 1
a263 1
    error_trap(displayfield_set_value(0, main_window_id, BlankDelayDisplay, "30 sec."), 0);
a321 1
    char *menustring;
a324 17
    /* Make monitors menu */
    menustring = malloc(read_monitors_list());
    if (!menustring) return;
    make_monitors_menu(menustring);
    error_trap(stringset_set_available(0, main_window_id, MonitorTypeStringSet, menustring), 0);
    free(menustring);

    /* Make screensaver menu */
    menustring = malloc(read_savers_list()+16);
    if (!menustring) return;
    make_savers_menu(menustring);
    error_trap(stringset_set_available(0, main_window_id, SaverTypeStringSet, menustring), 0);
    free(menustring);
    build_info_menu(main_menu_id, info_menu_id, saver_info_id);

    update_settings_icon();

d331 1
a331 1
            more=(int)fgets(string, 1024, fp);
a562 1
    int selected;
a568 28

        case MonitorTypeStringSet:
            error_trap(stringset_get_selected(1, main_window_id, MonitorTypeStringSet, &selected), 0);
            if (selected==0)
            {
                grey_gadget(main_window_id, ColourMenu);
                grey_gadget(main_window_id, ColourDisplay);
                grey_gadget(main_window_id, ResolutionMenu);
                grey_gadget(main_window_id, ResolutionDisplay);
                grey_gadget(main_window_id, FrameRateMenu);
                grey_gadget(main_window_id, FrameRateDisplay);
                menus_are_grey = 1;
            }
            else
            {
                if (menus_are_grey)
                {
                    ungrey_gadget(main_window_id, ColourMenu);
                    ungrey_gadget(main_window_id, ColourDisplay);
                    ungrey_gadget(main_window_id, ResolutionMenu);
                    ungrey_gadget(main_window_id, ResolutionDisplay);
                    ungrey_gadget(main_window_id, FrameRateMenu);
                    ungrey_gadget(main_window_id, FrameRateDisplay);
                }
                switch_monitor(selected-1);
            }
            break;

d581 48
d635 1
a635 1
    error_trap(menu_get_entry_text(0, res_menu_id, gadget, string, 256, 0), 0);
d638 1
a638 1
    error_trap(menu_set_tick(0, res_menu_id, currently_ticked, 0), 0);
d641 1
a641 1
    currently_ticked = gadget;
d652 1
a652 1
    error_trap(menu_get_entry_text(0, col_menu_id, gadget, string, 256, 0), 0);
d669 1
a669 1
    error_trap(menu_get_entry_text(0, hz_menu_id, gadget, string, 256, 0), 0);
d934 1
d941 1
d953 1
d963 6
@


1.12
log
@Correction to system variable name
Allocated application name and system variable name sync'd

Version 0.27. Tagged as 'ScrnSetup-0_27'
@
text
@d116 1
a116 1
        ungrey_gadget(main_window_id, SettingsButton);
d120 1
a120 1
        grey_gadget(main_window_id, SettingsButton);
d208 1
a208 1
    int  blanktime_to_seconds[8] = {0, 30, 60, 120, 300, 600, 900, 1800};
d750 1
a750 1
                /* Right click, so restore oringial settings */
d769 1
a769 1
        case SettingsButton:
@


1.11
log
@Minor ScrnSetup improvements
* Get OS_Byte/OS_File/filetypes/CMOS/OS_Module defs from header files.
* Fix ticket #312 (misuse of OS_GBPB means enumerating dirs on a non FileCore filing system could get stuck).
* Simplify the steps in the mode 'Try' sequence, now the mouse is bounded in the 'Keep/Cancel' message box (with the same 5s timeout) so that you can't click elsewhere on the main window. Previously, you could click 'Set', then the 5s would elapse and the mode revert to not the one you set.
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed.

Note that in reviewing the plugins the minimum resolution considered to fit without scroll bars is 640x480, a special case is made of the screen setup plugin in case it starts in some mode less than that and you can't reach the 'OK' button to set it to anything else.

Version 0.25. Tagged as 'ScrnSetup-0_25'
@
text
@d1008 1
a1008 1
                                  "<ScreenConfig$Dir>", &messages_desc, &idb,
@


1.10
log
@Fix null pointer dereference when monitor is unknown. Be more sensible when setting/testing mode.
Detail:
  c/monitor - Added a few checks to make sure current_monitor_file isn't null before we try accessing it. Make sure monitor is reset to "Auto" if switching to a set of settings where no MDF is loaded.
  c/monitor, h/monitor - Updated set_monitor_choices to only complain about unspecified mode settings if an MDF is in use. Return true/false for whether the settings were applied or not.
  c/main - Make use of set_monitor_choices return code to decide whether the 5 second "try" timeout is needed or not. Make sure selected monitor gets reset when switching between different settings during the various "try" stages.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.23. Tagged as 'ScrnSetup-0_23'
@
text
@d33 3
a47 1
#define CMOSBlankTimeByte 188
d215 1
a215 1
    cmosvalue = read_cmos_value(CMOSBlankTimeByte);
d218 1
a218 1
    write_cmos_value(CMOSBlankTimeByte, cmosvalue);
d374 1
a374 1
    blanktime = (read_cmos_value(CMOSBlankTimeByte) & BlankTimeBits) >> 3;
d418 1
a418 1
    _swix(OS_File, _INR(0,1)|_OUT(0), 17, pathname, &type);
d421 1
a421 1
    error_trap(_swix(OS_File, _INR(0,1)|_IN(4), 8, ChoicesDir, 0), 0);
d447 2
a448 1
    int event, time, now, button;
d460 7
a466 1
    error_trap(_swix(Wimp_ReportError, _INR(0,5)|_OUT(1), &err_blk, 0x39B, taskname, "co_screen", 1, 0, &button), 1);
d470 1
a470 20
    if(!set_monitor_choices(FTW_SCRAP)) return;

    /* Redraw the desktop at the new resolution and pause for 5 seconds */
    error_trap(_swix(OS_ReadMonotonicTime, _OUT(0), &time), 1);
    time += DisplayTestDuration;
    do {
        error_trap(_swix(Wimp_PollIdle, _INR(0,3)|_OUT(0), NULL_MASK, wimp_blk, time, 0, &event), 1);
        error_trap(_swix(OS_ReadMonotonicTime, _OUT(0), &now), 1);
    } while ((now < time) && (event != 0));

    /* Restore the original settings */
    read_current_mode_settings(FTR_CONFIG);
    discard_screenmodes_instantiation();
    create_screenmodes_instantiation();

    /* Make sure our icons contain the right details (required for set_monitor_choices) */
    create_resolutions_menu();
    update_monitor_displayfields();

    set_monitor_choices(FTW_NONE);
d473 2
a474 1
    do {
d478 3
a480 1
    /* Was the user happy with the new screen mode? */
d485 21
a505 1
    error_trap(_swix(Wimp_ReportError, _INR(0,5)|_OUT(1), &err_blk, 0x998, taskname, "co_screen", 1, buttons, &button), 1);
d507 2
a508 1
    {   /* Go with the new settings */
d510 6
a515 2
        discard_screenmodes_instantiation();
        create_screenmodes_instantiation();
d517 2
a518 3
        /* Make sure our icons contain the right details (required for set_monitor_choices) */
        create_resolutions_menu();
        update_monitor_displayfields();
d520 1
a520 4
        set_monitor_choices(FTW_NONE);
    }

    /* Make sure our icons contain the right details */
d524 2
d527 1
a527 1
    _swix(OS_File, _INR(0,1), 6, ScrapConfigFile);
a897 1
    BBox bbox;
d900 27
a926 1
    int  buffer[2];
d928 1
a928 1
    /* Create window */
a942 8
    read_choices();
    read_current_mode_settings(FTR_CONFIG);
    create_screenmodes_instantiation();
    create_resolutions_menu();
    create_hz_menu();
    update_monitor_displayfields();
    update_dpms_status();

d957 8
a964 1
    /* Work out positioning (unless it was supplied in the command line) */
d967 2
a968 4
        error_trap(common_read_screensize(&screenx, &screeny), 0);
        error_trap(window_get_extent(0, main_window_id, &bbox), 0);
        at_y = screeny - ((screeny+bbox.ymin)/2);
        at_x = (screenx - bbox.xmax)/2;
d970 3
d974 4
a977 4
    /* Show the window */
    buffer[0] = at_x;
    buffer[1] = at_y;
    error_trap(toolbox_show_object(0, main_window_id, 2, buffer, 0, 0), 0);
@


1.9
log
@Only create ScrSavers in choices when the plugin needs it
Really, the screen saver setup apps should do this themselves, but this plugin can at least defer the create until it's reasonably sure it's needed.

Version 0.22. Tagged as 'ScrnSetup-0_22'
@
text
@d461 1
a461 1
    set_monitor_choices(FTW_SCRAP);
d475 5
d498 5
@


1.8
log
@Fix null pointer dereference on startup
Detail:
  c/main - Command line parsing now checks if enough arguments exist before attempting to look for an -openat option
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.20. Tagged as 'ScrnSetup-0_20'
@
text
@d414 1
a414 1
    if (savername==0) return;
d418 3
a967 3
    /* Check the choices directory exists for the screensavers */
    error_trap(_swix(OS_File, _INR(0,1)|_IN(4), 8, ChoicesDir, 0), 0);

@


1.7
log
@Internationalised the screensaver blank times.
When reading choices, read from Choices:.
If no screensaver is set then adjustclicking on 'Cancel' now correctly restores the DPMS saver as the default.
Use OS_FSControl instead of OS_CLI(*COPY).
'Auto' and 'Unknown' put in messages file.

Version 0.19. Tagged as 'ScrnSetup-0_19'
@
text
@d987 1
a987 1
    if (strcmp(argv[1], "-openat")==0)
@


1.6
log
@Get error box title from "_TaskName" token in messages file.
Use Mask_NoNullEvents/Gadget_Faded flag from toolbox headers.
Use OSFile 8 to create directories not OS_CLI.
Code in 'common.[c|h]' made more common.

Version 0.18. Tagged as 'ScrnSetup-0_18'
@
text
@a71 9
static char      *blanktime_to_text[8] = {"Off",
                                          "30 sec.",
                                          "1 min.",
                                          "2 min.",
                                          "5 min.",
                                          "10 min.",
                                          "15 min.",
                                          "30 min."};

d340 1
a340 1
    fp=fopen(ChoicesFile, "r");
d353 5
d373 1
d375 1
a375 1
                                      blanktime_to_text[blanktime]), 0);
d402 1
a402 1
    /* FInd out which blanker is selected */
d675 1
d685 2
a686 1
    error_trap(displayfield_set_value(0, main_window_id, BlankDelayDisplay, blanktime_to_text[blanktime]), 0);
@


1.5
log
@Add framerate selection to ScrnSetup plugin. Update to take version number from VersionNum file.
Detail:
  c/main, c/monitor, h/defines, h/monitor, Resources/UK/Res,fae - Added an extra box to the display settings are to allow selection of screen refresh rate.
  Makefile, Resources/UK/Messages - Updated so that version number is taken from the VersionNum file instead of being hard-coded in the messages file.
Admin:
  Tested on Iyonix. New plugin seems to work OK with parsing both the old and new WimpMode lines, as well as when the PreDesk.Configure.Monitor file is missing altogether.


Version 0.16. Tagged as 'ScrnSetup-0_16'
@
text
@d953 1
a960 1
    messages_register(&messages_desc, messages_string);
d966 2
a967 1
    check_scrsaver_choices_dir();
@


1.4
log
@Fix bug in "Try" button for screensavers.

If you select a screensaver from the menu and 'try' it, then decide to
cancel the plug-in, the last selected screensaver is left as the current
saver, rather than restoring what you had configured originally. A reboot
would sort it out, but that's a little OTT. Fixed.

Version 0.15. Tagged as 'ScrnSetup-0_15'
@
text
@d65 1
d70 2
d569 2
d581 2
d634 17
d882 1
d886 1
d894 1
d905 1
@


1.3
log
@Added low res sprites.
Changed RMEnsure level to UtilityModule 3.50 as this relies on OS_ScreenMode
The colour depth menu will now have entries greyed out when the
list of mode descriptions given to it indicates there are some colour
depths unachieveable on this hardware.

Version 0.11. Tagged as 'ScrnSetup-0_11'
@
text
@d55 1
d181 18
d691 1
d956 1
d968 9
a987 1

@


1.2
log
@Addition of "Try" button to the mode settings frame,similar in principal
to the "Try" button for the screen saver.
Associated Res file change.

Version 0.10. Tagged as 'ScrnSetup-0_10'
@
text
@d61 1
d67 1
d543 2
a544 1
                grey_gadget(main_window_id, ColoursStringSet);
d553 2
a554 1
                    ungrey_gadget(main_window_id, ColoursStringSet);
a561 4
        case ColoursStringSet:
            error_trap(stringset_get_selected(1, main_window_id, ColoursStringSet, &selected), 0);
            switch_colour(selected);
            break;
d574 1
a574 1
static int menu_select(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
d591 17
d833 1
d840 1
d856 2
a857 1
    error_trap(event_register_toolbox_handler(res_menu_id, Menu_Selection, menu_select, NULL), 0);
@


1.1
log
@Initial revision
@
text
@d23 2
d46 5
d61 3
d117 1
a117 1
        ungrey_gadget(main_window_id, SettingsOption);
d121 1
a121 1
        grey_gadget(main_window_id, SettingsOption);
d123 1
a123 1
}    
d140 1
a140 1
    
d161 1
a161 1
    
d202 1
a202 1
    
d224 1
a224 1
    write_monitor_choices();
d260 1
a260 1
    
d281 1
a281 1
    {    
d289 1
a289 1
    
d305 1
a305 1
    int   more = 1;    
d313 1
a313 1
        
d320 1
d323 1
a323 1
 
d345 1
a345 1
                    error_trap(_swix(OS_CLI, _IN(0), string), 0); 
d350 1
a350 1
    }        
d380 1
a380 1
    
d394 1
a394 1
    sprintf(pathname, "%s.!Settings",savername);
d412 68
d536 1
a536 1
            
d553 1
a553 1
                }            
d557 1
a557 1
            
d586 18
d618 1
a618 1
    
d620 1
a620 1
    
d623 1
a623 1
    
d626 1
a626 1
    
d628 1
a628 1
    
d648 4
a651 2
            if ((block->hdr.flags & 7)==0) program_exit(); /* Return pressed */
            if (block->hdr.flags & 4) program_exit();      /* Left button */
d655 15
a669 7
            read_choices();
            read_current_mode_settings();
            discard_screenmodes_instantiation();
            create_screenmodes_instantiation();
            if ((block->hdr.flags & 7)==0) program_exit();             /* Escape pressed */
            if (block->hdr.flags & 1)      create_resolutions_menu();  /* Right button */
            if (block->hdr.flags & 4)      program_exit();             /* Left button */
d671 1
a671 1
            
d675 6
a680 2
            
        case SettingsOption:
d683 2
a684 2
            
        case TryButton:
d710 1
a710 1
            
d712 2
a713 1
            if ((block->hdr.flags & 7)==0)                  /* Escape pressed */
d715 3
a717 1
            if (block->hdr.flags & 1)                       /* Right button */
d719 1
a719 2
            if (block->hdr.flags & 4)                       /* Left button */
                error_trap(toolbox_hide_object(0, dpms_window_id), 0);
d721 1
a721 1
            
d725 1
d727 1
d729 1
d731 1
d744 1
a744 1
 
d748 1
a748 1
    
d778 1
a778 1
    
d792 1
a792 1
    
d817 4
a820 1
    error_trap(toolbox_create_object(0, DPMSString, &dpms_window_id), 1);
d822 2
d826 1
a826 1
    read_current_mode_settings();
a833 1
    error_trap(event_register_wimp_handler(main_window_id, Wimp_ECloseWindow, close_window, NULL), 0);
d838 2
d842 1
a842 1
    error_trap(event_register_toolbox_handler(dpms_window_id, ActionButton_Selected, dpms_action_selected, NULL), 0);
d881 1
d884 1
a884 1
                                
d891 1
a891 1
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);    
d902 1
a902 1
                                  
d926 1
a926 1
    
d935 1
a935 1
    
@


1.1.1.1
log
@Initial import of ScrnSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Resolution menu now same order as display manager.
@
text
@a22 1
/*          23-Apr-98: RML: Fixed bug with menu selections of resolutions.   */
a505 2
    
    currently_ticked = gadget;
@


1.1.1.3
log
@Screensaver settings plug-ins now called SvrSetup.
@
text
@d384 1
a384 1
    sprintf(pathname, "%s.!SvrSetup",savername);
@


1.1.1.4
log
@An Info menu is provided for screensavers author, version etc.
Clicks on Cancel only re-read settings if click was with adjust.
Bug fix: Screensaver !Run files were left open after reading Wimpslot size.
@
text
@a23 1
/*          03-Jun-98: RML: Added Info menu for screensavers.                */
a44 5
#define Flag_EscapeKey    7
#define Flag_ReturnKey    7
#define Flag_LeftButton   4
#define Flag_RightButton  1

a54 3
int               info_menu_id;
int               main_menu_id;
int               saver_info_id;
d108 1
a108 1
        ungrey_gadget(main_window_id, SettingsButton);
d112 1
a112 1
        grey_gadget(main_window_id, SettingsButton);
a310 1
    build_info_menu(main_menu_id, info_menu_id, saver_info_id);
a514 16
 * menu_submenu                                                              *
 *                                                                           *
 * Event raised before the screensaver info submenus are opened.             *
 *---------------------------------------------------------------------------*/

static int menu_submenu(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int gadget = id_block->self_component;

    fill_in_saver_info(saver_info_id, gadget);

    return 1;
}


/*---------------------------------------------------------------------------*
d554 2
a555 4
            if ( ((block->hdr.flags & Flag_ReturnKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
                program_exit();
            }
d559 7
a565 15
            if ( ((block->hdr.flags & Flag_EscapeKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
                program_exit();
            }
            else if (block->hdr.flags & Flag_RightButton)
            {
                /* Right click, so restore oringial settings */
                read_choices();
                read_current_mode_settings();
                discard_screenmodes_instantiation();
                create_screenmodes_instantiation();
                create_resolutions_menu();
                update_monitor_displayfields();
                update_dpms_status();
            }
d572 1
a572 1
        case SettingsButton:
d604 1
a604 2
            if ( ((block->hdr.flags & Flag_EscapeKey)==0) || (block->hdr.flags & Flag_LeftButton) )
            {
d606 1
a606 3
            }
            else if (block->hdr.flags & Flag_RightButton)
            {
d608 2
a609 1
            }
a614 1
            {
a615 1
            }
a616 1
            {
a617 1
            }
d703 1
a703 4
    error_trap(toolbox_create_object(0, "InfoMenu", &info_menu_id), 1);
    error_trap(toolbox_create_object(0, "SaverInfo", &saver_info_id), 1);
    error_trap(toolbox_create_object(0, "MainMenu", &main_menu_id), 1);
    error_trap(toolbox_create_object(0, "DPMS", &dpms_window_id), 1);
a704 2
    error_trap(window_set_menu(0, main_window_id, main_menu_id), 1);
    error_trap(menu_set_sub_menu_show(0, main_menu_id, 0, info_menu_id), 1);
d715 1
a719 2
    error_trap(event_register_toolbox_handler(dpms_window_id, ActionButton_Selected, dpms_action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(info_menu_id, Menu_SubMenu, menu_submenu, NULL), 0);
d722 1
a722 1
    error_trap(event_register_wimp_handler(main_window_id, Wimp_ECloseWindow, close_window, NULL), 0);
a760 1
                                Menu_SubMenu,
@

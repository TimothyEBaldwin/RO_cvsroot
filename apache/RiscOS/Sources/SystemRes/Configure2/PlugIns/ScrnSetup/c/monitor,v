head	1.21;
access;
symbols
	ScrnSetup-0_43:1.21
	ScrnSetup-0_42:1.21
	ScrnSetup-0_41:1.20
	ScrnSetup-0_40:1.19
	ScrnSetup-0_39:1.18
	ScrnSetup-0_38:1.17
	ScrnSetup-0_37:1.16
	ScrnSetup-0_36:1.15
	ScrnSetup-0_35:1.14
	ScrnSetup-0_34:1.13
	ScrnSetup-0_33:1.13
	ScrnSetup-0_32:1.13
	ScrnSetup-0_31:1.13
	ScrnSetup-0_30:1.13
	ScrnSetup-0_29:1.12
	ScrnSetup-0_28:1.11
	ScrnSetup-0_27:1.10
	ScrnSetup-0_26:1.10
	ScrnSetup-0_25:1.10
	ScrnSetup-0_24:1.9
	ScrnSetup-0_23:1.9
	ScrnSetup-0_22:1.8
	ScrnSetup-0_21:1.8
	ScrnSetup-0_20:1.7
	ScrnSetup-0_19:1.7
	ScrnSetup-0_18:1.6
	ScrnSetup-0_17:1.5
	ScrnSetup-0_16:1.5
	ScrnSetup-0_15:1.4
	ScrnSetup-0_14:1.4
	ScrnSetup-0_13:1.3
	ScrnSetup-0_12:1.3
	ScrnSetup-0_11:1.3
	ScrnSetup-0_10:1.2
	ScrnSetup-0_09:1.1.1.5
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.5
	Ursula_RiscPC:1.1.1.5.0.2
	rthornb_UrsulaBuild-19Aug1998:1.1.1.5
	UrsulaBuild_FinalSoftload:1.1.1.5
	rthornb_UrsulaBuild-29Jul1998:1.1.1.5
	rthornb_UrsulaBuild-22Jul1998:1.1.1.5
	rleggett_ScrnSetup-0_08:1.1.1.5
	rthornb_UrsulaBuild-15Jul1998:1.1.1.4
	rthornb_UrsulaBuild-07Jul1998:1.1.1.4
	rthornb_UrsulaBuild-17Jun1998:1.1.1.4
	rleggett_ScrnSetup-0_07:1.1.1.4
	rthornb_UrsulaBuild-03Jun1998:1.1.1.4
	rthornb_UrsulaBuild-27May1998:1.1.1.4
	rthornb_UrsulaBuild-21May1998:1.1.1.4
	rthornb_UrsulaBuild_01May1998:1.1.1.3
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.21
date	2018.04.14.17.52.50;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	4WDNwmdnQD6f5ryA;

1.20
date	2017.04.08.20.14.38;	author rool;	state Exp;
branches;
next	1.19;
commitid	dMN8yIo9bZlfNLMz;

1.19
date	2017.03.05.15.35.50;	author rool;	state Exp;
branches;
next	1.18;
commitid	pXgDBRq60MdmlnIz;

1.18
date	2016.08.04.08.06.01;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	Vu6lBW12jz6xHXgz;

1.17
date	2016.08.02.17.54.25;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	O1Nr1KXUCG5o1Lgz;

1.16
date	2016.05.19.19.59.39;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	2IeQPndzgzxO787z;

1.15
date	2016.05.18.21.26.40;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	ZXaRZP5oar7ED07z;

1.14
date	2016.05.18.21.19.20;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	HMZqYtNJWkx7B07z;

1.13
date	2014.02.09.13.02.12;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	ureZvxROBfkGuqox;

1.12
date	2013.12.18.13.22.21;	author jlee;	state Exp;
branches;
next	1.11;
commitid	MJRQNzj7JbmejChx;

1.11
date	2013.12.15.22.12.06;	author jlee;	state Exp;
branches;
next	1.10;
commitid	KqO0dfOA3DjWkhhx;

1.10
date	2013.01.17.21.24.05;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	oUFvl5G78V97KBAw;

1.9
date	2012.08.28.20.57.43;	author jlee;	state Exp;
branches;
next	1.8;
commitid	4NuHSXS9qPu4amiw;

1.8
date	2012.07.22.09.46.33;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	h015P4FWeP2zDxdw;

1.7
date	2012.02.12.15.46.29;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	AITMkVfdGV9SNSSv;

1.6
date	2012.02.11.18.26.20;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	Tn70qsPfKA3JILSv;

1.5
date	2011.04.13.22.45.03;	author jlee;	state Exp;
branches;
next	1.4;
commitid	usaqYFvcXuqiVIfv;

1.4
date	2009.10.25.15.53.06;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.02.23.00.30;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.19.22.50.48;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.41.00;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.16.14.56.18;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.04.23.13.06.55;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.05.01.13.42.21;	author rleggett;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.07.22.10.39.32;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Improve fading logic when unselecting Native
When the previously configured mode was Native, in order to avoid accessing the colour flags array with a -ve index, the depth was arbitrarily set to 1bpp.
However, if the graphics controller doesn't support 1bpp the search would exit with no matches the the colour/frame rate popups remained greyed and unselectable.
Instead let the loop run up to the highest colour depth (16M), the best match logic will pick the best colour/frame rate combination, but more importantly the GUI controls will be activated.

Version 0.42. Tagged as 'ScrnSetup-0_42'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.monitor                                                        */
/* Purpose: Code for reading MDFs.                                           */
/* Author:  Richard Leggett                                                  */
/* History: 26-Nov-97: RML: Begun, borrowing lots of code from the previous  */
/*                          version of Configure.                            */
/*          12-Feb-98: RML: Changed saving of PreDesk config.                */
/*          16-Apr-98: RML: save_monitor_choices now also changes the to the */
/*                          new setup.                                       */
/*          01-May-98: RML: Bug fix.                                         */
/*          21-Jul-98: RML: Bug fix: Monitor name could be displayed wrong   */
/*                          if two very similar filenames existed.           */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/Services.h"
#include "Global/ModHand.h"
#include "Global/FileTypes.h"
#include "Global/VduExt.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "event.h"
#include "gadgets.h"
#include "menu.h"
#include "common.h"
#include "defines.h"
#include "monitor.h"
#include "screen.h"

#define flags_squarepixel ((unsigned)1<<31)
#define ORIGIN_EDID       2
#define ORIGIN_MDF        1

monitor_ref         *monitors_list = NULL;
static monitor_ref **monitors_list_tail = NULL;

static char *current_monitor_file = NULL;
static int   my_screenmodes_instantiation;
static char *desktop_instantiation;
static int   desktop_monitortype;
static int   nummodes=0;
static char *modes_block = NULL;
static int **modes_index;
static int   res_menu_entries=1;
static int   current_x_res, current_y_res, current_flags;   /* colours are 0-9 as per the menu */

typedef struct
{
    int ncolour;
    int modeflags;
    int log2bpp;
} gv_pixelformat;

typedef struct
{
    gv_pixelformat format;
    char *text,*alttext;
    bool iscolour;
}   colourchoice;

/* These are ordered by menu component index, which is also assumed to be in
   order of increasing number of colours */
static const colourchoice colourchoices[] = {
    { { 1, 0, 0 }, "C2", "G2", false },
    { { 3, 0, 1 }, "C4", "G4", false },
    { { 15, 0, 2 }, "G16", NULL, false },
    { { 15, 0, 2 }, "C16", NULL, true },
    { { 255, ModeFlag_FullPalette, 3 }, "G256", NULL, false },
    { { 255, ModeFlag_FullPalette, 3 }, "C256", NULL, true },
    { { 4095, 0, 4 }, "C4K", "C4T", true },
    { { 65535, 0, 4 }, "C32K", "C32T", true },
    { { 65535, ModeFlag_64k, 4 }, "C64K", "C64T", true },
    { { -1, 0, 5 }, "C16M", NULL, true },
};
#define num_colourchoices (sizeof(colourchoices)/sizeof(colourchoices[0]))

static const char *rgb_alpha_mode[4] = {
    "",
    " LTRGB",
    " LABGR",
    " LARGB",
};

extern int  main_window_id, dpms_window_id, montype_menu_entries, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_res, hz_menu_id, current_hz, hz_menu_entries;
extern bool menus_are_grey, support_edid;
extern void update_montype_tick(ObjectId, ComponentId);
extern int montype_menu_select(int, ToolboxEvent *, IdBlock *, void *);

/*---------------------------------------------------------------------------*
 * find_colours                                                              *
 *                                                                           *
 * Convert NColour, ModeFlags, Log2BPP triplet to colours menu item          *
 *---------------------------------------------------------------------------*/

static int find_colours(const gv_pixelformat format,bool iscolour)
{
    int best = -1;
    int modeflags = format.modeflags & (ModeFlag_FullPalette | ModeFlag_64k); /* Ignore RGB/alpha flags */
    for(int i=0;i<num_colourchoices;i++)
    {
        if((colourchoices[i].format.ncolour == format.ncolour)
        && (colourchoices[i].format.modeflags == modeflags)
        && (colourchoices[i].format.log2bpp == format.log2bpp))
        {
            best = i;
            /* Return this entry if it's an exact match for colour/greyscale
               choice */
            if(colourchoices[i].iscolour == iscolour)
            {
                return i;
            }
        }
    }

    return best;
}


/*---------------------------------------------------------------------------*
 * descriptor_to_pixelformat                                                 *
 *                                                                           *
 * Parse a mode descriptor to extract a gv_pixelformat                       *
 *---------------------------------------------------------------------------*/

static gv_pixelformat descriptor_to_pixelformat(const int *descriptor)
{
    gv_pixelformat format;
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        format.ncolour = descriptor[4];
        format.modeflags = descriptor[5];
        format.log2bpp = descriptor[6];
    }
    else
    {
        /* Old format */
        format.log2bpp = descriptor[4];
        format.modeflags = (format.log2bpp == 3?ModeFlag_FullPalette:0);
        format.ncolour = (1<<(1<<format.log2bpp))-1;
    }
    return format;
}


/*---------------------------------------------------------------------------*
 * descriptor_hz                                                             *
 *                                                                           *
 * Parse a mode descriptor to extract framerate                              *
 *---------------------------------------------------------------------------*/

static int descriptor_hz(const int *descriptor)
{
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        return descriptor[7];
    }
    else
    {
        /* Old format */
        return descriptor[5];
    }
}


/*---------------------------------------------------------------------------*
 * descriptor_name                                                           *
 *                                                                           *
 * Parse a mode descriptor to extract mode name                              *
 *---------------------------------------------------------------------------*/

static char *descriptor_name(const int *descriptor)
{
    if((descriptor[1] & 0xff) != 1)
    {
        /* New format */
        return (char *) (descriptor+8);
    }
    else
    {
        /* Old format */
        return (char *) (descriptor+6);
    }
}


/*---------------------------------------------------------------------------*
 * read_current_mode_settings                                                *
 *                                                                           *
 * Read current MDF and chosen resolution from the choices file in PreDesk.  *
 *---------------------------------------------------------------------------*/

void read_current_mode_settings(int file_to_read)
{
    FILE *fp;
    char *string;
    char  res0[256];
    char  res1[256];
    char  res2[256];
    char  res3[256];
    char  res4[256];
    char  buffer[1024];

    if (current_monitor_file) free(current_monitor_file);
    current_monitor_file=NULL;
    current_x_res = -1;
    current_y_res = -1;
    current_colours = -1;
    current_flags = 0;
    current_hz = -1;

    /* Read in the PreDesk or temporary config file */
    if (file_to_read == FTR_CONFIG)
      fp=fopen(PreDeskConfigFile, "r");
    else
      fp=fopen(ScrapConfigFile, "r");
    if (fp)
    {
        /* Scan forwards until we find the LoadModeFile command */
        do {
            if (!fgets(buffer, 1024, fp))
            {
                fclose(fp);
                return;
            }
        } while (strncmp(buffer, LoadModeCmd, strlen(LoadModeCmd)));
        
        if (buffer[strlen(buffer)-1]==NewLine)
            buffer[strlen(buffer)-1]=0;
        /* Get current selected MDF */
        string=strchr(buffer, ' ');
        if (!string)
        {
            fclose(fp);
            return;
        }
        current_monitor_file=malloc(strlen(string));
        if (!current_monitor_file)
        {
            fclose(fp);
            return;
        }
        strcpy(current_monitor_file, string+1);

        /* Next line should be a WimpMode command */
        fgets(buffer, 1024, fp);
        int offset;
        int count = sscanf(buffer, "%s%n %s %s %s %s", res0, &offset, res1, res2, res3, res4);

        if (strncmp(res0, WimpModeCmd, strlen(WimpModeCmd))==0)
        {
            int modeblock[14];

            /* Use the OS to parse the string if possible */
            if(!_swix(OS_ScreenMode,_INR(0,3),ScreenModeReason_ModeStringToSpecifier,buffer+offset,modeblock,sizeof(modeblock)))
            {
                current_x_res = modeblock[1];
                current_y_res = modeblock[2];
                current_hz = modeblock[4];
                /* Identify pixel format */
                gv_pixelformat format;
                format.log2bpp = modeblock[3];
                error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), modeblock, VduExt_NColour, &format.ncolour), 0);
                error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), modeblock, VduExt_ModeFlags, &format.modeflags), 0);
                current_colours = find_colours(format,!(format.modeflags & ModeFlag_GreyscalePalette));
            }
            /* Fall back on manual parsing */
            else if(((count == 4) || (count == 5))
                 && (res1[0]=='X')
                 && (res2[0]=='Y')
                 && (res3[0]=='C' || res3[0]=='G') )
            {
                /* Deal with resolution */
                current_x_res=atoi(res1+1);
                current_y_res=atoi(res2+1);
    
                /* Deal with colours */
                for(int i=0;i<num_colourchoices;i++)
                {
                    if (!strcmp(res3,colourchoices[i].text)
                        || (colourchoices[i].alttext && !strcmp(res3,colourchoices[i].alttext)))
                    {
                        current_colours = i;
                        break;
                    }
                }
    
                /* Deal with frame rate */
                if(res4[0]=='F') current_hz = atoi(res4+1);
            }

            /* Find out if selected mode is rectangular or square pixel */
            if ( current_x_res != -1 && current_y_res != -1 && current_colours != -1 )
            {
                int xeig, yeig;
    
                modeblock[0] = 1;
                modeblock[1] = current_x_res;
                modeblock[2] = current_y_res;
                modeblock[3] = colourchoices[current_colours].format.log2bpp;
                modeblock[4] = -1;
                modeblock[5] = VduExt_NColour;
                modeblock[6] = colourchoices[current_colours].format.ncolour;
                modeblock[7] = VduExt_ModeFlags;
                modeblock[8] = colourchoices[current_colours].format.modeflags;
                modeblock[9] = -1;
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, VduExt_XEigFactor, &xeig), 0);
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, VduExt_YEigFactor, &yeig), 0);
                if (xeig==yeig) current_flags |= flags_squarepixel;
            }
        }
        else
        {
            /* See if it's a live monitor showing best resolution, for which we emit a WimpModeCmdBest */
            if (strncmp(buffer, WimpModeCmdBest, strlen(WimpModeCmdBest))==0)
            {
                current_x_res = current_y_res = -2;
            }
        }
        fclose(fp);
    }
}


/*---------------------------------------------------------------------------*
 * update_monitor_displayfields                                              *
 *                                                                           *
 * Update all the monitor displayfields (monitor, resolution, colours, frame *
 * rate) according to the current settings.                                  *
 *---------------------------------------------------------------------------*/

void update_monitor_displayfields(void)
{
    monitor_ref *m;
    int          i;
    char         res_string[256];
    char         menu_string[256];
    bool         monitor_set = false;

    if ((current_x_res==-1) || (current_y_res==-1))
        error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, messages_lookup("Unk")), 0);

    if (current_colours<0)
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, messages_lookup("Unk")), 0);

    if (current_hz<0)
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, messages_lookup("Unk")), 0);

    if ((current_x_res==-2) && (current_y_res==-2))
    {
        /* Best available */
        error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, messages_lookup("Best")), 0);
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, messages_lookup("Auto")), 0);
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, messages_lookup("Auto")), 0);
        grey_gadget(main_window_id, ColourMenu);
        grey_gadget(main_window_id, ColourDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
        grey_gadget(main_window_id, FrameRateDisplay);
        menus_are_grey = true;
   }
   else
   {
        if (!current_monitor_file)
        {
            /* From "Auto" */
            grey_gadget(main_window_id, ColourMenu);
            grey_gadget(main_window_id, ColourDisplay);
            grey_gadget(main_window_id, ResolutionMenu);
            grey_gadget(main_window_id, ResolutionDisplay);
            grey_gadget(main_window_id, FrameRateMenu);
            grey_gadget(main_window_id, FrameRateDisplay);
            menus_are_grey = true;
        }
        else
        {
            /* Manual */
            ungrey_gadget(main_window_id, ColourMenu);
            ungrey_gadget(main_window_id, ColourDisplay);
            ungrey_gadget(main_window_id, ResolutionMenu);
            ungrey_gadget(main_window_id, ResolutionDisplay);
            ungrey_gadget(main_window_id, FrameRateMenu);
            ungrey_gadget(main_window_id, FrameRateDisplay);
            menus_are_grey = false;
        }
   }

    if (current_monitor_file)
    {
        /* Update monitor name display */
        for (m=monitors_list; m; m =m->next)
        {
            if (strncmp(current_monitor_file, m->file_name, strlen(current_monitor_file))==0)
            {
                error_trap(displayfield_set_value(0, main_window_id, MonitorTypeDisplay, m->monitor_name), 0);
                update_montype_tick(m->menu_id, m->menu_entry);
                monitor_set = true;
                break;
            }
        }
    }

    if (!monitor_set)
    {
        error_trap(displayfield_set_value(0, main_window_id, MonitorTypeDisplay, messages_lookup("Auto")), 0);
        update_montype_tick(montype_menu_id, 0);
    }

    if (!current_monitor_file)
    {
        /* Resolution, colours and frame rate are all greyed out */
        return;
    }

    /* Update resolution display */
    for ( i=0; i<nummodes; i++ )
    {
        if (modes_index[i][2]==current_x_res &&
            modes_index[i][3]==current_y_res)
        {
            char *name = descriptor_name(modes_index[i]);
            if (*name=='\0')
            {
                char text[16];
                sprintf(text, "%d x %d", current_x_res, current_y_res);
                error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, text), 0);
            }
            else
            {
                error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, name), 0);
            }
            break;
        }
    }

    /* Work out which entry in the resolution menu to tick */
    error_trap(displayfield_get_value(0, main_window_id, ResolutionDisplay, res_string, sizeof(res_string), 0), 0);
    for (i=0; i<res_menu_entries; i++)
    {
        error_trap(menu_get_entry_text(0, res_menu_id, i, menu_string, sizeof(menu_string), 0), 0);
        if (strcmp(res_string, menu_string)==0)
        {
            error_trap(menu_set_tick(0, res_menu_id, current_res, 0), 0);
            error_trap(menu_set_tick(0, res_menu_id, i, 1), 0);
            current_res=i;
            break;
        }
    }

    /* Update colours menu */
    for (i=0; i<num_colourchoices; i++)
    {
        /* Untick the whole menu */
        error_trap(menu_set_tick(0, col_menu_id, i, 0), 0);
    }
    if (current_colours>=0)
    {
        /* Tick current,and refresh the display field */
        error_trap(menu_set_tick(0, col_menu_id, current_colours, 1), 0);
        error_trap(menu_get_entry_text(0, col_menu_id, current_colours, menu_string, sizeof(menu_string), 0), 0);
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, menu_string), 0);
    }

    /* Update frame rate display */
    if(current_hz>=0)
    {
        char text[16];
        sprintf(text,"%dHz",current_hz);
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, text), 0);
        /* Tick correct menu entry */
        for (i=0; i<hz_menu_entries; i++)
        {
            error_trap(menu_get_entry_text(0, hz_menu_id, i, menu_string, sizeof(menu_string), 0), 0);
            error_trap(menu_set_tick(0, hz_menu_id, i, (strcmp(text, menu_string)?0:1)), 0);
        }
    }
}


/*---------------------------------------------------------------------------*
 * update_dpms_status                                                        *
 *                                                                           *
 * Update the DPMS state icon for the current monitor file.                  *
 *---------------------------------------------------------------------------*/

void update_dpms_status(void)
{
    monitor_ref *m;
    char         message_tag[16];

    if(!current_monitor_file)
        return;

    /* Find current monitor in our list */
    for (m=monitors_list; m; m =m->next)
    {
        if (strncmp(current_monitor_file, m->file_name, strlen(m->file_name))==0)
        {
            sprintf(message_tag, "DPMS%d", m->dpms_state);
            error_trap(displayfield_set_value(0, dpms_window_id, DPMSStateDisplay, messages_lookup(message_tag)), 0);
            break;
        }
    }
}


/*---------------------------------------------------------------------------*
 * create_screenmodes_instantiation                                          *
 *                                                                           *
 * Create a new instantiation of the ScreenModes module so that we can load  *
 * any newly selected MDF into it.                                           *
 *---------------------------------------------------------------------------*/

void create_screenmodes_instantiation(void)
{
    char tbuf[256];
    int i;

    /* Find highest numeric instantiation currently present */
    for ( i=0; i<1000; i++ )
    {
        sprintf(tbuf, "ScreenModes%%%d", i);
        if (_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_LookupName, tbuf)) break;
    }
    my_screenmodes_instantiation = i;

    /* create new instantiation */
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), ModHandReason_LookupName, "ScreenModes", &desktop_instantiation), 0);
    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_NewIncarnation, tbuf), 0);

#if UseVIDCBandLimitAlias
        /* issue VIDCBandLimit command, if Alias$VIDCBandLimit has been set (should be set by BandLimit app in
           PreDesk.Configure, with VIDCBandwidthLimit parameters as appropriate, eg. for 7500FE with EDO) */
        if (getenv("Alias$VIDCBandLimit")) (void)_swix( OS_CLI, _IN(0), "VIDCBandLimit");
#else
        /* Activate any VIDCBandwidthLimit command if its there */
        (void)_swix( OS_CLI, _IN(0), "IfThere Choices:Boot.PreDesk.BandLimit then /Choices:Boot.PreDesk.BandLimit "
                "else IfThere Boot:Utils.BandLimit then /Boot:Utils.BandLimit" );
            /*Fix bug: JRC 26th Jan 1995*/
#endif

    /* Now load our mode file */
    if (current_monitor_file)
    {
        error_trap(_swix(OS_ReadSysInfo, _IN(0)|_OUT(1), 1, &desktop_monitortype), 0);
        sprintf(tbuf, LoadModeCmd " %s", current_monitor_file);
        /* Only complain if the LoadModeFile doesn't work */
        error_trap(_swix( OS_CLI, _IN(0), tbuf ), 0);
    }

    /* Choose our preferred instantiation */
    sprintf(tbuf, "ScreenModes%%%s", desktop_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf ), 0);
}


/*---------------------------------------------------------------------------*
 * choose_my_screenmodes_instantiation                                       *
 *                                                                           *
 * Choose the newly created screenmodes instantiation as the current one.    *
 *---------------------------------------------------------------------------*/

static void choose_my_screenmodes_instantiation( void )
{
    char tbuf[256];

    /* read current preferred */
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), ModHandReason_LookupName, "ScreenModes", &desktop_instantiation), 0);
    /* read current monitortype */
    error_trap(_swix(OS_ReadSysInfo, _IN(0)|_OUT(1), 1, &desktop_monitortype), 0);
    /* switch to mine */
    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix( OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * return_to_base_screenmodes_instantiation                                  *
 *                                                                           *
 * Choose the original screenmodes instantiation as the current one.         *
 *---------------------------------------------------------------------------*/

static void return_to_base_screenmodes_instantiation( void )
{
    char tbuf[256];

    if (desktop_instantiation == NULL) return;

    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, desktop_monitortype), 0);

    /* switch instantiation */
    sprintf(tbuf, "ScreenModes%%%s", desktop_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_MakePreferred, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * discard_screenmodes_instantiation                                         *
 *                                                                           *
 * Get rid of our created screenmodes instantiation.                         *
 *---------------------------------------------------------------------------*/

void discard_screenmodes_instantiation(void)
{
    char tbuf[256];

    sprintf(tbuf, "ScreenModes%%%d", my_screenmodes_instantiation);
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), ModHandReason_Delete, tbuf), 0);
}


/*---------------------------------------------------------------------------*
 * mode_compare2                                                             *
 *                                                                           *
 * The guts of the comparison code, it does everything except the RGB/alpha  *
 * comparison.                                                               *
 *---------------------------------------------------------------------------*/

static int mode_compare2( const int *a, const int *b )
{
    if ( (a[1] & flags_squarepixel) != (b[1] & flags_squarepixel) )
            return (a[1] & flags_squarepixel) ? 1 : -1 ;

    if ( a[2] != b[2] ) return a[2] - b[2];         /* Xres */

    if ( a[3] != b[3] ) return a[3] - b[3];         /* Yres */

    gv_pixelformat format_a = descriptor_to_pixelformat(a);
    gv_pixelformat format_b = descriptor_to_pixelformat(b);

    int colours_a = find_colours(format_a,true);
    int colours_b = find_colours(format_b,true); 

    if ( colours_a != colours_b ) return colours_a - colours_b; /* colours */

    int hz_a = descriptor_hz(a);
    int hz_b = descriptor_hz(b);

    if ( hz_a != hz_b ) return hz_b - hz_a;         /* frame rate */

    return 0;
}


/*---------------------------------------------------------------------------*
 * mode_compare                                                              *
 *                                                                           *
 * Function for qsort to decide when a mode descriptor is higher or lower.   *
 *---------------------------------------------------------------------------*/

static int mode_compare( const void *aa, const void *bb )
{
    const int *a = *(int **)aa;
    const int *b = *(int **)bb;

    int comparison = mode_compare2(a,b);

    if (comparison) return comparison; 

    gv_pixelformat format_a = descriptor_to_pixelformat(a);
    gv_pixelformat format_b = descriptor_to_pixelformat(b);

    return (format_a.modeflags & ModeFlag_DataFormatSub_Mask) - (format_b.modeflags & ModeFlag_DataFormatSub_Mask); /* RGB/alpha flags */ 
}


/*---------------------------------------------------------------------------*
 * create_resolutions_menu                                                   *
 *                                                                           *
 * Given the object ID of the resolution menu, create the menu entries for   *
 * the selected MDF.                                                         *
 *                                                                           *
 * In: menu_handle = object id of resolution menu.                           *
 *---------------------------------------------------------------------------*/

void create_resolutions_menu(void)
{
    MenuTemplateEntry entry;
    static char *bestres;
    int   i, spaceformodes, numdiffmodes, flag, entryno, colourmask = 0;
    char *rover;
    bool  montype_live;

    /* Keep 1 copy of the extra resolution */
    if (bestres == NULL)
    {
        bestres = malloc(strlen(messages_lookup("Best")) + 1);
        if (bestres != NULL) strcpy(bestres, messages_lookup("Best"));
    }

    /* Remove all current menu entries */
    for (i=0; i<res_menu_entries; i++) error_trap(menu_remove_entry(0, res_menu_id, i), 0);
    res_menu_entries=0;
    current_res=0;

    choose_my_screenmodes_instantiation();

    /* Find spaces needed to enumerate the available screen modes */
    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(2)|_IN(6)|_IN(7)|_OUT(2)|_OUT(7),
                ScreenModeReason_EnumerateModes, 0, 0, 0, &nummodes, &spaceformodes), 0);

    if (modes_block) free(modes_block);
    if (modes_index) free(modes_index);
    modes_block=NULL;
    modes_index=NULL;

    /* Get memory to store mode information */
    modes_block=malloc(-spaceformodes);
    if (!modes_block)
    {
        nummodes = 0;
        return;
    }

    /* Enumerate the available screen modes */
    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(2)|_IN(6)|_IN(7),
                 ScreenModeReason_EnumerateModes, 0, modes_block, -spaceformodes), 0);
    nummodes=-nummodes;

    return_to_base_screenmodes_instantiation();

    /* Modes index is a list of pointers to each mode in the mode data returned by EnumerateScreenModes */
    modes_index = malloc( sizeof( *modes_index ) * nummodes );
    if (!modes_index)
    {
        nummodes = 0;
        return;
    }

    if (nummodes==0) return;

    /* Go through all the modes and check for square pixel modes (mark these) */
    rover = modes_block;
    int j = 0;
    for ( i=0; i<nummodes; i++ )
    {
        int xeig,yeig;
        int selector[10];

        /* check descriptor format and generate a mode selector */
        int format = (((int *)rover)[1] & 0xff);
        if(format == 1)
        {
            selector[0] = 1;
            selector[1] = ((int *)rover)[2];
            selector[2] = ((int *)rover)[3];
            selector[3] = ((int *)rover)[4];
            selector[4] = ((int *)rover)[5];
            selector[5] = -1;
        }
        else if(format == 3)
        {
            selector[0] = 1;
            selector[1] = ((int *)rover)[2];
            selector[2] = ((int *)rover)[3];
            selector[3] = ((int *)rover)[6];
            selector[4] = ((int *)rover)[7];
            selector[5] = VduExt_NColour;
            selector[6] = ((int *)rover)[4];
            selector[7] = VduExt_ModeFlags;
            selector[8] = ((int *)rover)[5];
            selector[9] = -1;
        }
        else
        {
            /* Unknown format, skip it */
            rover += *((int *)rover);
            continue;
        }

        /* check we recognise the pixel format */
        if(find_colours(descriptor_to_pixelformat((int *)rover),true) == -1)
        {
            rover += *((int *)rover);
            continue;
        }

        /* check for square pixels */
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), selector, VduExt_XEigFactor, &xeig), 0);
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), selector, VduExt_YEigFactor, &yeig), 0);
        /* naughty, naughty, we're changing mode selector flags! */
        if ( xeig == yeig )
        {
            ((int *)rover)[1] |= flags_squarepixel;
        }
        else
        {
            ((int *)rover)[1] &= ~flags_squarepixel;
        }
        
        /* Store the index for this mode */
        modes_index[j] = (int *)rover;
        rover += *((int *)rover);
        j++;
    }
    nummodes = j;

    /* Sort the modes into resolution order */
    qsort( modes_index, nummodes, 4, mode_compare );

    /* Run through the list again and discard any which are identical apart from RGB/alpha flags - currently the user has no control over RGB/alpha selection, instead we decide for him what the most compatible mode is */
    for(i=0;i<nummodes-1;i++)
    {
        if(!mode_compare2(modes_index[i],modes_index[i+1]))
        {
            /* Ditch the second entry */
            memmove(&modes_index[i+1],&modes_index[i+2],sizeof(int*)*(nummodes-(i+2)));
            nummodes--;
            i--;
        }
    }

    /* We're not bothered about these fields in the menu entry data: */
    entry.click_show=0;
    entry.submenu_show=0;
    entry.submenu_event=0;
    entry.click_event=0;
    entry.help_message=0;
    entry.max_entry_help=0;

    /* Construct menu string */
    flag = modes_index[nummodes-1][1] & flags_squarepixel;
    numdiffmodes=0;

    for (i=nummodes-1; i>=0; i--)
    {
        gv_pixelformat format = descriptor_to_pixelformat(modes_index[i]);
        colourmask |= 1<<find_colours(format,true);
        colourmask |= 1<<find_colours(format,false);

        if ( (i==0 ||
              modes_index[i][2] != modes_index[i-1][2] ||
              modes_index[i][3] != modes_index[i-1][3]) &&
             *descriptor_name(modes_index[i]) )
        {
            numdiffmodes++;

            /* Mark divider between square and rectangular pixel modes */
            entry.flags=0;
            if (flag != (modes_index[i][1] & flags_squarepixel))
            {
                flag = modes_index[i][1] & flags_squarepixel;
                entry.flags = Menu_Entry_DottedLine;
            }

            entry.component_id=res_menu_entries;
            entry.text=descriptor_name(modes_index[i]);
            entry.max_text=256;
            menu_add_entry(0, res_menu_id, -1, (char*)&entry, &entryno);
            res_menu_entries++;
        }
    }

    montype_live = strncmpa(current_monitor_file, MonitorsLive, sizeof(MonitorsLive) - 1) == 0; 
    if (montype_live && (bestres != NULL))
    {
        /* Selected monitor is from live data, include a special "best resolution" entry */
        entry.flags=0;
        entry.component_id=res_menu_entries;
        entry.text=bestres;
        entry.max_text=256;
        menu_add_entry(0, res_menu_id, -1, (char*)&entry, &entryno);
        res_menu_entries++;
    }

    /* Optionally shade the colour menus if some bpp aren't there */
    for(i=0;i<num_colourchoices;i++)
    {
       if(!(colourmask & (1<<i)))
           menu_set_fade(0, col_menu_id, i, 1);
    }
}


/*---------------------------------------------------------------------------*
 * create_hz_menu                                                            *
 *                                                                           *
 * Recreates the framerate menu whenever we change monitor/mode/depth/cols   *
 *---------------------------------------------------------------------------*/

void create_hz_menu(void)
{
    MenuTemplateEntry entry;
    int   i, entryno;
    memset(&entry,0,sizeof(entry));

    /* Remove all current menu entries */
    for (i=0; i<hz_menu_entries; i++) error_trap(menu_remove_entry(0, hz_menu_id, i), 0);
    hz_menu_entries=0;

    /* Add all the new entries for the current mode */
    for (i=0; i<nummodes; i++)
    {
        if ((modes_index[i][2] == current_x_res) &&
            (modes_index[i][3] == current_y_res) &&
            (find_colours(descriptor_to_pixelformat(modes_index[i]), colourchoices[current_colours].iscolour) == current_colours))
        {
            int hz = descriptor_hz(modes_index[i]);
            if(!hz_menu_entries || (hz != descriptor_hz(modes_index[i-1])))
            {
                char text[16];
                sprintf(text,"%dHz",hz);
                /* If the refresh rate is currently unknown (e.g. due to loading a WimpMode line saved by an older version of the plugin) then now is a good time to set the refresh rate to max */
                if(current_hz == -1)
                {
                    current_hz = hz;
                    error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, text), 0);
                }
                entry.flags=(hz==current_hz ? Menu_Entry_Ticked : 0);
                entry.component_id=hz_menu_entries;
                entry.text=(char *)text;
                entry.max_text=256;
                menu_add_entry(0, hz_menu_id, hz_menu_entries-1, (char*)&entry, &entryno);
                hz_menu_entries++;
            }
        }
        else if(hz_menu_entries)
        {
            /* As modes_index is sorted, exit early now the resolution has passed */
            break;
        }
    }
    if (!hz_menu_entries)
    {
        /* When colours/resolution is unknown this is an empty menu. Fade it. */
        grey_gadget(main_window_id, FrameRateDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
    }
    else
    {
        ungrey_gadget(main_window_id, FrameRateDisplay);
        ungrey_gadget(main_window_id, FrameRateMenu);
    }
}


/*---------------------------------------------------------------------------*
 * is_duplicate_monitor                                                      *
 *                                                                           *
 * Check if this is a duplicate monitor from another similar MDF             *
 *                                                                           *
 * Out: true if the proposed monitor shouldn't be added to the global list   *
 *---------------------------------------------------------------------------*/

static bool is_duplicate_monitor(char *name, char *file, int origin)
{
    int filelen, namelen;
    monitor_ref *previous, *dup;
        
    filelen = strlen(file) - strlen(get_leafname(file));
    namelen = strlen(name);
    dup = monitors_list;
    previous = NULL;
    while (dup)
    {
        if ((strncmpa(name, dup->monitor_name, namelen) == 0) &&
            (strncmpa(file, dup->file_name, filelen) == 0))
        {
            /* Rules: new = MDF  dup = MDF  -> keep first found
             *        new = MDF  dup = EDID -> keep EDID (ie. first found)
             *        new = EDID dup = MDF  -> keep EDID
             *        new = EDID dup = EDID -> keep first found
             */
            if ((origin == ORIGIN_EDID) && (dup->origin == ORIGIN_MDF))
            {
                /* Unlink the duplicate */
                if (dup->next == NULL)
                {
                    monitors_list_tail = (previous == NULL) ? &monitors_list : &previous->next;
                }
                if (monitors_list == dup)
                {
                    monitors_list = dup->next;
                }
                else
                {
                    previous->next = dup->next;
                }
                free(dup);

                return false; /* Replace it with this */
            }
            return true; /* Keep original, discard this */
        }
        previous = dup;
        dup = dup->next;
    }

    return false; /* No match, do add this */
}


/*---------------------------------------------------------------------------*
 * extract_monitor_name_dpms                                                 *
 *                                                                           *
 * Scan an MDF or EDID block for the monitor name and DPMS value             *
 *                                                                           *
 * Out: priority indication, or -ve on failure                               *
 *---------------------------------------------------------------------------*/

static short extract_monitor_name_dpms(FILE *fp, char *name, int *dpms_state)
{
    char buffer[256];
    static const char edidhdr[] = { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 };
    static const char namehdr[] = { 0x00, 0x00, 0x00, 0xFC, 0x00 }; /* Display product name */

    if (fread(buffer, sizeof(edidhdr), 1, fp) != 1)
    {
        /* Give up, since file_format:1 string of an MDF is longer than that */
        return -1;
    }

    /* Default if no DPMS keyword */
    *dpms_state = 0; 

    fseek(fp, 0, SEEK_SET);

    if (memcmp(buffer, edidhdr, sizeof(edidhdr)) == 0)
    {
        size_t i, j;
        char   sum;

        /* Looks like an EDID block */
        if (!support_edid)
        {
            return -1; /* OS can't handle EDID */
        }
        if (fread(buffer, EDIDBaseBlockSize, 1, fp) != 1)
        {
            return -1; /* File too short */
        }
        for (i = 0, sum = 0; i < EDIDBaseBlockSize; i++)
        {
            sum = sum + buffer[i];
        }
        if (sum != 0)
        {
            return -1; /* Bad checksum */
        }

        /* Interpret feature bits for DPMS */
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMStandbySupported)
        {
            *dpms_state = 1;
        }
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMSuspendSupported)
        {
            *dpms_state = 2;
        }
        if (buffer[EDIDFeaturesOffset] & EDIDFeaturesDPMActiveOffSupported)
        {
            *dpms_state = 3;
        }

        /* Look for optional name display descriptor */
        for (i = 0; i < 4; i++)
        {
            if (memcmp(&buffer[EDIDDataBlocksOffset + (i * 18)], namehdr, sizeof(namehdr)) == 0)
            {
                const char *desc = &buffer[EDIDDataBlocksOffset + (i * 18) + sizeof(namehdr)];

                /* Copy the name out, replacing unprintables with spaces */
                for (j = 0; j < (18 - sizeof(namehdr)); j++)
                {
                    if (desc[j] == NewLine) break;
                    *name = ((desc[j] < 32) || (desc[j] == 127)) ? ' ' : desc[j];
                    name++;
                }
                *name = '\0';
                return ORIGIN_EDID;
            }
        }

        /* Invent a name */
        strcpy(name, messages_lookup("NoName"));
        return ORIGIN_EDID;
    }
    else
    {
        bool gotfmt = false, gotname = false, gotdpms = false;

        /* Check for a file_format:1 string */
        while (!feof(fp) && !gotfmt)
        {
            fgets(buffer, sizeof(buffer), fp);
            if (strncmpa(buffer, FileFormat, strlen(FileFormat)) == 0) gotfmt = true;
        }
        if (gotfmt)
        {
            while (!feof(fp) && !(gotname && gotdpms))
            {
                fgets(buffer, sizeof(buffer), fp);
                if (strncmpa(buffer, MonitorTitle, strlen(MonitorTitle)) == 0)
                {
                    /* Found monitor_title:xxx string */
                    if (buffer[strlen(buffer) - 1] == NewLine) buffer[strlen(buffer) - 1] = '\0';
                    strcpy(name, &buffer[strlen(MonitorTitle)]);
                    gotname = true;
                }
                if (strncmpa(buffer, DPMSState, strlen(DPMSState)) == 0)
                {
                    /* Found the DPMS_state:xxx string */
                    if (buffer[strlen(buffer) - 1] == NewLine) buffer[strlen(buffer) - 1] = '\0';
                    *dpms_state = atoi(&buffer[strlen(DPMSState)]);
                    gotdpms = true;
                }
            }
        }
        return gotname ? ORIGIN_MDF : -1; /* Require at least a name */
    }
}

/*---------------------------------------------------------------------------*
 * construct_monitors_list                                                   *
 *                                                                           *
 * Build a structure with the details of all available MDFs.                 *
 *---------------------------------------------------------------------------*/

static void construct_monitors_list(char *dirname, char *buffer_end)
{
    _kernel_oserror *e = NULL;
    monitor_ref     *new_ref;
    FILE            *fp;
    char            *dirname_end;
    char             string[256];
    int              pos = 0;
    int              num, type, dpms_state;
    short            origin;

    dirname_end = dirname + strlen(dirname);

    while ((e == NULL) && (pos != -1))
    {
        /* Get next entry from directory */
        e = _swix(OS_GBPB, _INR(0,6)|_OUTR(3,4),
                           OSGBPB_ReadDirEntries, dirname, dirname_end+1, 1, pos,
                           buffer_end - (dirname_end+1), 0,
                           &num, &pos);

        if ((e == NULL) && (num > 0))
        {
            *dirname_end = '.';

            /* Find the type of the entry we've just read */
            e = _swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, dirname, &type);
            if ((e == NULL) && (type == object_directory))
            {
                /* It was a directory, so scan this as well */
                construct_monitors_list(dirname, buffer_end);
            }
            else
            {
                /* It was a file, so try and read monitor information */
                fp = fopen(dirname, "r");
                origin = extract_monitor_name_dpms(fp, string, &dpms_state);
                if ((origin > 0) && !is_duplicate_monitor(string, dirname, origin))
                {
                    char *store;

                    /* Found a monitor title, so store details in a structure */
                    store = malloc(sizeof(monitor_ref) + /* For new_ref */
                                   strlen(dirname)+1 +   /* For new_ref->filename */
                                   strlen(string)+1      /* For new_ref->monitor_name */);
                    if (store == NULL)
                    {
                        error_trap(common_error(messages_lookup("NotEnoughMemory")), 0);
                        fclose(fp);
                        return;
                    }
                    new_ref = (monitor_ref *)&store[0];
                    new_ref->file_name     = &store[0+sizeof(monitor_ref)];
                    new_ref->monitor_name  = &store[0+sizeof(monitor_ref)+strlen(dirname)+1];
                    new_ref->next = NULL;
                    strcpy(new_ref->file_name, dirname);
                    strcpy(new_ref->monitor_name, string);
                    new_ref->dpms_state = dpms_state;
                    new_ref->origin = origin;
                    *monitors_list_tail = new_ref;
                    monitors_list_tail = &new_ref->next;
                }
                fclose(fp);
            }
            e = NULL; /* On error, carry on with the enumeration */
            *dirname_end = '\0';
        }
    }
}


/*---------------------------------------------------------------------------*
 * read_monitors_list                                                        *
 *                                                                           *
 * Read list of MDFs.                                                        *
 *                                                                           *
 *---------------------------------------------------------------------------*/

static void read_monitors_list(void)
{
    char buffer[1024];

    monitors_list=NULL;
    monitors_list_tail=&monitors_list;

    _swix(Hourglass_On, 0);
    strcpy(buffer, MonitorsDirectory);
    construct_monitors_list(buffer, buffer + sizeof(buffer));
    strcpy(buffer, MonitorsLive);
    construct_monitors_list(buffer, buffer + sizeof(buffer));
    _swix(Hourglass_Off, 0);
}


/*---------------------------------------------------------------------------*
 * create_monitors_menu                                                      *
 *                                                                           *
 * Build a menu stucture with the details of all available MDFs.             *
 *                                                                           *
 *---------------------------------------------------------------------------*/

void create_monitors_menu(void)
{
    static char *helpedidtype;
    monitor_ref *ref;
    MenuTemplateEntry entry;
    ComponentId       where;
    bool              live; /* Is this read live via EDID? */
    char     live_entry[128];
    ObjectId last_submenu = montype_menu_id;
    char     last_dirname[128] = "";
    ObjectId this_submenu;
    char     this_dirname[128];

    read_monitors_list();

    /* Keep 1 copy of the extra help */
    if (helpedidtype == NULL)
    {
        helpedidtype = malloc(strlen(messages_lookup("HelpEDIDType")) + 1);
        if (helpedidtype != NULL) strcpy(helpedidtype, messages_lookup("HelpEDIDType"));
    }

    /* Always "Auto" */
    entry.component_id = 0;
    entry.click_show = NULL;
    entry.submenu_show = NULL;
    entry.submenu_event = 0;
    entry.click_event = 0;
    entry.help_message = NULL;
    entry.max_entry_help = 0;
    montype_menu_entries = 1;

    /* Now the other ones */
    ref=monitors_list;
    while (ref)
    {
        *this_dirname = '\0';
        live = true;
        if (strncmp(ref->file_name, MonitorsDirectory, sizeof(MonitorsDirectory) - 1) == 0)
        {
            char *dirstart, *dirend;

            live = false;
            dirstart = &ref->file_name[sizeof(MonitorsDirectory)];
            dirend = strchr(dirstart, '.');
            if (dirend != NULL)
            {
                /* Is in a subdirectory of the MonitorsDirectory */
                strncat(this_dirname, dirstart, dirend - dirstart);
            }
        }

        /* We'll flatten everything below 1 level deep in the MonitorsDirectory, and
         * put everything else ungrouped in the top menu.
         */
        where = Menu_AddEntryAtEnd;
        entry.flags = 0;
        entry.component_id = -1 /* Next free */;
        if (live)
        {
            /* Emphasise the origin */
            sprintf(live_entry, "%s (%s)", messages_lookup("Auto"), ref->monitor_name);
            entry.text = live_entry;
        }
        else
        {
            entry.text = ref->monitor_name;
        }
        entry.max_text = strlen(entry.text) + 1;
        if (strlen(this_dirname) != 0)
        {
            if (strcmp(last_dirname, this_dirname) == 0)
            {
                /* More to add to an existing group */
                this_submenu = last_submenu;
            }
            else
            {
                MenuTemplateEntry group;
                ComponentId       group_id;

                /* Create a new group (submenu) */
                error_trap(toolbox_create_object(0, "MonManuMenu", &this_submenu), 0);
                last_submenu = this_submenu;
                strcpy(last_dirname, this_dirname);
                error_trap(menu_set_title(0, this_submenu, this_dirname), 0);

                /* Add the group to the top menu */
                memcpy(&group, &entry, sizeof(entry));
                group.text = this_dirname;
                group.max_text = strlen(group.text) + 1;
                error_trap(menu_add_entry(0, montype_menu_id, Menu_AddEntryAtEnd, (char *)&group, &group_id), 0);
                montype_menu_entries++;
                error_trap(menu_set_sub_menu_show(0, montype_menu_id, group_id, this_submenu), 0);
                error_trap(event_register_toolbox_handler(this_submenu, Menu_Selection, montype_menu_select, NULL), 0);
            }
        }
        else
        {
            /* Not existing, not new, so back up to top menu */
            *last_dirname = '\0';
            this_submenu = montype_menu_id;
            where = 0; /* After "Auto" */
        }
        entry.help_message = live ? helpedidtype : NULL;
        entry.max_entry_help = live ? strlen(helpedidtype) + 1 : 0;
        error_trap(menu_add_entry(0, this_submenu, where, (char *)&entry, &ref->menu_entry), 0);
        ref->menu_id = this_submenu;
        ref=ref->next;
    }
}


/*---------------------------------------------------------------------------*
 * switch_resolution                                                         *
 *                                                                           *
 * Resolution has been changed - find nearest possible match for other       *
 * settings.                                                                 *
 *---------------------------------------------------------------------------*/

void switch_resolution(void)
{
    char buffer[256];
    int  x_to_find, y_to_find, nbytes, i, bestmatch, bestmatch_colours;

    displayfield_get_value(0, main_window_id, ResolutionDisplay, buffer, sizeof(buffer), &nbytes);

    if (strcmp(buffer, messages_lookup("Best")) == 0)
    {
        current_x_res = current_y_res = -2;
        current_hz = current_colours = -1;
        update_monitor_displayfields();
        return;
    }

    /* Search for the selected resolution string in our mode data */
    for (i=0; i<nummodes; i++)
    {
        if (strcmp(descriptor_name(modes_index[i]), buffer)==0) break;
    }

    /* Make sure we found the entry */
    if (i==nummodes) return;

    x_to_find = modes_index[i][2];
    y_to_find = modes_index[i][3];

    /* Now try and match to current_colours */
    bestmatch = -1;
    bestmatch_colours = -1;
    for (i=0; i<nummodes; i++)
    {
        if (modes_index[i][2]==x_to_find && modes_index[i][3]==y_to_find)
        {
            /* This mode has the right resolution */
            int colours;
            if (current_colours>=0)
            {
                /* Check for going past the current colour depth */
                colours = find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[current_colours].iscolour);
                if (colours > current_colours) break;
            }
            else
            {
                /* When 'Unknown' any old port in a storm, preferably colour */
                colours = find_colours(descriptor_to_pixelformat(modes_index[i]),TRUE);
            }

            /* Check if this is a better mode that bestmatch */
            if (bestmatch<0 || colours!=bestmatch_colours)
            {
                bestmatch=i;
                bestmatch_colours = colours;
            }
        }
    }

    /* If didn't find any suitable mode... */
    if (bestmatch<0) return;

    /* Found a bestmatch, so switch to that */
    current_colours = bestmatch_colours;

    current_flags=modes_index[bestmatch][1] & flags_squarepixel;
    current_x_res=modes_index[bestmatch][2];
    current_y_res=modes_index[bestmatch][3];
    current_hz=descriptor_hz(modes_index[bestmatch]);

    create_hz_menu();

    update_monitor_displayfields();
}


/*---------------------------------------------------------------------------*
 * switch_colour                                                             *
 *                                                                           *
 * Colour has been changed - find mode that most matches  resolution.        *
 *---------------------------------------------------------------------------*/

void switch_colour(int menusel)
{
    int i, bestmatch;
    int limit_x_res=current_x_res;
    int limit_y_res=current_y_res;

    /* If unknown resolution, then limit to mode 27 */
    if (limit_x_res<0) limit_x_res=640;
    if (limit_y_res<0) limit_y_res=480;

    /* Try and find the bestmatch */
    bestmatch=-1;
    for (i=0; i<nummodes; i++)
    {
        if (find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[menusel].iscolour) == menusel)
        {
            /* This mode has the right colour depth */
            if (bestmatch>=0)
            {
                /* We already have a match, so test for being in menu */
                char c1=*descriptor_name(modes_index[bestmatch]);
                char c2=*descriptor_name(modes_index[i]);

                if ((c1!='\0') && (c2=='\0')) continue;

                if ((c1!='\0') || (c2=='\0'))
                {
                    /* Either both are not in the menu or both are in the menu */
                    int f1=modes_index[bestmatch][1] & flags_squarepixel;
                    int f2=modes_index[i][1] & flags_squarepixel;
                    if (f1==f2)
                    {
                        /* Both the same pixel shape, so test x resolution */
                        if ( (modes_index[i][2] > limit_x_res) || (modes_index[i][2] < modes_index[bestmatch][2]) )
                            continue;
                        /* Test y resolution as well - we didn't always do this, but doing so will make us more consistent with how the display manager does things */
                        if ( (modes_index[i][3] > limit_y_res) || (modes_index[i][3] < modes_index[bestmatch][3]) )
                            continue;
                    }
                    else
                    {
                        if ( f2 != current_flags ) continue;
                    }
                }
            }
            bestmatch=i;
        }
    }

    /* If didn't find any suitable mode... */
    if (bestmatch<0) return;

    /* Found a bestatch, so switch to that */
    current_colours=menusel;
    current_flags=modes_index[bestmatch][1] & flags_squarepixel;
    current_x_res=modes_index[bestmatch][2];
    current_y_res=modes_index[bestmatch][3];
    current_hz=descriptor_hz(modes_index[bestmatch]);

    create_hz_menu();

    update_monitor_displayfields();
}


/*---------------------------------------------------------------------------*
 * switch_monitor                                                            *
 *                                                                           *
 * Monitor has been changed. Try and find mode that most matches colours and *
 * resolution settings.                                                      *
 *---------------------------------------------------------------------------*/

void switch_monitor(const monitor_ref *rover)
{
    char tbuf[256];

    if (current_monitor_file) free(current_monitor_file);
    if (modes_block) free (modes_block);
    if (modes_index) free (modes_index);
    current_monitor_file=NULL;
    modes_block=NULL;
    modes_index=NULL;

    if (rover)
    {
        /* Record the monitor name */
        current_monitor_file=malloc(strlen(rover->file_name)+1);
        if (!current_monitor_file) return;
        strcpy(current_monitor_file, rover->file_name);

        /* Load that file into our ScreenModes instantiation */
        choose_my_screenmodes_instantiation();
        sprintf(tbuf, LoadModeCmd " %s", current_monitor_file);
        error_trap(_swix(OS_CLI, _IN(0), tbuf), 0);
        return_to_base_screenmodes_instantiation();

        if ((current_x_res==-2) && (current_y_res==-2))
        {
            /* If previously best resolution, drop to unknown */
            current_x_res = current_y_res = -1;
        }

        /* Reinform the world that current monitor has changed too. */
        error_trap(_swix(OS_ServiceCall, _IN(1), Service_ModeFileChanged), 0);

        create_resolutions_menu();
        create_hz_menu();
    }

    update_monitor_displayfields();
    update_dpms_status();

    if (rover)
        switch_colour(current_colours);
}


/*---------------------------------------------------------------------------*
 * set_monitor_choices                                                       *
 *                                                                           *
 * Write the monitor choices file.                                           *
 *                                                                           *
 * Out: true on success, false on failure                                    *
 *---------------------------------------------------------------------------*/

bool set_monitor_choices(int file_to_write)
{
    FILE *dest_fp;
    char  line1[256];
    char  line2[256];
    bool  montype_auto = (current_monitor_file == NULL);
    bool  exe_wimpmodecmd = true;

    if (!montype_auto)
    {
        /* Not Auto */
        sprintf(line1, LoadModeCmd " %s", current_monitor_file);
        if ((current_x_res==-2) && (current_y_res==-2))
        {
            /* Best resolution depends on the monitor currently plugged in.
             * This works because ScreenModes notes the manufacturer's preferred
             * mode from the live EDID, then when the Wimp uses OS_ReadSysInfo(1)
             * to set the mode on entering the desktop this sends round
             * Service_MonitorLeadTranslation to ask for that preferred mode.
             */
            strcpy(line2, WimpModeCmdBest);
            _swix(OS_CLI, _IN(0), "Configure WimpMode Auto");
            exe_wimpmodecmd = false;
        }
        else
        {
            if ((current_x_res==-1) || (current_y_res==-1) || (current_colours==-1))
            {
                warning_box(messages_lookup("CantSaveMode"));
                return false;
            }

            /* Find the descriptor entry so we can work out the RGB/alpha settings */
            int rgb_alpha = 0;
            for(int i=0;i<nummodes;i++)
            {
                if((modes_index[i][2] == current_x_res) &&
                   (modes_index[i][3] == current_y_res) &&
                   (descriptor_hz(modes_index[i]) == current_hz))
                {
                    gv_pixelformat format = descriptor_to_pixelformat(modes_index[i]);
                    int colours = find_colours(format,colourchoices[current_colours].iscolour);
                    if(colours == current_colours)
                    {
                        /* Found it! */
                        rgb_alpha = (format.modeflags & ModeFlag_DataFormatSub_Mask) >> 14;
                        break;
                    }
                }
            }
            sprintf(line2, WimpModeCmd " X%d Y%d %s F%d%s", current_x_res, current_y_res, colourchoices[current_colours].text, current_hz, rgb_alpha_mode[rgb_alpha]);
        }
    }
    else
    {
        /* Set auto monitor type (whatever's in CMOS) */
        line1[0]=0;
        line2[0]=0;
        _swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, -1);
        exe_wimpmodecmd = false;
    }

    /* If we're not just trying-out the settings, build the new settings file */
    if (file_to_write != FTW_NONE)
    {
        char *filename;
  
        if (file_to_write == FTW_CONFIG)
            filename = PreDeskConfigFile;
        else
            filename = ScrapConfigFile;
  
        _swix(OS_File, _INR(0,1)|_IN(5), OSFile_WriteAttr, filename, read_attribute | write_attribute); /* Ignore error if file not found */
        dest_fp = fopen(filename, "w");
        if (dest_fp == NULL)
        {
            error_trap(common_error(messages_lookup_with_parameter("CantWriteFile", filename)), 0);
            return false;
        }
  
        /* Write the LoadModeFile and WimpMode commands to the file */
        if (!montype_auto)
        {
            fputs(line1, dest_fp);
            fputc(NewLine, dest_fp);
            fputs(line2, dest_fp);
            fputc(NewLine, dest_fp);
        }
  
        fclose(dest_fp);
        error_trap(_swix(OS_File, _INR(0,2), OSFile_SetType, filename, FileType_Obey), 0);
    }

    /* When writing to FTW_CONFIG also tell the base instantiation what's
     * going on so when this plugin finishes the monitor is what's just been set.
     * Since the two then end up in sync there's no need to send a
     * fake Service_ModeFileChanged afterwards.
     */
    if (file_to_write == FTW_CONFIG)
    {
        discard_screenmodes_instantiation();
        if (!montype_auto)
            _swix(OS_CLI, _IN(0), line1); /* LoadModeFile */
        else
            _swix(OS_ScreenMode, _IN(0)|_IN(1), ScreenModeReason_SelectMonitorType, -1); /* Auto from CMOS */
        create_screenmodes_instantiation();
    }

    _swix(OS_CLI, _IN(0), line1);
    if (exe_wimpmodecmd)
    {
        _swix(OS_CLI, _IN(0), line2);
    }
    else
    {
        int mode;

        _swix(OS_ReadSysInfo, _IN(0)|_OUT(0), 1, &mode);
        _swix(Wimp_SetMode, _IN(0), mode);
    }

    return true;
}
@


1.20
log
@Minor UI improvements
Detail:
  Move the resolution picker menu after the monitor type picker menu, so the logical order flows better.
  Fix for failure to unshade menus after cancelling a 'Try' operation with the Auto monitor type.
  Improve the clarity of the magic EDID entry by using the text 'Auto (BrandX 123GTI)' in the menu so it stands out from other non-Auto detected types.
Admin:
  Submission for the EDID bounty.

Version 0.41. Tagged as 'ScrnSetup-0_41'
@
text
@a1389 1
    if (current_colours == -1) current_colours = 0; /* Unknown becomes 0th choice */
d1395 12
a1406 3
            /* Check for going past the current colour depth */
            int colours = find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[current_colours].iscolour);
            if (colours > current_colours) break;
@


1.19
log
@Add support for EDID monitors in the system
Detail:
  Upgrade the MDF directory enumeration to minimally parse EDID data blobs. Add these to the list of known monitors. This allows a disc based MDF to override faulty data in the monitor, or on systems such as IOMD that don't support EDID, for them to benefit from a library of blobs rather than needing a parallel set of MDFs creating.
  Add the path of EDID blobs exported by ScrModes to those scanned for monitor definitions. EDID data is always placed in the top level manufacturer menu below 'Auto'.
  Add interactive help to clarify what 'Auto' means and how it differs from the EDID data.

  common.c: Relocate [un]grey_gadget() from screen.c.
  main.c: Simplify unnecessary memset(). Create a flag based on ScreenModes_Features whether the host OS supports EDID or not.
  monitor.c: Extra scanning. Conflict resolution if duplicate monitor definitions exist from differing sources. Simple EDID parser to get the monitor name (else default string) and DPMS flags.
Admin:
  Submission for the EDID bounty.
  Tested with ScrModes-0_61, and also on earlier versions, on RISC OS 5.23.
  Briefly tested on RISC OS 3.70 with !Boot.Resources.Configure.Monitors containing EDID data (should be ignored).

Version 0.40. Tagged as 'ScrnSetup-0_40'
@
text
@d371 1
d383 22
a404 2
        ungrey_gadget(main_window_id, ColourMenu);
        ungrey_gadget(main_window_id, ColourDisplay);
d407 1
a407 11
    if (!current_monitor_file)
    {
        grey_gadget(main_window_id, ColourMenu);
        grey_gadget(main_window_id, ColourDisplay);
        grey_gadget(main_window_id, ResolutionMenu);
        grey_gadget(main_window_id, ResolutionDisplay);
        grey_gadget(main_window_id, FrameRateMenu);
        grey_gadget(main_window_id, FrameRateDisplay);
        menus_are_grey = true;
    }
    else
d1247 1
d1298 10
a1307 1
        entry.text = ref->monitor_name;
@


1.18
log
@Fix for Auto setting not being stored
3rd time's a charm: in changing from a stringset changed to a menu selection event, nothing was updating the globals holding the monitor details for the Auto case calling switch_monitor(). Move that call so it is.
Change menus_are_grey to a boolean.

Version 0.39. Tagged as 'ScrnSetup-0_39'
@
text
@d50 2
d104 1
a104 1
extern bool menus_are_grey;
d332 8
d369 17
d688 1
d691 8
d703 1
d852 1
a852 1
                entry.flags=2;
d863 11
a873 2
    current_res=0;
    error_trap(menu_set_tick(0, res_menu_id, current_res, 1), 0);
a880 1
       
d903 3
a905 1
        if((modes_index[i][2] == current_x_res) && (modes_index[i][3] == current_y_res) && (find_colours(descriptor_to_pixelformat(modes_index[i]),colourchoices[current_colours].iscolour) == current_colours))
d918 1
a918 1
                entry.flags=(hz==current_hz?1:0);
d928 1
d931 68
a998 1
    }          
d1003 120
d1136 2
a1137 2
    bool             match = FALSE;
    int              num, type;
d1164 2
a1165 10

                /* Check for a file_format:1 string */
                while (!feof(fp) && match==FALSE)
                {
                    fgets(string, 256, fp);
                    if (strncmpa(string, FileFormat, strlen(FileFormat))==0) match=TRUE;
                }

                /* Check for monitor_title:xxx */
                if (match)
d1167 1
a1167 31
                    new_ref = NULL;
                    match = FALSE;
                    while (!feof(fp))
                    {
                        fgets(string, 256, fp);
                        if (string[strlen(string)-1]==10) string[strlen(string)-1]=0;
                        if (strncmpa(string, MonitorTitle, strlen(MonitorTitle))==0)
                        {
                            char *store;

                            /* Found a monitor title, so store details in a structure */
                            match=TRUE;
                            store=malloc(sizeof(monitor_ref) + /* For new_ref */
                                         strlen(dirname)+1 +   /* For new_ref->filename */
                                         strlen(string)-strlen(MonitorTitle)+1 /* For new_ref->monitor_name */);
                            if (store == NULL)
                            {
                                error_trap(common_error(messages_lookup("NotEnoughMemory")), 0);
                                return;
                            }
                            new_ref=(monitor_ref *)&store[0];
                            new_ref->file_name    =&store[0+sizeof(monitor_ref)];
                            new_ref->monitor_name =&store[0+sizeof(monitor_ref)+strlen(dirname)+1];
                            new_ref->next = NULL;
                            strcpy(new_ref->file_name, dirname);
                            strcpy(new_ref->monitor_name, string+strlen(MonitorTitle));
                            *monitors_list_tail=new_ref;
                            monitors_list_tail=&new_ref->next;
                            break;
                        }
                    }
d1169 5
a1173 2
                    /* Check for DPMS state */
                    if (match)
d1175 3
a1177 11
                        while (!feof(fp))
                        {
                            fgets(string, 256, fp);
                            if (string[strlen(string)-1]==10) string[strlen(string)-1]=0;
                            if (strncmpa(string, DPMSState, strlen(DPMSState))==0)
                            {
                                /* Found the DPMS_state: string */
                                new_ref->dpms_state=atoi(string+strlen(DPMSState));
                                break;
                            }
                        }
d1179 10
a1189 1

a1211 1
    strcpy(buffer, MonitorsDirectory);
d1214 4
a1217 1
    construct_monitors_list(buffer, buffer+1024);
d1231 1
d1235 1
d1243 7
a1253 1
    entry.help_message = NULL;
d1265 1
d1270 1
d1288 1
a1288 1
        if (strcmp(last_dirname, this_dirname) == 0)
d1290 6
a1295 6
            /* More to add to an existing group */
            this_submenu = last_submenu;
        }
        else
        {
            if (strlen(this_dirname) != 0)
a1314 7
            else
            {
                /* Not existing, not new, so back up to top menu */
                *last_dirname = '\0';
                this_submenu = montype_menu_id;
                where = 0; /* After "Auto" */
            }
d1316 9
d1346 8
d1369 1
d1507 6
d1542 1
d1547 2
a1548 1
        if ((current_x_res==-1) || (current_y_res==-1) || (current_colours==-1))
d1550 9
a1558 2
            warning_box(messages_lookup("CantSaveMode"));
            return false;
d1560 7
d1568 7
a1574 9
        /* Find the descriptor entry so we can work out the RGB/alpha settings */
        int rgb_alpha = 0;
        for(int i=0;i<nummodes;i++)
        {
            if((modes_index[i][2] == current_x_res) && (modes_index[i][3] == current_y_res) && (descriptor_hz(modes_index[i]) == current_hz))
            {
                gv_pixelformat format = descriptor_to_pixelformat(modes_index[i]);
                int colours = find_colours(format,colourchoices[current_colours].iscolour);
                if(colours == current_colours)
d1576 8
a1583 3
                    /* Found it! */
                    rgb_alpha = (format.modeflags & ModeFlag_DataFormatSub_Mask) >> 14;
                    break;
d1586 1
a1587 3

        sprintf(line1, LoadModeCmd " %s", current_monitor_file);
        sprintf(line2, WimpModeCmd " X%d Y%d %s F%d%s", current_x_res, current_y_res, colourchoices[current_colours].text, current_hz, rgb_alpha_mode[rgb_alpha]);
d1595 1
a1595 1
        _swix(Wimp_SetMode, _IN(0), 27);
d1601 26
a1626 26
      char *filename;

      if (file_to_write == FTW_CONFIG)
          filename = PreDeskConfigFile;
      else
          filename = ScrapConfigFile;

      _swix(OS_File, _INR(0,1)|_IN(5), OSFile_WriteAttr, filename, read_attribute | write_attribute); /* Ignore error if file not found */
      dest_fp = fopen(filename, "w");
      if (dest_fp == NULL)
      {
          error_trap(common_error(messages_lookup_with_parameter("CantWriteFile", filename)), 0);
          return false;
      }

      /* Write the LoadModeFile and WimpMode commands to the file */
      if (!montype_auto)
      {
          fputs(line1, dest_fp);
          fputc(NewLine, dest_fp);
          fputs(line2, dest_fp);
          fputc(NewLine, dest_fp);
      }

      fclose(dest_fp);
      error_trap(_swix(OS_File, _INR(0,2), OSFile_SetType, filename, FileType_Obey), 0);
d1645 11
a1655 1
    _swix(OS_CLI, _IN(0), line2);
@


1.17
log
@Fix for thinking 0th model is Auto type
The current_montype variable now holds the entry number within the menu for the selected manufacturer, whereas it used to be the current entry for the 1 (and only) models menu.
So, when selecting any 0th model from a submenu this would be mistaken as the former 'Auto' entry, and the PreDesk$Configure file wiped out.

Rescope current_montype to be static so it can only be used for its intended purpose, and derive 'Auto' or not in set_monitor_choices() by whether the filename is NULL like elsewhere.
Use defines when calling OS_ScreenMode rather than magic numbers.
Should fix issue described in https://www.riscosopen.org/forum/forums/11/topics/6370 introduced in ScrnSetup-0_36.

Version 0.38. Tagged as 'ScrnSetup-0_38'
@
text
@d101 2
a102 1
extern int  main_window_id, dpms_window_id, montype_menu_entries, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
d367 1
a367 1
        menus_are_grey=1;
d390 6
a436 1
    /* Tick current,and refresh the display field */
d439 1
@


1.16
log
@Make the previous selection more obvious
Having chosen a monitor type from within a group, it wasn't very obvious from which group it came.
Follow the same behaviour as a font menu: tick the parent when an exclusive selection is made from its child.

Version 0.37. Tagged as 'ScrnSetup-0_37'
@
text
@d101 1
a101 1
extern int  main_window_id, dpms_window_id, montype_menu_entries, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_montype, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
d564 1
a564 1
    error_trap(_swix(OS_ScreenMode, _IN(0)|_IN(1), 3, desktop_monitortype), 0);
d1304 1
d1306 1
a1306 2
    /* Find monitor type (0=Auto) */
    if (current_montype > 0)
d1340 1
a1340 1
        _swix(OS_ScreenMode, _IN(0)|_IN(1), 3, -1);
d1363 1
a1363 1
      if (current_montype > 0)
d1383 1
a1383 1
        if (current_montype > 0)
d1386 1
a1386 1
            _swix(OS_ScreenMode, _IN(0)|_IN(1), 3, -1); /* Auto from CMOS */
@


1.15
log
@Group manufacturers together in the type menu
The plugin scans all the subdirectories of BootResources:Configure.Monitors but then presents the findings unsorted in a huge menu. Now there are lots of MDFs the menu is so big it has a scrollbox too.
To simplify this, and make finding the right one easier, collect up the monitors by manufacturer (inferred from name of the topmost directory) into submenus.
Tested on a Risc PC with a mix of complexities of subdirectories from a default !Boot.

Version 0.36. Tagged as 'ScrnSetup-0_36'
@
text
@d101 3
a103 2
extern int  main_window_id, dpms_window_id, current_montype_menu_id, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_montype, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;

d376 1
a376 4
                error_trap(menu_set_tick(0, current_montype_menu_id, current_montype, 0), 0);
                error_trap(menu_set_tick(0, m->menu_id, m->menu_entry, 1), 0);
                current_montype = m->menu_entry;
                current_montype_menu_id = m->menu_id;                
d386 1
a386 4
        error_trap(menu_set_tick(0, current_montype_menu_id, current_montype, 0), 0);
        error_trap(menu_set_tick(0, montype_menu_id, 0, 1), 0);
        current_montype = 0;
        current_montype_menu_id = montype_menu_id;
d1040 1
a1078 1
                extern int montype_menu_select(int, ToolboxEvent *, IdBlock *, void *); /* main.c */
d1091 1
@


1.14
log
@Make monitor type into a display field + popup menu
Was previously a StringSet, but these are limited to only one level of menu tree.
Turned off "Deliver event before showing" for the popups in the main window, since nothing registered events against them.
No longer spends an eternity rebuilding the monitors menu when adjust clicking on 'Cancel', because the read_choices() function also used to scan the MDFs to make the menu. Now it really does just read the choices back in.
Correction to interactive help for the "Resolution" menu - the guidance about square and rectangular pixels was back to front.

Version 0.35. Tagged as 'ScrnSetup-0_35'
@
text
@d41 1
d101 1
a101 1
extern int  main_window_id, dpms_window_id, montype_menu_id, res_menu_id, col_menu_id, current_colours, current_montype, current_res, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
d375 2
a376 2
                error_trap(menu_set_tick(0, montype_menu_id, current_montype, 0), 0);
                error_trap(menu_set_tick(0, montype_menu_id, m->menu_entry, 1), 0);
d378 1
d388 1
a388 1
        error_trap(menu_set_tick(0, montype_menu_id, current_montype, 0), 0);
d391 1
a903 2
    _swix (Hourglass_On, 0);

a992 2

    _swix (Hourglass_Off, 0);
a1000 1
 * Returns: Number of monitor titles found (useful for menu entries).        *
d1003 1
a1003 1
static int read_monitors_list(void)
d1005 1
a1005 3
    monitor_ref *ref;
    char         buffer[1024];
    int          size = 0;
d1011 1
d1013 1
a1013 9

    ref=monitors_list;
    while (ref)
    {
        size++;
        ref=ref->next;
    }

    return size;
d1028 5
a1037 1
    entry.flags = 0;
d1050 20
a1069 1
        entry.component_id++;
d1072 37
a1108 1
        error_trap(menu_add_entry(0, montype_menu_id, Menu_AddEntryAtEnd, (char *)&entry, &ref->menu_entry), 0);
@


1.13
log
@Leave the selected monitor type correct after hitting 'Set'
When the monitor type is Auto at startup (type=3) and the user selects a monitor from an MDF (type=7) when pressing 'Set' the temporary instance of the ScreenModes module is killed off (in program_exit()) which restores the monitor type back to what it was when starting (type=3). That leaves DisplayManager thinking there's an MDF loaded, but the base instance of ScreenModes thinking not.
main.c/defines.h:
Minor unrelated clean ups.
monitor.c:
When saving the settings, kill off the temporary instance, apply the setting, then create a new one - this is much like adjust clicking on cancel does.
Complete a TODO with an error message if the settings file wont open.
Messages;
New error token for the TODO.

Fixes ticket #372.

Version 0.30. Tagged as 'ScrnSetup-0_30'
@
text
@d50 1
a50 9
typedef struct monitor_ref
{
    struct monitor_ref *next;
    char               *monitor_name;
    char               *file_name;
    int                 dpms_state;
}   monitor_ref;

static monitor_ref  *monitors_list = NULL;
d100 1
a100 1
extern int  main_window_id, dpms_window_id, res_menu_id, col_menu_id, current_colours, currently_ticked, menus_are_grey, hz_menu_id, current_hz, hz_menu_entries;
d373 4
a376 1
                error_trap(stringset_set_selected(0, main_window_id, MonitorTypeStringSet, m->monitor_name), 0);
d384 6
a389 1
        error_trap(stringset_set_selected(0, main_window_id, MonitorTypeStringSet, messages_lookup("Auto")), 0);
d413 1
a413 1
    error_trap(displayfield_get_value(0, main_window_id, ResolutionDisplay, res_string, 256, 0), 0);
d416 1
a416 1
        error_trap(menu_get_entry_text(0, res_menu_id, i, menu_string, 256, 0), 0);
d419 1
a419 1
            error_trap(menu_set_tick(0, res_menu_id, currently_ticked, 0), 0);
d421 1
a421 1
            currently_ticked=i;
d436 1
a436 1
        error_trap(menu_get_entry_text(0, col_menu_id, current_colours, menu_string, 256, 0), 0);
d449 1
a449 1
            error_trap(menu_get_entry_text(0, hz_menu_id, i, menu_string, 256, 0), 0);
d821 2
a822 2
    currently_ticked=0;
    error_trap(menu_set_tick(0, res_menu_id, currently_ticked, 1), 0);
d1002 1
a1002 2
 * Returns: Memory required to construct a comma seperated string of all the *
 *          monitor titles (useful for stringset_set_available).             *
d1005 1
a1005 1
int read_monitors_list(void)
d1018 1
a1018 1
    while (ref->next)
d1020 1
a1020 1
        size+=strlen(ref->monitor_name)+1;
a1022 2
    size+=strlen(ref->monitor_name)+1;
    size+=16;
d1029 1
a1029 1
 * construct_monitors_menu                                                   *
d1031 1
a1031 1
 * Build a menu string with the details of all available MDFs.               *
a1032 1
 * In: menustring -> memory to construct string in.                          *
d1035 1
a1035 1
void make_monitors_menu(char *menustring)
d1038 3
d1042 10
a1051 2
    sprintf(menustring, "%s,", messages_lookup("Auto"));
    if (monitors_list==0) menustring[strlen(menustring)]=0;
d1053 1
d1055 1
a1055 1
    while (ref->next)
d1057 4
a1060 2
        strcat(menustring, ref->monitor_name);
        strcat(menustring, ",");
a1062 1
    strcat(menustring, ref->monitor_name);
d1078 1
a1078 1
    displayfield_get_value(0, main_window_id, ResolutionDisplay, buffer, 256, &nbytes);
d1208 1
a1208 1
void switch_monitor(int menusel)
a1209 1
    monitor_ref *rover;
a1210 1
    int i;
a1218 8
    /* Find the monitor that's just been selected, in our array */
    i = 0;
    for ( rover = monitors_list; rover; rover = rover->next )
    {
        if (i==menusel ) break;
        i++;
    }

a1259 1
    int   type;
d1262 1
a1262 3
    error_trap(stringset_get_selected(1, main_window_id, MonitorTypeStringSet, &type), 0);

    if (type>0)
a1264 1

d1319 1
a1319 1
      if (type > 0)
d1339 1
a1339 1
        if (type > 0)
@


1.12
log
@Fix a couple of issues
Detail:
  Resources/UK/Res,fae - Change the default Colours box text to "4096 colours", as it's now the longest string the box needs to display. Fixes "buffer too short" error when trying to select a 4K colour mode.
  c/monitor - Adjust switch_colour() so that it checks both the X and Y dimensions when finding the new mode instead of just the X dimension. Avoids the selection unintentionally switching to the tallest available mode with the matching width when all you want to do is change the number of colours.
  c/monitor - Adjust update_monitor_displayfields() so that the monitor text box is only reset to "Auto" if it failed to find a monitor. Fixes a visible flicker on some machines due to the display temporarily switching to "Auto" when changing settings.
Admin:
  Tested on RiscPC with latest ROM softload


Version 0.29. Tagged as 'ScrnSetup-0_29'
@
text
@d564 1
a564 1
    if ( !desktop_instantiation ) return;
d1316 6
a1321 2
      dest_fp=fopen(filename, "w");
      if (!dest_fp) return false; /* TODO - Show an error! */
d1324 1
a1324 1
      if (type>0)
d1336 15
@


1.11
log
@Update to add support for new screen modes
Detail:
  Resources/UK/Res,fae - Add new 4K and 64K entries to colours menu
  c/monitor - Generalise mode provider block parsing to deal with the fact we might encounter both new and old format blocks. Rework handling of colour menu entries and colour selection to deal with 4K & 64K modes and the possibility of RGB/alpha variants. Update PreDesk configuration file parsing to prefer to use OS_ScreenMode 13 where possible.
Admin:
  Tested on Iyonix & BB with new and old ROMs
  Requires Kernel-5_35-4_79_2_203 to build


Version 0.28. Tagged as 'ScrnSetup-0_28'
@
text
@d353 1
a363 3
    if(monitors_list)
        error_trap(stringset_set_selected(0, main_window_id, MonitorTypeStringSet, messages_lookup("Auto")), 0);

d382 1
d388 3
d1162 3
@


1.10
log
@Minor ScrnSetup improvements
* Get OS_Byte/OS_File/filetypes/CMOS/OS_Module defs from header files.
* Fix ticket #312 (misuse of OS_GBPB means enumerating dirs on a non FileCore filing system could get stuck).
* Simplify the steps in the mode 'Try' sequence, now the mouse is bounded in the 'Keep/Cancel' message box (with the same 5s timeout) so that you can't click elsewhere on the main window. Previously, you could click 'Set', then the 5s would elapse and the mode revert to not the one you set.
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed.

Note that in reviewing the plugins the minimum resolution considered to fit without scroll bars is 640x480, a special case is made of the screen setup plugin in case it starts in some mode less than that and you can't reach the 'OK' button to set it to anything else.

Version 0.25. Tagged as 'ScrnSetup-0_25'
@
text
@d38 1
d69 1
a69 1
static int   current_x_res, current_y_res, current_flags;   /* colours are 0-7 as per the menu */
d71 36
a106 6
static int  cmenutodepth[8] = {0,1,2,2,3,3,4,5};
static char cdepth[8]={0,1,2,2,3,3,4,5};        /* menu entry->colour depth */
static char cdeptht[8]={0,0,0,1,0,1,1,1};       /* menu entry->colour/black and white */
static char cdepthc[6]={0,1,3,5,6,7};           /* colour depth->colour menu entry */
static char cdepthg[6]={0,1,2,4,6,7};           /* colour depth->grey menu entry */
static char *cmenutotext[8] = {"C2","C4","G16","C16","G256","C256","C32K","C16M"};
d112 99
d270 2
a271 1
        int count = sscanf(buffer, "%s %s %s %s %s", res0, res1, res2, res3, res4);
d273 3
a275 20
        if (   (strncmp(res0, WimpModeCmd, strlen(WimpModeCmd))==0)
            && ((count == 4) || (count == 5))
            && (res1[0]=='X')
            && (res2[0]=='Y')
            && (res3[0]=='C' || res3[0]=='G') )
        {
            /* Deal with resolution */
            current_x_res=atoi(res1+1);
            current_y_res=atoi(res2+1);

            /* Deal with colours */
            if (strcmp(res3, "C2")==0) current_colours=0;
            if (strcmp(res3, "C4")==0) current_colours=1;
            if (strcmp(res3, "G16")==0) current_colours=2;
            if (strcmp(res3, "C16")==0) current_colours=3;
            if (strcmp(res3, "G256")==0) current_colours=4;
            if (strcmp(res3, "C256")==0) current_colours=5;
            if (strcmp(res3, "C32K")==0) current_colours=6;
            if (strcmp(res3, "C32T")==0) current_colours=6;
            if (strcmp(res3, "C16M")==0) current_colours=7;
d277 37
a313 2
            /* Deal with frame rate */
            if(res4[0]=='F') current_hz = atoi(res4+1);
a317 1
                int modeblock[6];
d319 1
a319 1

d323 1
a323 1
                modeblock[3] = cmenutodepth[current_colours];
d325 7
a331 3
                modeblock[5] = -1;
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, 4, &xeig), 0);
                error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, 5, &yeig), 0);
d395 2
a396 1
            if (*(char*)&modes_index[i][6]=='\0')
d404 1
a404 1
                error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, (char*)&modes_index[i][6]), 0);
d425 1
a425 1
    for (i=0; i<8; i++)
d588 33
d628 2
a629 2
        const int *a = *(int **)aa;
        const int *b = *(int **)bb;
d631 1
a631 2
        if ( (a[1] & flags_squarepixel) != (b[1] & flags_squarepixel) )
                return (a[1] & flags_squarepixel) ? 1 : -1 ;
d633 1
a633 1
        if ( a[2] != b[2] ) return a[2] - b[2];         /* Xres */
d635 2
a636 1
        if ( a[3] != b[3] ) return a[3] - b[3];         /* Yres */
d638 1
a638 3
        if ( a[4] != b[4] ) return a[4] - b[4];         /* pixel depth */

        return b[5] - a[5];                             /* frame rate */
d665 1
a665 1
                2, 0, 0, 0, &nummodes, &spaceformodes), 0);
d682 1
a682 1
                2, 0, modes_block, -spaceformodes), 0);
d699 1
d702 40
a741 1
        int save,xeig,yeig;
d743 3
a745 7
        /* convert into mode selector */
        save = ((int *)rover)[6];
        ((int *)rover)[6] = -1;
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), rover+4, 4, &xeig), 0);
        error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), rover+4, 5, &yeig), 0);
        /* put back what we corrupted */
        ((int *)rover)[6] = save;
d747 9
a755 1
        if ( xeig == yeig ) ((int *)rover)[1] |= flags_squarepixel;
d757 3
a759 2
        modes_index[i] = (int *)rover;
        rover = (char *)((int)(rover + 24 + strlen( rover+24 ) + 4) & ~3);
d761 1
d766 12
d792 3
a794 1
        colourmask = colourmask | 1<<modes_index[i][4];
d799 1
a799 1
             ((char *)modes_index[i])[24] )
d812 1
a812 1
            entry.text=(char *)modes_index[i]+24;
d823 5
a827 18
    if ((colourmask & 1) == 0)
       menu_set_fade(0, col_menu_id, 0, 1);
    if ((colourmask & 2) == 0)
       menu_set_fade(0, col_menu_id, 1, 1);
    if ((colourmask & 4) == 0)
       {
       menu_set_fade(0, col_menu_id, 2, 1);
       menu_set_fade(0, col_menu_id, 3, 1);
       }
    if ((colourmask & 8) == 0)
       {
       menu_set_fade(0, col_menu_id, 4, 1);
       menu_set_fade(0, col_menu_id, 5, 1);
       }
    if ((colourmask & 16) == 0)
       menu_set_fade(0, col_menu_id, 6, 1);
    if ((colourmask & 32) == 0)
       menu_set_fade(0, col_menu_id, 7, 1);
d851 1
a851 1
        if((modes_index[i][2] == current_x_res) && (modes_index[i][3] == current_y_res) && (modes_index[i][4] == cdepth[current_colours]))
d853 2
a854 1
            if(!hz_menu_entries || (modes_index[i][5] != modes_index[i-1][5]))
d857 1
a857 1
                sprintf(text,"%dHz",modes_index[i][5]);
d861 1
a861 1
                    current_hz = modes_index[i][5];
d864 1
a864 1
                entry.flags=(modes_index[i][5]==current_hz?1:0);
d1065 1
a1065 1
    int  x_to_find, y_to_find, nbytes, i, bestmatch;
d1072 1
a1072 1
        if (strcmp((char*)&modes_index[i][6], buffer)==0) break;
d1083 1
d1090 2
a1091 1
            if (modes_index[i][4] > cdepth[current_colours]) break;
d1094 5
a1098 1
            if (bestmatch<0 || modes_index[bestmatch][4]!=modes_index[i][4]) bestmatch=i;
d1106 1
a1106 8
    if (modes_index[bestmatch][4]!=cdepth[current_colours])
    {
        /* Basically this goes:
           Lookup the colour depth we can achieve in one of the colour
           or grey downgrade tables. We choose which based on whether
           the old current_colours was colour or greys. */
        current_colours = (cdeptht[current_colours]?cdepthc:cdepthg)[ modes_index[bestmatch][4] ];
    }
d1111 1
a1111 1
    current_hz=modes_index[bestmatch][5];
d1139 1
a1139 1
        if (modes_index[i][4]==cdepth[menusel])
d1145 2
a1146 2
                char c1=*(char*)&modes_index[bestmatch][6];
                char c2=*(char*)&modes_index[i][6];
d1179 1
a1179 1
    current_hz=modes_index[bestmatch][5];
d1271 17
d1289 1
a1289 1
        sprintf(line2, WimpModeCmd " X%d Y%d %s F%d", current_x_res, current_y_res, cmenutotext[current_colours], current_hz);
@


1.9
log
@Fix null pointer dereference when monitor is unknown. Be more sensible when setting/testing mode.
Detail:
  c/monitor - Added a few checks to make sure current_monitor_file isn't null before we try accessing it. Make sure monitor is reset to "Auto" if switching to a set of settings where no MDF is loaded.
  c/monitor, h/monitor - Updated set_monitor_choices to only complain about unspecified mode settings if an MDF is in use. Return true/false for whether the settings were applied or not.
  c/main - Make use of set_monitor_choices return code to decide whether the 5 second "try" timeout is needed or not. Make sure selected monitor gets reset when switching between different settings during the various "try" stages.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.23. Tagged as 'ScrnSetup-0_23'
@
text
@d35 4
a46 1
#define Service_ModeFileChanged 0x94
d344 1
a344 1
        if (_swix(OS_Module, _IN(0)|_IN(1), 18, tbuf)) break;
d349 1
a349 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), 18, "ScreenModes", &desktop_instantiation), 0);
d351 1
a351 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), 14, tbuf), 0);
d375 1
a375 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), 16, tbuf ), 0);
d390 1
a390 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1)|_OUT(5), 18, "ScreenModes", &desktop_instantiation), 0);
d395 1
a395 1
    error_trap(_swix( OS_Module, _IN(0)|_IN(1), 16, tbuf), 0);
d415 1
a415 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), 16, tbuf), 0);
d430 1
a430 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), 4, tbuf), 0);
d656 2
a657 2
    _kernel_oserror *e=NULL;
    monitor_ref     *new_ref=NULL;
d661 3
a663 1
    int              num=0, last_item_read=0, pos=0, type, match=FALSE;
d665 1
a665 1
    dirname_end=dirname+strlen(dirname);
d669 1
a669 1
    while(last_item_read!=-1)
d672 4
a675 4
        _swi(OS_GBPB, _INR(0,6)|_OUTR(3,4),
                      9, dirname, dirname_end+1, 1, pos,
                      buffer_end - (dirname_end+1), 0,
                      &num, &last_item_read);
a680 2
            pos+=num;

d682 2
a683 2
            e = _swix(OS_File, _INR(0,1)|_OUT(0), 17, dirname, &type);
            if ((e == NULL) && (type == 2))
d703 2
a704 1
                    match=FALSE;
d754 1
d780 1
a780 1
    sprintf(buffer, MonitorsDirectory);
d1062 1
a1062 1
      _swix(OS_File, _INR(0,1)|_IN(5), 4, filename, 3); /* Ignore error if file not found */
d1076 1
a1076 1
      error_trap(_swix(OS_File, _INR(0,2), 18, filename, 0xFEB), 0);
@


1.8
log
@Enable hourglass while scanning monitor directories.
Check return result from malloc() and don't dereference NULL on failure.
Pointers initialised to NULL not 0.

Version 0.21. Tagged as 'ScrnSetup-0_21'
@
text
@d208 3
d221 1
a221 3

    /* Update monitor name display */
    for (m=monitors_list; m; m =m->next)
d223 2
a224 1
        if (strncmp(current_monitor_file, m->file_name, strlen(current_monitor_file))==0)
d226 5
a230 2
            error_trap(stringset_set_selected(0, main_window_id, MonitorTypeStringSet, m->monitor_name), 0);
            break;
d309 3
d1008 1
a1008 1
 * set_monitor_choices                                                     *
d1011 2
d1015 1
a1015 1
void set_monitor_choices(int file_to_write)
a1021 6
    if ((current_x_res==-1) || (current_y_res==-1) || (current_colours==-1))
    {
        warning_box(messages_lookup("CantSaveMode"));
        return;
    }

d1028 7
d1059 1
a1059 1
      if (!dest_fp) return;
d1076 2
@


1.7
log
@Internationalised the screensaver blank times.
When reading choices, read from Choices:.
If no screensaver is set then adjustclicking on 'Cancel' now correctly restores the DPMS saver as the default.
Use OS_FSControl instead of OS_CLI(*COPY).
'Auto' and 'Unknown' put in messages file.

Version 0.19. Tagged as 'ScrnSetup-0_19'
@
text
@d54 2
a55 2
static monitor_ref  *monitors_list=0;
static monitor_ref **monitors_list_tail=0;
d643 1
a643 1
static void construct_monitors_list(char *dirname, char* buffer_end)
d646 1
a646 1
    monitor_ref     *new_ref = 0;
d654 2
d660 3
a662 3
                         9, dirname, dirname_end+1, 1, pos,
                         buffer_end - (dirname_end+1), 0,
                         &num, &last_item_read);
d664 1
a664 1
        if (!e && num>0)
d671 2
a672 2
            e=_swix(OS_File, _INR(0,1)|_OUT(0), 17, dirname, &type);
            if (type==2)
d699 2
d703 12
a714 4
                            new_ref=malloc(sizeof(monitor_ref));
                            new_ref->file_name=malloc(strlen(dirname)+1);
                            new_ref->monitor_name=malloc(strlen(string)-strlen(MonitorTitle)+1);
                            new_ref->next=0;
d745 2
@


1.6
log
@Get error box title from "_TaskName" token in messages file.
Use Mask_NoNullEvents/Gadget_Faded flag from toolbox headers.
Use OSFile 8 to create directories not OS_CLI.
Code in 'common.[c|h]' made more common.

Version 0.18. Tagged as 'ScrnSetup-0_18'
@
text
@d200 1
a200 1
        error_trap(displayfield_set_value(0, main_window_id, ResolutionDisplay, UnknownString), 0);
d203 1
a203 1
        error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, UnknownString), 0);
d206 1
a206 1
        error_trap(displayfield_set_value(0, main_window_id, FrameRateDisplay, UnknownString), 0);
d357 1
a357 1
        sprintf(tbuf, LoadModeCmd "%s", current_monitor_file);
d782 1
a782 1
    sprintf(menustring, "%s,", AutoString);
d966 1
a966 1
        sprintf(tbuf, "%s %s", LoadModeCmd, current_monitor_file);
d1010 1
a1010 1
        sprintf(line1, LoadModeCmd "%s", current_monitor_file);
@


1.5
log
@Add framerate selection to ScrnSetup plugin. Update to take version number from VersionNum file.
Detail:
  c/main, c/monitor, h/defines, h/monitor, Resources/UK/Res,fae - Added an extra box to the display settings are to allow selection of screen refresh rate.
  Makefile, Resources/UK/Messages - Updated so that version number is taken from the VersionNum file instead of being hard-coded in the messages file.
Admin:
  Tested on Iyonix. New plugin seems to work OK with parsing both the old and new WimpMode lines, as well as when the PreDesk.Configure.Monitor file is missing altogether.


Version 0.16. Tagged as 'ScrnSetup-0_16'
@
text
@d41 1
@


1.4
log
@Fix broken ScrnSetup Configure plugin
Detail:
  read_current_mode_settings() in monitor.c now correctly parses the default Choices:Boot.PreDesk.Configure.Monitor file (The addition of the Castle license text was causing the original code to fail)
  update_monitor_displayfields() in monitor.c now behaves correctly if the current colour depth is unknown
  trap_error() in common.c/.h has been updated to allow the reporting of the file & line that caused the error, to allow errors to be tracked down more easily in the future.
Admin:
  Tested on rev C2 beagleboard.


Version 0.14. Tagged as 'ScrnSetup-0_14'
@
text
@d73 1
a73 1
extern int  main_window_id, dpms_window_id, res_menu_id, col_menu_id, current_colours, currently_ticked, menus_are_grey;
d90 1
d99 1
d136 1
a136 1
        sscanf(buffer, "%s %s %s %s", res0, res1, res2, res3);
d139 1
d159 3
d187 2
a188 2
 * Update all the monitor displayfields (monitor, resolution, colours)       *
 * according to the current settings.                                        *
d204 3
d213 2
d276 13
d590 47
d852 3
d920 3
d973 1
d1010 1
a1010 1
        sprintf(line2, WimpModeCmd " X%d Y%d %s", current_x_res, current_y_res, cmenutotext[current_colours]);
@


1.3
log
@Added low res sprites.
Changed RMEnsure level to UtilityModule 3.50 as this relies on OS_ScreenMode
The colour depth menu will now have entries greyed out when the
list of mode descriptions given to it indicates there are some colour
depths unachieveable on this hardware.

Version 0.11. Tagged as 'ScrnSetup-0_11'
@
text
@d106 3
a108 9
        /* First line should be a LoadModeFile command */
        fgets(buffer, 1024, fp);
        if (strncmp(buffer, LoadModeCmd, strlen(LoadModeCmd))==0)
        {
            if (buffer[strlen(buffer)-1]==NewLine)
                buffer[strlen(buffer)-1]=0;
            /* Get current selected MDF */
            string=strchr(buffer, ' ');
            if (!string)
d113 42
a154 7
            current_monitor_file=malloc(strlen(string));
            if (!current_monitor_file)
            {
                fclose(fp);
                return;
            }
            strcpy(current_monitor_file, string+1);
d156 2
a157 8
            /* Next line should be a WimpMode command */
            fgets(buffer, 1024, fp);
            sscanf(buffer, "%s %s %s %s", res0, res1, res2, res3);

            if (   (strncmp(res0, WimpModeCmd, strlen(WimpModeCmd))==0)
                && (res1[0]=='X')
                && (res2[0]=='Y')
                && (res3[0]=='C' || res3[0]=='G') )
d159 2
a160 14
                /* Deal with resolution */
                current_x_res=atoi(res1+1);
                current_y_res=atoi(res2+1);

                /* Deal with colours */
                if (strcmp(res3, "C2")==0) current_colours=0;
                if (strcmp(res3, "C4")==0) current_colours=1;
                if (strcmp(res3, "G16")==0) current_colours=2;
                if (strcmp(res3, "C16")==0) current_colours=3;
                if (strcmp(res3, "G256")==0) current_colours=4;
                if (strcmp(res3, "C256")==0) current_colours=5;
                if (strcmp(res3, "C32K")==0) current_colours=6;
                if (strcmp(res3, "C32T")==0) current_colours=6;
                if (strcmp(res3, "C16M")==0) current_colours=7;
d162 9
a170 16
                /* Find out if selected mode is rectangular or square pixel */
                if ( current_x_res != -1 && current_y_res != -1 && current_colours != -1 )
                {
                    int modeblock[6];
                    int xeig, yeig;

                    modeblock[0] = 1;
                    modeblock[1] = current_x_res;
                    modeblock[2] = current_y_res;
                    modeblock[3] = cmenutodepth[current_colours];
                    modeblock[4] = -1;
                    modeblock[5] = -1;
                    error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, 4, &xeig), 0);
                    error_trap(_swix(OS_ReadModeVariable, _IN(0)|_IN(1)|_OUT(2), modeblock, 5, &yeig), 0);
                    if (xeig==yeig) current_flags |= flags_squarepixel;
                }
d258 6
a263 3
    error_trap(menu_set_tick(0, col_menu_id, current_colours, 1), 0);
    error_trap(menu_get_entry_text(0, col_menu_id, current_colours, menu_string, 256, 0), 0);
    error_trap(displayfield_set_value(0, main_window_id, ColourDisplay, menu_string), 0);
@


1.2
log
@Addition of "Try" button to the mode settings frame,similar in principal
to the "Try" button for the screen saver.
Associated Res file change.

Version 0.10. Tagged as 'ScrnSetup-0_10'
@
text
@d64 1
a64 1
static int   current_x_res, current_y_res, current_flags, current_colours;   /* colours are 0-7 as per the menu */
d73 1
a73 1
extern int  main_window_id, dpms_window_id, res_menu_id, currently_ticked, menus_are_grey;
d192 1
a192 1
        error_trap(stringset_set_selected(0, main_window_id, ColoursStringSet, UnknownString), 0);
d196 2
a197 1
        grey_gadget(main_window_id, ColoursStringSet);
d247 11
a257 2
    /* Update colours display */
    error_trap(stringset_set_selected(1, main_window_id, ColoursStringSet, (char*)current_colours), 0);
d427 1
a427 1
    int   i, spaceformodes, numdiffmodes, flag, entryno;
d504 1
a504 1
    //for ( i=0; i<nummodes; i++ )
d507 2
d534 21
@


1.1
log
@Initial revision
@
text
@d22 5
d40 1
d42 1
a42 1
#define Service_ModeFileChanged 0x94    
d82 1
a82 1
void read_current_mode_settings(void)
d99 5
a103 2
    /* Read in the PreDesk config file */
    fp=fopen(PreDeskConfigFile, "r");
d126 1
a126 1
            
d130 1
a130 1
  
d170 1
a170 1
    }    
d187 1
a187 1
    
d190 1
a190 1
    
d193 1
a193 1
        
a200 1
    
d203 1
a203 1
    for (m=monitors_list; m; m =m->next)   
d205 1
a205 1
        if (strncmp(current_monitor_file, m->file_name, strlen(m->file_name))==0)
d231 1
a231 1
    
d245 1
a245 1
    
d263 1
a263 1
    for (m=monitors_list; m; m =m->next)   
d273 1
a273 1
    
d286 1
a286 1
    
d292 1
a292 1
    }    
d299 1
a299 1
    
d342 1
a342 1
    error_trap(_swix( OS_Module, _IN(0)|_IN(1), 16, tbuf), 0);                      
d362 1
a362 1
    error_trap(_swix(OS_Module, _IN(0)|_IN(1), 16, tbuf), 0);              
d429 1
a429 1
    
d447 1
a447 1
    
d452 1
a452 1
    if (!modes_index) 
d457 1
a457 1
    
d467 1
a467 1
        save = ((int *)rover)[6];       
d472 1
a472 1
        ((int *)rover)[6] = save;       
d492 1
a492 1
    flag = modes_index[0][1] & flags_squarepixel;
d494 2
a495 1
    for ( i=0; i<nummodes; i++ )
d511 1
a511 1
            
d519 1
a519 1
    
d539 1
a539 1
        
a541 1

d553 1
a553 1
            
d567 1
a567 1
                
d574 1
a574 1
                
d598 1
a598 1
                    
d611 1
a611 1
                            }       
d613 1
a613 1
                    }    
d638 1
a638 1
    
d642 1
a642 1
    
d655 2
a656 2
}   
  
d669 1
a669 1
    
d695 1
a695 1
    
d697 1
a697 1
    
d700 1
d702 1
d707 3
a709 3
    x_to_find=modes_index[i][2];
    y_to_find=modes_index[i][3];
    
d711 1
a711 1
    bestmatch=-1;
d719 1
a719 1
            
d724 1
a724 1
    
d740 1
a740 1
    current_y_res=modes_index[bestmatch][3]; 
d797 1
a797 1
    
d800 1
a800 1
    
d809 1
a809 1
                
d845 1
a845 1
        
d857 1
a857 1
    
d860 1
a860 1
 
d867 1
a867 1
 * write_monitor_choices                                                     *
d872 1
a872 1
void write_monitor_choices(void)
d903 26
a928 3
    /* Open a scrap file to build the new version of the file */
    dest_fp=fopen(PreDeskConfigFile, "w");
    if (!dest_fp) return;
d930 2
a931 11
    /* Write the LoadModeFile and WimpMode commands to the file */
    if (type>0)
    {
        fputs(line1, dest_fp);
        fputc(NewLine, dest_fp);
        fputs(line2, dest_fp);
        fputc(NewLine, dest_fp);
    }
    
    fclose(dest_fp);
    error_trap(_swix(OS_File, _INR(0, 2), 18, PreDeskConfigFile, 0xFEB), 0);
@


1.1.1.1
log
@Initial import of ScrnSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Fixed crash which can occur if ScrSavers directory doesn't exist.
A click on Set now actually sets the screen for the current session
(ie. not just on re-boot)
@
text
@a21 2
/*          16-Apr-98: RML: save_monitor_choices now also changes the to the */
/*                          new setup.                                       */
a907 3
    
    _swix(OS_CLI, _IN(0), line1);
    _swix(OS_CLI, _IN(0), line2);
@


1.1.1.3
log
@Resolution menu now same order as display manager.
@
text
@d387 1
a387 1
                return (b[1] & flags_squarepixel) ? 1 : -1 ;
d389 1
a389 1
        if ( a[2] != b[2] ) return b[2] - a[2];         /* Xres */
d391 1
a391 1
        if ( a[3] != b[3] ) return b[3] - a[3];         /* Yres */
d393 1
a393 1
        if ( a[4] != b[4] ) return b[4] - a[4];         /* pixel depth */
@


1.1.1.4
log
@Screensaver settings plug-ins now called SvrSetup.
@
text
@a23 1
/*          01-May-98: RML: Bug fix.                                         */
d387 1
a387 1
                return (a[1] & flags_squarepixel) ? 1 : -1 ;
d389 1
a389 1
        if ( a[2] != b[2] ) return a[2] - b[2];         /* Xres */
d391 1
a391 1
        if ( a[3] != b[3] ) return a[3] - b[3];         /* Yres */
d393 1
a393 1
        if ( a[4] != b[4] ) return a[4] - b[4];         /* pixel depth */
d486 1
a486 1
    flag = modes_index[nummodes-1][1] & flags_squarepixel;
d488 1
a488 2
    //for ( i=0; i<nummodes; i++ )
    for (i=nummodes-1; i>=0; i--)
a693 1
    {
a694 1
    }
d699 2
a700 2
    x_to_find = modes_index[i][2];
    y_to_find = modes_index[i][3];
d703 1
a703 1
    bestmatch = -1;
@


1.1.1.5
log
@Fixed bug which could cause wrong monitor name to be displayed if two MDFs
had very similar filenames.
@
text
@a24 2
/*          21-Jul-98: RML: Bug fix: Monitor name could be displayed wrong   */
/*                          if two very similar filenames existed.           */
d196 1
d200 1
a200 1
        if (strncmp(current_monitor_file, m->file_name, strlen(current_monitor_file))==0)
d536 1
@

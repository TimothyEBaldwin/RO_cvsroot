head	1.12;
access;
symbols
	PinSetup-0_24:1.12
	PinSetup-0_23:1.12
	PinSetup-0_22:1.11
	PinSetup-0_21:1.10
	PinSetup-0_20:1.9
	PinSetup-0_19:1.8
	PinSetup-0_18:1.8
	PinSetup-0_17:1.6
	PinSetup-0_16:1.5
	PinSetup-0_15:1.4
	PinSetup-0_14:1.4
	PinSetup-0_13:1.4
	PinSetup-0_12:1.3
	PinSetup-0_11:1.2
	PinSetup-0_10:1.1.1.6
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.6
	Ursula_RiscPC:1.1.1.6.0.2
	rleggett_PinSetup-0_09b:1.1.1.6
	rthornb_UrsulaBuild-19Aug1998:1.1.1.6
	UrsulaBuild_FinalSoftload:1.1.1.6
	rthornb_UrsulaBuild-29Jul1998:1.1.1.6
	rthornb_UrsulaBuild-22Jul1998:1.1.1.6
	rleggett_PinSetup-0_09:1.1.1.6
	rthornb_UrsulaBuild-15Jul1998:1.1.1.5
	rthornb_UrsulaBuild-07Jul1998:1.1.1.5
	rthornb_UrsulaBuild-17Jun1998:1.1.1.4
	rleggett_PinSetup-0_08:1.1.1.4
	rthornb_UrsulaBuild-03Jun1998:1.1.1.4
	rthornb_UrsulaBuild-27May1998:1.1.1.4
	rthornb_UrsulaBuild-21May1998:1.1.1.3
	rthornb_UrsulaBuild_01May1998:1.1.1.3
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2013.07.31.07.11.15;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	YeLg1afLQTiUKAZw;

1.11
date	2013.07.17.19.45.50;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	SaltlNJgLHpGnRXw;

1.10
date	2013.01.17.21.14.05;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	9FCAOzzKYdvGGBAw;

1.9
date	2013.01.02.22.38.05;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	1J7CzOyw7f0pDGyw;

1.8
date	2012.09.10.12.11.37;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	WfM8GtM10aMHPYjw;

1.7
date	2012.09.10.12.06.57;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	XK7uRdwovkl3OYjw;

1.6
date	2012.09.09.18.57.28;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	skbKDg9lUvGS6Tjw;

1.5
date	2012.06.26.23.39.12;	author jlee;	state Exp;
branches;
next	1.4;
commitid	0yTg8lwUMDe15haw;

1.4
date	2007.11.05.16.43.47;	author srevill;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.03.13.52.08;	author rsprowson;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.19.21.31.58;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.38.43;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.38.43;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.16.14.58.12;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.04.23.13.14.51;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.05.26.16.56.30;	author rleggett;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.07.06.11.05.24;	author rleggett;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.07.22.10.42.14;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Correction to system variable name
Allocated application name and system variable name sync'd

Version 0.23. Tagged as 'PinSetup-0_23'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    main.c                                                           */
/* Purpose: Main WIMP shell for Pinboard configuration                       */
/* Author:  Richard Leggett                                                  */
/* History: 28-Oct-97: RML: Begun.                                           */
/*          04-Nov-97: RML: First version given for testing.                 */
/*          13-Nov-97: RML: Minor modifications                              */
/*          30-Jan-98: RML: Tidied up a little.                              */
/*          20-Mar-98: RML: Minor modifications                              */
/*          16-Apr-98: RML: Tiled JPEGs no longer allowed.                   */
/*          23-Apr-98: RML: Now greys out the IconiseStack menu if Iconise   */
/*                          to Icon or Iconise to Iconbar is selected.       */
/*          01-Jul-98: RML: 'Drop image' in the custom tile drop zone is now */
/*                          icons, rather than a sprite.                     */
/*                          Reduced flicker in some redraw cases.            */
/*                          If Try was clicked, Cancel button restores saved */
/*                          state as was before Try.                         */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "colourdbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "defines.h"
#include "pinboard.h"
#include "wimplib.h"
#include "sprite.h"

#define MaxFilenameSize         1024
#define DefaultBackgroundColour 0x77777700
#define DefaultTextColour       0xffffff00

static unsigned int background_colour = DefaultBackgroundColour;
static unsigned int text_colour = DefaultTextColour;
static MessagesFD   messages_desc;
static IdBlock      idb;
static char         messages_string[255];
static char         rand_suffix;
static int          config_id;
static int          bgcolourbox_id = 0;
static int          txcolourbox_id = 0;
static int          current_tile = 1;
static int          max_std_tile;
static char*        custom_filename;
static int          custom_filetype;
static int*         client_sprite_area;
static int          changes_have_been_made = FALSE;


/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * redraw_custom_image_icon                                                  *
 *                                                                           *
 * Force a redraw of the custom_image icon                                   *
 *---------------------------------------------------------------------------*/

static void redraw_custom_image_icon(void)
{
    BBox gadget_bbox;

    error_trap(gadget_get_bbox(0, config_id, CustomDropZoneE, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * hide_custom_sprite_icons                                                  *
 *                                                                           *
 * Hide the default custom sprite drop zone icons (the spritefile icon, the  *
 * jpegfile icon and the display icon that says 'Drop image'). Show the icon *
 * which shows the custom image.                                             *
 *---------------------------------------------------------------------------*/

void hide_custom_sprite_icons(int hide)
{
    BBox bbox;
    int  invert;
    int  gadget;
    int  do_redraw;

    /* Always make sure the custom image area is redrawn */
    do_redraw = TRUE;

    /* There are two cases for the value of hide:
          hide = 1: Show the custom sprite icon with the tiled sprite in it, but hide the three
                    drop zone icons (sprite icon, jpeg icon, 'drop image' label).
          hide = 0: Show the three drop zone icons, but hide the icon with the tiled sprite in
                    it.
       In each case, the icons are hidden by putting them off the window (-ve x and -ve y co-ords)
    */

    for (gadget=CustomDropZoneA; gadget<=CustomDropZoneE; gadget++)
    {
        invert = 0;

        gadget_get_bbox(0, config_id, gadget, &bbox);

        if (gadget == CustomDropZoneE)
        {
            if ((hide) && (bbox.xmin < 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin > 0)) invert = TRUE;
        }
        else
        {
            if ((hide) && (bbox.xmin > 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin < 0)) invert = TRUE;
        }

        if (invert)
        {
            do_redraw = FALSE;
            bbox.xmin = -bbox.xmin;
            bbox.ymin = -bbox.ymin;
            bbox.xmax = -bbox.xmax;
            bbox.ymax = -bbox.ymax;
            gadget_move_gadget(0, config_id, gadget, &bbox);
        }
    }

    if (do_redraw) redraw_custom_image_icon();
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char backdrop_command[MaxFilenameSize];
    char pinboard_command[256];
    char string[MaxFilenameSize];
    int  radio_on;
    int  grid_lock;
    int  selected;
    int  lighter;
    int  random;
    int  type;

    /* First work out the *Backdrop command */
    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &radio_on), 0);
    switch (radio_on)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
            if (random)
            {
               sprintf(backdrop_command,
                       TextureResPath "RTexture %c\nBackdrop -T",
                       lighter ? 'L' : ' ');
            }
            else
            {
               pinboard_get_tile_filename(current_tile, max_std_tile, lighter, string);
               sprintf(backdrop_command, "Backdrop -T %s", string);
            }
            break;

        case CustomImageRadio:
            if (custom_filename[0] != 0)
            {
                error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &type), 0);
                switch (type)
                {
                    case ScaledRadioButton: sprintf(string, "Backdrop -S"); break;
                    case CentredRadioButton: sprintf(string, "Backdrop -C"); break;
                    default: sprintf(string, "Backdrop -T"); break;
                }
                sprintf(backdrop_command, "%s %s", string, custom_filename);
            }
            else
            {
                sprintf(backdrop_command, "Backdrop -Remove");
            }
            break;

       default:
           sprintf(backdrop_command, "Backdrop -R");
           break;
    }

    /* Add the colour switch to the backdrop command... */
    sprintf(string, " -Colour &%x ", background_colour);
    strcat(backdrop_command, string);

    /* ...and the icon text colour */
    sprintf(string, " -TextColour &%x\0", text_colour);
    strcat(backdrop_command, string);

    /* Now work out the *Pinboard command */
    strcpy(pinboard_command, "PinboardOptions");
    error_trap(optionbutton_get_state(0, config_id, GridLockOption, &grid_lock), 0);
    if (grid_lock) strcat(pinboard_command, " -G");

    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);
    switch (selected)
    {
        case 1: strcat(pinboard_command, " -ITIB"); break;
        case 2: strcat(pinboard_command, " -ITTL"); break;
        case 3: strcat(pinboard_command, " -ITBL"); break;
        case 4: strcat(pinboard_command, " -ITTR"); break;
        case 5: strcat(pinboard_command, " -ITBR"); break;
    }

    error_trap(stringset_get_selected(1, config_id, IconiseStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -ISV");

    error_trap(stringset_get_selected(1, config_id, TidyToMenu, &selected), 0);
    switch (selected)
    {
        case 0: strcat(pinboard_command, " -TTTL"); break;
        case 1: strcat(pinboard_command, " -TTBL"); break;
        case 2: strcat(pinboard_command, " -TTTR"); break;
        case 3: strcat(pinboard_command, " -TTBR"); break;
    }

    error_trap(stringset_get_selected(1, config_id, TidyStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -TSV");

    /* Now write the commands to the choices file */
    error_trap(pinboard_write_choices(backdrop_command, pinboard_command), 0);
}


/*---------------------------------------------------------------------------*
 * try_it                                                                    *
 *                                                                           *
 * User has clicked on 'Try' button, so make up a *Backdrop command and      *
 * execute it.                                                               *
 *---------------------------------------------------------------------------*/

static void try_it(void)
{
    char  backdrop_string[MaxFilenameSize];
    char  string[256];
    int   lighter;
    int   random;
    int   option;
    int   radio;

    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &option), 0);
    switch (option)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
            strcpy(backdrop_string, "Backdrop -Tile ");
            if (random)
            {
               /* Use 'RTexture' directly to randomise */
               sprintf(string,
                       "WimpTask " TextureResPath "RTexture %c",
                       lighter ? 'L' : ' ');
               error_trap(_swix(Wimp_StartTask, _IN(0), string), 0);
            }
            else
            {
               pinboard_get_tile_filename(current_tile, max_std_tile, lighter, string);
               strcat(backdrop_string, string);
            }
            break;

        case CustomImageRadio:
            if (custom_filename[0] == 0)
            {
               sprintf(backdrop_string, "Backdrop -Remove");
               break;
            }
            memset(string, 0, 64);
            error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio), 0);
            switch (radio)
            {
                case ScaledRadioButton: sprintf(backdrop_string, "Backdrop -Scale "); break;
                case TiledRadioButton: sprintf(backdrop_string, "Backdrop -Tile "); break;
                default: sprintf(backdrop_string, "Backdrop -Centre "); break;
            }
            strcat(backdrop_string, custom_filename);
            break;

        default:
            sprintf(backdrop_string, "Backdrop -Remove");
            break;
    }

    /* Add the colour switch to the backdrop command... */
    sprintf(string, " -Colour &%x ", background_colour);
    strcat(backdrop_string, string);

    /* ...and the icon text colour */
    sprintf(string, " -TextColour &%x\0", text_colour);
    strcat(backdrop_string, string);

    error_trap(_swix(OS_CLI, _IN(0), backdrop_string), 0);
}


/*---------------------------------------------------------------------------*
 * update_colour_icon                                                        *
 *                                                                           *
 * Update the background/icon text colour icon to display the user's choice  *
 * of colour.                                                                *
 *---------------------------------------------------------------------------*/

static void update_colour_icon(int icon)
{
    _kernel_oserror *e;
    BBox             gadget_bbox;
    char            *sprite_addr;
    int              width, height, colour;
    char             sprname[12];

    if (icon == PlainColBox)
    {
      strcpy(sprname, "plain_col");
      colour = background_colour;
    }
    else
    {
      strcpy(sprname, "plain_colt");
      colour = text_colour;
    }

    e=sprite_find_address_of(client_sprite_area, sprname, &sprite_addr);
    if (!e) e=sprite_return_size(client_sprite_area, sprite_addr, &width, &height);

    /* Fill in the sprite with the new colour */
    if (!e)
    {
        int  i;
        int *sprite_data = (int*) (sprite_addr + 44);

        for (i=0; i < (width*height); i++)
        {
            sprite_data[i] = colour >> 8;
        }
    }

    /* Force a redraw of the icon */
    error_trap(gadget_get_bbox(0, config_id, icon, &gadget_bbox), 0);
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * update_standard_tile_icon                                                 *
 *                                                                           *
 * Update the standard tile icon to display the user's choice of tile.       *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static void update_standard_tile_icon(void)
{
    BBox gadget_bbox;
    char tilename[128];
    int  lighter;

    error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);

    /* Check if this tile exists. If not, then previous one must do, but that's already
     * displayed, so exit
     */
    if (!pinboard_get_tile_filename(current_tile, max_std_tile, lighter, tilename))
    {
        current_tile--;
        return;
    }

    /* Update sprite and redraw */
    error_trap(pinboard_plot_texture_into_sprite(client_sprite_area,
                                                 tilename,
                                                 0,
                                                 "std_tile"), 0);
    error_trap(gadget_get_bbox(0, config_id, StandardTileSprite, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}




/*---------------------------------------------------------------------------*
 * update_custom_image_icon                                                  *
 *                                                                           *
 * Force an update of the custom image icon, so that it shows the user's     *
 * latest choice.                                                            *
 *---------------------------------------------------------------------------*/

static void update_custom_image_icon(int redraw)
{
      int radio_on;

      error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio_on), 0);

      /* Prevent tiled JPEGs */
/*      if (custom_filetype == FileType_JPEG)
      {
          grey_gadget(config_id, TiledRadioButton);

          if (radio_on == TiledRadioButton)
          {
              error_trap(radiobutton_set_state(0, config_id, CentredRadioButton, 1), 0);
              radio_on = CentredRadioButton;
          }
      }
      else
      {
          ungrey_gadget(config_id, TiledRadioButton);
      }*/

      /* Create custom image icon */
      switch (custom_filetype)
      {
          case FileType_Sprite:
              error_trap(pinboard_do_custom_image_sprite(client_sprite_area,
                                                         custom_filename,
                                                         radio_on,
                                                         background_colour), 0);
              break;

          case FileType_JPEG:
              error_trap(pinboard_do_custom_image_jpeg(client_sprite_area,
                                                       custom_filename,
                                                       radio_on,
                                                       background_colour), 0);
              break;
      }

      if (redraw) redraw_custom_image_icon();
}


/*---------------------------------------------------------------------------*
 * grey_backdrop_choices                                                     *
 *                                                                           *
 * Depending on which of the backdrop types (plain colour, standard tile or  *
 * custom image) is selected, grey appropriate options.                      *
 *                                                                           *
 * In: icon = id of the radio icon which is selected.                        *
 *---------------------------------------------------------------------------*/

static void grey_backdrop_choices(int icon)
{
    int haverand,random;

    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, TextureResPath "RTexture", &haverand), 0);
    error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
    switch (icon)
    {
        case PlainColourRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, Randomise);
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;

        case StandardTileRadio:
            ungrey_gadget(config_id, LighterOptionButton);
            if (haverand==1)
            {
               ungrey_gadget(config_id, Randomise);
               ungrey_gadget(config_id, TileUpArrow);   /* Always ungrey incase RTexture magically appeared since */
               ungrey_gadget(config_id, TileDownArrow); /* the plugin last checked */
               if (random)
               {
                  grey_gadget(config_id, TileUpArrow);
                  grey_gadget(config_id, TileDownArrow);
               }
            }
            else
            {
               random = 0;
               error_trap(optionbutton_set_state(0, config_id, Randomise, random), 0);
               grey_gadget(config_id, Randomise);
               ungrey_gadget(config_id, TileUpArrow);
               ungrey_gadget(config_id, TileDownArrow);
            }
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;

        case CustomImageRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, Randomise);
            ungrey_gadget(config_id, ScaledRadioButton);
            ungrey_gadget(config_id, CentredRadioButton);
            ungrey_gadget(config_id, TiledRadioButton);
            break;
    }
}


/*---------------------------------------------------------------------------*
 * parse_backdrop_command                                                    *
 *                                                                           *
 * Parse a *Backdrop command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Backdrop                                   *
 *                                                                           *
 * Globals: current_tile, background_colour, text_colour, custom_filetype    *
 *---------------------------------------------------------------------------*/

static void parse_backdrop_command(char *string)
{
    static const char backdrop_args[] = "path,"
                                        "Centre=C/S,Tile=T/S,Scale=S/S,NoRecache=N/S,Remove=R/S,"
                                        "Colour/E,TextColour/E,";
    char  default_path[] = DefaultTexture;
    char *path;
    int   buffer[16 + ((MaxFilenameSize /* Path */ + 5 /* Colour */ + 5 /* TextColour */)/sizeof(int))];
    int   custom_radio = TiledRadioButton;
    int   backdrop_type;
    int   filetype;
    int   random;
    int   texture_no;
    int   is_lighter;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), backdrop_args, string, buffer, sizeof(buffer)), 0);

    /* Check for background colour */
    if (buffer[6])
    {
        char *answer = ((char*)buffer[6] + 1);

        background_colour = (answer[3]<<24) + (answer[2]<<16) + (answer[1]<<8);
        update_colour_icon(PlainColBox);
    }

    /* Check for icon text colour */
    if (buffer[7])
    {
        char *answer = ((char*)buffer[7] + 1);

        text_colour = (answer[3]<<24) + (answer[2]<<16) + (answer[1]<<8);
        update_colour_icon(TextColourBox);
    }

    /* Are we tiled, scaled or centred? */
    if (buffer[1]) custom_radio = CentredRadioButton;
    if (buffer[2]) custom_radio = TiledRadioButton;
    if (buffer[3]) custom_radio = ScaledRadioButton;
    error_trap(radiobutton_set_state(0, config_id, custom_radio, 1), 0);

    /* If a pathname was specified, ensure it is a sprite or a JPEG */
    path = (char*)buffer[0];
    if (path != NULL)
    {
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(6), OSFile_ReadWithTypeNoPath, path, &filetype), 0);
        if ((filetype != FileType_Sprite) && (filetype != FileType_JPEG)) path = NULL;
    }

    /* Depending on the type of backdrop (plain colour, standard tile, custom image)... */
    error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
    if (random)
    {
        default_path[strlen(default_path)-1] = rand_suffix;
        path = (char *)default_path;
    }

    if (path == NULL)
    {
        /* No pathname - use a plain colour */
        backdrop_type = PlainColourRadio;
    }
    else if (pinboard_query_standard_texture(&texture_no, max_std_tile, &is_lighter, path))
    {
        /* This is a standard tile */
        backdrop_type = StandardTileRadio;
        current_tile = texture_no;
        error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, is_lighter), 0);
        update_standard_tile_icon();
    }
    else
    {
        /* Custom image */
        backdrop_type = CustomImageRadio;
        strcpy(custom_filename, path);
        custom_filetype = filetype;
        update_custom_image_icon(0);
        hide_custom_sprite_icons(1);
        update_standard_tile_icon();
    }

    /* Grey other icons as appropriate */
    error_trap(radiobutton_set_state(0, config_id, backdrop_type, 1), 0);
    grey_backdrop_choices(backdrop_type);
}


/*---------------------------------------------------------------------------*
 * parse_pinboard_command                                                    *
 *                                                                           *
 * Parse a *Pinboard command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Pinboard                                   *
 *---------------------------------------------------------------------------*/

static void parse_pinboard_command(char *string)
{
    static const char pinboard_args[] = "Grid/S,IconiseToIconBar=ITIB/S,"
                                        "IconiseToTopLeft=ITTL/S,IconiseToBottomLeft=ITBL/S,"
                                        "IconiseToTopRight=ITTR/S,IconiseToBottomRight=ITBR/S,"
                                        "IconiseStackVertical=ISV/S,"
                                        "TidyToTopLeft=TTTL/S,TidyToBottomLeft=TTBL/S,"
                                        "TidyToTopRight=TTTR/S,TidyToBottomRight=TTBR/S,"
                                        "TidyStackVertical=TSV/S,";
    int  buffer[24];
    int  grid_lock = 0;
    int  iconise_to = 0;
    int  iconise_stack = 0;
    int  tidy_to = 0;
    int  tidy_stack = 0;
    int  n;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), pinboard_args, string, buffer, sizeof(buffer)), 0);

    /* Read Grid lock option */
    if (buffer[0]) grid_lock = 1;
    else grid_lock = 0;

    /* Read Iconise to... options */
    for (n=1; n<=5; n++) if (buffer[n]) iconise_to = n;
    if (buffer[6]) iconise_stack = 1;
    else iconise_stack = 0;

    /* Read Tidy to... options */
    for (n=7; n<=10; n++) if (buffer[n]) tidy_to = n - 7;
    if (buffer[11]) tidy_stack = 1;
    else tidy_stack = 0;

    /* Update icons */
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, grid_lock), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)iconise_to), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)iconise_stack), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, (char*)tidy_to), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, (char*)tidy_stack), 0);

    /* Grey out iconise stack menu if iconise to iconbar or to icon */
    if (iconise_to < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the *Pinboard and *Backdrop commands from the choices file.          *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[1024];
    int   more = 1;

    /* Read current setup */
    fp = fopen(ChoicesFileRO, "r");
    if (fp != NULL)
    {
        while (more)
        {
            more = (int)fgets(string, 1024, fp);
            if (more)
            {
                if (strncmpa(string, "Backdrop", 8)==0) parse_backdrop_command(string+9);
                if (strncmpa(string, "PinboardOptions", 15)==0) parse_pinboard_command(string+16);
                if (strstr(string, "RTexture") != NULL)
                {
                   optionbutton_set_state(0, config_id, Randomise, 1); /* Tick randomise */
                   rand_suffix = string[(int)(strstr(string, "RTexture")-string)+9]; /* Deduce if lighter was requested */
                }
            }
        }
        fclose(fp);
    }
}


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Set the default choices.                                                  *
 *                                                                           *
 * Globals: current_tile, background_colour                                  *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    memset(custom_filename, 0, MaxFilenameSize);

    error_trap(radiobutton_set_state(0, config_id, StandardTileRadio, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, 0), 0);
    error_trap(optionbutton_set_state(0, config_id, Randomise, 0), 0);
    error_trap(radiobutton_set_state(0, config_id, TiledRadioButton, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, 0), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)4), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)1), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, 0), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, 0), 0);
    ungrey_gadget(config_id, IconiseStackMenu);
    ungrey_gadget(config_id, TileUpArrow);
    ungrey_gadget(config_id, TileDownArrow);

    /* Change current tile? */
    if (current_tile != 1)
    {
        current_tile = 1;
        update_standard_tile_icon();
    }

    /* Change background colour? */
    if (background_colour != DefaultBackgroundColour)
    {
        background_colour = DefaultBackgroundColour;
        update_colour_icon(PlainColBox);
    }

    /* Change icon text colour? */
    if (text_colour != DefaultTextColour)
    {
        text_colour = DefaultTextColour;
        update_colour_icon(TextColourBox);
    }

    hide_custom_sprite_icons(0);
    grey_backdrop_choices(StandardTileRadio);
}


/*-----------------------------------------------------------------------------------------------*
 *                                      Event handlers                                           *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case TryActionButton:
            try_it();
            changes_have_been_made = TRUE;
            break;

        case SetActionButton:
            save_choices();
            /* If Return pressed or click on Set was with Return, then exit program */
            if ( ((block->hdr.flags & Action_ReturnKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
            break;

        case CancelActionButton:
            /* If right button pressed (meaning window stays open) or if changes
               have been made to the backdrop (eg. by clicking on Try), then
               read the original choices back in and update actual backdrop, if
               necessary */
            if ((block->hdr.flags & Action_AdjustButton) || (changes_have_been_made))
            {
                read_choices();
                if (changes_have_been_made) try_it();
                changes_have_been_made = FALSE;
            }

            /* If Escape pressed or click on Cancel was with Select, then exit */
            if ( ((block->hdr.flags & Action_EscapeKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
            break;

        case DefaultActionButton:
            set_default_choices();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * adjuster_clicked                                                          *
 *                                                                           *
 * Handler for when adjuster arrows are clicked.                             *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static int adjuster_clicked(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    AdjusterClickedEvent *adjuster_block = (AdjusterClickedEvent*) event_block;
    int                   icon = id_block->self_component;

    if ((icon == TileUpArrow) || (icon == TileDownArrow))
    {
        if (adjuster_block->direction == 0) current_tile--;
        else current_tile++;

        if (current_tile < 1) current_tile = 1;
        else update_standard_tile_icon();
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * colour_selected                                                           *
 *                                                                           *
 * Handler for colour selection from Colour Dialogue Box                     *
 *                                                                           *
 * Globals: background_colour                                                *
 *---------------------------------------------------------------------------*/

static int colour_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->parent_component;
    ColourDboxColourSelectedEvent *evblock = (ColourDboxColourSelectedEvent*) event_block;
    char                          *colour_block = (char*)evblock + 16;

    switch (icon)
    {
      case PlainColourPopUp :
      {
        background_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);

        update_colour_icon(PlainColBox);
        error_trap(toolbox_delete_object(0, bgcolourbox_id), 0);
        bgcolourbox_id = 0;
        break;
      }

      case TextColourPopUp :
      {
        text_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);
        update_colour_icon(TextColourBox);
        error_trap(toolbox_delete_object(0, txcolourbox_id), 0);
        txcolourbox_id = 0;
        break;
      }
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * option_changed                                                            *
 *                                                                           *
 * Handler for option button changed events.                                 *
 *---------------------------------------------------------------------------*/

static int option_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int random;

    if (icon == LighterOptionButton) update_standard_tile_icon();
    if (icon == Randomise)
    {
       error_trap(optionbutton_get_state(0, config_id, Randomise, &random), 0);
       if (random)
       {
          grey_gadget(config_id, TileUpArrow);
          grey_gadget(config_id, TileDownArrow);
       }
       else
       {
          ungrey_gadget(config_id, TileUpArrow);
          ungrey_gadget(config_id, TileDownArrow);
       }
    }
    return 1;
}


/*---------------------------------------------------------------------------*
 * radio_changed                                                             *
 *                                                                           *
 * Handler for radio button changed events.                                  *
 *---------------------------------------------------------------------------*/

static int radio_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;

    switch (icon)
    {
        case ScaledRadioButton:
        case CentredRadioButton:
        case TiledRadioButton:
            update_custom_image_icon(1);
            break;

        case PlainColourRadio:
        case StandardTileRadio:
        case CustomImageRadio:
            grey_backdrop_choices(icon);
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * stringset_changed                                                         *
 *                                                                           *
 * Handle event when stringset value changes.                                *
 *---------------------------------------------------------------------------*/

static int stringset_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int selected;

    /* We're only interested in the iconise to menu */
    if (icon != IconiseToMenu) return 1;

    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);

    /* If Iconise to icon or iconise to iconbar, grey the iconise stack menu */
    if (selected < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);

    return 1;
}


/*---------------------------------------------------------------------------*
 * popup_showing                                                             *
 *                                                                           *
 * Called when a colour box popup is about to be displayed.                  *
 *---------------------------------------------------------------------------*/
static int popup_showing(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    unsigned int colour_block[2];
    ObjectId id = 0;

    switch (icon)
    {
      case PlainColourPopUp :
        colour_block[0] = background_colour;
        if (bgcolourbox_id == 0)
        {
          error_trap(toolbox_create_object(0, "BGColDbox", &bgcolourbox_id), 1);
        }
        id = bgcolourbox_id;
        break;

      case TextColourPopUp :
        colour_block[0] = text_colour;
        if (txcolourbox_id == 0)
        {
          error_trap(toolbox_create_object(0, "ITColDbox", &txcolourbox_id), 1);
        }
        id = txcolourbox_id;
        break;
    }

    if ((icon == PlainColourPopUp) || (icon == TextColourPopUp))
    {
      colour_block[1] = 0;
      error_trap(colourdbox_set_colour(0, id, (int*)&colour_block), 0);
      error_trap(toolbox_show_object(0, id, 0, 0, config_id, icon), 0);
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/

static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, config_id, 0, 0, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_dataload                                                          *
 *                                                                           *
 * Called when wimp dataload message received.                               *
 *                                                                           *
 * Globals: custom_filetype                                                  *
 *---------------------------------------------------------------------------*/

static int message_dataload(WimpMessage *event, void *handler)
{
    int object;
    int component;
    int window = event->data.data_load.destination_window;
    int icon = event->data.data_load.destination_icon;
    int filetype = event->data.data_load.file_type;

    error_trap(window_wimp_to_toolbox(0, window, icon, &object, &component), 0);
    if (object != config_id) return 1;
    if ((component < CustomDropZoneA) && (component > CustomDropZoneE)) return 1;
    if ((filetype != FileType_Sprite) && (filetype != FileType_JPEG)) return 1;

    error_trap(radiobutton_set_state(0, config_id, CustomImageRadio, 1), 0);
    grey_backdrop_choices(CustomImageRadio);

    custom_filetype = filetype;
    strcpy(custom_filename, event->data.data_load.leaf_name);
    update_custom_image_icon(0);
    hide_custom_sprite_icons(1);

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();

    return 1;
}


/*-----------------------------------------------------------------------------------------------*
 *                              Program startup & Polling loop                                   *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    int  screenx;
    int  screeny;
    ObjectTemplateHeader *objtemplate;
    WindowTemplate       *wintemplate;
    WimpWindow           *windef;

    /* Read the window object in by hand */
    error_trap(toolbox_template_lookup(0, "PinConfig", (void **)&objtemplate), 1);
    if (objtemplate->object_class != Window_ObjectClass)
    {
        error_trap(common_error(messages_lookup("BadClass")), 1);
    }
    wintemplate = objtemplate->body;
    windef = &wintemplate->window;
    if (common_read_screensize(&screenx, &screeny) == NULL)
    {
        /* Calculate the window height compared with the screen and
         * turn the vertical scrollbar on if it doesn't fit
         */
        if ((windef->visible_area.ymax - windef->visible_area.ymin) >= screeny)
        {
            windef->flags |= WimpWindow_VScroll;
        }
        else
        {
            windef->flags &= ~WimpWindow_VScroll;
        }
    }
    error_trap(toolbox_create_object(Toolbox_CreateObject_InCore, objtemplate, &config_id), 1);

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);
    error_trap(event_register_wimp_handler(config_id, Wimp_ECloseWindow, close_window, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, Adjuster_Clicked, adjuster_clicked, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, OptionButton_StateChanged, option_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(-1, ColourDbox_ColourSelected, colour_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, RadioButton_StateChanged, radio_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, StringSet_ValueChanged, stringset_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, PopUp_AboutToBeShown, popup_showing, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MDataLoad, message_dataload, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);

    /* Read in the choices, populate and show dialogue */
    max_std_tile = pinboard_count_standard_textures();
    hide_custom_sprite_icons(0);
    update_standard_tile_icon();
    read_choices();
    if ((at_x==-1) && (at_y==-1))
    {
        /* No position supplied in the command line, just centre it */
        error_trap(toolbox_show_object(0, config_id, Toolbox_ShowObject_Centre, NULL, 0, 0), 0);
    }
    else
    {
        int  buffer[2];

        buffer[0] = at_x;
        buffer[1] = at_y;
        error_trap(toolbox_show_object(0, config_id, Toolbox_ShowObject_TopLeft, buffer, 0, 0), 0);
    }
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *                                                                           *
 * Globals: custom_filename, client_sprite_area                              *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MDataLoad,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                Adjuster_Clicked,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                ColourDbox_ColourSelected,
                                RadioButton_StateChanged,
                                StringSet_ValueChanged,
                                PopUp_AboutToBeShown,
                                0};
    void      *sprptr;
    int        task_handle;

    custom_filename = malloc(MaxFilenameSize);
    if (!custom_filename) return 0;
    memset(custom_filename, 0, MaxFilenameSize);

    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<PinSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, &sprptr) ,1);
    client_sprite_area = (int*)sprptr;
    error_trap(event_initialise(&idb), 1);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat") == 0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;

    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }

    return 0;
}

@


1.11
log
@Makefile updated for BuildSys-6_20
Never used toolbox event removed from event table.
!Run file moved into locale specific resources as it contains english.

Version 0.22. Tagged as 'PinSetup-0_22'
@
text
@d1254 1
a1254 1
                                  "<PinConfig$Dir>", &messages_desc, &idb,
@


1.10
log
@Minor PinSetup improvements
* Use JPEG swis from "swis.h"
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed
Requires RISC_OSLi-5_75 for the swi defs.

Version 0.21. Tagged as 'PinSetup-0_21'
@
text
@a1242 1
                                Toolbox_ObjectAutoCreated,
@


1.9
log
@Fix buffer overflow dealing with custom backdrops in paths > 78 long
The buffer for OS_ReadArgs was not allowing for MaxFilenameSize length paths, so got a buffer overflow error & quit.
For both backdrop and pinboardoptions some slack is allowed with a trailing comma for as yet unknown switches to be added in the future.
For pinboardoptions parsing the keyword string is now a constant rather than being built up with strcat/strcpy.
Fixes ticket #331.

Version 0.20. Tagged as 'PinSetup-0_20'
@
text
@a1156 1
    BBox bbox;
d1159 27
a1185 7
    int  buffer[2];

    /* Create window */
    error_trap(toolbox_create_object(0, "PinConfig", &config_id), 1);
    max_std_tile = pinboard_count_standard_textures();
    hide_custom_sprite_icons(0);
    update_standard_tile_icon();
d1200 4
d1205 1
a1205 3

    /* Work out positioning (unless it was supplied in the command line) */
    if ((at_x == -1) && (at_y == -1))
d1207 2
a1208 4
        error_trap(common_read_screensize(&screenx, &screeny), 0);
        error_trap(window_get_extent(0, config_id, &bbox), 0);
        at_y = screeny - ((screeny+bbox.ymin)/2);
        at_x = (screenx - bbox.xmax)/2;
d1210 3
d1214 4
a1217 5
    /* Show the window */
    buffer[0] = at_x;
    buffer[1] = at_y;
    error_trap(toolbox_show_object(0, config_id, 2, buffer, 0, 0), 0);

@


1.8
log
@No need to shade the tile sprite

Version 0.18. Not tagged
@
text
@d555 3
a557 1
    static const char backdrop_args[] = "path,Centre=C/S,Tile=T/S,Scale=S/S,N=NoRecache/S,Remove=R/S,Colour/E,TextColour/E";
d560 1
a560 1
    int   buffer[32];
d568 1
a568 1
    error_trap(_swix(OS_ReadArgs, _INR(0,3), backdrop_args, string, buffer, 32 * sizeof(int)), 0);
d651 8
a658 2
    char pinboard_args[300];
    int  buffer[16];
d666 1
a666 9
    strcpy(pinboard_args, "Grid=/S,IconiseToIconBar=ITIB/S,");
    strcat(pinboard_args, "IconiseToTopLeft=ITTL/S,IconiseToBottomLeft=ITBL/S,");
    strcat(pinboard_args, "IconiseToTopRight=ITTR/S,IconiseToBottomRight=ITBR/S,");
    strcat(pinboard_args, "IconiseStackVertical=ISV/S,");
    strcat(pinboard_args, "TidyToTopLeft=TTTL/S,TidyToBottomLeft=TTBL/S,");
    strcat(pinboard_args, "TidyToTopRight=TTTR/S,TidyToBottomRight=TTBR/S,");
    strcat(pinboard_args, "TidyStackVertical=TSV/S,");

    error_trap(_swix(OS_ReadArgs, _INR(0,3), pinboard_args, string, buffer, 16*sizeof(int)), 0);
@


1.7
log
@Teach about looking for backdrop tiles in subdirectories
* Now matches 'RTexture' in its ability to select backdrop tiles from the currently configured theme
* Add lost Cosprites11 file from Richard Hallas
* Replace a few hardwired 1024's with the MaxFilenameSize constant
* Fix RTexture not being run due to errant '.' added in 0.17
In the event that the theme gets changed between last run of !PinSetup, the default built in T1L will be substituted.

Version 0.18. Tagged as 'PinSetup-0_18'
@
text
@a513 1
                  grey_gadget(config_id, StandardTileSprite);
@


1.6
log
@PinSetup tidy step
Usual drill
* Makefile recreated from fragments
* Version number inserted to messages at build time
* Local OS interface definitions replaced with central header files
* Read choices from Choices$Path write via Choices$Write
Also simplified the random texture 'try' option by just running RTexture directly rather than emulating it in C.
Tested briefly, still works.

Version 0.17. Tagged as 'PinSetup-0_17'
@
text
@d65 1
d169 1
a169 1
    char backdrop_command[1024];
d171 1
a171 1
    char string[1024];
d179 1
a179 2
    memset(backdrop_command, 0, 1024);
    memset(pinboard_command, 0, 256);
d181 1
a181 3

    /* First work out the *Backdrop command */
    switch(radio_on)
d189 1
a189 1
                       "BootResources:Configure.Textures.RTexture %c\nBackdrop -T",
d194 1
a194 1
               pinboard_get_tile_filename(current_tile, lighter, string);
d274 2
a275 2
    char  backdrop_string[1024];
    char  string[128];
a280 1
    memset(backdrop_string, 0, 1024);
d282 1
a282 2

    switch(option)
d292 1
a292 1
                       "WimpTask Boot:Resources.Configure.Textures.RTexture %c",
d294 1
a294 1
               error_trap(_swix(OS_CLI, _IN(0), string), 0);
d298 1
a298 1
               pinboard_get_tile_filename(current_tile, lighter, string);
d400 4
a403 3
    /* Check if this tile exists. If not, then previous one must do, but that's already */
    /* displayed, so exit */
    if (!pinboard_get_tile_filename(current_tile, lighter, tilename))
d489 1
a489 1
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, "BootResources.Configure.Textures.RTexture", &haverand), 0);
d514 1
d556 1
a556 1
    char  backdrop_args[] = "path,Centre=C/S,Tile=T/S,Scale=S/S,N=NoRecache/S,Remove=R/S,Colour/E,TextColour/E";
d559 1
a559 1
    int   buffer[256];
d567 1
a567 1
    error_trap(_swix(OS_ReadArgs, _INR(0,3), backdrop_args, string, buffer, 256*sizeof(int)), 0);
d593 1
a593 1
    /* If a pathname was specified, check it is a sprite or a JPEG */
d605 2
a606 2
       default_path[strlen(default_path)-1] = rand_suffix;
       path = (char *)default_path;
d614 1
a614 1
    else if (pinboard_query_standard_texture(path, &texture_no, &is_lighter))
d709 1
a709 1
    fp=fopen(ChoicesFileRO, "r");
d714 1
a714 1
            more=(int)fgets(string, 1024, fp);
d719 1
a719 1
                if (strstr(string, "RTexture") != 0)
d721 1
a721 1
                   optionbutton_set_state(0, config_id, Randomise, 1); /* Check randomise */
d896 1
a896 1
        if (current_tile<1) current_tile = 1;
d1165 1
a1165 2
//    error_trap(toolbox_create_object(0, "BGColDbox", &bgcolourbox_id), 1);
//    error_trap(popup_set_menu(0, config_id, PlainColourPopUp, bgcolourbox_id), 1);
@


1.5
log
@Fix null pointer dereference on startup
Detail:
  c/main - Command line parsing now checks if enough arguments exist before attempting to look for an -openat option
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.16. Tagged as 'PinSetup-0_16'
@
text
@d16 1
a16 1
/* File:    c.main                                                           */
a34 1

d39 2
d51 1
a51 3
#define VduCLG                  16
#define SpriteFileType          0xff9
#define JPEGFileType            0xc85
d189 1
a189 1
               {
d191 3
a193 3
                       "BootResources:Configure.Textures.RTexture %s\nBackdrop -T",
                       lighter ? "L" : " ");
               }
d195 1
a195 1
               {
d198 1
a198 1
               }
d233 1
a233 1
    sprintf(pinboard_command,"PinboardOptions");
a279 1
    float choice;
d291 1
d293 7
a299 5
               {
               /* Fake the running of 'RTexture' */
               choice = ((float)rand()/(float)RAND_MAX) * (float)pinboard_count_standard_textures();
               sprintf(string, "%s%d%s", TexturePrefix, (int)choice ? (int)choice : 1, lighter ? "L" : " ");
               }
d301 1
a301 1
               {
d303 2
a304 2
               }
            sprintf(backdrop_string, "Backdrop -T %s", string);
d309 1
a309 1
               {
d312 1
a312 1
               }
d442 1
a442 1
/*      if (custom_filetype == JPEGFileType)
d460 1
a460 1
          case SpriteFileType:
d467 1
a467 1
          case JPEGFileType:
d490 1
a490 1
int haverand,random;
d492 1
a492 1
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, "BootResources:Configure.Textures.RTexture", &haverand), 0);
d509 1
a509 1
               {
d514 1
a514 1
                  {
a516 1
                  }
d518 1
d520 1
a520 1
               {
d526 1
a526 1
               }
d597 1
a597 1
    if (path != 0)
d599 2
a600 2
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(6), 23, path, &filetype), 0);
        if ((filetype != SpriteFileType) && (filetype != JPEGFileType)) path = 0;
d606 1
a606 1
       {
d609 1
a609 1
       }
d611 1
a611 1
    if (path == 0)
d711 2
a712 2
    fp=fopen(ChoicesFile, "r");
    if (fp)
d722 1
a722 1
                   {
d725 1
a725 1
                   }
d959 1
a959 1
       {
d962 1
a962 1
          {
d965 1
a965 1
          }
d967 1
a967 1
          {
a969 1
          }
d971 1
d1120 1
a1120 1
    if ((filetype != SpriteFileType) && (filetype != JPEGFileType)) return 1;
d1241 1
a1241 1
    error_trap(event_initialise(&idb), 0);
@


1.4
log
@Enable tiled jpeg backdrop images.
Details:
  Commented out the code that shaded the Tile option when the backdrop image
  was a Jpeg.
Admin:
  Tested on Iyonix RO5.11
Changes by:
  Fred Graute

Version 0.13. Tagged as 'PinSetup-0_13'
@
text
@d1265 1
a1265 1
    if (strcmp(argv[1], "-openat") == 0)
@


1.3
log
@The try button wasn't trying the chosen text and text background colours
whereas a right click on "Set" did.
Trying to set the options having chosen to use a custom sprite but
forgetting to drop one in led to a "File -Colour not found" error - it
now defaults to a plain colour backdrop instead.
Added low res sprites.
Case sensitive string comparison meant it would have amnesia when trying
to read in the old setup file - the case compared now matches that written.
Added "Random" button,which simply adds an extra line to the setup file
to run RTexture (if present).

Version 0.12. Tagged as 'PinSetup-0_12'
@
text
@d437 1
a437 1
     
d439 1
a439 1
     
d441 1
a441 1
      if (custom_filetype == JPEGFileType)
d444 1
a444 1
     
d454 1
a454 1
      }
d465 1
a465 1
  
d473 1
a473 1
  
d516 1
a516 1
                  }              
d520 1
a520 1
               random = 0; 
d524 1
a524 1
               ungrey_gadget(config_id, TileDownArrow);               
d756 1
a756 1
    
d955 1
a955 1
    
@


1.2
log
@Addition of "Icon Text Colour" popup to support *backdrop command.
UK Res file overhaul.

Version 0.11. Tagged as 'PinSetup-0_11'
@
text
@d61 1
d176 1
d188 12
a199 2
            pinboard_get_tile_filename(current_tile, lighter, string);
            sprintf(backdrop_command, "Backdrop -T %s", string);
d214 4
d277 7
a283 5
    char backdrop_string[1024];
    char string[64];
    int  lighter;
    int  option;
    int  radio;
d286 1
a286 3
    error_trap(radiobutton_get_state(0, config_id, PlainColourRadio, 0, &option), 0);

    sprintf(backdrop_string, "Backdrop -Colour &%x -TextColour &%x\0", background_colour, text_colour);
d292 12
a303 3
            pinboard_get_tile_filename(current_tile, lighter, string);
            strcat(backdrop_string, " -Tile ");
            strcat(backdrop_string, string);
d307 5
a311 1
            if (custom_filename[0] == 0) break;
d316 3
a318 3
                case ScaledRadioButton: sprintf(string, " -Scale "); break;
                case TiledRadioButton: sprintf(string, " -Tile "); break;
                default: sprintf(string, " -Centre "); break;
a319 1
            strcat(backdrop_string, string);
d323 2
a324 2
        case PlainColourRadio:
            strcat(backdrop_string, " -Remove");
d328 8
d436 19
a454 1
    int radio_on;
d456 12
a467 23
    error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio_on), 0);

    /* Prevent tiled JPEGs */
    if (custom_filetype == JPEGFileType)
    {
        grey_gadget(config_id, TiledRadioButton);

        if (radio_on == TiledRadioButton)
        {
            error_trap(radiobutton_set_state(0, config_id, CentredRadioButton, 1), 0);
            radio_on = CentredRadioButton;
        }
    }
    else
    {
        ungrey_gadget(config_id, TiledRadioButton);
    }

    /* Create custom image icon */
    switch (custom_filetype)
    {
        case SpriteFileType:
            error_trap(pinboard_do_custom_image_sprite(client_sprite_area,
d471 4
a474 11
            break;

        case JPEGFileType:
            error_trap(pinboard_do_custom_image_jpeg(client_sprite_area,
                                                     custom_filename,
                                                     radio_on,
                                                     background_colour), 0);
            break;
    }

    if (redraw) redraw_custom_image_icon();
d489 4
d499 1
d507 19
a525 2
            ungrey_gadget(config_id, TileUpArrow);
            ungrey_gadget(config_id, TileDownArrow);
d535 1
d552 1
a552 1
 * Globals: current_tile, background_colour, text_colour, custom_filetype*
d558 1
d564 1
d603 7
d614 1
a614 1
   }
d718 7
a724 2
                if (strncmpa(string, "backdrop", 8)==0) parse_backdrop_command(string+9);
                else if (strncmpa(string, "pinboardoptions", 15)==0) parse_pinboard_command(string+16);
d746 1
d754 3
a756 1

a925 1
//        update_custom_image_icon(1);
d954 2
a955 1

d957 14
a970 1

d1037 1
a1037 1
    ObjectId id;
a1169 1
    read_choices();
d1183 2
@


1.1
log
@Initial revision
@
text
@d24 8
d54 1
d57 1
d62 2
a63 1
static int          colourbox_id;
d68 1
d84 77
d179 1
a179 1
    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &radio_on), 0);    
d186 1
a186 1
            tile_filename(current_tile, lighter, string);
d189 2
a190 2
            
        case CustomImageRadio:        
d203 1
a203 1
            
d209 6
a214 2
    /* Add the colour switch to the backdrop command */
    sprintf(string, " -Colour &%x", background_colour);
d216 1
a216 1
    
d231 1
a231 1
    
d248 1
a248 1
    error_trap(write_pinboard_choices(backdrop_command, pinboard_command), 0);        
d266 1
a266 1
    
d270 1
a270 1
    sprintf(backdrop_string, "Backdrop -Colour &%x", background_colour);
d276 1
a276 1
            tile_filename(current_tile, lighter, string);
d305 1
a305 1
 * update_background_colour_icon                                             *
d307 2
a308 1
 * Update the background colour icon to display the user's choice of colour. *
d311 1
a311 1
static void update_background_colour_icon(void)
d316 2
a317 4
    int             *sprite_data;
    int              width;
    int              height;
    int              i;
d319 12
a330 1
    e=sprite_find_address_of(client_sprite_area, "plain_col", &sprite_addr);
d333 1
a333 1
    /* Fill in the 'plain_col' sprite with the new colour */
d336 2
a337 1
        sprite_data = (int*) (sprite_addr + 44);
d341 1
a341 1
            sprite_data[i] = background_colour>>8;
d344 3
a346 3
       
    /* Force a redraw of the 'plain_col' icon */
    error_trap(gadget_get_bbox(0, config_id, PlainColBox, &gadget_bbox), 0);
d364 1
a364 1
    
d369 1
a369 1
    if (!tile_filename(current_tile, lighter, tilename))
d374 1
a374 1
    
d376 4
a379 1
    error_trap(texture_into_sprite(client_sprite_area, tilename, 0, "std_tile"), 0);
d386 1
a386 2
}    

a387 9
/*---------------------------------------------------------------------------*
 * redraw_custom_image_icon                                                  *
 *                                                                           *
 * Force a redraw of the custom_image icon                                   *
 *---------------------------------------------------------------------------*/

static void redraw_custom_image_icon(void)
{
    BBox gadget_bbox;
a388 7
    error_trap(gadget_get_bbox(0, config_id, CustomDropZone, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}
d398 1
a398 1
static void update_custom_image_icon(void)
d401 1
a401 1
   
d404 17
d424 4
a427 3
            error_trap(do_custom_image_sprite(client_sprite_area, custom_filename,
                                              radio_on, background_colour), 0);
            redraw_custom_image_icon();
d431 4
a434 3
            error_trap(do_custom_image_jpeg(client_sprite_area, custom_filename,
                                            radio_on, background_colour), 0);
            redraw_custom_image_icon();
d437 3
a439 1
}    
d472 1
a472 1
    
d493 1
a493 1
 * Globals: current_tile, background_colour, custom_filetype                 *
d498 1
a498 1
    char  backdrop_args[] = "path,Centre=C/S,Tile=T/S,Scale=S/S,N=NoRecache/S,Remove=R/S,Colour/E";
d509 1
a509 1
    /* Check for colour */
d512 2
a513 3
        unsigned int  colour_block[2];
        char         *answer = ((char*)buffer[6] + 1);
        
d515 10
a524 4
        update_background_colour_icon();
        colour_block[0] = background_colour;
        colour_block[1] = 0;
        error_trap(colourdbox_set_colour(0, colourbox_id, (int*)&colour_block), 0);
d532 1
a532 1
    
d540 2
a541 2
        
    /* Depending on the type of backdrop (plain colour, standard tile, custom image)... */            
d547 1
a547 1
    else if (path_is_a_standard_texture(path, &texture_no, &is_lighter))
d553 2
a554 2
        update_standard_tile_icon();        
    }    
d561 2
a562 1
        update_custom_image_icon();
d599 1
a599 1
    
d622 4
d656 1
a656 1
}    
d679 1
d681 6
a686 2
    background_colour = DefaultBackgroundColour;
    update_background_colour_icon();
d688 6
a693 5
    error_trap(texture_into_sprite(client_sprite_area,
                                   "<PinConfig$Dir>.Sprites",
                                   "cust_tile",
                                   "cust_tile"), 0);
    redraw_custom_image_icon();
d695 9
a703 2
    current_tile = 1;
    update_standard_tile_icon();    
d761 1
d766 6
a771 2
            if ((block->hdr.flags & 7) == 0) program_exit(); /* Return pressed */
            if (block->hdr.flags & 4) program_exit();        /* Left button */
d775 17
a791 3
            if ((block->hdr.flags & 7) == 0) program_exit(); /* Escape pressed */
            if (block->hdr.flags & 1) read_choices();        /* Right button */
            if (block->hdr.flags & 4) program_exit();        /* Left button */
d820 2
a821 2
        
        if (current_tile<1) current_tile = 1;                      
d824 1
a824 1
     
d839 1
a841 3
    int                            state;
    
    background_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);
d843 22
a864 4
    update_background_colour_icon();

    error_trap(radiobutton_get_state(0, config_id, CentredRadioButton, &state, 0), 0);
    if (state == 1) update_custom_image_icon();
d868 1
a868 1
   
d879 1
a879 1
                
d901 1
a901 1
            update_custom_image_icon();
d903 1
a903 1
                    
d910 68
a977 1
    
d987 1
a987 1
 
d991 1
a991 1
    
d1018 1
a1018 1
 
d1026 1
a1026 1
    
a1027 1

d1029 1
a1029 1
    if (component != CustomDropZone) return 1;
d1031 1
a1031 1
    
d1034 1
a1034 1
    
d1037 2
a1038 1
    update_custom_image_icon();
d1053 1
a1053 1
    
d1077 3
a1079 2
    error_trap(toolbox_create_object(0, "BGColDbox", &colourbox_id), 1);
    error_trap(popup_set_menu(0, config_id, PlainColourPopUp, colourbox_id), 1);
d1091 2
d1109 1
d1136 2
d1145 1
a1145 1
                                
d1151 1
a1151 1
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);    
d1159 1
a1159 1
                                  
d1183 1
a1183 1
    
d1192 1
a1192 1
    
d1194 1
a1194 1
}         
@


1.1.1.1
log
@Initial import of PinSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Tiled JPEGs no longer allowed.
Fully canonicalised path no longer used for standard textures. Instead
we use BootResources:Configure.Textures.
@
text
@a23 1
/*          16-Apr-98: RML: Tiled JPEGs no longer allowed.                   */
a312 5
    
    /* Prevent tiled JPEGs */
    if (custom_filetype == JPEGFileType)
    {
        grey_gadget(config_id, TiledRadioButton);
a313 12
        if (radio_on == TiledRadioButton)
        {
            error_trap(radiobutton_set_state(0, config_id, CentredRadioButton, 1), 0);
            radio_on = CentredRadioButton;
        }
    }
    else
    {        
        ungrey_gadget(config_id, TiledRadioButton);
    }
 
    /* Create custom image icon */
@


1.1.1.3
log
@Now greys out the Iconise Stack stringset if Iconise to close icon or
Iconise to Icon bar is selected.
@
text
@a24 2
/*          23-Apr-98: RML: Now greys out the IconiseStack menu if Iconise   */
/*                          to Icon or Iconise to Iconbar is selected.       */
a522 4
    
    /* Grey out iconise stack menu if iconise to iconbar or to icon */
    if (iconise_to < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);    
a575 1
    ungrey_gadget(config_id, IconiseStackMenu);
a764 24
 * stringset_changed                                                         *
 *                                                                           *
 * Handle event when stringset value changes.                                *
 *---------------------------------------------------------------------------*/

static int stringset_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int selected;

    /* We're only interested in the iconise to menu */
    if (icon != IconiseToMenu) return 1;
    
    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);    

    /* If Iconise to icon or iconise to iconbar, grey the iconise stack menu */
    if (selected < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);

    return 1;
}


/*---------------------------------------------------------------------------*
a871 1
    error_trap(event_register_toolbox_handler(config_id, StringSet_ValueChanged, stringset_changed, NULL), 0);
a913 1
                                StringSet_ValueChanged,
@


1.1.1.4
log
@Chosen backdrop colour now shows through masked sprites.
Choices file renamed to PinSetup (from Pinboard).
@
text
@a56 1
//static int          number_of_tiles = 0;
d692 2
a693 2

        if (current_tile<1) current_tile = 1;
a717 1
    update_custom_image_icon();
a964 2

    //number_of_tiles = count_standard_textures();
@


1.1.1.5
log
@Changed the way the custom tile drop zone is handled.
Reduced flicker in some redraw cases.
@
text
@a26 3
/*          01-Jul-98: RML: 'Drop image' in the custom tile drop zone is now */
/*                          icons, rather than a sprite.                     */
/*                          Reduced flicker in some redraw cases.            */
d57 1
a57 1
/* static int          number_of_tiles = 0; */
a75 77
 * redraw_custom_image_icon                                                  *
 *                                                                           *
 * Force a redraw of the custom_image icon                                   *
 *---------------------------------------------------------------------------*/

static void redraw_custom_image_icon(void)
{
    BBox gadget_bbox;

    error_trap(gadget_get_bbox(0, config_id, CustomDropZoneE, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * hide_custom_sprite_icons                                                  *
 *                                                                           *
 * Hide the default custom sprite drop zone icons (the spritefile icon, the  *
 * jpegfile icon and the display icon that says 'Drop image'). Show the icon *
 * which shows the custom image.                                             *
 *---------------------------------------------------------------------------*/

void hide_custom_sprite_icons(int hide)
{
    BBox bbox;
    int  invert;
    int  gadget;
    int  do_redraw;
    
    /* Always make sure the custom image area is redrawn */
    do_redraw = TRUE;

    /* There are two cases for the value of hide:
          hide = 1: Show the custom sprite icon with the tiled sprite in it, but hide the three
                    drop zone icons (sprite icon, jpeg icon, 'drop image' label).
          hide = 0: Show the three drop zone icons, but hide the icon with the tiled sprite in
                    it.
       In each case, the icons are hidden by putting them off the window (-ve x and -ve y co-ords)
    */
          
    for (gadget=CustomDropZoneA; gadget<=CustomDropZoneE; gadget++)
    {
        invert = 0;
        
        gadget_get_bbox(0, config_id, gadget, &bbox);
        
        if (gadget == CustomDropZoneE)
        {
            if ((hide) && (bbox.xmin < 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin > 0)) invert = TRUE;
        }
        else
        {
            if ((hide) && (bbox.xmin > 0)) invert = TRUE;
            if ((!hide) && (bbox.xmin < 0)) invert = TRUE;
        }
        
        if (invert)
        {
            do_redraw = FALSE;
            bbox.xmin = -bbox.xmin;
            bbox.ymin = -bbox.ymin;
            bbox.xmax = -bbox.xmax;
            bbox.ymax = -bbox.ymax;
            gadget_move_gadget(0, config_id, gadget, &bbox);
        }
    }
    
    if (do_redraw) redraw_custom_image_icon();
}


/*---------------------------------------------------------------------------*
d101 1
a101 1
            pinboard_get_tile_filename(current_tile, lighter, string);
d159 1
a159 1
    error_trap(pinboard_write_choices(backdrop_command, pinboard_command), 0);        
d187 1
a187 1
            pinboard_get_tile_filename(current_tile, lighter, string);
d269 1
a269 1
    if (!pinboard_get_tile_filename(current_tile, lighter, tilename))
d276 1
a276 4
    error_trap(pinboard_plot_texture_into_sprite(client_sprite_area,
                                                 tilename,
                                                 0,
                                                 "std_tile"), 0);
d286 17
d312 1
a312 1
static void update_custom_image_icon(int redraw)
d338 3
a340 4
            error_trap(pinboard_do_custom_image_sprite(client_sprite_area,
                                                       custom_filename,
                                                       radio_on,
                                                       background_colour), 0);
d344 3
a346 4
            error_trap(pinboard_do_custom_image_jpeg(client_sprite_area,
                                                     custom_filename,
                                                     radio_on,
                                                     background_colour), 0);
a348 2
    
    if (redraw) redraw_custom_image_icon();
d452 1
a452 1
    else if (pinboard_query_standard_texture(path, &texture_no, &is_lighter))
d466 1
a466 2
        update_custom_image_icon(0);
        hide_custom_sprite_icons(1);
d585 2
a586 6
    /* Change current tile? */
    if (current_tile != 1)
    {
        current_tile = 1;
        update_standard_tile_icon();
    }
d588 5
a592 6
    /* Change background colour? */
    if (background_colour != DefaultBackgroundColour)
    {
        background_colour = DefaultBackgroundColour;
        update_background_colour_icon();
    }        
d594 2
a595 2
    hide_custom_sprite_icons(0);
    grey_backdrop_choices(StandardTileRadio);
d714 1
d719 4
a722 1
    update_custom_image_icon(1);
d759 1
a759 1
            update_custom_image_icon(1);
d843 1
d845 1
a845 1
    if ((component < CustomDropZoneA) && (component > CustomDropZoneE)) return 1;
d853 1
a853 2
    update_custom_image_icon(0);    
    hide_custom_sprite_icons(1);
a893 1
    hide_custom_sprite_icons(0);
a921 1

d968 1
a968 1
    /* number_of_tiles = pinboard_count_standard_textures(); */
@


1.1.1.6
log
@* Fixed bug with plotting into sprites in rectangular pixel modes.
* If Try was clicked, Cancel button restores saved state as was before Try.
@
text
@a29 2
/*                          If Try was clicked, Cancel button restores saved */
/*                          state as was before Try.                         */
a63 1
static int          changes_have_been_made = FALSE;
a728 1
            changes_have_been_made = TRUE;
d733 2
a734 6
            /* If Return pressed or click on Set was with Return, then exit program */
            if ( ((block->hdr.flags & Action_ReturnKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
d738 3
a740 17
            /* If right button pressed (meaning window stays open) or if changes
               have been made to the backdrop (eg. by clicking on Try), then
               read the original choices back in and update actual backdrop, if
               necessary */
            if ((block->hdr.flags & Action_AdjustButton) || (changes_have_been_made))
            {
                read_choices();
                if (changes_have_been_made) try_it();
                changes_have_been_made = FALSE;
            }

            /* If Escape pressed or click on Cancel was with Select, then exit */
            if ( ((block->hdr.flags & Action_EscapeKey) == 0)
              || (block->hdr.flags & Action_SelectButton) )
            {
                program_exit();
            }
@

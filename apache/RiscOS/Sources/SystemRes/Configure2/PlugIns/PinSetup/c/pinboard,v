head	1.5;
access;
symbols
	PinSetup-0_24:1.5
	PinSetup-0_23:1.5
	PinSetup-0_22:1.5
	PinSetup-0_21:1.5
	PinSetup-0_20:1.4
	PinSetup-0_19:1.4
	PinSetup-0_18:1.4
	PinSetup-0_17:1.3
	PinSetup-0_16:1.2
	PinSetup-0_15:1.2
	PinSetup-0_14:1.2
	PinSetup-0_13:1.2
	PinSetup-0_12:1.2
	PinSetup-0_11:1.2
	PinSetup-0_10:1.1.1.6
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.5
	Ursula_RiscPC:1.1.1.5.0.2
	rleggett_PinSetup-0_09b:1.1.1.6
	rthornb_UrsulaBuild-19Aug1998:1.1.1.5
	UrsulaBuild_FinalSoftload:1.1.1.5
	rthornb_UrsulaBuild-29Jul1998:1.1.1.5
	rthornb_UrsulaBuild-22Jul1998:1.1.1.5
	rleggett_PinSetup-0_09:1.1.1.5
	rthornb_UrsulaBuild-15Jul1998:1.1.1.4
	rthornb_UrsulaBuild-07Jul1998:1.1.1.4
	rthornb_UrsulaBuild-17Jun1998:1.1.1.3
	rleggett_PinSetup-0_08:1.1.1.3
	rthornb_UrsulaBuild-03Jun1998:1.1.1.3
	rthornb_UrsulaBuild-27May1998:1.1.1.3
	rthornb_UrsulaBuild-21May1998:1.1.1.2
	rthornb_UrsulaBuild_01May1998:1.1.1.2
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2013.01.17.21.14.05;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	9FCAOzzKYdvGGBAw;

1.4
date	2012.09.10.12.06.58;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	XK7uRdwovkl3OYjw;

1.3
date	2012.09.09.18.57.28;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	skbKDg9lUvGS6Tjw;

1.2
date	2002.12.19.21.31.58;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.38.43;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.38.43;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.16.14.58.13;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.05.26.16.56.32;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.07.06.11.05.26;	author rleggett;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.07.22.10.42.15;	author rleggett;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.08.28.13.08.49;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Minor PinSetup improvements
* Use JPEG swis from "swis.h"
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed
Requires RISC_OSLi-5_75 for the swi defs.

Version 0.21. Tagged as 'PinSetup-0_21'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    pinboard.c                                                       */
/* Purpose: Non WIMP, but Pinboard specific code                             */
/* Author:  Richard Leggett                                                  */
/* History: 31-Oct-97: RML: Begun.                                           */
/*          16-Apr-98: RML: No longer uses full path for standard textures.  */
/*          01-Jul-98: RML: Tidied up.                                       */
/*          21-Jul-98: RML: Fixed bug with plotting into sprites in          */
/*                          rectangular pixel modes.                         */
/*                                                                           */
/* Copyright © 1997 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/Sprite.h"
#include "Global/FileTypes.h"
#include "Interface/HighFSI.h"
#include "toolbox.h"
#include "sprite.h"
#include "common.h"
#include "gadgets.h"
#include "defines.h"

#define PRESERVE_CHOICES_FILE FALSE

/*---------------------------------------------------------------------------*
 * pinboard_plot_texture_into_sprite                                         *
 *                                                                           *
 * Plot a texture sprite into one of the sprites contained within the client *
 * sprite area of this application (eg. std_tile, cust_tile etc.).           *
 *                                                                           *
 * In: client_sprite_area -> application's client_sprite_area                *
 *     filename -> name of spritefile containing the texture sprite.         *
 *     name -> name of sprite we want to plot.                               *
 *     sprite_into -> name of sprite  we want to plot into.                  *
 *---------------------------------------------------------------------------*/

_kernel_oserror* pinboard_plot_texture_into_sprite(int *client_sprite_area,
                                                   char *filename,
                                                   char *name,
                                                   char *sprite_into)
{
    _kernel_oserror *e;
    int             *tile;
    char            *dest_sprite;
    char            *tile_sprite;
    char            *ctrans;
    int              areasize;
    int              x;
    int              y;
    int              xeig;
    int              yeig;
    int              tile_w;
    int              tile_h;
    int              into_w;
    int              into_h;

    /* Should really find xeig and yeig of the sprite we're plotting into
       But for now, we know it will always be 1 and 1 */
    xeig = 1;
    yeig = 1;

    /* Grab memory for the new sprite file (the sprite we're plotting into the texture sprite) */
    e = sprite_size_of_spritearea(filename, &areasize);
    if (e) return e;
    tile = malloc(areasize);
    if (!tile) return common_error(messages_lookup("NotEnoughMemory"));

    /* Load the sprite */
    e = sprite_init_and_load(filename, tile, areasize);
    if (e) return e;

    /* If a name was specified, use that tile, else assume the first sprite in the file */
    if (name == 0) tile_sprite = (char*)tile + 16;
    else e = sprite_find_address_of(tile, name, &tile_sprite);

    /* Find address of sprite we're plotting into */
    if (!e) e = sprite_find_address_of(client_sprite_area, sprite_into, &dest_sprite);

    /* Find size of sprite we're plotting and of sprite we're plotting into */
    if (!e) e = sprite_return_size((char*)tile, tile_sprite, &tile_w, &tile_h);
    if (!e) e = sprite_return_size(client_sprite_area, dest_sprite, &into_w, &into_h);

    /* Generate a colour translation table and switch output to the destination sprite */
    if (!e) e = sprite_generate_colourtrans32((char*)tile, tile_sprite, &ctrans);
    if (!e) e = sprite_output_to_sprite(client_sprite_area, dest_sprite);

    if (e)
    {
        if (ctrans) free(ctrans);
        free(tile);
        return e;
    }

    /* Tile the tile (!) into the sprite */
    for (y=0; y<into_h; y+=tile_h)
    {
        for (x=0; x<into_w; x+=tile_w)
        {
            error_trap(_swix(OS_SpriteOp, _INR(0,7),
                                          512+SpriteReason_PutSpriteScaled,
                                          (char*)tile, tile_sprite,
                                          x<<xeig, y<<yeig, 32, 0, ctrans) ,0);
        }
    }

    /* Direct vdu output back to screen */
    error_trap(sprite_output_back_to_screen(), 0);
    free(ctrans);
    free(tile);

    return NULL;
}


/*---------------------------------------------------------------------------*
 * pinboard_do_custom_image_sprite                                           *
 *                                                                           *
 * Plots a copy of the user's custom image (if a sprite) into a sprite. It   *
 * will also tile, scale, centre etc.                                        *
 *                                                                           *
 * In: client_sprite_area -> application's client sprite area.               *
 *     custom_filename -> filename of the custom image.                      *
 *     type = type of backdrop (scaled, tiled, centred).                     *
 *     bgcol = colour of background chosen.                                  *
 *---------------------------------------------------------------------------*/

_kernel_oserror* pinboard_do_custom_image_sprite(int *client_sprite_area,
                                                 char *custom_filename,
                                                 int type,
                                                 int bgcol)
{
    _kernel_oserror *e;
    int             *tile;
    char            *dest_sprite;
    char            *ctrans;
    int             *sprite_data;
    int              areasize;
    int              tile_w;
    int              tile_h;
    int              into_w;
    int              into_h;
    int              i;
    int              scale_factor[4];

    /* If the user hasn't yet dragged on a file, then we do nothing */
    if (custom_filename[0] == 0) return NULL;

    /* Claim memory needed for spritefile */
    e = sprite_size_of_spritearea(custom_filename, &areasize);
    if (e) return e;
    tile = malloc(areasize);
    if (!tile) return common_error(messages_lookup("NotEnoughMemory"));

    /* Load the file, find the size of the two sprites we're dealing with, */
    /* generate a colourtrans table and direct output to the destination sprite */
    e = sprite_init_and_load(custom_filename, tile, areasize);
    if (!e) e = sprite_return_size((char*)tile, (char*)tile+16, &tile_w, &tile_h);
    if (!e) e = sprite_find_address_of(client_sprite_area, "cust_tile", &dest_sprite);
    if (!e) e = sprite_return_size(client_sprite_area, dest_sprite, &into_w, &into_h);
    if (!e) e = sprite_generate_colourtrans32((char*)tile, (char*)tile + 16, &ctrans);
    if (!e) e = sprite_output_to_sprite(client_sprite_area, dest_sprite);

    /* Fill in the background of the sprite */
    sprite_data = (int*) (dest_sprite + 44);
    for (i=0; i < (into_w*into_h); i++) sprite_data[i] = bgcol>>8;

    if (e)
    {
        if (ctrans) free(ctrans);
        free(tile);
        return e;
    }

    /* If tiling the backdrop... */
    if (type == TiledRadioButton)
    {
        int x, y, xeig, yeig;

        /* Should really find xeig and yeig of the sprite we're plotting into
           But for now, we know it will always be 1 and 1 */
        xeig = 1;
        yeig = 1;

        for (y=0; y<into_h; y+=tile_h)
        {
            for (x=0; x<into_w; x+=tile_w)
            {
                error_trap(_swix(OS_SpriteOp, _INR(0,7),
                                              512+SpriteReason_PutSpriteScaled,
                                              (char*)tile, (char*)tile + 16,
                                              x<<xeig, y<<yeig, 32+8, 0, ctrans) ,0);
            }
        }
    }

    /* If scaling the backdrop... */
    else if (type == ScaledRadioButton)
    {
        scale_factor[0] = into_w;
        scale_factor[1] = into_h;
        scale_factor[2] = tile_w;
        scale_factor[3] = tile_h;
        error_trap(_swix(OS_SpriteOp, _INR(0,7),
                                      512+SpriteReason_PutSpriteScaled,
                                      (char*)tile, (char*)tile + 16,
                                      0, 0, 32+8, scale_factor, ctrans) ,0);
    }

    /* If centred image on backdrop... */
    else if (type == CentredRadioButton)
    {
        /* Plot the image in the centre of the sprite, scaled to leave a small border */
        scale_factor[0] = into_w-16;
        scale_factor[1] = into_h-16;
        scale_factor[2] = tile_w;
        scale_factor[3] = tile_h;
        error_trap(_swix(OS_SpriteOp, _INR(0,7),
                                      512+SpriteReason_PutSpriteScaled,
                                      (char*)tile, (char*)tile + 16,
                                      16, 16, 32+8, scale_factor, ctrans) ,0);

    }

    /* Direct output back to screen and free memory */
    error_trap(sprite_output_back_to_screen(), 0);
    free(ctrans);
    free(tile);

    return NULL;
}


/*---------------------------------------------------------------------------*
 * pinboard_do_custom_image_jpeg                                             *
 *                                                                           *
 * Plots a copy of the user's custom image (if a JPEG) into a sprite. It     *
 * will also tile, scale, centre etc.                                        *
 *                                                                           *
 * In: client_sprite_area -> application's client sprite area.               *
 *     custom_filename -> filename of the custom image.                      *
 *     type = type of backdrop (scaled, tiled, centred).                     *
 *     bgcol = colour of background chosen.                                  *
 *---------------------------------------------------------------------------*/

_kernel_oserror* pinboard_do_custom_image_jpeg(int *client_sprite_area,
                                               char *custom_filename,
                                               int type,
                                               int bgcol)
{
    _kernel_oserror *e;
    char            *dest_sprite;
    int             *sprite_data;
    int              into_w;
    int              into_h;
    int              tile_w;
    int              tile_h;
    int              i;
    int              scale_factor[4];

    /* If the user hasn't yet dragged on a file, then we do nothing */
    if (custom_filename[0] == 0) return NULL;

    e = sprite_find_address_of(client_sprite_area, "cust_tile", &dest_sprite);
    if (!e) e = sprite_return_size(client_sprite_area, dest_sprite, &into_w, &into_h);
    if (!e) e = _swix(JPEG_FileInfo, _INR(0,1)|_OUTR(2,3), 1, custom_filename, &tile_w, &tile_h);
    if (!e) e = sprite_output_to_sprite(client_sprite_area, dest_sprite);
    if (e) return e;

    /* If tiling the backdrop... */
    if (type == TiledRadioButton)
    {
        int x, y, xeig, yeig;

        /* Should really find xeig and yeig of the sprite we're plotting into
           But for now, we know it will always be 1 and 1 */
        xeig = 1;
        yeig = 1;

        for (y=0; y<into_h; y+=tile_h)
        {
            for (x=0; x<into_w; x+=tile_w)
            {
                error_trap(_swix(JPEG_PlotFileScaled, _INR(0,4), custom_filename, x<<xeig, y<<yeig, 0, 0), 0);
            }
        }
    }

    /* If scaling the backdrop... */
    else if (type == ScaledRadioButton)
    {
        scale_factor[0] = into_w;
        scale_factor[1] = into_h;
        scale_factor[2] = tile_w;
        scale_factor[3] = tile_h;
        error_trap(_swix(JPEG_PlotFileScaled, _INR(0,4), custom_filename, 0, 0, scale_factor, 0), 0);
    }

    /* If centred image on backdrop... */
    else if (type == CentredRadioButton)
    {
        /* Fill in the background of the sprite */
        sprite_data = (int*) (dest_sprite + 44);
        for (i=0; i < (into_w*into_h); i++) sprite_data[i]=bgcol>>8;

        /* Plot the image in the centre of the sprite, scaled to leave a small border */
        scale_factor[0] = into_w-16;
        scale_factor[1] = into_h-16;
        scale_factor[2] = tile_w;
        scale_factor[3] = tile_h;
        error_trap(_swix(JPEG_PlotFileScaled, _INR(0,4), custom_filename, 16, 16, scale_factor, 0), 0);
    }

    error_trap(sprite_output_back_to_screen(), 0);

    return NULL;
}


/*---------------------------------------------------------------------------*
 * pinboard_get_tile_filename                                                *
 *                                                                           *
 * Produce the filename of the tile specified by number 'num' and flag       *
 * 'lighter'. If the lighter is 1, but the lighter version of the tile       *
 * doesn't exist, the darker version will be used and vice versa.            *
 *                                                                           *
 * In: num = tile number                                                     *
 *     num_std_tiles = counted theme generic tiles                           *
 *     is_lighter = 1 if lighter version required, 0 otherwise               *
 *                                                                           *
 * On exit: path -> filename of tile sprite                                  *
 * Returns: 1 if succesful, 0 if tile not found.                             *
 *---------------------------------------------------------------------------*/

int pinboard_get_tile_filename(int num, int num_std_tiles, int is_lighter, char *path)
{
    char texture_string[64];
    char darker_string[128];
    char lighter_string[128];
    int  darker_exists;
    int  lighter_exists;

    if (num > num_std_tiles)
    {
        /* See if there are any theme specific tiles to choose from. The theme is expanded
         * with GSTrans so that the backdrop is preserved over a theme change (though
         * on next running this plugin it would subsequently be reset).
         */
        num = num - num_std_tiles;
        sprintf(texture_string, TextureThemePrefix"T%d", num);
        _swix(OS_GSTrans, _INR(0,2),
                          texture_string, darker_string, sizeof(darker_string));
        sprintf(texture_string, TextureThemePrefix"T%dL", num);
        _swix(OS_GSTrans, _INR(0,2),
                          texture_string, lighter_string, sizeof(lighter_string));
    }
    else
    {
        /* Choose from the set [1...num_std_tiles] */
        sprintf(darker_string, TexturePrefix"T%d", num);
        sprintf(lighter_string, TexturePrefix"T%dL", num);
    }
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, darker_string, &darker_exists), 0);
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), OSFile_ReadNoPath, lighter_string, &lighter_exists), 0);

    if ((!lighter_exists) && (!darker_exists)) return 0;

    if ((is_lighter) && (!lighter_exists)) is_lighter = 0;
    if ((!is_lighter) && (!darker_exists)) is_lighter = 1;

    if (is_lighter) strcpy(path, lighter_string);
    else strcpy(path, darker_string);

    return 1;
}


/*---------------------------------------------------------------------------*
 * ignore_string                                                             *
 *                                                                           *
 * Decide if a string in the choices file should be ignored (because we're   *
 * going to output an updated version)                                       *
 *                                                                           *
 * In: string -> the string                                                  *
 *                                                                           *
 * Returns: 1 if ignore, 0 not to ignore                                     *
 *---------------------------------------------------------------------------*/

#if PRESERVE_CHOICES_FILE
static int ignore_string(char *string)
{
    if (strncmpa(string, "backdrop", 8)==0) return 1;
    if (strncmpa(string, "pinboard", 8)==0) return 1;

    return 0;
}
#endif


/*---------------------------------------------------------------------------*
 * write_pinboard_choices                                                    *
 *                                                                           *
 * Given a *Backdrop command and a *Pinboard command, ammend the choices     *
 * file to have these commands.                                              *
 *                                                                           *
 * In: backdrop_command -> *Backdrop string.                                 *
 *     pinboard_command -> *Pinboard string.                                 *
 *---------------------------------------------------------------------------*/

_kernel_oserror* pinboard_write_choices(char *backdrop_command, char *pinboard_command)
{
    char  string[1024];
    FILE *dest_fp;
#if PRESERVE_CHOICES_FILE
    FILE *source_fp;

    source_fp = fopen(ChoicesFileRO, "r");
#endif
    dest_fp = fopen(ScrapFile, "w");
    if (dest_fp == NULL) return common_error(messages_lookup("ChoicesFileNotOpen"));

    /* Write the new *Pinboard and *Backdrop commands into the choices file */
    if (strlen(pinboard_command) > 9)
    {
        fputs(pinboard_command, dest_fp);
        fputc(NewLine, dest_fp);
    }
    if (strlen(backdrop_command) > 9)
    {
        fputs(backdrop_command, dest_fp);
        fputc(NewLine, dest_fp);
    }

#if PRESERVE_CHOICES_FILE
    if (source_fp != NULL)
    {
        int more = 1;

        /* Write out any other commands that were in the file */
        while(more)
        {
            more = (int)fgets(string, 1024, source_fp);
            if (more)
            {
                if (!ignore_string(string)) fputs(string, dest_fp);
            }
        }
        fclose(source_fp);
    }
#endif
    fclose(dest_fp);

    /* Set filetype of the new file */
    error_trap(_swix(OS_File, _INR(0, 2), OSFile_SetType, ScrapFile, FileType_Obey), 0);

    sprintf(string,"Copy %s %s A~CDF~L~N~P~Q~R~S~T~V", ScrapFile, ChoicesFile);
    error_trap(_swix(OS_CLI, _IN(0), string), 0);
    _swix(OS_File, _INR(0,1), OSFile_Delete, ScrapFile);

    sprintf(string, "Filer_Run %s", ChoicesFile);
    error_trap(_swix(OS_CLI, _IN(0), string), 0);

    return NULL;
}


/*---------------------------------------------------------------------------*
 * pinboard_query_standard_texture                                           *
 *                                                                           *
 * Given a pathname, decide if it is one of the standard textures.           *
 *                                                                           *
 * In: path -> pathname.                                                     *
 *     num_std_tiles = counted theme generic tiles                           *
 *                                                                           *
 * Returns: 1 if a standard texture, 0 otherwise.                            *
 *                                                                           *
 * On exit: num -> number of this texture (if a standard texture)            *
 *          is_lighter -> value of lighter (if a standard texture)           *
 *---------------------------------------------------------------------------*/

int pinboard_query_standard_texture(int *num, int num_std_tiles, int *is_lighter, const char *path)
{
    const char *ptr;
    char  selected[128];
    int   n;
    char  l;

    /* If the base path is wrong, stop now */
    if (strncmpa((char *)path, TextureResPath, strlen(TextureResPath)) != 0) return 0;
    ptr = path + strlen(TextureResPath);

    if (strchr(ptr, '.') != NULL)
    {
        /* In a subdirectory (maybe for a theme) of the texture resources */
        _swix(OS_GSTrans, _INR(0,2),
                          TextureThemePrefix, selected, sizeof(selected));
        if (strncmpa((char *)path, selected, strlen(selected)) != 0)
        {
            /* The theme has changed since last run, use default */
            strcpy(selected, DefaultTexture);
            ptr = selected + strlen(TexturePrefix);
            num_std_tiles = 0;
        }
        else
        {
            ptr = path + strlen(selected);
        }
        sscanf(ptr, "T%d%c", &n, &l);
        n = n + num_std_tiles;
    }
    else
    {
        sscanf(ptr, "T%d%c", &n, &l);
    }

    *num = n;
    *is_lighter = (l == 'L') ? 1 : 0;

    return 1;
}


/*---------------------------------------------------------------------------*
 * count_standard_textures                                                   *
 *                                                                           *
 * Find out how many standard textures are available on this machine.        *
 *---------------------------------------------------------------------------*/

int pinboard_count_standard_textures(void)
{
    char texture_string[64];
    int  darker_exists;
    int  lighter_exists;
    int  n;

    for (n = 1; n; n++)
    {
        sprintf(texture_string, TexturePrefix"T%d", n);
        error_trap(_swix(OS_File, _INR(0,1) | _OUT(0), OSFile_ReadNoPath, texture_string, &darker_exists), 0);
        sprintf(texture_string, TexturePrefix"T%dL", n);
        error_trap(_swix(OS_File, _INR(0,1) | _OUT(0), OSFile_ReadNoPath, texture_string, &lighter_exists), 0);
        if ((!lighter_exists) && (!darker_exists)) break;
    }

    return n - 1;
}
@


1.4
log
@Teach about looking for backdrop tiles in subdirectories
* Now matches 'RTexture' in its ability to select backdrop tiles from the currently configured theme
* Add lost Cosprites11 file from Richard Hallas
* Replace a few hardwired 1024's with the MaxFilenameSize constant
* Fix RTexture not being run due to errant '.' added in 0.17
In the event that the theme gets changed between last run of !PinSetup, the default built in T1L will be substituted.

Version 0.18. Tagged as 'PinSetup-0_18'
@
text
@a41 4
#define JPEG_FileInfo         0x49981
#define JPEG_PlotFileScaled   0x49983


@


1.3
log
@PinSetup tidy step
Usual drill
* Makefile recreated from fragments
* Version number inserted to messages at build time
* Local OS interface definitions replaced with central header files
* Read choices from Choices$Path write via Choices$Write
Also simplified the random texture 'try' option by just running RTexture directly rather than emulating it in C.
Tested briefly, still works.

Version 0.17. Tagged as 'PinSetup-0_17'
@
text
@d40 1
a40 1
#define PreserveChoicesFile   FALSE
d348 2
a349 1
 *     lighter = 1 if lighter version required, 0 otherwise                  *
d351 1
a351 1
 * On exit: filename -> filename of tile sprite                              *
d355 1
a355 1
int pinboard_get_tile_filename(int num, int lighter, char *filename)
d357 3
a359 2
    char darker_string[64];
    char lighter_string[64];
d363 20
a382 2
    sprintf(darker_string, TexturePrefix"%d", num);
    sprintf(lighter_string, TexturePrefix"%dL", num);
d388 2
a389 2
    if ((lighter) && (!lighter_exists)) lighter=0;
    if ((!lighter) && (!darker_exists)) lighter=1;
d391 2
a392 2
    if (lighter) strcpy(filename, lighter_string);
    else strcpy(filename, darker_string);
d409 1
a409 1
#if PreserveChoicesFile
d432 3
a435 2
    FILE *dest_fp;
    char  string[1024];
d438 1
d443 1
a443 1
    if (strlen(pinboard_command) >9)
d448 1
a448 1
    if (strlen(backdrop_command) >9)
d454 1
a456 1
#if PreserveChoicesFile
a467 1
#endif
d470 1
a470 2


d493 1
d497 2
a498 2
 * On exit: texture_no -> number of this texture (if a standard texture)     *
 *          is_lighter -> value of lighter (1 or 0) if this is a st. texture *
d501 1
a501 1
int pinboard_query_standard_texture(char *path, int *texture_no, int *is_lighter)
d503 2
a504 1
    char *ptr;
d508 30
a537 7
    if (strncmpa(path, TexturePrefix, strlen(TexturePrefix))!=0) return 0;
    ptr = path + (strlen(TexturePrefix));
    sscanf(ptr, "%d%c", &n, &l);

    *texture_no = n;
    if (l == 'L') *is_lighter = 1;
    else *is_lighter = 0;
d541 26
@


1.2
log
@Addition of "Icon Text Colour" popup to support *backdrop command.
UK Res file overhaul.

Version 0.11. Tagged as 'PinSetup-0_11'
@
text
@d16 1
a16 1
/* File:    c.pinboard                                                       */
a26 1

d31 3
d121 1
a121 1
                                          512+Sprite_PutScaled,
d210 1
a210 1
                                              512+Sprite_PutScaled,
d225 1
a225 1
                                      512+Sprite_PutScaled,
d239 1
a239 1
                                      512+Sprite_PutScaled,
d363 2
a364 2
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, darker_string, &darker_exists), 0);
    error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, lighter_string, &lighter_exists), 0);
a414 1
    int   more = 1;
d416 1
a416 1
    source_fp = fopen(ChoicesFile, "r");
d418 1
a418 1
    if (!dest_fp) return common_error(messages_lookup("ChoicesFileNotOpen"));
d432 1
a432 1
    if (source_fp)
d435 2
d454 1
a454 1
    error_trap(_swix(OS_File, _INR(0, 2), 18, ScrapFile, 0xFEB), 0);
d458 1
a458 1
    _swix(OS_File, _INR(0,1), 6, ScrapFile);
a495 27


/*---------------------------------------------------------------------------*
 * count_standard_textures                                                   *
 *                                                                           *
 * Find out how many standard textures are available on this machine.        *
 *---------------------------------------------------------------------------*/

int pinboard_count_standard_textures(void)
{
    char darker_string[64];
    char lighter_string[64];
    int  darker_exists;
    int  lighter_exists;
    int  n;

    for (n=1; n; n++)
    {
        sprintf(darker_string, TexturePrefix"%d", n);
        sprintf(lighter_string, TexturePrefix"%dL", n);
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, darker_string, &darker_exists), 0);
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, lighter_string, &lighter_exists), 0);
        if ((!lighter_exists) && (!darker_exists)) break;
    }

    return n-1;
}
@


1.1
log
@Initial revision
@
text
@d20 4
d38 2
d43 1
d45 1
a45 1
 * texture_into_sprite                                                       *
d47 2
a48 1
 * Plot a texture sprite into a sprite in the client sprite area of the app. *
d50 4
a53 4
 * In: client_sprite_are -> application's client_sprite_area                 *
 *     filename -> texture filename                                          *
 *     sprite_into -> name of sprite in client sprite area we're plotting    *
 *                    into.                                                  *
d56 4
a59 1
_kernel_oserror* texture_into_sprite(int* client_sprite_area, char* filename, char* name, char* sprite_into)
d66 14
a79 5
    int              areasize, x, y, xeig, yeig;
    int              tile_w, tile_h, into_w, into_h;

    _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &xeig);
    _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &yeig);
d81 1
a83 1
    
d87 1
d89 5
d95 4
a98 6
    if (!e)
    {
        if (name==0) tile_sprite = (char*)tile + 16;
        else e = sprite_find_address_of(tile, name, &tile_sprite);
    }
    
a99 1
    if (!e) e = sprite_find_address_of(client_sprite_area, sprite_into, &dest_sprite);
d101 2
d125 1
a126 1

d132 1
a132 1
    
d135 1
a135 1
 * do_custom_image_sprite                                                    *
d146 4
a149 1
_kernel_oserror* do_custom_image_sprite(int* client_sprite_area, char* custom_filename, int type, int bgcol)
d157 5
a161 1
    int              tile_w, tile_h, into_w, into_h, i;
d182 4
d197 5
a201 3
        
        e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &xeig);
        e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &yeig);
d210 1
a210 1
                                              x<<xeig, y<<yeig, 32, 0, ctrans) ,0);
d225 1
a225 1
                                      0, 0, 32, scale_factor, ctrans) ,0);
a230 4
        /* Fill in the background of the sprite */        
        sprite_data = (int*) (dest_sprite + 44);
        for (i=0; i < (into_w*into_h); i++) sprite_data[i] = bgcol>>8;
        
d239 1
a239 1
                                      16, 16, 32, scale_factor, ctrans) ,0);
d253 1
a253 1
 * do_custom_image_jpeg                                                      *
d264 4
a267 1
_kernel_oserror* do_custom_image_jpeg(int* client_sprite_area, char* custom_filename, int type, int bgcol)
d270 9
a278 5
    char *dest_sprite;
    int  *sprite_data;
    int   into_w, into_h, tile_w, tile_h, i;
    int   scale_factor[4];
    
d292 5
a296 3
        
        e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &xeig);
        e = _swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &yeig);
d323 1
a323 1
        
d339 1
a339 1
 * tile_filename                                                             *
d351 2
a352 2
 
int tile_filename(int num, int lighter, char* filename)
a353 1
    char buffer[256];
d356 2
a357 4
    int  darker_exists, lighter_exists, read;
    
    error_trap(_swix(OS_ReadVarVal, _INR(0,4)|_OUT(2), "Boot$Dir", buffer, 255, 0, 0, &read), 0);
    strcpy(buffer + read, ".Resources.Configure.Textures.T");
d359 2
a360 2
    sprintf(darker_string, "%s%d", buffer, num);
    sprintf(lighter_string, "%s%dL", buffer, num);
d371 1
a371 1
    
d387 1
d392 1
a392 1
    
d395 1
d407 2
a408 2
 
_kernel_oserror* write_pinboard_choices(char* backdrop_command, char* pinboard_command)
d414 1
a414 1
    
d418 1
a418 1
        
d433 1
d443 1
a443 1

d447 1
d449 1
a449 1
    
d465 1
a465 1
 * path_is_a_standard_texture                                                *
d477 1
a477 1
int path_is_a_standard_texture(char *path, int *texture_no, int *is_lighter)
a478 1
    char buffer[256];
d481 1
a481 4
    char  l, read;

    error_trap(_swix(OS_ReadVarVal, _INR(0,4)|_OUT(2), "Boot$Dir", buffer, 255, 0, 0, &read), 0);
    strcpy(buffer + read, ".Resources.Configure.Textures.T");
d483 2
a484 2
    if (strncmpa(path, buffer, strlen(buffer))!=0) return 0;
    ptr = path + (strlen(buffer));
d492 27
@


1.1.1.1
log
@Initial import of PinSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Tiled JPEGs no longer allowed.
Fully canonicalised path no longer used for standard textures. Instead
we use BootResources:Configure.Textures.
@
text
@a19 1
/*          16-Apr-98: RML: No longer uses full path for standard textures.  */
d55 2
a56 9
    int              areasize;
    int              x;
    int              y;
    int              xeig;
    int              yeig;
    int              tile_w;
    int              tile_h;
    int              into_w;
    int              into_h;
d129 1
a129 5
    int              tile_w;
    int              tile_h;
    int              into_w;
    int              into_h;
    int              i;
d233 4
a236 8
    char            *dest_sprite;
    int             *sprite_data;
    int              into_w;
    int              into_h;
    int              tile_w;
    int              tile_h;
    int              i;
    int              scale_factor[4];
d311 1
d314 4
a317 2
    int  darker_exists;
    int  lighter_exists;
d319 2
a320 2
    sprintf(darker_string, TexturePrefix"%d", num);
    sprintf(lighter_string, TexturePrefix"%dL", num);
d435 1
d438 4
a441 1
    char  l;
d443 2
a444 2
    if (strncmpa(path, TexturePrefix, strlen(TexturePrefix))!=0) return 0;
    ptr = path + (strlen(TexturePrefix));
@


1.1.1.3
log
@Chosen backdrop colour now shows through masked sprites.
Choices file renamed to PinSetup (from Pinboard).
@
text
@a161 4
    /* Fill in the background of the sprite */        
    sprite_data = (int*) (dest_sprite + 44);
    for (i=0; i < (into_w*into_h); i++) sprite_data[i] = bgcol>>8;

d184 1
a184 1
                                              x<<xeig, y<<yeig, 32+8, 0, ctrans) ,0);
d199 1
a199 1
                                      0, 0, 32+8, scale_factor, ctrans) ,0);
d204 5
a208 1
    {        
d217 1
a217 1
                                      16, 16, 32+8, scale_factor, ctrans) ,0);
a460 27
}


/*---------------------------------------------------------------------------*
 * count_standard_textures                                                   *
 *                                                                           *
 * Find out how many standard textures are available on this machine.        *
 *---------------------------------------------------------------------------*/

int count_standard_textures(void)
{
    char darker_string[64];
    char lighter_string[64];
    int  darker_exists;
    int  lighter_exists;
    int  n;

    for (n=1; n; n++)
    {
        sprintf(darker_string, TexturePrefix"%d", n);
        sprintf(lighter_string, TexturePrefix"%dL", n);
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, darker_string, &darker_exists), 0);
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(0), 17, lighter_string, &lighter_exists), 0);
        if ((!lighter_exists) && (!darker_exists)) break;
    }
    
    return n-1;
@


1.1.1.4
log
@Changed the way the custom tile drop zone is handled.
Reduced flicker in some redraw cases.
@
text
@a20 1
/*          01-Jul-98: RML: Tidied up.                                       */
a37 1

d39 1
a39 1
 * pinboard_plot_texture_into_sprite                                         *
d41 1
a41 2
 * Plot a texture sprite into one of the sprites contained within the client *
 * sprite area of this application (eg. std_tile, cust_tile etc.).           *
d43 4
a46 4
 * In: client_sprite_area -> application's client_sprite_area                *
 *     filename -> name of spritefile containing the texture sprite.         *
 *     name -> name of sprite we want to plot.                               *
 *     sprite_into -> name of sprite  we want to plot into.                  *
d49 1
a49 4
_kernel_oserror* pinboard_plot_texture_into_sprite(int *client_sprite_area,
                                                   char *filename,
                                                   char *name,
                                                   char *sprite_into)
a68 1
    /* Grab memory for the new sprite file (the sprite we're plotting into the texture sprite) */
d71 1
a74 1
    /* Load the sprite */
a75 1
    if (e) return e;
d77 5
a81 3
    /* If a name was specified, use that tile, else assume the first sprite in the file */
    if (name == 0) tile_sprite = (char*)tile + 16;
    else e = sprite_find_address_of(tile, name, &tile_sprite);
d83 1
a83 1
    /* Find address of sprite we're plotting into */
a84 3

    /* Find size of sprite we're plotting and of sprite we're plotting into */
    if (!e) e = sprite_return_size((char*)tile, tile_sprite, &tile_w, &tile_h);
a85 2

    /* Generate a colour translation table and switch output to the destination sprite */
a107 1
    /* Direct vdu output back to screen */
d109 1
d118 1
a118 1
 * pinboard_do_custom_image_sprite                                           *
d129 1
a129 4
_kernel_oserror* pinboard_do_custom_image_sprite(int *client_sprite_area,
                                                 char *custom_filename,
                                                 int type,
                                                 int bgcol)
d231 1
a231 1
 * pinboard_do_custom_image_jpeg                                             *
d242 1
a242 4
_kernel_oserror* pinboard_do_custom_image_jpeg(int *client_sprite_area,
                                               char *custom_filename,
                                               int type,
                                               int bgcol)
d312 1
a312 1
 * pinboard_get_tile_filename                                                *
d325 1
a325 1
int pinboard_get_tile_filename(int num, int lighter, char *filename)
d379 1
a379 1
_kernel_oserror* pinboard_write_choices(char *backdrop_command, char *pinboard_command)
d434 1
a434 1
 * pinboard_query_standard_texture                                           *
d446 1
a446 1
int pinboard_query_standard_texture(char *path, int *texture_no, int *is_lighter)
d470 1
a470 1
int pinboard_count_standard_textures(void)
@


1.1.1.5
log
@* Fixed bug with plotting into sprites in rectangular pixel modes.
* If Try was clicked, Cancel button restores saved state as was before Try.
@
text
@a21 2
/*          21-Jul-98: RML: Fixed bug with plotting into sprites in          */
/*                          rectangular pixel modes.                         */
d72 2
a73 4
    /* Should really find xeig and yeig of the sprite we're plotting into
       But for now, we know it will always be 1 and 1 */
    xeig = 1;
    yeig = 1;
d191 3
a194 5
        /* Should really find xeig and yeig of the sprite we're plotting into
           But for now, we know it will always be 1 and 1 */
        xeig = 1;
        yeig = 1;
        
d284 3
a286 5

        /* Should really find xeig and yeig of the sprite we're plotting into
           But for now, we know it will always be 1 and 1 */
        xeig = 1;
        yeig = 1;
@


1.1.1.6
log
@No longer preserves lines in PinSetup which we don't recognise. (This was
causing some problems).
@
text
@a37 2
#define PreserveChoicesFile   FALSE

a384 1
#if PreserveChoicesFile
a391 1
#endif
d409 1
a409 1
    int   more;
a410 1
    more = 1;    
a428 1
#if PreserveChoicesFile
d438 1
a438 1
#endif
a440 1

@

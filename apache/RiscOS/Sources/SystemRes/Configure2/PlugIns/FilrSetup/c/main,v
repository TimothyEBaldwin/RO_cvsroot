head	1.10;
access;
symbols
	FilrSetup-0_27:1.10
	FilrSetup-0_26:1.10
	FilrSetup-0_25:1.9
	FilrSetup-0_24:1.9
	FilrSetup-0_23:1.8
	FilrSetup-0_22:1.7
	FilrSetup-0_21:1.6
	FilrSetup-0_20:1.6
	FilrSetup-0_19:1.5
	FilrSetup-0_18:1.4
	FilrSetup-0_17:1.4
	FilrSetup-0_16:1.4
	FilrSetup-0_15:1.3
	FilrSetup-0_14:1.2
	FilrSetup-0_13:1.1.1.4
	FilrSetup-0_12:1.1.1.4
	FilrSetup-0_11:1.1.1.4
	FilrSetup-0_10:1.1.1.4
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.4
	Ursula_RiscPC:1.1.1.4.0.2
	rthornb_UrsulaBuild-19Aug1998:1.1.1.4
	UrsulaBuild_FinalSoftload:1.1.1.4
	rthornb_UrsulaBuild-29Jul1998:1.1.1.4
	rthornb_UrsulaBuild-22Jul1998:1.1.1.4
	rleggett_FilrSetup-0_09:1.1.1.4
	rthornb_UrsulaBuild-15Jul1998:1.1.1.4
	rthornb_UrsulaBuild-07Jul1998:1.1.1.4
	rthornb_UrsulaBuild-17Jun1998:1.1.1.4
	rleggett_FilrSetup-0_08:1.1.1.4
	rthornb_UrsulaBuild-03Jun1998:1.1.1.4
	rthornb_UrsulaBuild-27May1998:1.1.1.4
	rthornb_UrsulaBuild-21May1998:1.1.1.3
	rthornb_UrsulaBuild_01May1998:1.1.1.2
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2018.02.15.20.45.20;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	RUZuk436X7b1UZqA;

1.9
date	2013.11.24.12.39.43;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	xJYGtjHhKs3rQwex;

1.8
date	2013.07.31.07.10.02;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	HhmO6565LmAuKAZw;

1.7
date	2013.07.20.14.31.23;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	jGCpafuTdHaQxdYw;

1.6
date	2013.01.17.21.31.34;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	6aiWAyYDITTFMBAw;

1.5
date	2012.06.26.23.32.55;	author jlee;	state Exp;
branches;
next	1.4;
commitid	3t1QV2Irq2rS2haw;

1.4
date	2010.05.08.16.18.34;	author rsprowson;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.07.21.55.42;	author rool;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.07.21.47.54;	author rool;	state Exp;
branches;
next	1.1;

1.1
date	98.04.14.10.33.27;	author rleggett;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.14.10.33.27;	author rleggett;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.23.13.09.17;	author rleggett;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.05.19.16.06.40;	author rleggett;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.05.26.11.34.09;	author rleggett;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Use define from wimp.h
Requires (Toolbox) Libs-0_25.

Version 0.26. Tagged as 'FilrSetup-0_26'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*---------------------------------------------------------------------------*/
/* File:    c.main                                                           */
/* Purpose: Main WIMP shell for Filer configuration                          */
/* Author:  Richard Leggett                                                  */
/* History: 06-Nov-97: RML: Begun.                                           */
/*          20-Mar-98: RML: Minor modifications.                             */
/*          13-May-98: RML: If not high enough vertical resolution, use a    */
/*                          window with vertical scrollbar.                  */
/*          14-May-98: RML: Now redraws whole screen when Set clicked.       */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/CMOS.h"
#include "toolbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "menu.h"
#include "wimplib.h"
#include "defines.h"
#include "filer.h"

static IdBlock    idb;
static MessagesFD messages_desc;
static char       messages_string[255];
static ObjectId   main_window, sort_menu;
static int        fullinfo_truncation = 4096;
static BOOL       can_reversesort, can_numericalsort;

static int sort_selected(int, ToolboxEvent *, IdBlock *, void *);

/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char layout_command[256] = "Filer_Layout";
    char options_command[256] = "Filer_Options";
    char truncation_command[256] = "Filer_Truncation";
    char dclickhold_command[256] = "Filer_DClickHold";
    int  selected;
    int  largeicon_truncation;
    int  smallicon_truncation;
    int  dclickholddelay;
    int  value;

    /* Add icon size switch to Filer_Layout command */
    error_trap(stringset_get_selected(1, main_window, DisplayAsMenu, &selected), 0);
    switch (selected)
    {
        case 0: strcat(layout_command, " -LargeIcons"); break;
        case 1: strcat(layout_command, " -SmallIcons"); break;
        case 2: strcat(layout_command, " -FullInfo");   break;
    }

    /* Add sort type switch to Filer_Layout command */
    for (selected = 0; selected <= 3; selected++)
    {
        error_trap(menu_get_tick(0, sort_menu, selected, &value), 0);
        if (value) break;
    }
    switch (selected)
    {
        case 0: strcat(layout_command, " -SortByName"); break;
        case 1: strcat(layout_command, " -SortByType"); break;
        case 2: strcat(layout_command, " -SortBySize"); break;
        case 3: strcat(layout_command, " -SortByDate"); break;
    }

    if (can_reversesort)
    {
        /* Add sort order to Filer_Layout command */
        error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &selected), 0);
        if (selected) strcat(layout_command, " -ReverseSort");
    }

    if (can_numericalsort)
    {
        /* Add numerical sort style to Filer_Layout command */
        error_trap(menu_get_tick(0, sort_menu, MenuSortNumerical, &selected), 0);
        if (selected) strcat(layout_command, " -NumericalSort");
    }
    
    /* Make up Filer_Options command */
    error_trap(optionbutton_get_state(0, main_window, ConfirmOption, &selected), 0);
    if (selected)
    {
        error_trap(radiobutton_get_state(0, main_window, ConfirmAllRadio, 0, &selected), 0);
        switch(selected)
        {
            case ConfirmAllRadio:     strcat(options_command, " -ConfirmAll");     break;
            case ConfirmDeletesRadio: strcat(options_command, " -ConfirmDeletes"); break;
        }
    }

    error_trap(optionbutton_get_state(0, main_window, VerboseOption, &selected), 0);
    if (selected) strcat(options_command, " -Verbose");

    error_trap(optionbutton_get_state(0, main_window, NewerOption, &selected), 0);
    if (selected) strcat(options_command, " -Newer");

    error_trap(optionbutton_get_state(0, main_window, ForceOption, &selected), 0);
    if (selected) strcat(options_command, " -Force");

    error_trap(optionbutton_get_state(0, main_window, FasterOption, &selected), 0);
    if (selected) strcat(options_command, " -Faster");

    /* Make up a Filer_Truncation command */
    error_trap(numberrange_get_value(0, main_window, LargeIconRange, &largeicon_truncation), 0);
    error_trap(numberrange_get_value(0, main_window, SmallIconRange, &smallicon_truncation), 0);
    sprintf(truncation_command, "Filer_Truncation -LargeIconDisplay %d -SmallIconDisplay %d -FullInfoDisplay %d",
            largeicon_truncation, smallicon_truncation, fullinfo_truncation);

    /* Make up a Filer_DClickHold command */
    error_trap(optionbutton_get_state(0, main_window, DClickHoldOption, &selected), 0);
    if (selected)
    {
        error_trap(numberrange_get_value(0, main_window, DClickHoldDelay, &dclickholddelay), 0);
    }
    else
    {
        dclickholddelay = 0;
    }
    sprintf(dclickhold_command, "Filer_DClickHold %d", 10 * dclickholddelay);

    /* Now write the choices file */
    error_trap(write_filer_choices(options_command, truncation_command, layout_command, dclickhold_command), 0);

    /* Write the CMOS bits */
    value = read_cmos_value(FileSwitchCMOS) & ~(InteractiveCopyCMOSBit | DragASpriteCMOSBit);
    error_trap(optionbutton_get_state(0, main_window, ActiveCopyOption, &selected), 0);
    if (!selected) value = value | InteractiveCopyCMOSBit;
    error_trap(optionbutton_get_state(0, main_window, SolidDragOption, &selected), 0);
    if (selected) value = value | DragASpriteCMOSBit;
    write_cmos_value(FileSwitchCMOS, value);
}


/*---------------------------------------------------------------------------*
 * update_icon_widths                                                        *
 *                                                                           *
 * Update the 'at least...' boxes.                                           *
 *---------------------------------------------------------------------------*/

static void update_icon_widths(void)
{
    char string[256];
    int  value;

    error_trap(numberrange_get_value(0, main_window, LargeIconRange, &value), 0);
    sprintf(string, "%d", how_many_characters(value));
    error_trap(displayfield_set_value(0, main_window, LargeNotLessThan, string), 0);
    error_trap(numberrange_get_value(0, main_window, SmallIconRange, &value), 0);
    sprintf(string, "%d", how_many_characters(value));
    error_trap(displayfield_set_value(0, main_window, SmallNotLessThan, string), 0);
}


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Fill in the default choices in the dialogue box.                          *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    IdBlock id;

    error_trap(stringset_set_selected(StringSet_IndexedSelection, main_window, DisplayAsMenu, 0), 0);
    error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, 0), 0);
    error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, 0), 0);
    id.self_component = MenuSortName; /* Fake menu selection */
    sort_selected(0, NULL, &id, NULL);

    error_trap(optionbutton_set_state(0, main_window, ActiveCopyOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 0), 0);
    grey_gadget(main_window, ConfirmAllRadio);
    grey_gadget(main_window, ConfirmDeletesRadio);
    error_trap(optionbutton_set_state(0, main_window, VerboseOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, NewerOption, 1), 0);
    error_trap(optionbutton_set_state(0, main_window, ForceOption, 0), 0);
    error_trap(optionbutton_set_state(0, main_window, FasterOption, 0), 0);
    error_trap(numberrange_set_value(0, main_window, LargeIconRange, 256), 0);
    error_trap(numberrange_set_value(0, main_window, SmallIconRange, 256), 0);
    error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 0), 0);
    grey_gadget(main_window, DClickHoldWhenLabel);
    grey_gadget(main_window, DClickHoldSecsLabel);
    grey_gadget(main_window, DClickHoldDelay);
    error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, 2), 0);
    update_icon_widths();
}


/*---------------------------------------------------------------------------*
 * parse_options_command                                                     *
 *                                                                           *
 * Parse a *Filer_Options command and set options in configure window as     *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Options                              *
 *---------------------------------------------------------------------------*/

static void parse_options_command(char *string)
{
    static const char options_args[] = "ConfirmAll/S,ConfirmDeletes/S,Verbose/S,Force/S,Newer/S,Faster/S";
    int  buffer[32];

    error_trap(_swix(OS_ReadArgs, _INR(0,3), options_args, string, buffer, 32*sizeof(int)), 0);

    if (buffer[0] || buffer[1])
    {
        error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 1), 0);
        ungrey_gadget(main_window, ConfirmAllRadio);
        ungrey_gadget(main_window, ConfirmDeletesRadio);
    }
    else
    {
        error_trap(optionbutton_set_state(0, main_window, ConfirmOption, 0), 0);
        grey_gadget(main_window, ConfirmAllRadio);
        grey_gadget(main_window, ConfirmDeletesRadio);
    }

    if (buffer[0]) error_trap(radiobutton_set_state(0, main_window, ConfirmAllRadio, 1), 0);
    if (buffer[1]) error_trap(radiobutton_set_state(0, main_window, ConfirmDeletesRadio, 1), 0);

    error_trap(optionbutton_set_state(0, main_window, VerboseOption, buffer[2]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, ForceOption,   buffer[3]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, NewerOption,   buffer[4]>0 ? 1:0), 0);
    error_trap(optionbutton_set_state(0, main_window, FasterOption,  buffer[5]>0 ? 1:0), 0);
}


/*---------------------------------------------------------------------------*
 * parse_truncation_command                                                  *
 *                                                                           *
 * Parse a *Filer_Truncation command and set options in configure window as  *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Truncation                           *
 *---------------------------------------------------------------------------*/

static void parse_truncation_command(char *string)
{
    static const char truncation_args[] = "LargeIconDisplay=LID/E,SmallIconDisplay=SID/E,FullInfoDisplay=FID/E";
    char *byte;
    int   buffer[64];
    int   value;

    _swi(OS_ReadArgs, _INR(0,3), truncation_args, string, (char*)buffer, 256);

    /* LargeIconDisplay */
    if (buffer[0])
    {
        byte = (char*)(buffer[0]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        error_trap(numberrange_set_value(0, main_window, LargeIconRange, value), 0);
    }

    /* SmallIconDisplay */
    if (buffer[1])
    {
        byte = (char*)(buffer[1]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        error_trap(numberrange_set_value(0, main_window, SmallIconRange, value), 0);
    }

    /* FullInfoDisplay */
    if (buffer[2])
    {
        byte = (char*)(buffer[2]);
        fullinfo_truncation = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
    }

}


/*---------------------------------------------------------------------------*
 * parse_layout_command                                                      *
 *                                                                           *
 * Parse a *Filer_Layout command and set options in configure window as      *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_Layout                               *
 *---------------------------------------------------------------------------*/

static void parse_layout_command(char *string)
{
    static const char layout_args[] = "LargeIcons=LI/S,SmallIcons=SI/S,FullInfo=FI/S,"
                                      "SortByName=SBN/S,SortByType=SBT/S,SortBySize=SBS/S,SortByDate=SBD/S,"
                                      "ReverseSort=RS/S,NumericalSort=NS/S";
    int  buffer[32];
    int  display_as = 0;
    int  sort_by = 0;
    int  n;
    IdBlock id;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), layout_args, string, buffer, sizeof(buffer)), 0);

    /* Large, Small or Full Info */
    for (n=0; n<=2; n++)
    {
        if (buffer[n]) display_as = n;
    }
    error_trap(stringset_set_selected(StringSet_IndexedSelection, main_window, DisplayAsMenu, (char*)display_as), 0);

    /* Reverse sort order */
    if (!can_reversesort) buffer[7] = 0;
    error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, buffer[7] ? 1 : 0), 0);

    /* Numerical sort order */
    if (!can_numericalsort) buffer[8] = 0;
    error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, buffer[8] ? 1 : 0), 0);

    /* Sort type (assumes menu entries are ids 0-3) */
    for (n=3; n<=6; n++)
    {
        if (buffer[n]) sort_by = n - 3;
    }
    id.self_component = sort_by; /* Fake menu selection */
    sort_selected(0, NULL, &id, NULL);
}


/*---------------------------------------------------------------------------*
 * parse_dclickhold_command                                                  *
 *                                                                           *
 * Parse a *Filer_DClickHold command and set options in configure window as  *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Filer_DClickHold                           *
 *---------------------------------------------------------------------------*/

static void parse_dclickhold_command(char *string)
{
    char  dclickhold_args[] = "/E";
    char *byte;
    int   buffer[32];
    int   value;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), dclickhold_args, string, buffer, 32*sizeof(int)), 0);

    if (buffer[0])
    {
        byte = (char*)(buffer[0]);
        value = byte[1] + (byte[2]<<8) + (byte[3]<<16) + (byte[4]<<24);
        if (value)
        {
            error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, value/10), 0);
            error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 1), 0);
            ungrey_gadget(main_window, DClickHoldWhenLabel);
            ungrey_gadget(main_window, DClickHoldSecsLabel);
            ungrey_gadget(main_window, DClickHoldDelay);
        }
        else
        {
            error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, 2), 0);
            error_trap(optionbutton_set_state(0, main_window, DClickHoldOption, 0), 0);
            grey_gadget(main_window, DClickHoldWhenLabel);
            grey_gadget(main_window, DClickHoldSecsLabel);
            grey_gadget(main_window, DClickHoldDelay);
        }
    }
}


/*---------------------------------------------------------------------------*
 * read_cmos                                                                 *
 *                                                                           *
 * Read the options store in CMOS                                            *
 *---------------------------------------------------------------------------*/

static void read_cmos(void)
{
    int interactive, solid;

    /* Interactive file copying */
    interactive = (read_cmos_value(FileSwitchCMOS) & InteractiveCopyCMOSBit) ? 0:1;
    error_trap(optionbutton_set_state(0, main_window, ActiveCopyOption, interactive), 0);

    /* Solid drags */
    solid = (read_cmos_value(FileSwitchCMOS) & DragASpriteCMOSBit) ? 1:0;
    error_trap(optionbutton_set_state(0, main_window, SolidDragOption, solid), 0);
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the *Filer_Options command from the choices file.                    *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[256];
    int   more = 1;

    /* Read current setup */
    fp = fopen(ChoicesFileRO, "r");
    if (fp)
    {
        while (more)
        {
            more = (int)fgets(string, sizeof(string), fp);
            if (more)
            {
                if (strncmpa(string, "Filer_Options", 13)==0) parse_options_command(string+14);
                if (strncmpa(string, "Filer_Truncation", 16)==0) parse_truncation_command(string+17);
                if (strncmpa(string, "Filer_Layout", 12)==0) parse_layout_command(string+13);
                if (strncmpa(string, "Filer_DClickHold", 16)==0) parse_dclickhold_command(string+17);
            }
        }
        fclose(fp);
    }

    read_cmos();
}


/*---------------------------------------------------------------------------*
 * redraw_whole_screen                                                       *
 *                                                                           *
 * Force a redraw of the whole screen.                                       *
 *---------------------------------------------------------------------------*/

static void redraw_whole_screen(void)
{
    WimpMessage wm;

    wm.hdr.size = 32;
    wm.hdr.your_ref = 0;
    wm.hdr.action_code = Wimp_MFilerOpenDir;
    wm.data.words[0] = -1;
    wm.data.words[1] = 0;
    wm.data.words[2] = 0;
    error_trap(wimp_send_message(Wimp_EUserMessage, &wm, 0, 0, 0), 0);
}


/*-----------------------------------------------------------------------------------------------*/
/*                                          Event handlers                                       */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * sort_selected                                                             *
 *                                                                           *
 * Handler for when menu selection in the sort menu.                         *
 *---------------------------------------------------------------------------*/

static int sort_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int  gadget = id_block->self_component;
    int  i;
    BOOL reversed, numerical, state;
    char token[16];

    switch (gadget)
    {
        case MenuSortName:
        case MenuSortType:    
        case MenuSortSize:    
        case MenuSortDate:
            for (i = 0; i <= 3; i++)
            {
                error_trap(menu_set_tick(0, sort_menu, i, i == gadget), 0);
            }
            break;

        case MenuSortReversed:
            error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &reversed), 0);
            reversed = !reversed;
            error_trap(menu_set_tick(0, sort_menu, MenuSortReversed, reversed), 0);
            break;

        case MenuSortNumerical:
            error_trap(menu_get_tick(0, sort_menu, MenuSortNumerical, &numerical), 0);
            numerical = !numerical;
            error_trap(menu_set_tick(0, sort_menu, MenuSortNumerical, numerical), 0);
            break;
    }

    /* And update the top level display */
    for (i = 0; i <= 3; i++)
    {
        error_trap(menu_get_tick(0, sort_menu, i, &state), 0);
        if (state) break;
    }
    error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &reversed), 0);
    sprintf(token, "%s%d", reversed ? "Tors" : "Sort", i);
    error_trap(displayfield_set_value(0, main_window, SortByDisplay, messages_lookup(token)), 0);

    return 1; 
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case SetButton:
            save_choices();
            redraw_whole_screen();
            if ((block->hdr.flags & 7)==0) program_exit(); /* Return pressed */
            if (block->hdr.flags & 4) program_exit();      /* Left button */
            break;

        case CancelButton:
            if ((block->hdr.flags & 7)==0) program_exit(); /* Escape pressed */
            if (block->hdr.flags & 1)                      /* Right button */
            {
                 read_choices();
                 update_icon_widths();
            }
            if (block->hdr.flags & 4) program_exit();      /* Left button */
            break;

        case DefaultButton:
            set_default_choices();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * option_changed                                                            *
 *                                                                           *
 * Handler for option button changed events.                                 *
 *---------------------------------------------------------------------------*/

static int option_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    OptionButtonStateChangedEvent *event = (OptionButtonStateChangedEvent*) event_block;
    int                            icon = id_block->self_component;
    int                            state = event->new_state;

    switch(icon)
    {
        case ConfirmOption:
            if (state==1)
            {
                ungrey_gadget(main_window, ConfirmAllRadio);
                ungrey_gadget(main_window, ConfirmDeletesRadio);
            }
            else
            {
                grey_gadget(main_window, ConfirmAllRadio);
                grey_gadget(main_window, ConfirmDeletesRadio);
            }
            break;

        case DClickHoldOption:
            if (state==1)
            {
                ungrey_gadget(main_window, DClickHoldWhenLabel);
                ungrey_gadget(main_window, DClickHoldSecsLabel);
                ungrey_gadget(main_window, DClickHoldDelay);
            }
            else
            {
                grey_gadget(main_window, DClickHoldWhenLabel);
                grey_gadget(main_window, DClickHoldSecsLabel);
                grey_gadget(main_window, DClickHoldDelay);
            }
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * numrange_changed                                                          *
 *                                                                           *
 * Handler for bounding the character widths.                                *
 *---------------------------------------------------------------------------*/

static int numrange_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    NumberRangeValueChangedEvent *event = (NumberRangeValueChangedEvent*)event_block;
    int                           icon = id_block->self_component;
    char                          string[16];

    switch(icon)
    {
        case LargeIconRange:
            sprintf(string, "%d", how_many_characters(event->new_value));
            error_trap(displayfield_set_value(0, main_window, LargeNotLessThan, string), 0);
            break;

        case SmallIconRange:
            sprintf(string, "%d", how_many_characters(event->new_value));
            error_trap(displayfield_set_value(0, main_window, SmallNotLessThan, string), 0);
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/

static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_Default, NULL, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();

    return 1;
}


/*-----------------------------------------------------------------------------------------------*/
/*                               Program startup & polling loop                                  */
/*-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    int  screenx;
    int  screeny;
    ObjectTemplateHeader *objtemplate;
    WindowTemplate       *wintemplate;
    WimpWindow           *windef;

    /* Read the window object in by hand */
    error_trap(toolbox_template_lookup(0, "Filer", (void **)&objtemplate), 1);
    if (objtemplate->object_class != Window_ObjectClass)
    {
        error_trap(common_error(messages_lookup("BadClass")), 1);
    }
    wintemplate = objtemplate->body;
    windef = &wintemplate->window;
    if (common_read_screensize(&screenx, &screeny) == NULL)
    {
        /* Calculate the window height compared with the screen and
         * turn the vertical scrollbar on if it doesn't fit
         */
        if ((windef->visible_area.ymax - windef->visible_area.ymin) >= screeny)
        {
            windef->flags |= WimpWindow_VScroll;
        }
        else
        {
            windef->flags &= ~WimpWindow_VScroll;
        }
    }
    error_trap(toolbox_create_object(Toolbox_CreateObject_InCore, objtemplate, &main_window), 1);
    error_trap(toolbox_create_object(0, "SortMenu", &sort_menu), 1);
    error_trap(popup_set_menu(0, main_window, SortByPopUp, sort_menu), 1);

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(-1, Toolbox_Error, toolbox_error, NULL) ,0);
    error_trap(event_register_wimp_handler(main_window, Wimp_ECloseWindow, close_window, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, OptionButton_StateChanged, option_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(main_window, NumberRange_ValueChanged, numrange_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(sort_menu, Menu_Selection, sort_selected, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);

    /* The Filer_Layout command faults unknown switches, so don't try setting them when
     * running on an older Filer. Fade the menu entries also.
     */
    can_reversesort   = (_swix(OS_CLI, _IN(0), "RMEnsure Filer 2.22") == NULL);
    error_trap(menu_set_fade(0, sort_menu, MenuSortReversed, can_reversesort ? 0 : 1), 0);
    can_numericalsort = (_swix(OS_CLI, _IN(0), "RMEnsure Filer 2.34") == NULL);
    error_trap(menu_set_fade(0, sort_menu, MenuSortNumerical, can_numericalsort ? 0 : 1), 0);

    /* Read in the choices, populate and show dialogue */
    set_default_choices();
    read_choices();
    update_icon_widths();
    if ((at_x==-1) && (at_y==-1))
    {
        /* No position supplied in the command line, just centre it */
        error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_Centre, NULL, 0, 0), 0);
    }
    else
    {
        int  buffer[2];

        buffer[0] = at_x;
        buffer[1] = at_y;
        error_trap(toolbox_show_object(0, main_window, Toolbox_ShowObject_TopLeft, buffer, 0, 0), 0);
    }
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * In: Nothing.                                                              *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                NumberRange_ValueChanged,
                                Menu_Selection,
                                0};
    int        task_handle;

    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<FilrSetup$Dir>", &messages_desc, &idb,
                                  0, &task_handle, 0) ,1);


    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if ((argc >= 4) && (strcmp(argv[1], "-openat")==0))
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;

    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }

    return 0;
}
@


1.9
log
@Add numerical sort option support to configure plugin
Also fix the problem that !FilrSetup is installed into RO500Hook but was assuming -ReverseSort was always available, this would be faulted on machines with a Filer older than 2.22.
Tested on RISC OS 4.02 and 5.20.

Version 0.24. Tagged as 'FilrSetup-0_24'
@
text
@a41 2
#define Wimp_MFilerOpenDir     0x400

@


1.8
log
@Correction to system variable name
Allocated application name and system variable name sync'd

Version 0.23. Tagged as 'FilrSetup-0_23'
@
text
@d49 1
d106 6
a111 3
    /* Add sort order to Filer_Layout command */
    error_trap(menu_get_tick(0, sort_menu, MenuSortReversed, &selected), 0);
    if (selected) strcat(layout_command, " -ReverseSort");
d113 7
d207 1
d326 1
a326 1
                                      "ReverseSort=RS/S"; 
d343 1
d346 4
d509 1
a509 1
    BOOL reversed, state;
d529 6
d778 8
@


1.7
log
@Move solid file drags option into Filer Setup
Part of simplification of the window setup plugin.
To make space on what is otherwise an enormous configure window the 'Reverse sort' check box is now in the 'sort' menu, same as it is in the filer.

Version 0.22. Tagged as 'FilrSetup-0_22'
@
text
@d799 1
a799 1
                                  "<FilerConfig$Dir>", &messages_desc, &idb,
@


1.6
log
@Minor FilrSetup improvements
* Makefile recreated from fragments
* Window size is now compared with screensize on startup and the V scroll bar turned on/off as needed
* Magic numbers changed for header defines
* Read from Choices$Path and write through Choices$Write
* Version number now inserted at build time rather than being out of date

Version 0.20. Tagged as 'FilrSetup-0_20'
@
text
@d37 1
d47 1
a47 1
static int        main_window;
d50 1
d80 1
a80 1
    int  byte;
d92 5
a96 1
    error_trap(stringset_get_selected(1, main_window, SortByMenu, &selected), 0);
d106 1
a106 1
    error_trap(optionbutton_get_state(0, main_window, ReverseSortOption, &selected), 0);
d154 2
a155 1
    /* Write the interactive copy bit */
d157 4
a160 4
    byte = read_cmos_value(FileSwitchCMOS);
    byte = byte & (255 - InteractiveCopyCMOSBit);
    if (!selected) byte = byte | InteractiveCopyCMOSBit;
    write_cmos_value(FileSwitchCMOS, byte);
d192 6
a197 3
    error_trap(stringset_set_selected(1, main_window, DisplayAsMenu, 0), 0);
    error_trap(stringset_set_selected(1, main_window, SortByMenu, 0), 0);
    error_trap(optionbutton_set_state(0, main_window, ReverseSortOption, 0), 0);
a317 1
    int  reverse_sort = 0;
d319 1
d324 5
a328 2
    for (n=0; n<=2; n++) if (buffer[n]) display_as = n;
    error_trap(stringset_set_selected(1, main_window, DisplayAsMenu, (char*)display_as), 0);
d330 2
a331 3
    /* Sort type */
    for (n=3; n<=6; n++) if (buffer[n]) sort_by = n - 3;
    error_trap(stringset_set_selected(1, main_window, SortByMenu, (char*)sort_by), 0);
d333 7
a339 4
    /* Reverse sort order */
    if (buffer[7]) reverse_sort = 1;
    else reverse_sort = 0;
    error_trap(optionbutton_set_state(0, main_window, ReverseSortOption, reverse_sort), 0);
d393 1
a393 1
    int interactive;
d398 4
d423 1
a423 1
            more = (int)fgets(string, 256, fp);
d483 46
d632 2
d743 2
d747 1
a747 1
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);
d752 1
d794 1
@


1.5
log
@Fix null pointer dereference on startup
Detail:
  c/main - Command line parsing now checks if enough arguments exist before attempting to look for an -openat option
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.19. Tagged as 'FilrSetup-0_19'
@
text
@d32 1
a40 3
#define CMOSFileSwitchOptions  28
#define CMOSInteractiveCopyBit 4
#define MinWindowHeight        1100
d150 4
a153 4
    byte = read_cmos_value(CMOSFileSwitchOptions);
    byte = byte & (255 - CMOSInteractiveCopyBit);
    if (!selected) byte = byte | CMOSInteractiveCopyBit;
    write_cmos_value(CMOSFileSwitchOptions, byte);
d219 1
a219 1
    char options_args[] = "ConfirmAll/S,ConfirmDeletes/S,Verbose/S,Force/S,Newer/S,Faster/S";
d224 1
a224 1
    if ((buffer[0]) || (buffer[1]))
d258 1
a258 1
    char  truncation_args[] = "LargeIconDisplay=LID/E,SmallIconDisplay=SID/E,FullInfoDisplay=FID/E";
d302 3
a304 1
    char layout_args[256];
d311 1
a311 5
    strcpy(layout_args,"LargeIcons=LI/S,SmallIcons=SI/S,FullInfo=FI/S,");
    strcat(layout_args,"SortByName=SBN/S,SortByType=SBT/S,SortBySize=SBS/S,SortByDate=SBD/S,");
    strcat(layout_args,"ReverseSort=RS/S");

    error_trap(_swix(OS_ReadArgs, _INR(0,3), layout_args, string, buffer, 32*sizeof(int)), 0);
d381 1
a381 1
    interactive = (read_cmos_value(CMOSFileSwitchOptions) & CMOSInteractiveCopyBit) ? 0:1;
d399 1
a399 1
    fp = fopen(ChoicesFile, "r");
d615 1
a615 1
    error_trap(toolbox_show_object(0, main_window, 0, 0, 0, 0), 0);
a646 1
    BBox bbox;
d649 27
a675 10
    int  buffer[2];

    /* Create window */
    error_trap(common_read_screensize(&screenx, &screeny), 0);
    if (screeny<MinWindowHeight) error_trap(toolbox_create_object(0, "FilerS", &main_window), 1);
    else error_trap(toolbox_create_object(0, "Filer", &main_window), 1);

    set_default_choices();
    read_choices();
    update_icon_widths();
d685 4
a688 1
    /* Work out positioning (unless it was supplied in the command line) */
d691 2
a692 3
        error_trap(window_get_extent(0, main_window, &bbox), 0);
        at_y = screeny - ((screeny+bbox.ymin)/2);
        at_x = (screenx - bbox.xmax)/2;
d694 3
d698 4
a701 4
    /* Show the window */
    buffer[0] = at_x;
    buffer[1] = at_y;
    error_trap(toolbox_show_object(0, main_window, 2, buffer, 0, 0), 0);
d721 1
a721 1
        	                ActionButton_Selected,
@


1.4
log
@Fix ticket 235 for incorrect interactive help.
Also changed the double click hold option to be easier to understand for
normal humans by adding a check box to disable the option rather than having
to set the time to zero seconds.

Version 0.16. Tagged as 'FilrSetup-0_16'
@
text
@d740 1
a740 1
    if (strcmp(argv[1], "-openat")==0)
@


1.3
log
@  Add option to set reverse sort order
Details:
  The ability to sort objects in reverse order has been added to the Filer and
  this change reflects that in the Filer configure plug-in. A new option allows
  reverse sort to be set as default for newly opened directories.
  The radio buttons to set display and sort options have been removed in favour
  of string sets to reduce visual clutter. Window's been rearranged somewhat to
  get a tidier layout.
Admin:
  Tested on Iyonix RO5.14
  Submitted by Fred Graute, mid-December 2009

Version 0.15. Tagged as 'FilrSetup-0_15'
@
text
@d136 10
a145 2
    error_trap(numberrange_get_value(0, main_window, DClickHoldDelay, &dclickholddelay), 0);
    sprintf(dclickhold_command, "Filer_DClickHold %d", 10*dclickholddelay);
a186 3
//    error_trap(radiobutton_set_state(0, main_window, LargeIconRadio, 1), 0);
//    error_trap(radiobutton_set_state(0, main_window, SortByNameRadio, 1), 0);

d201 4
a257 1

d354 16
a369 1
        error_trap(numberrange_set_value(0, main_window, DClickHoldDelay, value/10), 0);
d548 15
@


1.2
log
@  Add option to set doubleclick-and-hold delay.
Details:
  The Filer has been updated such that the doubleclick-and-hold delay can now be
  specified. This change extends the Filer configure plug-in so that it can be
  used to set the default doubleclick-and-hold delay. Setting the delay to zero
  turns doubleclick-and-hold off.
Admin:
  Tested on Iyonix RO5.14
  Submitted by Fred Graute, mid-December 2009

Version 0.14. Tagged as 'FilrSetup-0_14'
@
text
@d72 1
a74 1
    char layout_command[256] = "Filer_Layout";
d83 2
a84 2
    error_trap(radiobutton_get_state(0, main_window, LargeIconRadio, 0, &selected), 0);
    switch(selected)
d86 3
a88 3
        case LargeIconRadio: strcat(layout_command, " -LargeIcons"); break;
        case SmallIconRadio: strcat(layout_command, " -SmallIcons"); break;
        case FullInfoRadio:  strcat(layout_command, " -FullInfo");   break;
d92 1
a92 1
    error_trap(radiobutton_get_state(0, main_window, SortByNameRadio, 0, &selected), 0);
d95 4
a98 4
        case SortByNameRadio: strcat(layout_command, " -SortByName"); break;
        case SortByTypeRadio: strcat(layout_command, " -SortByType"); break;
        case SortBySizeRadio: strcat(layout_command, " -SortBySize"); break;
        case SortByDateRadio: strcat(layout_command, " -SortByDate"); break;
d101 4
d179 7
a185 2
    error_trap(radiobutton_set_state(0, main_window, LargeIconRadio, 1), 0);
    error_trap(radiobutton_set_state(0, main_window, SortByNameRadio, 1), 0);
d298 4
d304 2
a305 1
    strcat(layout_args,"SortByName=SBN/S,SortByType=SBT/S,SortBySize=SBS/S,SortByDate=SBD/S");
d310 2
a311 3
    if (buffer[0]) error_trap(radiobutton_set_state(0, main_window, LargeIconRadio, 1), 0);
    if (buffer[1]) error_trap(radiobutton_set_state(0, main_window, SmallIconRadio, 1), 0);
    if (buffer[2]) error_trap(radiobutton_set_state(0, main_window, FullInfoRadio, 1), 0);
d314 7
a320 4
    if (buffer[3]) error_trap(radiobutton_set_state(0, main_window, SortByNameRadio, 1), 0);
    if (buffer[4]) error_trap(radiobutton_set_state(0, main_window, SortByTypeRadio, 1), 0);
    if (buffer[5]) error_trap(radiobutton_set_state(0, main_window, SortBySizeRadio, 1), 0);
    if (buffer[6]) error_trap(radiobutton_set_state(0, main_window, SortByDateRadio, 1), 0);
@


1.1
log
@Initial revision
@
text
@d21 3
d41 3
a43 1
#define CMOSInteractiveCopyBit 1<<2
d75 1
d79 3
a81 1
    
d89 2
a90 2
    }                                                                
    
d100 1
a100 1
    
d124 1
a124 1
    
d130 5
a134 1
 
d136 8
a143 1
    error_trap(write_filer_choices(options_command, truncation_command, layout_command), 0);
d157 1
a157 1
    
d160 1
a160 1
    error_trap(displayfield_set_value(0, main_window, LargeNotLessThan, string), 0);    
d187 1
d207 1
a207 1
    
d220 1
a220 1
     
d289 1
a289 1
    
d299 1
a299 1
    
d309 27
d344 1
a344 1
 
d346 1
a346 1
    interactive = (read_cmos_value(CMOSFileSwitchOptions) && CMOSInteractiveCopyBit) ? 1:0;
d348 1
a348 1
}    
d375 1
d380 22
a401 2
    
    read_cmos();    
d459 1
d468 1
a468 1
                 read_choices();      
d473 1
a473 1
            
d491 1
a491 1
    OptionButtonStateChangedEvent *event = (OptionButtonStateChangedEvent*) event_block;    
d531 1
a531 1
            
d547 1
a547 1
 
d551 1
a551 1
    
d580 1
a580 1
    
d603 3
a605 1
    error_trap(toolbox_create_object(0, "Filer", &main_window), 1);
a621 1
        error_trap(common_read_screensize(&screenx, &screeny), 0);
d655 1
a655 1
                                
d662 1
a662 1
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);    
d670 1
a670 1
                                  
d694 1
a694 1
    
d703 1
a703 1
    
d705 1
a705 1
}         
@


1.1.1.1
log
@Initial import of FilerSetup plugin for Configure.
@
text
@@


1.1.1.2
log
@Interactive file copy option now works properly.
@
text
@d38 1
a38 1
#define CMOSInteractiveCopyBit 4
a72 1
    int  byte;
a124 7
    
    /* Write the interactive copy bit */
    error_trap(optionbutton_get_state(0, main_window, ActiveCopyOption, &selected), 0);
    byte = read_cmos_value(CMOSFileSwitchOptions);
    byte = byte & (255 - CMOSInteractiveCopyBit);
    if (!selected) byte = byte | CMOSInteractiveCopyBit;
    write_cmos_value(CMOSFileSwitchOptions, byte);
d299 1
a299 1
    interactive = (read_cmos_value(CMOSFileSwitchOptions) & CMOSInteractiveCopyBit) ? 0:1;
@


1.1.1.3
log
@Added a scroll bar version of the window for low res screen modes.
Desktop redrawn when Set clicked on, to force update of truncation.
@
text
@a20 3
/*          13-May-98: RML: If not high enough vertical resolution, use a    */
/*                          window with vertical scrollbar.                  */
/*          14-May-98: RML: Now redraws whole screen when Set clicked.       */
a38 1
#define MinWindowHeight        1100
a344 16
/*---------------------------------------------------------------------------*
 * redraw_whole_screen                                                       *
 *                                                                           *
 * Force a redraw of the whole screen.                                       *
 *---------------------------------------------------------------------------*/

static void redraw_whole_screen(void)
{
    int screenx;
    int screeny;
    
    error_trap(common_read_screensize(&screenx, &screeny), 0);
    error_trap(wimp_force_redraw(-1, 0, 0, screenx, screeny), 0);
}


a398 1
            redraw_whole_screen();
d542 1
a542 3
    error_trap(common_read_screensize(&screenx, &screeny), 0);
    if (screeny<MinWindowHeight) error_trap(toolbox_create_object(0, "FilerS", &main_window), 1);
    else error_trap(toolbox_create_object(0, "Filer", &main_window), 1);
d559 1
@


1.1.1.4
log
@Config file renamed to Tasks.FilrSetup
@
text
@a42 1
#define Wimp_MFilerOpenDir     0x400
d357 5
a361 9
    WimpMessage wm;

    wm.hdr.size = 32;
    wm.hdr.your_ref = 0;
    wm.hdr.action_code = Wimp_MFilerOpenDir;
    wm.data.words[0] = -1;
    wm.data.words[1] = 0;
    wm.data.words[2] = 0;
    error_trap(wimp_send_message(Wimp_EUserMessage, &wm, 0, 0, 0), 0);
@

head	1.4;
access;
symbols
	KbdSetup-0_18:1.4
	KbdSetup-0_17:1.4
	KbdSetup-0_16:1.3
	KbdSetup-0_15:1.2
	KbdSetup-0_14:1.2
	KbdSetup-0_13:1.2
	KbdSetup-0_12:1.1.1.6
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.1.3
	Ursula_RiscPC:1.1.1.3.0.2
	bavison_KbdSetup-0_11:1.1.1.6
	bavison_KbdSetup-0_10:1.1.1.5
	rthornb_UrsulaBuild-19Aug1998:1.1.1.3
	UrsulaBuild_FinalSoftload:1.1.1.3
	bavison_KbdSetup-0_09:1.1.1.3
	rthornb_UrsulaBuild-29Jul1998:1.1.1.2
	rthornb_UrsulaBuild-22Jul1998:1.1.1.2
	rthornb_UrsulaBuild-15Jul1998:1.1.1.2
	rthornb_UrsulaBuild-07Jul1998:1.1.1.2
	bavison_KbdSetup-0_08:1.1.1.2
	bavison_KbdSetup-0_07:1.1.1.2
	rthornb_UrsulaBuild-17Jun1998:1.1.1.1
	bavison_KbdSetup-0_06:1.1.1.1
	rthornb_UrsulaBuild-03Jun1998:1.1.1.1
	rthornb_UrsulaBuild-27May1998:1.1.1.1
	rthornb_UrsulaBuild-21May1998:1.1.1.1
	rthornb_UrsulaBuild_01May1998:1.1.1.1
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2012.09.30.08.49.36;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	PPswe7vGR0Jv4xmw;

1.3
date	2012.07.28.07.22.05;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	2Hfk7t92Ett3Eiew;

1.2
date	2002.12.14.13.42.31;	author rsprowson;	state Exp;
branches;
next	1.1;

1.1
date	98.04.07.18.24.47;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.07.18.24.47;	author bavison;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.06.30.13.53.15;	author bavison;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.08.11.15.47.52;	author bavison;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.08.28.10.49.53;	author bavison;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.08.28.13.55.02;	author bavison;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.09.11.18.27.18;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Add option for num lock setting
When the kernel does not support *CONFIGURE [No]Num the default is set to 'on' and the gadgets shaded to prevent the user trying to change them when the setting will not be retained.
* Radio icons to select on/offness
* Makefile recreated from fragments
* Service_/OS_ magic numbers changed for defines

Version 0.17. Tagged as 'KbdSetup-0_17'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******	Keyboards.c *******************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Keyboard configuration plug-in
This file:	Keyboard handler routines

History:
Date		Who	Change
----------------------------------------------------------------------------
09/12/1997	BJGA	Added these headers
29/06/1998	BJGA	Removed code to support dedicated PC-type-delete handlers
30/06/1998	BJGA	Changed command from *Keyboard to *Country
			Bugfix: no * command was issued when changing to the default keyboard
11/08/1998	BJGA	Keyboard handler list now only includes countries
			for which a handler is currently loaded
27/08/1998	BJGA	Now compares whole keyboard handler table, rather than just its crc.
			keyboards_get() and keyboard_set() rewritten to deal with PreDesktop
			  instead of dedicated choice file, and also the Win95 key settings
11/09/1998	BJGA	Keyboard handler menu now displays territory names instead of country
			  names wherever possible, because they are internationalised. This
			  involved adding keyboards_buildnametable, rewriting getfullstring,
			  altering the building of the *Country command in keyboards_set, and
			  calling buildnametable just prior to menu building.
			Also changed names of Win95 key variables to Key$[C][S]<Acorn|Menu>.

\**************************************************************************/

/* Clib */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/Services.h"
#include "Global/FileTypes.h"
#include "Global/OsBytes.h"
#include "Interface/HighFSI.h"
/* Toolbox */
#include "wimplib.h"
/* Common */
#include "cmos.h"
#include "message.h"
#include "misc.h"
#include "str.h"
/* Local headers */
#include "Main.h"
#include "Keyboards.h"  /* includes prototypes for this file */
#include "VersionNum"

/* Statics */

cmos territory_cmos = { 0x18, 0, 8 } ; /* Held as Territory EOR 1 */
static char nametable [127] [30];

static BOOL getfullstring (int handler, char **buffer, int *space);

/******	keyboards_buildnametable() ****************************************\

Purpose:	Builds an internationalised territory number -> name table
		This table will also be used to convert name -> number,
		because I don't trust Territory_NameToNumber (the names it
		takes don't match those returned by Territory_NumberToName
		on all OSes). On the plus side, we can take advantage of
		this to account for the "(Default)" postfix at the same time.
		If a territory name is not available, we try to fall back
		to a (non-internationalised) country name instead.

\**************************************************************************/

void keyboards_buildnametable (int configured_territory)
{
  int territory;
  for (territory = 0; territory < 127; territory++)
  {
    _kernel_oserror *e = _swix (Territory_NumberToName, _INR(0,2), territory, nametable [territory], sizeof (nametable[0]));
    if (e != NULL)
    {
      int claimed;
      int length;
      e = _swix (OS_ServiceCall, _INR(1,5)|_OUT(1)|_OUT(5), Service_International, 2,
          territory, nametable [territory], sizeof (nametable[0]), &claimed, &length);
      if (e != NULL || claimed != 0)
      {
        sprintf (nametable [territory], "%d", territory); /* double fallback - should never be seen by user */
      }
      else
      {
        nametable [territory] [length] = '\0';
      }
    }
    if (territory == configured_territory)
    {
      char *ptr = nametable [territory];
      while (*ptr >= ' ') ptr++; /* point at terminator */
      str_cpy (ptr, message_lookup_direct(messages,"Default"));
    }
  }
}

/******	getfullstring() ***************************************************\

Purpose:	Adds verbose handler name (as used on menu) to specified buffer
In:		Handler number, current territory number (for comparison),
		  buffer pointer / remaining passed by reference
Out:		If it fits, name is added to buffer;
		  buffer pointer / remaining adjusted to compensate

\**************************************************************************/

static BOOL getfullstring (int handler, char **buffer, int *space)
{
  BOOL fits;
  int len = str_len (nametable [handler]);
  if (*space > len + 1)
  {
    str_cpy (*buffer, nametable [handler]);
    *buffer += len + 1;
    *space -= len + 1;
    fits = TRUE;
  }
  else
  {
    fits = FALSE;
  }
  return fits;
}

/******	keyboards_getavailable() ******************************************\

Purpose:	Builds a comma-separated, sorted list of available keyboard handlers
In:		Buffer to place result in
Out:		CRC of result

\**************************************************************************/

int keyboards_getavailable (char *buffer, int bufsize)
{
  int handlers = 0;
  int h;
  int country;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  int original_keyboard;
  void *UK_addr;
  int UK_table [8];
  char *handler_ptr [100];
  char *ptr;
  char *tmpbuf;
  ptr = tmpbuf = (char *) malloc (bufsize);

  /* Rescan table in case a territory or international module has been replaced in the meantime */
  keyboards_buildnametable (territory);

  /* Determine which handlers are available: step through all possible keyboards, and */
  /* assume that any that are not implemented will default to the UK handler. */
  /* InternationalKeyboard uses the same address to hold each installed handler, so we must */
  /* also compare the offsets therein. Only the first 32 bytes are required by the kernel. */
  original_keyboard = _swi (OS_Byte, _INR(0,1)|_RETURN(1), OsByte_Alphabet, 255);

  _swi (OS_Byte, _INR(0,1), OsByte_Alphabet, 0x81); /* set UK keyboard */
  UK_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
  memcpy (UK_table, UK_addr, sizeof (int) * 8);

  for (country = 0; country < 127; country++)
  {
    int handler;
    void *handler_addr;
    _swi (OS_Byte, _INR(0,1), OsByte_Alphabet, 0x81); /* set keyboard to UK */
    _swi (OS_Byte, _INR(0,1), OsByte_Alphabet, country | 0x80); /* try to set keyboard */
    handler = _swi (OS_Byte, _INR(0,1)|_RETURN(1), OsByte_Alphabet, 255); /* read it back again (may be different!) */
    handler_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
    if (handler != 1)
    {
      if ((handler_addr != UK_addr) ||
          (handler_addr == UK_addr && (memcmp (handler_addr, UK_table, sizeof (int) * 8) != 0)))
      {
        handler_ptr [handlers] = ptr;
        if (getfullstring (country, &ptr, &bufsize))
        {
          handlers++;
        }
      }
    }
  }

  /* Add on UK handler (assumed always present) and restore original keyboard */
  handler_ptr [handlers] = ptr;
  if (getfullstring (1, &ptr, &bufsize))
  {
    handlers++;
  }
  _swi (OS_Byte, _INR(0,1), OsByte_Alphabet, original_keyboard | 0x80);

  _swi (OS_HeapSort, _INR(0,2), handlers, (int) handler_ptr, 4);

  ptr = buffer;
  for (h = 0; h < handlers; h++) {
    strcpy (ptr, handler_ptr [h]);
    ptr += strlen (handler_ptr [h]);
    *ptr = (h == handlers-1) ? 0 : ',';
    ptr += 1;
  }
  free (tmpbuf);
  return _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, (int) buffer, (int) buffer + strlen (buffer), 1);
}

/******	keyboards_get() ***************************************************\

Purpose:	Reads keyboard handler and key tasks details from PreDesktop
		(or default keyboard handler for territory and hardcoded default tasks)
In:		Buffer to place keyboard result in, and get function to use
Out:		Buffer pointer, as passed in;
		  buffer holds (verbose) handler name

\**************************************************************************/

char *keyboards_get (char *buffer, int bufsize, int(get)(cmos item, void *messages))
{
  char *ptr = buffer;
  int original_bufsize = bufsize;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;  /* not get() */

  /* First, initialise settings as though there were no status file */
  if (!getfullstring (territory, &ptr, &bufsize))
  {
    str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
  }
  Tasks_Red [0][0]   = Tasks_Red [1][0]   = '\0';
  Tasks_Green [0][0] = Tasks_Green [1][0] = '\0';
  Tasks_Blue [0][0]  = Tasks_Blue [1][0]  = '\0';

  /* Now differentiate between current and default configuration */
  if (get == cmos_default)
  {
    /* Keyboard handler already determined, we have hardcoded knowledge of Win95 defaults as follows: */
    str_cpy (Tasks_Red [0], "Filer_OpenDir Resources:$.Apps");
    str_cpy (Tasks_Green [0], "<Boot$Dir>");
    str_cpy (Tasks_Blue [0],  "Help_On");
    str_cpy (Tasks_Blue [1],  "Help_Off");
  }
  else
  {
    BOOL error = FALSE;
    FILE *handle = NULL;
    char line [1000];

    error = misc_fileisunreadable ((char *)status_file);

    if (!error)
    {
      handle = fopen (status_file, "r");
      if (handle == NULL) error = TRUE;
    }

    if (!error)
    {
      /* Find the start of our entry */
      do
      {
        fgets (line, sizeof (line), handle);
        str_cpy (line, line); /* null-terminate */
      }
      while (strncmp (line, "|Start RISCOS KbdSetup ", 23) != 0 && !feof (handle));

      if (!feof (handle)) /* but if end of file *was* reached, defaults continue to apply */
      {
        int country;
        int claimed;

        /* Read lines until the end of our entry */
        do
        {
          fgets (line, sizeof (line), handle);
          str_cpy (line, line); /* null-terminate */

          if (strncmp (line, "Country ", 8) == 0)
          {
            error = (BOOL) _swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, line + 8, &claimed, &country);
            if (!error)
            {
              if (claimed != 0)
              {
                error = TRUE;
              }
              else
              {
                ptr = buffer;
                bufsize = original_bufsize;
                error = !getfullstring (country, &ptr, &bufsize);
              }
            }
          }
          else if (strncmp (line, "Set Key$Red ", 12) == 0)    str_cpy (Tasks_Red [0], line + 12);
          else if (strncmp (line, "Set Key$CRed ", 13) == 0)   str_cpy (Tasks_Red [1], line + 13);
          else if (strncmp (line, "Set Key$Green ", 14) == 0)  str_cpy (Tasks_Green [0], line + 14);
          else if (strncmp (line, "Set Key$CGreen ", 15) == 0) str_cpy (Tasks_Green [1], line + 15);
          else if (strncmp (line, "Set Key$Blue ", 13) == 0)   str_cpy (Tasks_Blue [0], line + 13);
          else if (strncmp (line, "Set Key$CBlue ", 14) == 0)  str_cpy (Tasks_Blue [1], line + 14);
        }
        while (strcmp (line, "|End") !=0 && !feof (handle));
      }

      if (error)
      {
        /* Mark keyboard handler as "unrecognised" */
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
      }
    }

    fclose (handle);
  }
  return buffer;
}

/******	keyboards_set() ***************************************************\

Purpose:	Sets the current and configured country and Win95 key tasks
In:		Pointer to (verbose) handler name

\**************************************************************************/

void keyboards_set (char *value)
{
  const char *file = "Pipe:$.KbdSetup";
  const char *predesktop = "<Choices$Write>.Boot.PreDesktop";
  FILE *f;
  char command [1024];
  WimpMessage block;
  int i;

  f = fopen (file, "w");
  if (f == NULL)
  {
    /* Can't open the temp file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swi (MessageTrans_ErrorLookup, _INR(0,7), &block, &messages, 0, 0, file, 0, 0, 0);
  }

  /* Write file */
  fprintf (f, "|Variable\n");
  fprintf (f, "|Start RISCOS KbdSetup "Module_MajorVersion" Options\n");

  message_lookup_buffer(command /* used as a temp buffer */, messages, "Mystery");
  str_cpy (command, command); /* null terminate */
  if (strcmp (command, value) != 0) /* don't do any keyboard handler stuff if undefined */
  {
    int handler;
    int length;
    char handler_name [30] = "";

    for (handler = 0; handler < 127; handler++)
    {
      if (0 == strcmp (value, nametable [handler])) break;
    }
    _swi (OS_ServiceCall, _INR(1,5)|_OUT(5), Service_International, 2, handler, handler_name, sizeof (handler_name), &length);
    /* must be claimed by someone, otherwise there wouldn't have been a keyboard handler there! */
    handler_name [length] = '\0';

    sprintf (command, "Country %s", handler_name);
    fprintf (f, "%s\n", command); /* add to file */
    _swi (OS_CLI, _IN(0), command); /* set now in either case */
  }

  for (i = 0; i < 2; i++)
  {
    /* Do red key */
    if (Tasks_Red [i][0] == '\0')
      sprintf (command, "Unset Key$%sRed", i&1 ? "C" : "");
    else
    {
      sprintf (command, "Set Key$%sRed %s", i&1 ? "C" : "", Tasks_Red [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);
  }

  for (i = 0; i < 2; i++)
  {
    /* Do green key */
    if (Tasks_Green [i][0] == '\0')
      sprintf (command, "Unset Key$%sGreen", i&1 ? "C" : "");
    else
    {
      sprintf (command, "Set Key$%sGreen %s", i&1 ? "C" : "", Tasks_Green [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);
  }

  for (i = 0; i < 2; i++)
  {
    /* Do blue key */
    if (Tasks_Blue [i][0] == '\0')
      sprintf (command, "Unset Key$%sBlue", i&1 ? "C" : "");
    else
    {
      sprintf (command, "Set Key$%sBlue %s", i&1 ? "C" : "", Tasks_Blue [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);

  }

  fprintf (f, "|End\n");

  fclose (f);
  _swi (OS_File, _INR(0,2), OSFile_SetType, file, FileType_Obey);

  /* Do the merge! */
  sprintf (command, "Install_Merge %s %s %s", predesktop, file, predesktop);
  _swi (OS_CLI, _IN(0), command);

  /* Broadcast the fact that the file has been updated */
  block.hdr.your_ref = 0;
  block.hdr.action_code = Wimp_MChoicesChanged;
  str_cpy (block.data.bytes, "Boot.PreDesktop");
  block.hdr.size = sizeof (block.hdr) + (~3 & (str_len (block.data.bytes) + 1 + 3));
  throw (wimp_send_message (17, &block, 0, 0, NULL));
}
@


1.3
log
@|Start and |End section now demarked with RISCOS rather than Acorn

Version 0.16. Tagged as 'KbdSetup-0_16'
@
text
@d47 4
d61 1
a64 2
#define Service_International 0x43

d170 1
a170 1
  original_keyboard = _swi (OS_Byte, _INR(0,1)|_RETURN(1), 71, 255);
d172 1
a172 1
  _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set UK keyboard */
d180 3
a182 3
    _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set keyboard to UK */
    _swi (OS_Byte, _INR(0,1), 71, country | 0x80); /* try to set keyboard */
    handler = _swi (OS_Byte, _INR(0,1)|_RETURN(1),71, 255); /* read it back again (may be different!) */
d204 1
a204 1
  _swi (OS_Byte, _INR(0,1), 71, original_keyboard | 0x80);
d259 1
a259 1
    error = misc_fileisunreadable (status_file);
a337 1
  char *version;
d348 1
a348 1
    _swi (MessageTrans_ErrorLookup, _INR(0,7), &block, messages, 0, 0, file, 0, 0, 0);
a350 3
  /* Get version number string */
  version = message_lookup_direct(messages, "VersionNumber");

d353 1
a353 1
  fprintf (f, "|Start RISCOS KbdSetup %s Options\n", version);
d419 1
a419 1
  _swi (OS_File, _INR(0,2), 18 /* set type */, file, 0xFEB /* obey file */);
@


1.2
log
@Resource file change,now refers to "Macro" keys not "Acorn" keys.
Writeables linked into a circle
Version number incremented in Messages file

Version 0.13. Tagged as 'KbdSetup-0_13'
@
text
@d272 1
a272 1
      while (strncmp (line, "|Start Acorn KbdSetup ", 22) != 0 && !feof (handle));
d354 1
a354 1
  fprintf (f, "|Start Acorn KbdSetup %s Options\n", version);
@


1.1
log
@Initial revision
@
text
@d25 14
d62 2
a63 1
static const cmos territory_cmos = { 0x18, 0, 8 } ; /* Held as Territory EOR 1 */
d65 44
a108 1
static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space);
d120 1
a120 1
static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space)
d122 12
a133 25
  int written;
  char buf [100] = "";
  char pcext [10], pc [40], sdefault [20];
  if (!_swi (OS_ServiceCall, _INR(1,5)|_RETURN(1)|_OUT(5), Service_International, 2, handler, buf, sizeof(buf), &written)) {
    /* handler number claimed */
    *(buf + written) = (char) 0; /* null-terminate */
    message_lookup_buffer(pcext,messages,"PCExt");
    if (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, (int) pcext, (int) (buf + written - strlen (pcext)), 1) == 0) {
      /* is a PC delete handler */
      message_lookup_buffer(pc,messages,"PCDel");
      strcpy (buf + written - strlen (pcext), pc);
      written += strlen (pc) - strlen (pcext);
    }
    if (handler == current_territory) {
      /* is the default handler for this territory */
      message_lookup_buffer(sdefault,messages,"Default");
      strcpy (buf+written, sdefault);
      written += strlen (sdefault);
    }
    if (*space > written + 1) {
      strcpy (*buffer, buf);
      *buffer += strlen (buf) + 1;
      *space -= strlen (buf) + 1;
    }
    return TRUE;
d135 1
a135 1
  return FALSE;
d148 10
a157 2
  int handlers = 0, h, country, territory = cmos_read (territory_cmos, NULL) ^ 1;
  char *handler_ptr [80], *ptr, *tmpbuf;
d159 34
a192 8
  
  for (country = 1; country < 80; country == 1 ? country = 4 : country++) {
    handler_ptr [handlers] = ptr;
    if (getfullstring (country, territory, &ptr, &bufsize)) handlers++;
  }
  if (handlers == 0) {
    handlers=1;
    strcpy ((char *) tmpbuf, message_lookup_direct(messages, "NoneAvail"));
d194 9
a202 1
  
d204 1
a204 1
  
d218 3
a220 2
Purpose:	Reads the current / default keyboard handler
In:		Buffer to place result in, and function to use
d229 86
a314 12
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  
  if (get == cmos_default || misc_fileisunreadable (status_file)) {
    /* default is default for current territory, ie the same number as the configured territory */
    /* no status file means configured keyboard is the default */
    if (!getfullstring (territory, territory, &ptr, &bufsize))
      str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
  }
  else {
    FILE *handle;
    if (NULL == (handle = fopen (status_file, "r"))) {
      if (!getfullstring (territory, territory, &ptr, &bufsize))
a315 13
    }
    else {
      char line [100];
      int claimed, country;
      if (!misc_readline (line, sizeof (line), handle)) {
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery2"), bufsize);
      }
      else {
        if (!_swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, 9 + (int) line, &claimed, &country))
          str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
        if (claimed != 0) str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
        if (!getfullstring (country, territory, &ptr, &bufsize))
          str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
a316 1
      fclose (handle);
d318 2
d326 1
a326 1
Purpose:	Sets the current and configured keyboard handler
d333 79
a411 35
  char buf [100] = "Keyboard ";
  char pcext [10], pc [40], sdefault [20];
  
  char tmpbuf [3] [100];
  message_lookup_buffer(tmpbuf[0],messages,"Mystery");
  message_lookup_buffer(tmpbuf[1],messages,"Mystery2");
  message_lookup_buffer(tmpbuf[2],messages,"NoneAvail");
  if ((_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[0]) == 0)
    || (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[1]) == 0)
    || (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[2]) == 0)) return; /* nothing we can do for these */

  str_cpy (buf + strlen (buf), value);
  message_lookup_buffer(sdefault,messages,"Default");
  if (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, (int) sdefault, (int) (buf + strlen (buf) - strlen (sdefault)), 1) == 0) {
    char command [256];
    sprintf (command, "Remove %s", status_file);          /* a lack of status file is sufficient to configure the default keyboard */
    _swi (OS_CLI, _IN(0), (int) command);
    return;
  }

  message_lookup_buffer(pc,messages,"PCDel");
  if (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, (int) pc, (int) (buf + strlen (buf) - strlen (pc)), 1) == 0) {
    *(buf + strlen (buf) - strlen (pc)) = (char) 0;       /* remove verbose postfix */
    message_lookup_buffer(pcext,messages,"PCExt");
    strcat (buf, pcext);                                  /* replace with concise postfix */
  }
  
  _swi (OS_CLI, _IN(0), buf);
  if (!misc_fileislocked (status_file)) {
    if (!_swix (OS_FSControl, _INR(0,3), 26, (int) "<KbdSetup$Dir>.Blank", (int) status_file, 2)) {
      FILE *handle;
      if (NULL != (handle = fopen (status_file, "a"))) {
        fprintf (handle, "%s\n", buf);
        fclose (handle);
      }
d413 2
d416 16
@


1.1.1.1
log
@Initial commit of Configure plug-in '!KbdSetup' to CVS.
@
text
@@


1.1.1.2
log
@Replaced old PC-delete code with new option button (currently does nothing
pending a CMOS allocation).
Changed command from *Keyboard to *Country.
Bugfix: no * command was issued when changing to the default keyboard.
@
text
@a24 3
29/06/1998	BJGA	Removed code to support dedicated PC-type-delete handlers
30/06/1998	BJGA	Changed command from *Keyboard to *Country
			Bugfix: no * command was issued when changing to the default keyboard
d66 1
a66 1
  char sdefault [20];
d70 7
d162 1
a162 1
        if (!_swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, 8 + (int) line, &claimed, &country))
d183 2
a184 2
  char buf [100] = "Country ";
  char sdefault [20];
a199 3
    /* Now issue the *Keyboard command */
    *(buf + str_len (buf) - str_len (sdefault)) = '\0'; /* remove suffix */
    _swi (OS_CLI, _IN(0), buf);
d203 7
@


1.1.1.3
log
@Now causes the desktop to be redrawn if changing the keyboard causes the
alphabet to be changed as well.

Keyboard handler menu now lists currently installed keyboard handlers (it
used to list available countries, excluding a few hard-coded cases).
@
text
@a27 2
11/08/1998	BJGA	Keyboard handler list now only includes countries
			for which a handler is currently loaded
d99 2
a100 10
  int handlers = 0;
  int h;
  int country;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  int original_keyboard;
  int UK_addr;
  int UK_crc;
  char *handler_ptr [80];
  char *ptr;
  char *tmpbuf;
d103 3
a105 30
  /* Determine which handlers are available: step through all possible keyboards, and */
  /* assume that any that are not implemented will default to the UK handler. */
  /* InternationalKeyboard uses the same address to hold each installed handler, so we must */
  /* also compare the offsets therein. Only the first 32 bytes are required by the kernel. */
  original_keyboard = _swi (OS_Byte, _INR(0,1)|_RETURN(1), 71, 255);
  
  _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set UK keyboard */
  UK_addr = _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
  UK_crc = _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, UK_addr, UK_addr + 32, 1);
  
  for (country = 0; country < 127; country++)
  {
    int handler;
    int handler_addr;
    int handler_crc;
    _swi (OS_Byte, _INR(0,1), 71, country | 0x80); /* try to set keyboard */
    handler = _swi (OS_Byte, _INR(0,1)|_RETURN(1),71, 255); /* read it back again (may be different!) */
    handler_addr = _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
    handler_crc = _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, handler_addr, handler_addr + 32, 1);
    if (handler != 1)
    {
      if ((handler_addr != UK_addr) || (handler_addr == UK_addr && handler_crc != UK_crc))
      {
        handler_ptr [handlers] = ptr;
        if (getfullstring (country, territory, &ptr, &bufsize))
        {
          handlers++;
        }
      }
    }
a106 10
  
  /* Add on UK handler (assumed always present) and restore original keyboard */
  handler_ptr [handlers] = ptr;
  if (getfullstring (1, territory, &ptr, &bufsize))
  {
    handlers++;
  }
  _swi (OS_Byte, _INR(0,1), 71, original_keyboard | 0x80);
  
  /* Just in case there aren't any handlers at all (!) */
@


1.1.1.4
log
@Added Win95 keys options - drop-sensitive writable icons for each key action.

Options are now read from / written to Choices.Boot.PreDesktop instead of
Choices.Boot.PreDesk.KbdSetup.

Bugfix: now uses Message_FontChanged to refresh the screen instead of
Wimp_ForceRedraw. This additionally causes the desktop font to be recached
appropriate to the new alphabet.

Bugfix: PC-delete option is now applied even if the choices file is locked.
@
text
@a29 3
27/08/1998	BJGA	Now compares whole keyboard handler table, rather than just its crc.
			keyboards_get() and keyboard_set() rewritten to deal with PreDesktop
			  instead of dedicated choice file, and also the Win95 key settings
d106 3
a108 3
  void *UK_addr;
  int UK_table [8];
  char *handler_ptr [100];
d120 2
a121 2
  UK_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
  memcpy (UK_table, UK_addr, sizeof (int) * 8);
d126 2
a127 1
    void *handler_addr;
d130 2
a131 1
    handler_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
d134 1
a134 2
      if ((handler_addr != UK_addr) || 
          (handler_addr == UK_addr && (memcmp (handler_addr, UK_table, sizeof (int) * 8) != 0)))
d153 6
d174 2
a175 3
Purpose:	Reads keyboard handler and key tasks details from PreDesktop
		(or default keyboard handler for territory and hardcoded default tasks)
In:		Buffer to place keyboard result in, and get function to use
d184 1
a184 2
  int original_bufsize = bufsize;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;  /* not get() */
d186 11
a196 29
  /* First, initialise settings as though there were no status file */
  if (!getfullstring (territory, territory, &ptr, &bufsize))
  {
    str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
  }
  Tasks_Acorn [0][0] = Tasks_Acorn [1][0] = Tasks_Acorn [2][0] = Tasks_Acorn [3][0] = '\0';
  Tasks_Menu [0][0]  = Tasks_Menu [1][0]  = Tasks_Menu [2][0]  = Tasks_Menu [3][0]  = '\0';
  
  /* Now differentiate between current and default configuration */
  if (get == cmos_default)
  {
    /* Keyboard handler already determined, we have hardcoded knowledge of Win95 defaults as follows: */
    str_cpy (Tasks_Acorn [0], "Filer_OpenDir Resources:$.Apps");
    str_cpy (Tasks_Acorn [1], "<Boot$Dir>");
    str_cpy (Tasks_Menu [0],  "Help_On");
    str_cpy (Tasks_Menu [1],  "Help_Off");
  }
  else
  {
    BOOL error = FALSE;
    FILE *handle = NULL;
    char line [1000];
    
    error = misc_fileisunreadable (status_file);
    
    if (!error)
    {
      handle = fopen (status_file, "r");
      if (handle == NULL) error = TRUE;
d198 5
a202 8
    
    if (!error)
    {
      /* Find the start of our entry */
      do
      {
        fgets (line, sizeof (line), handle);
        str_cpy (line, line); /* null-terminate */
d204 6
a209 70
      while (strncmp (line, "|Start Acorn KbdSetup ", 22) != 0 && !feof (handle));
      
      if (!feof (handle)) /* but if end of file *was* reached, defaults continue to apply */
      {
        int country;
        int claimed;
        
        /* Read lines until the end of our entry */
        do
        {
          fgets (line, sizeof (line), handle);
          str_cpy (line, line); /* null-terminate */
          
          if (strncmp (line, "Country ", 8) == 0)
          {
            error = (BOOL) _swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, line + 8, &claimed, &country);
            if (!error)
            {
              if (claimed != 0)
              {
                error = TRUE;
              }
              else
              {
                ptr = buffer;
                bufsize = original_bufsize;
                error = !getfullstring (country, territory, &ptr, &bufsize);
              }
            }
          }
          else if (strncmp (line, "Set Key$01C0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [0], line + 18);
          }
          else if (strncmp (line, "Set Key$01D0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [1], line + 18);
          }
          else if (strncmp (line, "Set Key$01E0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [2], line + 18);
          }
          else if (strncmp (line, "Set Key$01F0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [3], line + 18);
          }
          else if (strncmp (line, "Set Key$01C1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [0], line + 18);
          }
          else if (strncmp (line, "Set Key$01D1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [1], line + 18);
          }
          else if (strncmp (line, "Set Key$01E1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [2], line + 18);
          }
          else if (strncmp (line, "Set Key$01F1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [3], line + 18);
          }
        }
        while (strcmp (line, "|End") !=0 && !feof (handle));
      }
      
      if (error)
      {
        /* Mark keyboard handler as "unrecognised" */
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
d211 1
a212 2
    
    fclose (handle);
d219 1
a219 1
Purpose:	Sets the current and configured country and Win95 key tasks
d226 2
a227 7
  const char *file = "Pipe:$.KbdSetup";
  const char *predesktop = "<Choices$Write>.Boot.PreDesktop";
  char *version;
  FILE *f;
  char command [1024];
  WimpMessage block;
  int i;
d229 28
a256 46
  f = fopen (file, "w");
  if (f == NULL)
  {
    /* Can't open the temp file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swi (MessageTrans_ErrorLookup, _INR(0,7), &block, messages, 0, 0, file, 0, 0, 0);
  }
  
  /* Get version number string */
  version = message_lookup_direct(messages, "VersionNumber");
  
  /* Write file */
  fprintf (f, "|Variable\n");
  fprintf (f, "|Start Acorn KbdSetup %s Options\n", version);
  
  message_lookup_buffer(command /* used as a temp buffer */, messages, "Mystery");
  str_cpy (command, command); /* null terminate */
  if (strcmp (command, value) != 0) /* don't do any keyboard handler stuff if undefined */
  {
    char def_str [30];
    message_lookup_buffer(def_str, messages, "Default");
    str_cpy (def_str, def_str); /* null terminate */
    sprintf (command, "Country %s", value);
    if (strcmp (def_str, command + str_len (command) - str_len (def_str)) == 0)
    {
      * (command + str_len (command) - str_len (def_str)) = '\0'; /* truncate */
    }
    else
    {
      fprintf (f, "%s\n", command); /* add to file */
    }
    _swi (OS_CLI, _IN(0), command); /* set now in either case */
  }
  
  for (i = 0; i < 4; i++)
  {
    /* Do Acorn key */
    int code = 0x1C0 + i * 0x10;
    if (Tasks_Acorn [i][0] == '\0')
    {
      sprintf (command, "Unset Key$%04X$Task", code);
    }
    else
    {
      sprintf (command, "Set Key$%04X$Task %s", code, Tasks_Acorn [i]);
      fprintf (f, "%s\n", command);
a257 14
    _swi (OS_CLI, _IN(0), command);
    
    /* Do Menu key */
    code = 0x1C1 + i * 0x10;
    if (Tasks_Menu [i][0] == '\0')
    {
      sprintf (command, "Unset Key$%04X$Task", code);
    }
    else
    {
      sprintf (command, "Set Key$%04X$Task %s", code, Tasks_Menu [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);
a258 16
  
  fprintf (f, "|End\n");
  
  fclose (f);
  _swi (OS_File, _INR(0,2), 18 /* set type */, file, 0xFEB /* obey file */);
  
  /* Do the merge! */
  sprintf (command, "Install_Merge %s %s %s", predesktop, file, predesktop);
  _swi (OS_CLI, _IN(0), command);
  
  /* Broadcast the fact that the file has been updated */
  block.hdr.your_ref = 0;
  block.hdr.action_code = Wimp_MChoicesChanged;
  str_cpy (block.data.bytes, "Boot.PreDesktop");
  block.hdr.size = sizeof (block.hdr) + (~3 & (str_len (block.data.bytes) + 1 + 3));
  throw (wimp_send_message (17, &block, 0, 0, NULL));
@


1.1.1.5
log
@Moved default !Configure-launching shortcut from Shift-Acorn to Ctrl-Acorn,
because of Filer-Run's checking of the Shift key.

Retagged as bavison_KbdSetup-0_10.
@
text
@d197 1
a197 1
    str_cpy (Tasks_Acorn [2], "<Boot$Dir>");
@


1.1.1.6
log
@Internationalised keyboard handler menu.
Changed Windows 95 key variable names to Key$[C][S]<Acorn|Menu> form.
@
text
@a32 6
11/09/1998	BJGA	Keyboard handler menu now displays territory names instead of country
			  names wherever possible, because they are internationalised. This
			  involved adding keyboards_buildnametable, rewriting getfullstring,
			  altering the building of the *Country command in keyboards_set, and
			  calling buildnametable just prior to menu building.
			Also changed names of Win95 key variables to Key$[C][S]<Acorn|Menu>.
d56 1
a56 2
cmos territory_cmos = { 0x18, 0, 8 } ; /* Held as Territory EOR 1 */
static char nametable [127] [30];
d58 1
a58 44
static BOOL getfullstring (int handler, char **buffer, int *space);

/******	keyboards_buildnametable() ****************************************\

Purpose:	Builds an internationalised territory number -> name table
		This table will also be used to convert name -> number,
		because I don't trust Territory_NameToNumber (the names it
		takes don't match those returned by Territory_NumberToName
		on all OSes). On the plus side, we can take advantage of
		this to account for the "(Default)" postfix at the same time.
		If a territory name is not available, we try to fall back
		to a (non-internationalised) country name instead.

\**************************************************************************/

void keyboards_buildnametable (int configured_territory)
{
  int territory;
  for (territory = 0; territory < 127; territory++)
  {
    _kernel_oserror *e = _swix (Territory_NumberToName, _INR(0,2), territory, nametable [territory], sizeof (nametable[0]));
    if (e != NULL)
    {
      int claimed;
      int length;
      e = _swix (OS_ServiceCall, _INR(1,5)|_OUT(1)|_OUT(5), Service_International, 2,
          territory, nametable [territory], sizeof (nametable[0]), &claimed, &length);
      if (e != NULL || claimed != 0)
      {
        sprintf (nametable [territory], "%d", territory); /* double fallback - should never be seen by user */
      }
      else
      {
        nametable [territory] [length] = '\0';
      }
    }
    if (territory == configured_territory)
    {
      char *ptr = nametable [territory];
      while (*ptr >= ' ') ptr++; /* point at terminator */
      str_cpy (ptr, message_lookup_direct(messages,"Default"));
    }
  }
}
d70 1
a70 1
static BOOL getfullstring (int handler, char **buffer, int *space)
d72 18
a89 12
  BOOL fits;
  int len = str_len (nametable [handler]);
  if (*space > len + 1)
  {
    str_cpy (*buffer, nametable [handler]);
    *buffer += len + 1;
    *space -= len + 1;
    fits = TRUE;
  }
  else
  {
    fits = FALSE;
d91 1
a91 1
  return fits;
a115 3
  /* Rescan table in case a territory or international module has been replaced in the meantime */
  keyboards_buildnametable (territory);
  
a129 1
    _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set keyboard to UK */
d139 1
a139 1
        if (getfullstring (country, &ptr, &bufsize))
d149 1
a149 1
  if (getfullstring (1, &ptr, &bufsize))
d185 1
a185 1
  if (!getfullstring (territory, &ptr, &bufsize))
d249 1
a249 1
                error = !getfullstring (country, &ptr, &bufsize);
d253 1
a253 1
          else if (strncmp (line, "Set Key$Acorn ", 14) == 0)
d255 1
a255 1
            str_cpy (Tasks_Acorn [0], line + 14);
d257 1
a257 1
          else if (strncmp (line, "Set Key$SAcorn ", 15) == 0)
d259 1
a259 1
            str_cpy (Tasks_Acorn [1], line + 15);
d261 1
a261 1
          else if (strncmp (line, "Set Key$CAcorn ", 15) == 0)
d263 1
a263 1
            str_cpy (Tasks_Acorn [2], line + 15);
d265 1
a265 1
          else if (strncmp (line, "Set Key$CSAcorn ", 16) == 0)
d267 1
a267 1
            str_cpy (Tasks_Acorn [3], line + 16);
d269 1
a269 1
          else if (strncmp (line, "Set Key$Menu ", 13) == 0)
d271 1
a271 1
            str_cpy (Tasks_Menu [0], line + 13);
d273 1
a273 1
          else if (strncmp (line, "Set Key$SMenu ", 14) == 0)
d275 1
a275 1
            str_cpy (Tasks_Menu [1], line + 14);
d277 1
a277 1
          else if (strncmp (line, "Set Key$CMenu ", 14) == 0)
d279 1
a279 1
            str_cpy (Tasks_Menu [2], line + 14);
d281 1
a281 1
          else if (strncmp (line, "Set Key$CSMenu ", 15) == 0)
d283 1
a283 1
            str_cpy (Tasks_Menu [3], line + 15);
d337 9
a345 5
    int handler;
    int length;
    char handler_name [30] = "";
    
    for (handler = 0; handler < 127; handler++)
d347 1
a347 1
      if (0 == strcmp (value, nametable [handler])) break;
a348 6
    _swi (OS_ServiceCall, _INR(1,5)|_OUT(5), Service_International, 2, handler, handler_name, sizeof (handler_name), &length);
    /* must be claimed by someone, otherwise there wouldn't have been a keyboard handler there! */
    handler_name [length] = '\0';
    
    sprintf (command, "Country %s", handler_name);
    fprintf (f, "%s\n", command); /* add to file */
d355 1
d358 1
a358 1
      sprintf (command, "Unset Key$%s%sAcorn", i&2 ? "C" : "", i&1 ? "S" : "");
d362 1
a362 1
      sprintf (command, "Set Key$%s%sAcorn %s", i&2 ? "C" : "", i&1 ? "S" : "", Tasks_Acorn [i]);
d366 1
a366 4
  }
  
  for (i = 0; i < 4; i++)
  {
d368 1
d371 1
a371 1
      sprintf (command, "Unset Key$%s%sMenu", i&2 ? "C" : "", i&1 ? "S" : "");
d375 1
a375 1
      sprintf (command, "Set Key$%s%sMenu %s", i&2 ? "C" : "", i&1 ? "S" : "", Tasks_Menu [i]);
@

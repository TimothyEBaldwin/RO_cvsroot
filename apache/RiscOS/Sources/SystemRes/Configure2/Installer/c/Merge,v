head	1.2;
access;
symbols
	Installer-0_15:1.2
	Installer-0_14:1.2
	Installer-0_13:1.2
	Installer-0_12:1.2
	Installer-0_11:1.1.1.4
	Installer-0_10:1.1.1.4
	Installer-0_09:1.1.1.4
	Installer-0_08:1.1.1.4
	Installer-0_07:1.1.1.4
	rthornb_UrsulaBuild-29Jul1998:1.1.1.4
	rthornb_UrsulaBuild-22Jul1998:1.1.1.4
	rthornb_UrsulaBuild-15Jul1998:1.1.1.4
	rthornb_UrsulaBuild-07Jul1998:1.1.1.4
	bavison_Installer-0_06:1.1.1.4
	rthornb_UrsulaBuild-17Jun1998:1.1.1.3
	bavison_Installer-0_05:1.1.1.3
	rthornb_UrsulaBuild-03Jun1998:1.1.1.2
	rthornb_UrsulaBuild-27May1998:1.1.1.2
	rthornb_UrsulaBuild-21May1998:1.1.1.2
	rthornb_UrsulaBuild_01May1998:1.1.1.2
	bavison_Installer_004:1.1.1.2
	bavison_Installer_003:1.1.1.2
	initial:1.1.1.1
	Ursula:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2012.07.09.00.43.03;	author jlee;	state Exp;
branches;
next	1.1;
commitid	0SMfy3VUBob13Pbw;

1.1
date	98.04.07.18.12.52;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.07.18.12.52;	author bavison;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.04.21.17.27.15;	author bavison;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.06.09.11.16.42;	author bavison;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.06.23.11.16.19;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix null pointer dereference in static_ParseFile
Detail:
  c/Merge - Although the code that uses last_section, last_company and last_app checks if the rules pointer is null before each use, the code which initialises the variables in the first place (based on the contents of 'rules') wasn't performing any null pointer checks.
Admin:
  Tested on BB-xM with high processor vectors


Version 0.12. Tagged as 'Installer-0_12'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******	Merge.c ***********************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Configure Installer module (for SysMerge/FontMerge/BootMerge)
This file:	Structured obey file manipulation

History:
Date		Who	Change
----------------------------------------------------------------------------
08/01/1998	BJGA	Created
29/01/1998	BJGA	Started
30/01/1998	BJGA	Implemented static_ParseFile, static_ParseRules,
			  static_ParseEntryHeader, static_WriteFile,
			  static_FreeEntries and static_FreeRules;
			  work continued on Merge_Merge
31/01/1998	BJGA	Completed Merge_Merge, implemented Merge_DeMerge,
			  static_FindSectionRange, static_FindCompanyRange,
			  static_FindApp, static_ReplaceEntry,
			  static_AddEntry and static_RemoveEntry
20/04/1998	BJGA	Bugfix: didn't recognise file needed updating if the
			  *only* change(s) was an entry version increase (oops!)
09/06/1998	BJGA	Applied error numbers

\**************************************************************************/

/* CLib */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
/* Common */
#include "str.h"
/* local headers */
#include "Defs.h"
#include "File.h"
#include "FileOp.h"
#include "Log.h"
#include "Merge.h"
#include "Mess.h"

typedef struct entry
{
  struct entry *next;
  const char *start;
  const char *end;
  char *sect;
  char *sect_full;
  char *comp;
  char *app;
  int ver;
} entry;

typedef struct rule
{
  struct rule *next;
  char *uk; /* when this specifier is unrecognised, apply the rule */
  BOOL uk_wild;
  BOOL after;
  char *estab; /* this is the established specifier the rule is relative to */
  BOOL estab_wild;
} rule;

typedef struct
{
  rule *section;
  rule *company;
  rule *app;
} rule_set;

static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules, BOOL *is_variable);
static _kernel_oserror *static_ParseRules (const char *line, rule **last_rule_p, rule **first_rule_p);
static _kernel_oserror *static_ParseEntryHeader (const char *line, entry **last_entry_p, entry **first_entry_p);
static _kernel_oserror *static_WriteFile (const entry *entries, const char *name, int filetype);
static void static_FreeEntries (entry *entries);
static void static_FreeRules (rule_set *rules);
static _kernel_oserror *static_FindSectionRange (const char *section, entry *ent, entry **first, int *num);
static _kernel_oserror *static_FindCompanyRange (const char *company, entry *ent, int within, entry **first, int *num);
static _kernel_oserror *static_FindApp (const char *app, entry *ent, int within, entry **here);
static _kernel_oserror *static_ReplaceEntry (const char *name, entry *source, entry *dest);
static _kernel_oserror *static_AddEntry (const char *name, entry *source, BOOL after, entry *dest);
static _kernel_oserror *static_RemoveEntry (const char *name, entry **link_p);


/******	Merge_Merge() *****************************************************\

Purpose:	Merges two obeyfiles and places output in another
In:		Pointers to input files (held in memory), name of output, filetype of output
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *Merge_Merge (const char *base, const char *base_name, int base_len,
    const char *changes, const char *changes_name, int changes_len,
    const char *dest_name, int filetype, int old_type, int old_filetype, int old_ver)
{
  _kernel_oserror *err = NULL;
  entry *base_entries = NULL,
        *changes_entries = NULL,
        *new_e,
        *firstin_sect,
        *firstin_comp,
        *old_e;
  rule *r;
  int sect_range,
      comp_range;
  rule_set rules = { NULL, NULL, NULL };
  char *dest_rw;
  BOOL stuff_done = FALSE;
  BOOL variable;
  
  dest_rw = malloc (str_len (dest_name) + 1);
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
  
  /* Parse the input files */
  if (!err)
  {
    err = static_ParseFile (base, base_len, &base_entries, NULL, NULL);
  }
  if (!err)
  {
    err = static_ParseFile (changes, changes_len, &changes_entries, &rules, &variable);
  }
  
  /* Sanity check */
  if (!err && base_entries == NULL)
  {
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, base_name);
  }
  if (!err && changes_entries == NULL)
  {
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, changes_name);
  }
  
  /* Find the next entry from changes file, and compare it */
  for (new_e = changes_entries; !err && new_e != NULL; new_e = new_e->next)
  {
    
    /* Look for the matching section in base file */
    err = static_FindSectionRange (new_e->sect, base_entries, &firstin_sect, &sect_range);
    if (!err && sect_range == 0)
    {
      /* Entry is in a new section - consult rules to determine where to create it */
      for (r = rules.section; r != NULL; r = r->next)
      {
        int diff;
        err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, r->uk, new_e->sect, 1, &diff); /* see if we match rule */
        if (!err && (diff == 0 || r->uk_wild))
        {
          if (r->estab_wild)
          {
            old_e = base_entries;
            if (r->after) while (old_e->next != NULL) old_e = old_e->next; /* skip to last entry */
            err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
            break;
          }
          else
          {
            err = static_FindSectionRange (r->estab, base_entries, &firstin_sect, &sect_range); /* see if rule is useful */
            if (!err && sect_range != 0) /* rule can be applied - entry goes before or after section specified in rule */
            {
              old_e = firstin_sect;
              if (r->after) while (sect_range-- > 1) old_e = old_e->next; /* skip to last entry in section */
              err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
              break;
            }
          }
        }
      }
      if (!err && r == NULL) /* default rule *>* applies */
      {
        old_e = base_entries;
        while (old_e->next != NULL) old_e = old_e->next; /* skip to last entry */
        err = static_AddEntry (dest_name, new_e, TRUE, old_e); /* insert new entry */
      }
      stuff_done = TRUE; /* flag file update as necessary */
      
      
    }
    else if (!err)
    {
      /* Found the entry's section, now look for the matching company in base file */
      err = static_FindCompanyRange (new_e->comp, firstin_sect, sect_range, &firstin_comp, &comp_range);
      if (!err && comp_range == 0)
      {
        /* Entry is in a new company - consult rules to determine where to create it */
        for (r = rules.company; r != NULL; r = r->next)
        {
          int diff;
          err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, r->uk, new_e->comp, 1, &diff); /* see if we match rule */
          if (!err && (diff == 0 || r->uk_wild))
          {
            if (r->estab_wild)
            {
              old_e = firstin_sect;
              if (r->after) while (sect_range-- > 1) old_e = old_e->next; /* skip to last entry in section */
              err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
              break;
            }
            else
            {
              err = static_FindCompanyRange (r->estab, firstin_sect, sect_range, &firstin_comp, &comp_range); /* see if rule is useful */
              if (!err && comp_range != 0) /* rule can be applied - entry goes before or after company specified in rule */
              {
                old_e = firstin_comp;
                if (r->after) while (comp_range-- > 1) old_e = old_e->next; /* skip to last entry in company */
                err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
                break;
              }
            }
          }
        }
        if (!err && r == NULL) /* default rule *>* applies */
        {
          old_e = firstin_sect;
          while (sect_range-- > 1) old_e = old_e->next; /* skip to last entry in section */
          err = static_AddEntry (dest_name, new_e, TRUE, old_e); /* insert new entry */
        }
        stuff_done = TRUE;
        
        
      }
      else if (!err)
      {
        /* Found the entry's company and section, now look for the matching application in base file */
        err = static_FindApp (new_e->app, firstin_comp, comp_range, &old_e);
        if (!err && old_e == NULL)
        {
          /* Entry is a new application - consult rules to determine where to create it */
          for (r = rules.app; r != NULL; r = r->next)
          {
            int diff;
            err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, r->uk, new_e->app, 1, &diff); /* see if we match rule */
            if (!err && (diff == 0 || r->uk_wild))
            {
              if (r->estab_wild)
              {
                old_e = firstin_comp;
                if (r->after) while (comp_range-- > 1) old_e = old_e->next; /* skip to last entry in company */
                err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
                break;
              }
              else
              {
                err = static_FindApp (r->estab, firstin_comp, comp_range, &old_e); /* see if rule is useful */
                if (!err && old_e != NULL) /* rule can be applied - entry goes before or after application specified in rule */
                {
                  err = static_AddEntry (dest_name, new_e, r->after, old_e); /* insert new entry */
                  break;
                }
              }
            }
          }
          if (!err && r == NULL) /* default rule *>* applies */
          {
            old_e = firstin_comp;
            while (comp_range-- > 1) old_e = old_e->next; /* skip to last entry in company */
            err = static_AddEntry (dest_name, new_e, TRUE, old_e); /* insert new entry */
          }
          stuff_done = TRUE;
          
          
        }
        else if (!err)
        {
          /* Found the application, company and section, now compare versions */
          if ((!variable && (old_e->ver < new_e->ver)) ||
              (variable && (old_e->ver <= new_e->ver)))
          {
            err = static_ReplaceEntry (dest_name, new_e, old_e);
            stuff_done = TRUE;
          }
        }
      }
    }
  }
  
  if (!err && stuff_done)
  {
    /* Clear the way for destination to be written */
    if (old_type > 0) /* voids' parent-files get backed up during the directory tree build operation */
    {
      err = File_Backup (dest_name, TRUE, old_type, old_filetype, old_ver); /* always recurse dirs/fonts */
    }
    if (!err)
    {
      str_cpy (dest_rw, dest_name);
      err = FileOp_BuildTree (dest_rw, TRUE);
    }
  
    /* Write output file */
    if (!err)
    {
      err = static_WriteFile (base_entries, dest_name, filetype);
    }
  }
  
  static_FreeRules (&rules);
  static_FreeEntries (changes_entries);
  static_FreeEntries (base_entries);
  free (dest_rw);
  return err;
}

/******	Merge_DeMerge() ***************************************************\

Purpose:	Uses one obeyfile to remove entries from another, and places output in a third
In:		Pointers to input files (held in memory), name of output, filetype of output
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *Merge_DeMerge (const char *base, const char *base_name, int base_len,
    const char *changes, const char *changes_name, int changes_len,
    const char *dest_name, int filetype, int old_type, int old_filetype, int old_ver)
{
  _kernel_oserror *err = NULL;
  entry *base_entries = NULL,
        *changes_entries = NULL,
        *new_e,
        **old_e_p;
  char *dest_rw;
  BOOL stuff_done = FALSE,
       found;
  
  dest_rw = malloc (str_len (dest_name) + 1);
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
  
  /* Parse the input files */
  if (!err)
  {
    err = static_ParseFile (base, base_len, &base_entries, NULL, NULL);
  }
  if (!err)
  {
    err = static_ParseFile (changes, changes_len, &changes_entries, NULL, NULL);
  }
  
  /* Sanity check */
  if (!err && base_entries == NULL)
  {
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, base_name);
  }
  if (!err && changes_entries == NULL)
  {
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, changes_name);
  }
  
  /* Find the next entry from changes file */
  for (new_e = changes_entries; !err && new_e != NULL; new_e = new_e->next)
  {
    /* Check every object in base file for a match */
    for (old_e_p = &base_entries; !err && *old_e_p != NULL; )
    {
      /* Compare */
      int diff;
      found = FALSE;
      err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, (*old_e_p)->sect, new_e->sect, 1, &diff);
      if (!err && diff == 0)
      {
        err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, (*old_e_p)->comp, new_e->comp, 1, &diff);
        if (!err && diff == 0)
        {
          err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, (*old_e_p)->app, new_e->app, 1, &diff);
          if (!err && diff == 0)
          {
            /* Check versions */
            if ((*old_e_p)->ver <= new_e->ver) found = TRUE;
          }
        }
      }
      if (found)
      {
        /* Remove entry from base file - this will also adjust the pointer referenced by |old_e_p| automatically */
        err = static_RemoveEntry (dest_name, old_e_p);
        stuff_done = TRUE;
      }
      else
      {
        /* Move |old_e_p| on to next pointer manually */
        old_e_p = &((*old_e_p)->next);
      }
    }
  }
  
  
  if (!err && stuff_done)
  {
    /* Clear the way for destination to be written */
    if (old_type > 0) /* voids' parent-files get backed up during the directory tree build operation */
    {
      err = File_Backup (dest_name, TRUE, old_type, old_filetype, old_ver); /* always recurse dirs/fonts */
    }
    if (!err)
    {
      str_cpy (dest_rw, dest_name);
      err = FileOp_BuildTree (dest_rw, TRUE);
    }
  
    /* Write output file */
    if (!err)
    {
      err = static_WriteFile (base_entries, dest_name, filetype);
    }
  }
  
  static_FreeEntries (changes_entries);
  static_FreeEntries (base_entries);
  free (dest_rw);
  return err;
}

/******	static_ParseFile() ************************************************\

Purpose:	Identifies the overall structure of a file
In:		Position of file in memory, references to pass back
		entry list, rules lists and variable-entry-flag pointers
Out:		Pointer to error block
Note:		Rules lists and variable-entry pointers references are optional (NULL => don't use)

\**************************************************************************/

static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules, BOOL *is_variable)
{
  _kernel_oserror *err = NULL;
  const char *ptr = file,
             *end = file + len;
  char start[10]; /* This is as long as we need */
  entry *last_entry = *first_entry_p;
  rule *last_section,*last_company,*last_app;
  BOOL in_an_entry = FALSE;
  BOOL found_Variable = FALSE;
  int diff;

  if (rules)
  {
    last_section = rules->section;
    last_company = rules->company;
    last_app = rules->app;
  }
  else
  {
    last_section = last_company = last_app = NULL;
  }
  
  while (ptr < end && !err)
  {
    /* Examine the beginning of the line case-insensitively, to see if it has special meaning */
    
    /* First check 9-char-long strings */
    str_ncpy (start, ptr, 10);
    
    if (rules && !in_an_entry)
    {
      if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|Company ", 1, &diff);
      if (!err && diff == 0)
      {
        err = static_ParseRules (ptr + 9, &last_company, &(rules->company));
      }
      
      if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|Section ", 1, &diff);
      if (!err && diff == 0)
      {
        err = static_ParseRules (ptr + 9, &last_section, &(rules->section));
      }
      
      if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|Variable", 1, &diff);
      if (!err && diff == 0)
      {
        found_Variable = TRUE;
      }
    }
    
    /* Truncate, and check 7-char-long strings */
    start[7] = '\0';
    
    if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|Start ", 1, &diff);
    if (!err && diff == 0)
    {
      if (in_an_entry) last_entry->end = ptr;
      err = static_ParseEntryHeader (ptr, &last_entry, first_entry_p);
      in_an_entry = TRUE;
    }
    
    /* Truncate, and check 5-char-long strings */
    start[5] = '\0';
    
    if (rules && !in_an_entry)
    {
      if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|App ", 1, &diff);
      if (!err && diff == 0)
      {
        err = static_ParseRules (ptr + 5, &last_app, &(rules->app));
      }
    }
    
    /* Truncate, and check 4-char-long strings */
    start[4] = '\0';
    
    if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|End", 1, &diff);
    if (!err && diff == 0)
    {
      if (in_an_entry) last_entry->end = ptr;
      in_an_entry = FALSE;
    }
    
    /* Find next line */
    while (*ptr++ != '\n');
  }
  
  /* If there was no |End for the last entry, mark end-of-file as end-of-entry */
  if (in_an_entry && !err)
  {
    last_entry->end = (*(end - 1) == '\n') ? end - 1 : end;
    if (last_entry->end < last_entry->start) last_entry->end = last_entry->start;
  }
  
  /* Return is_variable if appropriate */
  if (is_variable != NULL)
  {
    *is_variable = found_Variable;
  }
  
  return err;
}

/******	static_ParseRules() ***********************************************\

Purpose:	Build rule links from a rule string
In:		Pointer to string (excluding command), references to return
		first and last rule link pointers
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_ParseRules (const char *line, rule **last_rule_p, rule **first_rule_p)
{
  _kernel_oserror *err = NULL;
  rule *link = NULL;
  const char *ptr,
             *spec1,
             *spec2;
  int spec1_len,
      spec2_len;
  BOOL after;
  
  ptr = line;
  while (*ptr != '\n' && !err)
  {
    
    /* First, skip any spaces */
    while (*ptr == ' ') ptr++;
    /* Now at specifier 1 start */
    spec1 = ptr;
    while (*ptr != ' ' && *ptr != '\n' && *ptr != '<' && *ptr != '>') ptr++;
    /* Now at specifier 1 end */
    spec1_len = ptr - spec1;
    if (*ptr == ' ' || *ptr == '\n' || spec1_len == 0)
    {
      while (*ptr != ' ' && *ptr != '\n') ptr++; /* skip remainder of word, if any */
      continue; /* This is an invalid rule */
    }
    /* Examine comparator */
    after = (*ptr == '>');
    ptr++;
    /* Now at specifier 2 start */
    spec2 = ptr;
    while (*ptr != ' ' && *ptr != '\n' && *ptr != '<' && *ptr != '>') ptr++;
    /* Now at specifier 2 end */
    spec2_len = ptr - spec2;
    if (*ptr == '<' || *ptr == '>' || spec2_len == 0)
    {
      while (*ptr != ' ' && *ptr != '\n') ptr++; /* skip remainder of word, if any */
      continue; /* This is an invalid rule */
    }
    
    /* Rule now scanned, allocate memory for the link */
    link = malloc (sizeof (*link));
    if (link == NULL)
    {
      err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
    }
    else
    {
      memset (link, 0, sizeof (*link));
      
      /* Allocate memory for the strings hanging off the link */
      link->uk = malloc (spec1_len + 1);
      link->estab = malloc (spec2_len + 1);
      
      if (!link->uk || !link->estab)
      {
        free (link->estab);
        free (link->uk);
        err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
      }
      else
      {
        
        /* Memory allocation successful - fill in the blanks */
        link->uk_wild = (*spec1 == '*' && spec1_len == 1);
        link->after = after;
        link->estab_wild = (*spec2 == '*' && spec2_len == 1);
        
        str_ncpy (link->uk, spec1, spec1_len + 1);
        str_ncpy (link->estab, spec2, spec2_len + 1);
        
        if (*last_rule_p != NULL) (*last_rule_p)->next = link;
        if (*first_rule_p == NULL) *first_rule_p = link;
        
        *last_rule_p = link;
      }
    }
  }
  
  return err;
}

/******	static_ParseEntryHeader() *****************************************\

Purpose:	Builds an entry link from the entry header string
In:		String pointer (== entry start pointer), references to return
		first and last entry link pointers
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_ParseEntryHeader (const char *line, entry **last_entry_p, entry **first_entry_p)
{
  _kernel_oserror *err = NULL;
  entry *link = NULL;
  const char *ptr,
             *company,
             *app,
             *section;
  int company_len,
      app_len,
      ver = 0,
      section_len,
      section_fulllen;
  
  /* First, skip any surplus spaces after "|Start" */
  ptr = line + 7;
  while (*ptr == ' ') ptr++;
  /* Now at company name start */
  company = ptr;
  while (*ptr != ' ' && *ptr != '\n') ptr++;
  /* Now at company name end */
  company_len = ptr - company;
  while (*ptr == ' ') ptr++;
  /* Now at app name start */
  app = ptr;
  while (*ptr != ' ' && *ptr != '\n') ptr++;
  /* Now at app name end */
  app_len = ptr - app;
  while (*ptr == ' ') ptr++;
  /* Now at version start */
  while (*ptr >= '0' && *ptr <= '9')
  {
    ver *= 10;
    ver += (*ptr - '0') * 100;
    ptr++;
  }
  if (*ptr == '.')
  {
    ptr++;
    if (*ptr >= '0' && *ptr <= '9')
    {
      ver += (*ptr - '0') * 10;
      ptr ++;
      if (*ptr >= '0' && *ptr <= '9')
      {
        ver += (*ptr - '0');
      }
    }
  }
  while (*ptr != ' ' && *ptr != '\n') ptr++;
  while (*ptr == ' ') ptr++;
  /* Now at section name start */
  section = ptr;
  while (*ptr != ' ' && *ptr != '\n') ptr++;
  /* Now at section first-word end */
  section_len = ptr - section;
  while (*ptr != '\n') ptr++;
  /* Now at end of section */
  section_fulllen = ptr - section;
  
  /* String now scanned, allocate memory for the link */
  link = malloc (sizeof (*link));
  if (link == NULL)
  {
    err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
  }
  else
  {
    memset (link, 0, sizeof (*link));
    
    /* Allocate memory for the strings hanging off the link */
    link->sect = malloc (section_len + 1);
    link->sect_full = malloc (section_fulllen + 1);
    link->comp = malloc (company_len + 1);
    link->app = malloc (app_len + 1);
    
    if (!link->sect || !link->sect_full || !link->comp || !link->app)
    {
      free (link->app);
      free (link->comp);
      free (link->sect_full);
      free (link->sect);
      err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
    }
    else
    {
      
      /* Memory allocation successful - fill in the blanks */
      link->start = ptr + 1;
      link->ver = ver;
      
      str_ncpy (link->sect, section, section_len + 1);
      str_ncpy (link->sect_full, section, section_fulllen + 1);
      str_ncpy (link->comp, company, company_len + 1);
      str_ncpy (link->app, app, app_len + 1);
      
      if (*last_entry_p != NULL) (*last_entry_p)->next = link;
      if (*first_entry_p == NULL) *first_entry_p = link;
      
      *last_entry_p = link;
    }
  }
  
  return err;
}

/******	static_WriteFile() ************************************************\

Purpose:	Outputs a file, representing the contents of the entry list
In:		Pointer to entry list, filename and filetype to use
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_WriteFile (const entry *entries, const char *name, int filetype)
{
  _kernel_oserror *err = NULL;
  const entry *link;
  char *temp;
  int fh = 0,
      nbytes;
  
  /* Open file */
  err = _swix (OS_Find, _INR(0,1)|_OUT(0), 0x83 /* openout, no path */, name, &fh);
  if (!err && fh != 0)
  {
    
    /* Step through the list */
    for (link = entries; link != NULL; link = link->next)
    {
      temp = malloc (7 + str_len (link->comp) + 1 + str_len (link->app) + 1 + 11 + 1
          + str_len (link->sect_full) + 1 + /* to be safe */ str_len ("<company><application><section>"));
      if (temp == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
      if (!err)
      {        
        /* Create and write the |Start line */
        sprintf (temp, "|Start %s %s %d.%02d %s\n%n",
            *link->comp == '\0' ? "<company>" : link->comp,
            *link->app == '\0' ? "<application>" : link->app,
            link->ver/100,
            link->ver%100,
            *link->sect_full == '\0' ? "<section>" : link->sect_full,
            &nbytes);
        err = _swix (OS_GBPB, _INR(0,3), 2 /* write bytes */, fh, temp, nbytes);
      }
      if (!err)
      {
        /* Write the entry */
        err = _swix (OS_GBPB, _INR(0,3), 2 /* write bytes */, fh, link->start, link->end - link->start);
      }
      if (!err)
      {
        /* Create and write the !End line */
        sprintf (temp, "|End\n%s%n", (link->next == NULL) ? "" : "\n", &nbytes);
        err = _swix (OS_GBPB, _INR(0,3), 2 /* write bytes */, fh, temp, nbytes);
      }
      free (temp);
    }
  }
  
  if (fh != 0)
  {
    /* Tidy up */
    _swix (OS_Find, _INR(0,1), 0 /* close */, fh);
    _swix (OS_File, _INR(0,2), 18 /* set type */, name, filetype);
  }
  
  return err;
}

/******	static_FreeEntries() **********************************************\

Purpose:	Deallocates the entries linked list
In:		Pointer to list

\**************************************************************************/

static void static_FreeEntries (entry *entries)
{
  entry *link,
        *next_link;
  
  for (link = entries; link != NULL; link = next_link)
  {
    next_link = link->next;
    free (link->app);
    free (link->comp);
    free (link->sect_full);
    free (link->sect);
    free (link);
  }
  
  return;
}

/******	static_FreeRules() ************************************************\

Purpose:	Deallocates the rules linked lists
In:		Pointer to list

\**************************************************************************/

static void static_FreeRules (rule_set *rules)
{
  rule *rule,
       *next_rule;
  
  for (rule = rules->app; rule != NULL; rule = next_rule)
  {
    next_rule = rule->next;
    free (rule->estab);
    free (rule->uk);
    free (rule);
  }
  
  for (rule = rules->company; rule != NULL; rule = next_rule)
  {
    next_rule = rule->next;
    free (rule->estab);
    free (rule->uk);
    free (rule);
  }
  
  for (rule = rules->section; rule != NULL; rule = next_rule)
  {
    next_rule = rule->next;
    free (rule->estab);
    free (rule->uk);
    free (rule);
  }
  
  return;
}

/******	static_FindSectionRange() *****************************************\

Purpose:	Determines the start and extent of a section within a complete list of entries
In:		Section name, list start, references to return section start and extent
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_FindSectionRange (const char *section, entry *ent, entry **first, int *num)
{
  _kernel_oserror *err = NULL;
  int diff = 1;
  
  /* Initialise */
  *num = 0;
  
  /* Find first entry in section */
  for (; ent != NULL; ent = ent->next)
  {
    err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, section, ent->sect, 1, &diff);
    if (diff == 0 || err) break;
  }
  if (!err && diff == 0)
  {
    
    /* |ent| points at first matching entry - now count number of entries in section */
    *first = ent;
    for (; ent != NULL; ent = ent->next)
    {
      err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, section, ent->sect, 1, &diff);
      if (diff != 0 || err) break;
      (*num)++;
    }
  }
  
  return err;
}

/******	static_FindCompanyRange() *****************************************\

Purpose:	Determines the start and extent of a company within a section
In:		Company name, section start and extent, references to return company start and extent
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_FindCompanyRange (const char *company, entry *ent, int within, entry **first, int *num)
{
  _kernel_oserror *err = NULL;
  int diff = 1;
  
  /* Initialise */
  *num = 0;
  
  /* Find first entry in company */
  for (; within > 0; within--, ent = ent->next)
  {
    err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, company, ent->comp, 1, &diff);
    if (diff == 0 || err) break;
  }
  if (!err && diff == 0)
  {
    
    /* |ent| points at first matching entry - now count number of entries in company */
    *first = ent;
    for (; within > 0; within--, ent = ent->next)
    {
      err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, company, ent->comp, 1, &diff);
      if (diff != 0 || err) break;
      (*num)++;
    }
  }
  
  return err;
}

/******	static_FindApp() **************************************************\

Purpose:	Finds an application within a list fragment of constant section and company
In:		Application name, fragment start and extent, reference to return entry pointer (or NULL if not found)
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_FindApp (const char *app, entry *ent, int within, entry **here)
{
  _kernel_oserror *err = NULL;
  int diff = 1;
  
  /* Initialise */
  *here = NULL;
  
  /* Scan list */
  for (; within > 0; within--, ent = ent->next)
  {
    err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, app, ent->app, 1, &diff);
    if (diff == 0 || err) break;
  }
  if (!err && diff == 0)
  {
    
    /* |ent| points at matching entry */
    *here = ent;
  }
  
  return err;
}

/******	static_ReplaceEntry() *********************************************\

Purpose:	Replaces a link with another, writes operation to log file
In:		Filename, source and destination links
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_ReplaceEntry (const char *name, entry *source, entry *dest)
{
  _kernel_oserror *err = NULL;
  entry temp;
  
  /* Write log entry before we go deallocating stuff */
  err = Log_Write ("Updating", name, " : updated %s %s %s entry version %d.%02d to version %d.%02d\n",
      source->comp,
      source->app,
      source->sect,
      dest->ver/100,
      dest->ver%100,
      source->ver/100,
      source->ver%100);
  
  if (!err)
  {
    /* Deallocate everything associated with the destination link */
    free (dest->sect);
    free (dest->sect_full);
    free (dest->comp);
    free (dest->app);
    
    /* Copy everything across except the |next| pointer */
    temp = *source;
    temp.next = dest->next;
    *dest = temp;
    
    /* Make sure stuff isn't freed twice */
    source->sect = NULL;
    source->sect_full = NULL;
    source->comp = NULL;
    source->app = NULL;
    
  }
  return err;
}

/******	static_AddEntry() *************************************************\

Purpose:	Inserts a link, writes operation to log file
In:		Filename, source and destination links, whether inserted before or after
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_AddEntry (const char *name, entry *source, BOOL after, entry *dest)
{
  _kernel_oserror *err = NULL;
  entry *added = NULL;
  
  /* Write log entry before we go deallocating stuff */
  err = Log_Write ("Updating", name, " : added %s %s %s entry %s %s %s %s entry\n",
      source->comp,
      source->app,
      source->sect,
      after ? "after" : "before",
      dest->comp,
      dest->app,
      dest->sect);
  
  /* Allocate space for the new link */
  if (!err)
  {
    added = malloc (sizeof (*added));
    if (added == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
  }
  if (!err)
  {

    if (after)
    {
      /* Add-after case - copy source to the new link */
      *added = *source;
      added->next = dest->next;
      dest->next = added;
    }
    else
    {
      /* Add-before case - copy dest to the new link, copy source to dest */
      *added = *dest;
      *dest = *source;
      dest->next = added;
    }
    
    /* Make sure stuff isn't freed twice */
    source->sect = NULL;
    source->sect_full = NULL;
    source->comp = NULL;
    source->app = NULL;
    
  }
  return err;
}

/******	static_RemoveEntry() **********************************************\

Purpose:	Deletes a link, writes operation to log file
In:		Filename, reference of pointer to link
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_RemoveEntry (const char *name, entry **link_p)
{
  _kernel_oserror *err = NULL;
  entry *removed;
  
  /* Write log entry before we go deallocating stuff */
  err = Log_Write ("Updating", name, " : removed %s %s %s entry\n",
      (*link_p)->comp,
      (*link_p)->app,
      (*link_p)->sect);
  
  if (!err)
  {
    /* Unlink */
    removed = *link_p;
    *link_p = (*link_p)->next;
    
    /* Deallocate everything */
    free (removed->sect);
    free (removed->sect_full);
    free (removed->comp);
    free (removed->app);
    free (removed);
    
  }
  return err;
}
@


1.1
log
@Initial revision
@
text
@d34 3
d85 1
a85 1
static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules);
d124 1
d127 1
a127 1
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d132 1
a132 1
    err = static_ParseFile (base, base_len, &base_entries, NULL);
d136 1
a136 1
    err = static_ParseFile (changes, changes_len, &changes_entries, &rules);
d142 1
a142 1
    err = Mess_GenerateError ("BadObey", errno_DONT_CARE, 1, base_name);
d146 1
a146 1
    err = Mess_GenerateError ("BadObey", errno_DONT_CARE, 1, changes_name);
d281 2
a282 1
          if (old_e->ver < new_e->ver)
d285 1
d341 1
a341 1
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d346 1
a346 1
    err = static_ParseFile (base, base_len, &base_entries, NULL);
d350 1
a350 1
    err = static_ParseFile (changes, changes_len, &changes_entries, NULL);
d356 1
a356 1
    err = Mess_GenerateError ("BadObey", errno_DONT_CARE, 1, base_name);
d360 1
a360 1
    err = Mess_GenerateError ("BadObey", errno_DONT_CARE, 1, changes_name);
d431 1
a431 1
		entry list and rules lists pointers
d433 1
a433 1
Note:		Rules lists pointers reference is optional (NULL => don't use)
d437 1
a437 1
static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules)
d444 1
a444 3
  rule *last_section = rules->section,
       *last_company = rules->company,
       *last_app = rules->app;
d446 1
d448 11
d480 6
d532 6
d595 1
a595 1
      err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d609 1
a609 1
        err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d706 1
a706 1
    err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d724 1
a724 1
      err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d774 1
a774 1
      if (temp == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
d1057 1
a1057 1
    if (added == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
@


1.1.1.1
log
@Initial commit of Configure's shared Installer module to CVS.
@
text
@@


1.1.1.2
log
@Bugfix: correct filename now reported back from *Install_(De)Merge when changes
file is absent, a directory or not an obey file.
Bugfix: didn't recognise file needed updating if the *only* change(s) was an
entry version increase (oops!)
Re-worded LogDirIsnt token.
@
text
@a33 2
20/04/1998	BJGA	Bugfix: didn't recognise file needed updating if the
			  *only* change(s) was an entry version increase (oops!)
a279 1
            stuff_done = TRUE;
@


1.1.1.3
log
@Now uses allocated error numbers.
@
text
@a35 1
09/06/1998	BJGA	Applied error numbers
d125 1
a125 1
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d140 1
a140 1
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, base_name);
d144 1
a144 1
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, changes_name);
d338 1
a338 1
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d353 1
a353 1
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, base_name);
d357 1
a357 1
    err = Mess_GenerateError ("BadObey", errno_BAD_OBEY, 1, changes_name);
d570 1
a570 1
      err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d584 1
a584 1
        err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d681 1
a681 1
    err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d699 1
a699 1
      err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d749 1
a749 1
      if (temp == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
d1032 1
a1032 1
    if (added == NULL) err = Mess_GenerateError ("NoMem", errno_NO_MEM, 0);
@


1.1.1.4
log
@Added support for entries whose contents may vary despite having the same
version number (typically used for storing user options).
@
text
@d85 1
a85 1
static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules, BOOL *is_variable);
a123 1
  BOOL variable;
d131 1
a131 1
    err = static_ParseFile (base, base_len, &base_entries, NULL, NULL);
d135 1
a135 1
    err = static_ParseFile (changes, changes_len, &changes_entries, &rules, &variable);
d280 1
a280 2
          if ((!variable && (old_e->ver < new_e->ver)) ||
              (variable && (old_e->ver <= new_e->ver)))
d344 1
a344 1
    err = static_ParseFile (base, base_len, &base_entries, NULL, NULL);
d348 1
a348 1
    err = static_ParseFile (changes, changes_len, &changes_entries, NULL, NULL);
d429 1
a429 1
		entry list, rules lists and variable-entry-flag pointers
d431 1
a431 1
Note:		Rules lists and variable-entry pointers references are optional (NULL => don't use)
d435 1
a435 1
static _kernel_oserror *static_ParseFile (const char *file, int len, entry **first_entry_p, rule_set *rules, BOOL *is_variable)
a445 1
  BOOL found_Variable = FALSE;
a467 6
      
      if (!err) err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, start, "|Variable", 1, &diff);
      if (!err && diff == 0)
      {
        found_Variable = TRUE;
      }
a511 6
  }
  
  /* Return is_variable if appropriate */
  if (is_variable != NULL)
  {
    *is_variable = found_Variable;
@

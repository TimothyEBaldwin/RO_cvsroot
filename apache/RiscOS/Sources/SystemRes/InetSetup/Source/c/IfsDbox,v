head	1.11;
access;
symbols
	Source-0_59:1.11
	Source-0_58:1.11
	Source-0_57:1.11
	Source-0_56:1.10
	Source-0_55:1.10
	Source-0_54:1.10
	Source-0_53:1.10
	Source-0_52:1.10
	Source-0_51:1.10
	Source-0_50:1.9
	Source-0_49:1.8
	InetSetup-0_49:1.8
	InetSetup-0_48:1.8
	InetSetup-0_47:1.7
	InetSetup-0_46:1.7
	InetSetup-0_45:1.7
	InetSetup-0_44:1.6
	InetSetup-0_43:1.5
	InetSetup-0_42:1.5
	InetSetup-0_41:1.5
	InetSetup-0_40:1.5
	InetSetup-0_39:1.5
	InetSetup-0_38:1.5
	InetSetup-0_37:1.5
	InetSetup-0_36:1.5
	InetSetup-0_35:1.5
	InetSetup-0_34:1.5
	InetSetup-0_33:1.5
	InetSetup-0_32:1.4
	InetSetup-0_31:1.4
	InetSetup-0_30:1.4
	InetSetup-0_29:1.4
	StrongARM_merge:1.1.4.1
	sbrodie_InetSetup_dev_merge:1.2.2.2.2.1
	Daytona_merge:1.2
	Ursula_merge:1.2.2.2
	InetSetup-0_28:1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.2.2.2
	Ursula_RiscPC:1.2.2.2.0.4
	InetSetup-0_22-1_1_2_4:1.2.2.2
	InetSetup-0_22-1_1_2_3_2_1:1.2.2.2.2.1
	sbrodie_InetSetup_dev-1_1_2_3:1.2.2.2.0.2
	sbrodie_InetSetup_dev-1_1_2_3_bp:1.2.2.2
	rthornb_UrsulaBuild-19Aug1998:1.2.2.2
	UrsulaBuild_FinalSoftload:1.2.2.2
	rthornb_UrsulaBuild-12Aug1998:1.2.2.2
	aglover_UrsulaBuild-05Aug1998:1.2.2.2
	rthornb_UrsulaBuild-29Jul1998:1.2.2.2
	rthornb_UrsulaBuild-22Jul1998:1.2.2.2
	InetSetup-0_22-1_1_2_3:1.2.2.2
	rthornb_UrsulaBuild-15Jul1998:1.2.2.2
	rthornb_UrsulaBuild-07Jul1998:1.2.2.2
	rthornb_UrsulaBuild-17Jun1998:1.2.2.2
	rthornb_UrsulaBuild-03Jun1998:1.2.2.2
	rthornb_UrsulaBuild-27May1998:1.2.2.2
	rthornb_UrsulaBuild-21May1998:1.2.2.2
	bavison_InetSetup-0_25:1.2.2.2
	rthornb_UrsulaBuild_01May1998:1.2.2.1
	celkins_InetSetup_0_24:1.2.2.1
	InetSetup-0_22-1_1_2_2:1.2.2.1
	Daytona:1.2.0.4
	Daytona_bp:1.2
	Ursula:1.2.0.2
	Ursula_bp:1.2
	StrongARM:1.1.0.4
	RO_3_71:1.1.4.1;
locks; strict;
comment	@# @;


1.11
date	2015.12.11.20.56.41;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	PxajFBzwRK0dAzMy;

1.10
date	2013.12.31.18.10.21;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	Pca7rqboBSn8ujjx;

1.9
date	2013.10.03.20.07.09;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	iG3J3iBSU4UyZS7x;

1.8
date	2012.09.15.10.19.56;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	rCoFS9CCmPHm3Ckw;

1.7
date	2012.07.29.08.56.17;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	iMWPXwWp5h8n8rew;

1.6
date	2012.07.20.12.10.00;	author rgriffin;	state Exp;
branches;
next	1.5;
commitid	0DXnHqDQjQ2Kuidw;

1.5
date	2002.12.19.20.31.28;	author srevill;	state Exp;
branches;
next	1.4;

1.4
date	99.08.11.14.38.05;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.08.10.16.05.01;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	97.05.06.17.27.18;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.30.18.43.24;	author kbracey;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.2.2.1
date	97.11.18.16.08.41;	author dbrown;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	98.05.18.14.56.56;	author bavison;	state Exp;
branches
	1.2.2.2.2.1;
next	;

1.2.2.2.2.1
date	98.09.02.11.36.59;	author sbrodie;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.30.18.43.25;	author kbracey;	state Exp;
branches;
next	;

1.1.4.1
date	97.05.06.17.11.04;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Be more helpful when no hostname is set
Rather than explaining in a wordy error box how to get to the hostname dialogue, rephrase the diagnosis message to say that a hostname is required, then simply open the dialogue with the caret in the box to resolve the problem.
Implements ticket #406.
Also change the top level icon label for AUN to say Econet, since that makes more sense alongside Access and Internet (which are protocols). The interactive help introduces the term AUN for some context (as before).

Messages: Rephrased error box text.
Res: Rephrased AUN option.
Diagnose.c: Open the hostname window when no hostname is set.
IfsDbox.c/Main.c/Main.h: Rename OpenWindowFromIcon() to a more Toolboxey show_window_from_component().

Version 0.57. Tagged as 'Source-0_57'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <stdio.h>

#include "window.h"
#include "gadget.h"
#include "label.h"
#include "button.h"
#include "optionbutton.h"
#include "ActionButton.h"
#include "writablefield.h"
#include "radiobutton.h"
#include "displayfield.h"
#include "slider.h"
#include "Territory.h"

#include "event.h"
#include "Load.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Main.h"
#include "ModUtils.h"
#include "Versions.h"

#include "socklib.h"
#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/socket.h"
#include "sys/sockio.h"
#include "net/if.h"
#include "netinet/in.h"
#include "net/route.h"
#include "arpa/inet.h"

#include "my_swis.h"

#ifdef PlugIn
extern toolbox_o InternetObject;
#endif
extern toolbox_o InterfacesObject;
toolbox_o interface_object[16];
toolbox_o interface_statistics[16];
toolbox_c interface_addrtype[16];
static struct
{
    struct in_addr ip;
    struct in_addr gateway;
    struct in_addr mask;
    struct in_addr remote;
    unsigned long  tx_sum;
    unsigned long  rx_sum;
    unsigned char *eui_ptr;
    struct
    {
        unsigned char st_interface_type;
        unsigned char st_link_status;
        unsigned char st_link_polarity;
    } live;
#define HAS_CHANGED(thing) (init || (interface_lastlive[i].thing != (thing)))
#define NOTE_CHANGE(thing) (interface_lastlive[i].thing = (thing))
} interface_lastlive[16];

static void FillInterfaceDbox(toolbox_o, int);
static void FillStatisticsDbox(int, const Dib *, struct in_addr, osbool);
static bool FillStatisticsDboxes(wimp_event_no, wimp_block *, toolbox_block *, void *);
static bool ifs_enable_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool ifs_close_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_button_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_option_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool ifs_action_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_action_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_close_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool default_netmask_handler(bits, toolbox_action *, toolbox_block *, void *);

void MakeIfsDbox(toolbox_block *id)
{
    int i, w;
    int label_width = 80, close_width;
    int name_width = 0, config_width, stats_width;
    os_box box;
    toolbox_position pos;
#ifndef PlugIn
    toolbox_resource_file_object *obj;
    window_object *win;
#endif
#ifdef OSLib_4_8
    static my_gadget_OBJECT(4) g;
#else
    static gadget_OBJECT(4) g;
#endif

    InterfacesObject = toolbox_create_object(0, (toolbox_id) "Interfaces");
    event_register_toolbox_handler (InterfacesObject, action_ACTION_BUTTON_SELECTED, ifs_action_handler, 0);

    for (i=0; i < interfaces; i++)
    {
        /* RISC OS 3.5 SWI */
        if (WimpVersion >= 350) w = wimptextop_string_width(interface_location[i], 0);
        else w = strlen(interface_location[i]) * 16;
        if (w > label_width) label_width = w;

        if (WimpVersion >= 350) w = wimptextop_string_width(interface_name[i], 0);
        else w = strlen(interface_name[i]) * 16;
        if (w > name_width) name_width = w;
    }

    label_width += 12;
    name_width += 24 + 44;
    if (WimpVersion >= 350) config_width = wimptextop_string_width(msgs_lookup("Conf"), 0) + 32;
    else config_width = strlen(msgs_lookup("Conf")) * 16 + 32;
    if (WimpVersion >= 350) stats_width = wimptextop_string_width(msgs_lookup("Stat"), 0) + 32;
    else stats_width = strlen(msgs_lookup("Stat")) * 16 + 32;

    gadget_get_bbox(0, InterfacesObject, ifs_Close, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;
    box.x1 = 12 + label_width + 8 + name_width + 8 + config_width + 8 + stats_width;
    box.x0 = box.x1 - close_width;

    gadget_move_gadget(0, InterfacesObject, ifs_Close, &box);

    for (i = 0; i < interfaces; i++)
    {
        int have_driver;
        char buffer[256];

        sprintf(buffer, "System:Modules.Network.%s", interface_filename[i]);
        have_driver = RMFind(interface_module[i], buffer, interface_version[i]);

        /* Location label */
        g.flags = label_NO_BOX | label_RJUSTIFIED;
        if (!have_driver)
            g.flags |= gadget_FADED;
        g.class_no_and_size = class_LABEL;
        g.bbox.x0 = 12;
        g.bbox.x1 = 12 + label_width;
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 1;
        g.help_message = 0;
        g.help_limit = 0;
#ifdef OSLib_4_8
        ((label_object *) g.gadget)->label = interface_location[i];
#else
        ((label_gadget *) g.gadget)->label = interface_location[i];
#endif
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        /* Should the conf/stat buttons be faded or not? */
        g.flags = actionbutton_IS_LOCAL;

        if (interface_address[i][0] == '\0' &&
            interface_addrtype[i] == 0 ||
            !have_driver)
            g.flags |= gadget_FADED;

        /* PPP will allow blank fields so gadget will not be faded if interface type is PPP and it was found on startup */
        if (interface_is_pp[i] == 2 &&
            interface_has_section[i]) g.flags &= ~gadget_FADED;

        /* Add the configure button for each interface */
        g.class_no_and_size = class_ACTION_BUTTON;
        g.bbox.x0 = 12 + label_width + 8 + name_width + 8;
        g.bbox.x1 = g.bbox.x0 + config_width;
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 2;
        sprintf(buffer, msgs_lookup("IfsHelp1"), interface_name[i]);
        g.help_message = buffer;
        g.help_limit = strlen(buffer)+1;
#ifdef OSLib_4_8
        ((actionbutton_object *) g.gadget)->text = msgs_lookup("Conf");
        ((actionbutton_object *) g.gadget)->text_limit =
          strlen(((actionbutton_object *) g.gadget)->text) + 1;
        ((actionbutton_object *) g.gadget)->click_show = 0;
        ((actionbutton_object *) g.gadget)->action = 0;
#else
        ((actionbutton_gadget *) g.gadget)->text = msgs_lookup("Conf");
        ((actionbutton_gadget *) g.gadget)->text_limit =
          strlen(((actionbutton_gadget *) g.gadget)->text) + 1;
        ((actionbutton_gadget *) g.gadget)->click_show = 0;
        ((actionbutton_gadget *) g.gadget)->action = 0;
#endif
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        /* Add the statistics button for each interface */
        g.class_no_and_size = class_ACTION_BUTTON;
        g.bbox.x0 = 12 + label_width + 8 + name_width + 8 + config_width + 8;
        g.bbox.x1 = g.bbox.x0 + stats_width;
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 3;
        sprintf(buffer, msgs_lookup("IfsHelp3"), interface_name[i]);
        g.help_message = buffer;
        g.help_limit = strlen(buffer)+1;
#ifdef OSLib_4_8
        ((actionbutton_object *) g.gadget)->text = msgs_lookup("Stat");
        ((actionbutton_object *) g.gadget)->text_limit =
          strlen(((actionbutton_object *) g.gadget)->text) + 1;
        ((actionbutton_object *) g.gadget)->click_show = 0;
        ((actionbutton_object *) g.gadget)->action = 0;
#else
        ((actionbutton_gadget *) g.gadget)->text = msgs_lookup("Stat");
        ((actionbutton_gadget *) g.gadget)->text_limit =
          strlen(((actionbutton_gadget *) g.gadget)->text) + 1;
        ((actionbutton_gadget *) g.gadget)->click_show = 0;
        ((actionbutton_gadget *) g.gadget)->action = 0;
#endif
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        g.flags = 1; /* Generate events */
        if (!have_driver)
            g.flags |= gadget_FADED;
        else if (Set(interface_address[i]) || interface_addrtype[i])
            g.flags |= 4; /* Selected */

        /* PPP will allow blank fields so gadget will be ticked if interface type is PPP and it was found on startup*/
        if (interface_is_pp[i] == 2 &&
            interface_has_section[i]) g.flags |= 4; /* Selected */

        /* Add the enable option for each interface */
        g.class_no_and_size = class_OPTION_BUTTON;
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + name_width;
        g.bbox.y1 = -8 - (52+8) * i - 4;
        g.bbox.y0 = g.bbox.y1 - 44;
        g.cmp = (i << 8) + 4;
        g.help_message = msgs_lookup("IfsHelp2");
        g.help_limit = strlen(g.help_message)+1;
#ifdef OSLib_4_8
        ((optionbutton_object *) g.gadget)->label = interface_name[i];
        ((optionbutton_object *) g.gadget)->label_limit = strlen(interface_name[i]) + 1;
        ((optionbutton_object *) g.gadget)->action = 0;
#else
        ((optionbutton_gadget *) g.gadget)->label = interface_name[i];
        ((optionbutton_gadget *) g.gadget)->label_limit = strlen(interface_name[i]) + 1;
        ((optionbutton_gadget *) g.gadget)->action = 0;
#endif
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        /* Create copies of the respective windows to open */
        interface_object[i] = toolbox_create_object(0, (toolbox_id)
                                (interface_is_pp[i] ? "InterfacePP" : "Interface"));
        interface_statistics[i] = toolbox_create_object(0, (toolbox_id)
                                                                      "ShowStat");
        sprintf(buffer, "%s: %s", interface_location[i], interface_name[i]);
        window_set_title(0, interface_object[i], buffer);
        window_set_title(0, interface_statistics[i], buffer);

        /* Modify stats window for PPP or not */
        if (interface_is_pp[i])
        {
            window_remove_gadget(0, interface_statistics[i], stat_HWAddr);
            gadget_set_help_message(0, interface_statistics[i], stat_DisplayHWRemAddr,
                                    msgs_lookup("HRemAddr"));
        }
        else
        {
            window_remove_gadget(0, interface_statistics[i], stat_RemAddr);
            gadget_set_help_message(0, interface_statistics[i], stat_DisplayHWRemAddr,
                                    msgs_lookup("HHWAddr"));
        }

        /* Associate events with the new gadgets */
        FillInterfaceDbox(interface_object[i], i);
        event_register_toolbox_handler(interface_object[i],
                                       action_RADIO_BUTTON_STATE_CHANGED,
                                       if_button_handler, (void *) i);
        event_register_toolbox_handler(interface_object[i],
                                       action_OPTION_BUTTON_STATE_CHANGED,
                                       if_option_handler, (void *) i);
        event_register_toolbox_handler(interface_object[i],
                                       action_ACTION_BUTTON_SELECTED,
                                       if_action_handler, (void *) i);
        event_register_toolbox_handler(interface_statistics[i],
                                       action_WINDOW_DIALOGUE_COMPLETED,
                                       if_close_handler, NULL);
    }

    event_register_toolbox_handler(InterfacesObject,
                                   action_OPTION_BUTTON_STATE_CHANGED,
                                   ifs_enable_handler, 0);

    event_register_toolbox_handler(InterfacesObject,
                                   action_WINDOW_DIALOGUE_COMPLETED,
                                   ifs_close_handler, 0);

    event_register_toolbox_handler(event_ANY,
                                   action_DefaultNetmask,
                                   default_netmask_handler, 0);

    /* Fake a first fill */
    FillStatisticsDboxes(wimp_NULL_REASON_CODE, NULL, NULL, NULL);
    event_register_wimp_handler(event_ANY, wimp_NULL_REASON_CODE, FillStatisticsDboxes, 0);

    if (id)
    {
#ifdef PlugIn
      wimp_window_state state;
      show_window_from_component(InterfacesObject, InternetObject, internet_Interfaces);
      state.w = window_get_wimp_handle (0, InterfacesObject);
      wimp_get_window_state (&state);
      pos.full.visible.x0 = state.visible.x0;
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + name_width + 8 + config_width + 8 + stats_width + 12;
      pos.full.visible.y1 = state.visible.y1;
      pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
      pos.full.xscroll = state.xscroll;
      pos.full.yscroll = state.yscroll;
      pos.full.next = wimp_TOP;

      toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                          id->this_obj, id->this_cmp);
#else
      obj = (toolbox_resource_file_object *) toolbox_template_look_up(0, "Interfaces");
      win = (window_object *) obj->object;
  
      pos.full.visible.x0 = win->window.visible.x0;
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + name_width + 8 + config_width + 8 + stats_width + 12;
      pos.full.visible.y1 = win->window.visible.y1;
      pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
      pos.full.xscroll = win->window.xscroll;
      pos.full.yscroll = win->window.yscroll;
      pos.full.next = wimp_TOP;

      toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                          id->this_obj, id->this_cmp);
#endif
    }
}

static void FillInterfaceDbox(toolbox_o o, int i)
{
    if (interface_addrtype[i] == if_FromHostname)
        /* Because host name might have been changed... */
        writablefield_set_value(0, o, if_Address, HostName);
    else
        writablefield_set_value(0, o, if_Address, interface_address[i]);
    writablefield_set_value(0, o, if_Netmask, interface_netmask[i]);
    if (interface_is_pp[i])
        writablefield_set_value(0, o, if_LinkAddr, interface_linkaddr[i]);
    optionbutton_set_state(0, o, if_Primary, primary_interface == i);
    if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_RevARP || interface_addrtype[i] == if_DHCP)
    {
        char *msg;
        switch (interface_addrtype[i])
        {
           case if_BOOTP: msg = "BOOTP"; break;
           case if_DHCP: msg= "DHCP"; break;
           default: msg = "RevARP"; break;
        }
        /* RG: I believe the netmask box should be faded for BOOTP/DHCP	*/
        if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_DHCP)
        {
            gadget_set_flags(0, o, if_Netmask, gadget_FADED);
            window_set_default_focus(0, o, (toolbox_c) -2);
        }
        gadget_set_flags(0, o, if_ICMP, 0);
        writablefield_set_value(0, o, if_Address, msgs_lookup(msg));
    }

    if (interface_addrtype[i] == 0)
        interface_addrtype[i] = if_Manual;

    radiobutton_set_state(0, o, interface_addrtype[i], TRUE);

#ifdef OSLib_4_8
    if (!my_radiobutton_get_state(0, o, if_Manual, 0))
        gadget_set_flags(0, o, if_Address, gadget_FADED);
#else
    if (!radiobutton_get_state(0, o, if_Manual, 0))
        gadget_set_flags(0, o, if_Address, gadget_FADED);
#endif

    if (!interface_is_pp[i])
        gadget_set_flags(0, o, if_FromCMOS, CMOSIP ? 0 : gadget_FADED);

    if (!interface_is_pp[i] && !Exists("Inet:bin.IfRConfig"))
    {
        gadget_set_flags(0, o, if_RevARP, gadget_FADED);
        gadget_set_flags(0, o, if_BOOTP, gadget_FADED);
    }

    if (!interface_is_pp[i] && (!RMFind("DHCP", "System:Modules.Network.DHCP", v_DHCP) ||
                                !RMFind("Internet", "System:Modules.Network.Internet", v_InternetDHCP)))
    {
        gadget_set_flags(0, o, if_DHCP, gadget_FADED);
    }

    if (strcmp(interface_netmask[i], "zzzz") == 0)
    {
        strcpy(interface_netmask[i], "default");
        writablefield_set_value(0, o, if_Netmask, msgs_lookup("ICMPReq"));
        gadget_set_flags(0, o, if_Netmask, gadget_FADED);
        if (!interface_is_pp[i])
            optionbutton_set_state(0, o, if_ICMP, TRUE);
        window_set_default_focus(0, o, (toolbox_c) -2);
    }

    if (strcmp(interface_unit[i], "ec0") == 0)
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
    else if (interfaces == 1)
    {
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
        optionbutton_set_state(0, o, if_Primary, TRUE);
    }
}

static bool ifs_close_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    int i;

    for (i = 0; i < interfaces; i++)
    {
        toolbox_hide_object(0, interface_object[i]);
        toolbox_hide_object(0, interface_statistics[i]);
    }

    return FALSE;
}

static bool ifs_enable_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *optevent =
                     (optionbutton_action_state_changed *) &event->data;

    gadget_set_flags(0, id->this_obj, id->this_cmp - 1 /* Stat */, optevent->on ? 0 : gadget_FADED);
    gadget_set_flags(0, id->this_obj, id->this_cmp - 2 /* Conf */, optevent->on ? 0 : gadget_FADED);
    if (!optevent->on)
    {
        toolbox_hide_object(0, interface_object[id->this_cmp >> 8]);
        interface_has_section[id->this_cmp >> 8] = 0;   /* ppp will NOT be saved */
        /*
         * RG: If an interface is disabled, set its addrype to 'manual' to prevent
         * an RMEnsure command being written to the setup file.
        */
        interface_addrtype[id->this_cmp >> 8] = 6;
    } else
    {
        interface_has_section[id->this_cmp >> 8] = 1;   /* ppp will be saved */
    }


    return TRUE;
}

static bool ifs_action_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    int i = (id->this_cmp) >> 8;
    wimp_poll_flags mask;

    switch (id->this_cmp & 0xFF)
    {
        case 2: /* Conf */
#ifdef PlugIn
            show_window_from_component(interface_object[i], InterfacesObject, id->this_cmp);
#else
            toolbox_show_object(0, interface_object[i], toolbox_POSITION_DEFAULT, 0, id->this_obj, id->this_cmp);
#endif
            break;
        case 3: /* Stat */
#ifdef PlugIn
            show_window_from_component(interface_statistics[i], InterfacesObject, id->this_cmp);
#else
            toolbox_show_object(0, interface_statistics[i], toolbox_POSITION_DEFAULT, 0, id->this_obj, id->this_cmp);
#endif
            /* One or more stats windows open, enable polling */
            event_get_mask(&mask);
            event_set_mask(mask & ~wimp_MASK_NULL);
            break;
    }
    return TRUE;
}

/****************************************************************************
 *
 * Interface configuration handlers
 *
 ****************************************************************************/
static bool if_action_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    int i = (int) handle;

    if (event->flags & actionbutton_SELECTED_DEFAULT)
    {
        writablefield_get_value(0, interface_object[i], if_Address,
                                interface_address[i], sizeof interface_address[i]);
        writablefield_get_value(0, interface_object[i], if_Netmask,
                                interface_netmask[i], sizeof interface_netmask[i]);
        if (interface_is_pp[i])
            writablefield_get_value(0, interface_object[i], if_LinkAddr,
                                    interface_linkaddr[i], sizeof interface_linkaddr[i]);
        if (optionbutton_get_state(0, interface_object[i], if_Primary))
            primary_interface = i;
        else if (primary_interface == i)
            primary_interface = -1;
#ifdef OSLib_4_8
        my_radiobutton_get_state(0, interface_object[i], if_Manual,
                              &interface_addrtype[i]);
#else
        radiobutton_get_state(0, interface_object[i], if_Manual,
                              &interface_addrtype[i]);
#endif

        return TRUE;
    }
    if (event->flags & actionbutton_SELECTED_CANCEL)
    {
        toolbox_action action;
        radiobutton_action_state_changed *r =
                          (radiobutton_action_state_changed *) &action.data;
        optionbutton_action_state_changed *opt =
                          (optionbutton_action_state_changed *) &action.data;

        writablefield_set_value(0, id->this_obj, if_Address, interface_address[i]);
        writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[i]);
        if (interface_is_pp[i])
            writablefield_set_value(0, id->this_obj, if_LinkAddr, interface_linkaddr[i]);

        action.size = 16 + 8;
        action.action_no = action_RADIO_BUTTON_STATE_CHANGED;
        action.flags = radiobutton_STATE_CHANGED_SELECT;
        r->on = FALSE;
#ifdef OSLib_4_8
        my_radiobutton_get_state(0, id->this_obj, if_Manual, &r->previous_on);
#else
        radiobutton_get_state(0, id->this_obj, if_Manual, &r->previous_on);
#endif
        radiobutton_set_state(0, id->this_obj, interface_addrtype[i], TRUE);
        toolbox_raise_toolbox_event(0, id->this_obj, r->previous_on, &action);

        r->on = TRUE;
        toolbox_raise_toolbox_event(0, id->this_obj, interface_addrtype[i], &action);

        action.size = 16 + 4;
        action.action_no = action_OPTION_BUTTON_STATE_CHANGED;
        action.flags = optionbutton_STATE_CHANGED_SELECT;
        opt->on = primary_interface == i;
        optionbutton_set_state(0, id->this_obj, if_Primary, opt->on);
        toolbox_raise_toolbox_event(0, id->this_obj, if_Primary, &action);
        return TRUE;
    }
    return FALSE;
}

static bool if_button_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    radiobutton_action_state_changed *r = (radiobutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_FromHostname:
        if (r->on)
        {
            int i;
            writablefield_set_value(0, id->this_obj, if_Address, HostName);
            gadget_set_flags(0, id->this_obj, if_Netmask, 0);
            for (i = 0; i < interfaces; i++)
#ifdef OSLib_4_8
                if (i != (int) handle &&
                       my_radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
#else
                if (i != (int) handle &&
                       radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
#endif
                {
                    radiobutton_set_state(0, interface_object[i], if_Manual, TRUE);
                    gadget_set_flags(0, interface_object[i], if_Address, 0);
                }
        }
        break;

      case if_Manual:
        gadget_set_flags(0, id->this_obj, if_Address, r->on ? 0 : gadget_FADED);
        gadget_set_flags(0, id->this_obj, if_Netmask, 0);
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle]);
            if (toolbox_get_object_info(0, id->this_obj) & toolbox_INFO_SHOWING)
                gadget_set_focus(0, id->this_obj, if_Address);
        }
        else
            writablefield_get_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle],
                                    sizeof interface_address[(int) handle]);
        break;

      case if_RevARP:
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("RevARP"));
            if (r->previous_on != if_RevARP)
            {
                gadget_set_flags(0, id->this_obj, if_ICMP, 0);
                if (optionbutton_get_state(0, id->this_obj, if_ICMP))
                {
                    gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
                }
                else
                {
                    gadget_set_flags(0, id->this_obj, if_Netmask, 0);
                    gadget_set_focus(0, id->this_obj, if_Netmask);
                }
            }
        }
        break;

      case if_DHCP:
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("DHCP"));
            writablefield_set_value(0, id->this_obj, if_Netmask, "default");
            gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
            window_set_default_focus(0, id->this_obj, (toolbox_c) -2);
        }
        break;

      case if_BOOTP:
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("BOOTP"));
            writablefield_set_value(0, id->this_obj, if_Netmask, "default");
            gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
            window_set_default_focus(0, id->this_obj, (toolbox_c) -2);
        }
        break;

      case if_FromCMOS:
        if (r->on)
        {
            /* Silliness */
            struct in_addr in;
            in.s_addr = CMOSIP;
            writablefield_set_value(0, id->this_obj, if_Address, inet_ntoa(in));
        }
    }


    if ( ((id->this_cmp != if_DHCP) && (id->this_cmp != if_BOOTP))
         &&
         ((r->previous_on == if_DHCP) || (r->previous_on == if_BOOTP))
       )
    {
       writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
    }


    if ((id->this_cmp != if_RevARP) && (r->previous_on == if_RevARP))
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, gadget_FADED);
//        gadget_set_flags(0, id->this_obj, if_Netmask, 0);
//        window_set_default_focus(0, id->this_obj, if_Address);
        if (optionbutton_get_state(0, id->this_obj, if_ICMP))
        {
            optionbutton_set_state(0, id->this_obj, if_ICMP, FALSE);
            if ((id->this_cmp == if_DHCP) && (id->this_cmp == if_BOOTP))
            {
                writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
            }
        }
    }

    return TRUE;
}

static bool if_option_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *r = (optionbutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_Primary:
        if (r->on)
        {
            int i;

            for (i = 0; i < interfaces; i++)
            {
                if (interface_object[i] == id->this_obj)
                    continue;

                optionbutton_set_state(0, interface_object[i], if_Primary, FALSE);
            }
        }
        break;
      case if_ICMP:
        if (r->on)
        {
            xwimp_set_caret_position(window_get_wimp_handle(0, id->this_obj),
                                     (wimp_i) -1, 0, 0, (1<<25), 0);
            gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
            writablefield_get_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle], sizeof interface_netmask[(int) handle]);
            writablefield_set_value(0, id->this_obj, if_Netmask, msgs_lookup("ICMPReq"));
            window_set_default_focus(0, id->this_obj, (toolbox_c) -2);
        }
        else
        {
            gadget_set_flags(0, id->this_obj, if_Netmask, 0);
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
            gadget_set_focus(0, id->this_obj, if_Netmask);
            window_set_default_focus(0, id->this_obj, if_Address);
        }
        break;
    }

    return TRUE;
}

static bool default_netmask_handler(bits event_code, toolbox_action *event,
                                    toolbox_block *id, void *handle)
{
    writablefield_set_value(0, id->ancestor_obj, if_Netmask, "default");
    gadget_set_flags(0, id->ancestor_obj, if_Netmask, 0);
    xoptionbutton_set_state(0, id->ancestor_obj, if_ICMP, FALSE);

    return TRUE;
}

/****************************************************************************
 *
 * Interface statistics handlers
 *
 ****************************************************************************/

static bool if_close_handler(bits event_code, toolbox_action *event,
                             toolbox_block *id, void *handle)
{
    wimp_poll_flags mask;
    int i;

    /* A statistics box was closed, if it was the last, stop polling */
    for (i = 0; i < interfaces; i++)
    {
        if (toolbox_get_object_info(0, interface_statistics[i]) & toolbox_INFO_SHOWING)
        {
            return FALSE;
        }
    }
    event_get_mask(&mask);
    event_set_mask(mask | wimp_MASK_NULL);

    return FALSE;
}

static char *stat_to_string(unsigned long val, char *buff, const char *sep, const char *grp)
{
    char *in, *out, *rev;
    char  raw[10 + 1];
    char  grouped[20 + 1];
    int   count;

    in = raw + sprintf(raw, "%lu", val);
    out = grouped;
    do
    {
        /* As %lu can't output 255 chars, this deals with 'no grouping' too */
        for (count = 0; (count < *grp) && (in != raw); count++)
        {
            in--; *out = *in; out++;
        }

        /* Next group, unless it's a repeat group */
        if (grp[1]) grp++;
        if (in != raw) *out++ = *sep;
    } while (in != raw);

    /* Reverse result */
    rev = buff;
    do
    {
        out--; *rev = *out; rev++;
    } while (out != grouped);
    *rev = 0; /* Terminate */

    return buff;
}

static int stat_to_bargraph(osbool implemented,
                            unsigned long frames, unsigned long errors)
{
    if (implemented)
    {
        /* The bargraph is scaled 0-255 so divide by shifting until in range */
        while ((frames > UINT8_MAX) && errors)
        {
            frames = frames >> 1;
            errors = errors >> 1;
        }
    }
    else
    {
        errors = 0;
    }
    return (int)errors;
}

static void stat_gw_address(struct in_addr *gateway)
{
    int   route, sent, recv;
    int   seq, mask;
    pid_t pid;
    char *tail;
    union
    {
        struct
        {
            struct rt_msghdr hdr;
            struct sockaddr_in dest;
            struct sockaddr_in mask;
        } req;
        struct
        {
            struct rt_msghdr hdr;
            char   data[256];
        } rsp;
    } msg;
 
    /* Default to unset */
    gateway->s_addr = INADDR_ANY;

    /* Build a request to get the route to any INET address */
    pid = (pid_t)toolboxgetsysinfo_task();
    seq = 99;
    memset(&msg.req, 0, sizeof(msg.req));
    msg.req.hdr.rtm_msglen = sizeof(msg.req);
    msg.req.hdr.rtm_version = RTM_VERSION;
    msg.req.hdr.rtm_type = RTM_GET;
    msg.req.hdr.rtm_flags = RTF_UP | RTF_GATEWAY | RTF_HOST | RTF_STATIC;
    msg.req.hdr.rtm_pid = pid;
    msg.req.hdr.rtm_addrs = RTA_DST | RTA_NETMASK;
    msg.req.hdr.rtm_seq = seq;
    msg.req.dest.sin_len = sizeof(msg.req.dest);
    msg.req.dest.sin_family = AF_INET;
    msg.req.dest.sin_addr.s_addr = INADDR_ANY;
    msg.req.mask.sin_len = sizeof(msg.req.mask);
    msg.req.mask.sin_family = AF_INET;
    msg.req.mask.sin_addr.s_addr = INADDR_ANY;
 
    /* Send the request to the route table */
    route = socket(AF_ROUTE, SOCK_RAW, PF_INET);
    if (route < 0) return;
    sent = socketwrite(route, &msg.req, sizeof(msg.req));
    if (sent < 0) goto tidyup;
    if (sent != sizeof(msg.req))
    {
        goto tidyup;
    }
 
    /* Wait for the reply */
    do
    {
        memset(&msg.rsp, 0, sizeof(msg.rsp));
        recv = socketread(route, &msg.rsp, sizeof(msg.rsp));
        if (recv < 0) goto tidyup;
    } while ((msg.rsp.hdr.rtm_seq != seq) || (msg.rsp.hdr.rtm_pid != pid));
 
    if ((msg.rsp.hdr.rtm_version != RTM_VERSION) ||
        (msg.rsp.hdr.rtm_msglen > recv) ||
        (msg.rsp.hdr.rtm_errno != 0))
    {
        goto tidyup;
    }
 
    /* Walk over the results looking for the gateway */
    tail = msg.rsp.data;
    for (mask = 1; mask != 0; mask = mask << 1)
    {
        struct sockaddr *sa = (struct sockaddr *)tail;
        struct sockaddr_in *gw = (struct sockaddr_in *)tail;
 
        switch (msg.rsp.hdr.rtm_addrs & mask)
        {
            case RTA_GATEWAY:
                /* Bingo */
                gateway->s_addr = gw->sin_addr.s_addr;
                goto tidyup;
 
            case 0:
                /* Not returned in rtm_addrs */
                break;
 
#define ALIGN(k) ((char *)(((uintptr_t)(k) + 3) & ~3))
            default:
                /* Skip over something we're not interested in */
                if (sa->sa_len)
                {
                    tail = ALIGN(tail + sa->sa_len);
                }
                else
                {
                    tail = ALIGN(tail + sizeof(sa->sa_len));
                }
                break;
        }
    }

tidyup:
    socketclose(route);
}

static void stat_if_addresses(const char *name, struct in_addr *ip,
                              struct in_addr *mask, struct in_addr *remote)
{
    int    datagram;
    struct ifreq ifr;

    /* Ensure everything returns 0 => 'Unset' in case of error */
    ip->s_addr = INADDR_ANY;
    mask->s_addr = INADDR_ANY;
    remote->s_addr = INADDR_ANY;

    strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
    datagram = socket(AF_INET, SOCK_DGRAM, PF_UNSPEC);
    if (datagram < 0) return;

    /* Get the addresses for the given ifname */
    if (socketioctl(datagram, SIOCGIFADDR, &ifr) >= 0)
    {
        ip->s_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
    } 
    if (socketioctl(datagram, SIOCGIFDSTADDR, &ifr) >= 0)
    {
        remote->s_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
    } 
    if (socketioctl(datagram, SIOCGIFNETMASK, &ifr) >= 0)
    {
        mask->s_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
    }

    socketclose(datagram);
}

static bool FillStatisticsDboxes(wimp_event_no event_code, wimp_block *event,
                                 toolbox_block *id, void *handle)
{
    int   i;
    char  unit[16];
    const Dib   *devices[16];
    const ChDib *chd, *prev;
    struct in_addr gateway;

    /* Some defaults, incase the driver is not yet loaded */
    for (i = 0; i < interfaces; i++)
    {
        devices[i] = NULL;
    }

    /* Request the default gateway once for all interfaces */
    stat_gw_address(&gateway);

    service_enumerate_network_drivers(&chd);
    while (chd != NULL)
    {
        /* DCI4 requires the Dib to be static storage, but the chain is
         * from the RMA. Match them to interfaces here so they can be freed
         * before any error-causing Toolbox functions might cause an RMA leak.
         */
        sprintf(unit, "%s%u", chd->chd_dib->dib_name, chd->chd_dib->dib_unit);
        for (i = 0; i < interfaces; i++)
        {
            if (strcmp(unit, interface_unit[i]) == 0) devices[i] = chd->chd_dib;
        }
        prev = chd;
        chd = chd->chd_next;
        xosmodule_free((void *)prev);
    }

    for (i = 0; i < interfaces; i++)
    {
        FillStatisticsDbox(i, devices[i], gateway, id == NULL);
    }

    return TRUE;
}

static void FillStatisticsDbox(int i, const Dib *d, struct in_addr gateway, osbool init)
{
    struct stats imp, live;
    const char *sep;
    const char *grp;
    char        buffer[128];
    toolbox_o   o;
    int         mbps = 0;
    osbool      implemented;
    unsigned long  tx_sum, rx_sum;
    unsigned char *eui_ptr;
    struct in_addr ip, mask, remote;

    sep = territory_read_string_symbols(territory_CURRENT, territory_SYMBOL_GROUP_SEPARATOR);
    grp = territory_read_string_symbols(territory_CURRENT, territory_SYMBOL_GROUPING_LIST);
    o = interface_statistics[i];

    /* Ask this interface's driver for some stats for the i'th interface */
    if (d == NULL)
    {
        memset(&imp, 0, sizeof(imp));
    }
    else
    {
        network_driver_implemented_stats(d->dib_swibase, d->dib_unit, &imp);
        network_driver_return_stats(d->dib_swibase, d->dib_unit, &live);
    }

    /* Transmit statistics */
    tx_sum = live.st_tx_frames + live.st_tx_general_errors;
    if (HAS_CHANGED(tx_sum))
    {
        NOTE_CHANGE(tx_sum);
        displayfield_set_value(0, o, stat_DisplayTxFrames, (imp.st_tx_frames == UINT32_MAX)
                               ? stat_to_string(live.st_tx_frames, buffer, sep, grp)
                               : msgs_lookup("UnImp"));
        displayfield_set_value(0, o, stat_DisplayTxErrors, (imp.st_tx_general_errors == UINT32_MAX)
                               ? stat_to_string(live.st_tx_general_errors, buffer, sep, grp)
                               : msgs_lookup("UnImp"));
        implemented = (imp.st_tx_frames == UINT32_MAX) && (imp.st_tx_general_errors == UINT32_MAX);
        gadget_set_flags(0, o, stat_TxBarGraph, implemented ? 0 : gadget_FADED);
        slider_set_value(0, o, stat_TxBarGraph,
                         stat_to_bargraph(implemented, live.st_tx_frames, live.st_tx_general_errors));
    }

    /* Receive statistics */
    rx_sum = live.st_rx_frames + live.st_rx_general_errors;
    if (HAS_CHANGED(rx_sum))
    {
        NOTE_CHANGE(rx_sum);
        displayfield_set_value(0, o, stat_DisplayRxFrames, (imp.st_rx_frames == UINT32_MAX)
                               ? stat_to_string(live.st_rx_frames, buffer, sep, grp)
                               : msgs_lookup("UnImp"));
        displayfield_set_value(0, o, stat_DisplayRxErrors, (imp.st_rx_general_errors == UINT32_MAX)
                               ? stat_to_string(live.st_rx_general_errors, buffer, sep, grp)
                               : msgs_lookup("UnImp"));
        implemented = (imp.st_rx_frames == UINT32_MAX) && (imp.st_rx_general_errors == UINT32_MAX); 
        gadget_set_flags(0, o, stat_RxBarGraph, implemented ? 0 : gadget_FADED);
        slider_set_value(0, o, stat_RxBarGraph,
                         stat_to_bargraph(implemented, live.st_rx_frames, live.st_rx_general_errors));
    }

    /* Link flags */
    if (HAS_CHANGED(live.st_link_status) || HAS_CHANGED(live.st_link_polarity))
    {
        NOTE_CHANGE(live.st_link_polarity);
        NOTE_CHANGE(live.st_link_status);
        button_set_value(0, o, stat_Polarity, (imp.st_link_polarity == UINT8_MAX)
                         ? (live.st_link_polarity & ST_LINK_POLARITY_CORRECT) ? "yes"
                                                                              : "no"
                         : "dontcare");
        button_set_value(0, o, stat_FullDuplex, (imp.st_link_status == UINT8_MAX)
                         ? (live.st_link_status & ST_STATUS_FULL_DUPLEX) ? "yes"
                                                                         : "no"
                         : "dontcare");
        button_set_value(0, o, stat_OK, (imp.st_link_status == UINT8_MAX)
                         ? (live.st_link_status & ST_STATUS_OK) ? "yes"
                                                                : "no"
                         : "dontcare");
        button_set_value(0, o, stat_Active, (imp.st_link_status == UINT8_MAX)
                         ? (live.st_link_status & ST_STATUS_ACTIVE) ? "yes"
                                                                    : "no"
                         : "dontcare");
    }

    /* Some network addresses */
    stat_if_addresses(interface_unit[i], &ip, &mask, &remote);
    if (HAS_CHANGED(ip.s_addr) || HAS_CHANGED(mask.s_addr))
    {
        NOTE_CHANGE(ip);
        NOTE_CHANGE(mask);
        displayfield_set_value(0, o, stat_DisplayIPAddr,
                               ip.s_addr == INADDR_ANY ? msgs_lookup("Unset")
                                                       : inet_ntoa(ip));
        displayfield_set_value(0, o, stat_DisplayNetmask,
                               mask.s_addr == INADDR_ANY ? msgs_lookup("Unset")
                                                         : inet_ntoa(mask));
    }
    if (HAS_CHANGED(gateway.s_addr))
    {
        NOTE_CHANGE(gateway);
        displayfield_set_value(0, o, stat_DisplayGateway,
                               gateway.s_addr == INADDR_ANY ? msgs_lookup("Unset")
                                                            : inet_ntoa(gateway));
    }

    /* PPP interface modifiers */
    if (interface_is_pp[i])
    {
        /* Remote address */
        if (HAS_CHANGED(remote.s_addr))
        {
            NOTE_CHANGE(remote);
            displayfield_set_value(0, o, stat_DisplayHWRemAddr,
                                   remote.s_addr == INADDR_ANY ? msgs_lookup("Unset")
                                                               : inet_ntoa(remote));
        }
    }
    else
    {
        /* Hardware address */
        eui_ptr = (d == NULL) ? NULL : d->dib_address;
        if (HAS_CHANGED(eui_ptr))
        {
            NOTE_CHANGE(eui_ptr);
            if (d == NULL)
            {
                strcpy(buffer, msgs_lookup("UnImp"));
            }
            else
            {
                sprintf(buffer, "%02X:%02X:%02X:%02X:%02X:%02X",
                        d->dib_address[0], d->dib_address[1], d->dib_address[2], 
                        d->dib_address[3], d->dib_address[4], d->dib_address[5]);
            }
            displayfield_set_value(0, o, stat_DisplayHWRemAddr, buffer);
        }
    }

    /* Set the speed */
    if (HAS_CHANGED(live.st_interface_type))
    {
        NOTE_CHANGE(live.st_interface_type);
        switch (live.st_interface_type)
        {
            case ST_TYPE_10BASE5:
            case ST_TYPE_10BASE2:
            case ST_TYPE_10BASET:
            case ST_TYPE_10BASE5N2:
            case ST_TYPE_10BASE2NT:
            case ST_TYPE_RSQUELCH10BASET:
            case ST_TYPE_10BASE5N2NT:
            case ST_TYPE_10BASEFX:
                mbps = 10;
                break;
    
            case ST_TYPE_100BASETX:
            case ST_TYPE_100BASEVG:
            case ST_TYPE_100BASET4:
            case ST_TYPE_100BASEFX:
                mbps = 100;
                break;
    
            case ST_TYPE_1000BASESX:
            case ST_TYPE_1000BASET:
            case ST_TYPE_1000BASELX:
            case ST_TYPE_1000BASECX:
                mbps = 1000;
                break;
        }
        if (interface_is_pp[i] || (mbps == 0) || (live.st_interface_type == UINT8_MAX))
        {
            strcpy(buffer, msgs_lookup("ActPP"));
        }
        else
        {
            sprintf(buffer, msgs_lookup("ActMb"), mbps);
        }
        button_set_value(0, o, stat_ActivitySpeed, buffer);
    }
}
@


1.10
log
@Workaround Internet module panic when gateway unset
With no gateway set this plugin would cause Internet to panic when trying to write to the routing socket.
Inspection of the logic inside Internet revealed a (dummy) netmask must be provided so it fails to route and doesn't end up trying to free a block it didn't malloc.

Tested with EtherY configured with no gateway, Internet module no longer quits.

Version 0.51. Tagged as 'Source-0_51'
@
text
@d315 1
a315 1
      OpenWindowFromIcon (InterfacesObject, InternetObject, internet_Interfaces);
d473 1
a473 1
            OpenWindowFromIcon (interface_object[i], InterfacesObject, id->this_cmp);
d480 1
a480 1
            OpenWindowFromIcon (interface_statistics[i], InterfacesObject, id->this_cmp);
@


1.9
log
@Add a live interface status/statistics view to the interface dialogue
This new button, 'status', to compliment the 'configure' button, shows various useful facts for an interface (packets, errors, link state, IP address) and updates every second.
Previously, obtaining this information required messing around with showstat or ifconfig at the command line.

Version 0.50. Tagged as 'Source-0_50'
@
text
@d830 1
d851 1
a851 1
    msg.req.hdr.rtm_addrs = RTA_DST;
d856 3
@


1.8
log
@Fix to work when DHCP doesn't support -p switch
The DHCP module uses OS_ReadArgs for switch matching, but in the CMHG table it strictly checks for max-args. The recently added '-p' switch therefore should not be output by !InetSetup when the available module doesn't support it.
Load.c: parse setup files with or without -p
Save.c: use RMFind() to figure out if -p is available, and omit it when not
Also
* Bumped up the !Internet version number in the comment block written out
* Make sure DHCP is plugged in during save (and unplugged if TCP/IP is actively disabled)
* Fixed the minimum DHCP version number, !InetSetup was always outputting -w even though that wasn't supported in the version that was being RMEnsure'd

Version 0.48. Tagged as 'InetSetup-0_48'
@
text
@d21 1
d23 1
a23 1
#include "actionbutton.h"
d26 3
d38 1
d40 4
d45 1
a49 1

d55 1
d57 18
d77 2
a80 1
//static bool ifs_show_handler(bits, toolbox_action *, toolbox_block *, void *);
a82 1
#ifdef PlugIn
a83 1
#endif
d85 1
a87 11
/*
 * Two possible styles of Interfaces dbox:
 *
 * 1)     Serial [       SLIP      ] []       { The original and still the worst! }
 *           NIC [ Beebug Ethernet ] []
 *
 * 2)     Serial [] SLIP            [ Configure... ]    { Somewhat more intuitive }
 *           NIC [] Beebug Ethernet [ Configure... ]
 */
#define IfsStyle 2

d92 1
a92 5
    #if IfsStyle == 1
    int button_width = 320;
    #elif IfsStyle == 2
    int button_width = 0, config_width;
    #endif
a105 1
#ifdef PlugIn
a106 1
#endif
d117 1
a117 1
        if (w > button_width) button_width = w;
a119 4
    #if IfsStyle == 1
    label_width += 12;
    button_width += 32;
    #elif IfsStyle == 2
d121 1
a121 1
    button_width += 24 + 44;
d124 2
a125 1
    #endif
d132 1
a132 5
    #if IfsStyle == 1
    box.x1 = 12 + label_width + 8 + button_width + 8 + 44;
    #elif IfsStyle == 2
    box.x1 = 12 + label_width + 8 + button_width + 8 + config_width;
    #endif
d145 1
d164 1
a166 2


d176 1
a176 1

d178 1
a178 5
        #if IfsStyle == 1
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + button_width;
        #elif IfsStyle == 2
        g.bbox.x0 = 12 + label_width + 8 + button_width + 8;
a179 1
        #endif
a186 4
        #if IfsStyle == 1
        ((actionbutton_object *) g.gadget)->text = interface_name[i];
        ((actionbutton_object *) g.gadget)->text_limit = strlen(interface_name[i])+1;
        #elif IfsStyle == 2
a189 1
        #endif
a192 4
        #if IfsStyle == 1
        ((actionbutton_gadget *) g.gadget)->text = interface_name[i];
        ((actionbutton_gadget *) g.gadget)->text_limit = strlen(interface_name[i])+1;
        #elif IfsStyle == 2
a195 1
        #endif
d201 22
a222 10
        interface_object[i] = toolbox_create_object(0, (toolbox_id)
                                (interface_is_pp[i] ? "InterfacePP" : "Interface"));

#ifndef PlugIn
        my_actionbutton_set_click_show(0,
                                       InterfacesObject,
                                       (i << 8) + 2,
                                       interface_object[i],
                                       0
                                      );
d224 1
d236 1
a237 4
        #if IfsStyle == 1
        g.bbox.x0 = g.bbox.x1 + 8;
        g.bbox.x1 = g.bbox.x0 + 44;
        #elif IfsStyle == 2
d239 1
a239 2
        g.bbox.x1 = g.bbox.x0 + button_width;
        #endif
d242 1
a242 1
        g.cmp = (i << 8) + 3;
a245 4
        #if IfsStyle == 1
        ((optionbutton_object *) g.gadget)->label = 0;
        ((optionbutton_object *) g.gadget)->label_limit = 0;
        #elif IfsStyle == 2
a247 1
        #endif
a249 4
        #if IfsStyle == 1
        ((optionbutton_gadget *) g.gadget)->label = 0;
        ((optionbutton_gadget *) g.gadget)->label_limit = 0;
        #elif IfsStyle == 2
a251 1
        #endif
d256 24
d290 3
a294 17
#ifndef PlugIn
    obj = (toolbox_resource_file_object *) toolbox_template_look_up(0, "Interfaces");
    win = (window_object *) obj->object;

    pos.full.visible.x0 = win->window.visible.x0;
    #if IfsStyle == 1
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + 44 + 12;
    #elif IfsStyle == 2
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + config_width + 12;
    #endif
    pos.full.visible.y1 = win->window.visible.y1;
    pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
    pos.full.xscroll = win->window.xscroll;
    pos.full.yscroll = win->window.yscroll;
    pos.full.next = wimp_TOP;
#endif

d307 3
a309 3
    /*event_register_toolbox_handler(InterfacesObject,
                                   action_WINDOW_ABOUT_TO_BE_SHOWN,
                                   ifs_show_handler, 0);*/
a310 2

#ifdef PlugIn
d313 1
d319 1
a319 5
      #if IfsStyle == 1
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + 44 + 12;
      #elif IfsStyle == 2
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + config_width + 12;
      #endif
a327 1
    }
d329 13
a341 3
    if (id)
        toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                            id->this_obj, id->this_cmp);
d343 1
a347 4
    char buffer[128];

    sprintf(buffer, "%s: %s", interface_location[i], interface_name[i]);
    window_set_title(0, o, buffer);
a422 17
#if 0
static bool ifs_show_handler(bits event_code, toolbox_action *event,
                             toolbox_block *id, void *handle)
{
    int i;

    /* Window module bug - we can't seem to set the flags above */
    for (i = 0; i < interfaces; i++)
        if (interface_address[i][0] == '\0')
            gadget_set_flags(0, InterfacesObject, (i << 8) + 2, gadget_FADED);
        else
            gadget_set_flags(0, InterfacesObject, (i << 8) + 2, 0);

    return TRUE;
}
#endif

d429 1
d431 2
d443 2
a444 1
    gadget_set_flags(0, id->this_obj, id->this_cmp - 1, optevent->on ? 0 : gadget_FADED);
a462 1
#ifdef PlugIn
d467 22
a488 1
    OpenWindowFromIcon (interface_object[i], InterfacesObject, id->this_cmp);
a490 1
#endif
d492 5
d739 435
@


1.7
log
@Employ bit 5 of TaskManager_Shutdown
Harmless on task managers that don't support it.
Uncurled some braces to match local style.
Don't compare "FILE *" with 0, uses NULL.
Switched out unused os_reset_old_machine assembler.

Version 0.45. Tagged as 'InetSetup-0_45'
@
text
@d400 1
a400 1
            !RMFind("Internet", "System:Modules.Network.Internet", v_InetDHCP)))
@


1.6
log
@Rmensure DHCP module if an interface is using DHCP, whether or not it's the primary interface.
Don't rmensure DHCP if interface is turned off.
Faded netmask box if DHCP or BOOTP are in use.
Call TaskManager_Shutdown instead of OS_Reset.
Removed call to osfscontrol_shutdown that was causing disc corruption on Raspberry Pi.

Version 0.44. Tagged as 'InetSetup-0_44'
@
text
@d368 2
a369 1
        if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_DHCP) {
@


1.5
log
@Changes to the greying out behaviour in the "Obtain IP address" dialogue
as it was a real mess,particularly the behaviour when DHCP was selected.
UK Res file overhaul.
You can now drag the AUNMap to an editor and it will be loaded.
New Sprites files.

Version 0.33. Tagged as 'InetSetup-0_33'
@
text
@d367 5
d462 5
@


1.4
log
@  DHCP support added.
Detail:
  The DHCP button in the interface configuration window is now unfaded
    as long as InetSetup can locate Internet 5.31 or later and DHCP
    0.11 and later.  Any number of interfaces may use DHCP to configure
    their interfaces,
Admin:
  Tested in Risc PCs

Version 0.29. Tagged as 'InetSetup-0_29'
@
text
@a132 8
    gadget_get_bbox(0, InterfacesObject, ifs_Logo, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;

    gadget_move_gadget(0, InterfacesObject, ifs_Logo, &box);

d144 1
a144 2
        g.class_no = class_LABEL;
        g.size = 0;
d166 1
a166 1
    	    g.flags |= gadget_FADED;
d168 3
a170 3
    	/* PPP will allow blank fields so gadget will not be faded if interface type is PPP and it was found on startup */
    	if (interface_is_pp[i] == 2 &&
    	    interface_has_section[i]) g.flags &= ~gadget_FADED;
d173 2
a174 3
        g.class_no = class_ACTION_BUTTON;
        g.size = 0;
    	#if IfsStyle == 1
d177 2
a178 2
    	#elif IfsStyle == 2
    	g.bbox.x0 = 12 + label_width + 8 + button_width + 8;
d180 1
a180 1
    	#endif
d231 2
a232 2
    	if (interface_is_pp[i] == 2 &&
    	    interface_has_section[i]) g.flags |= 4; /* Selected */
d234 1
a234 2
        g.class_no = class_OPTION_BUTTON;
        g.size = 0;
d269 2
a270 2
    	event_register_toolbox_handler(interface_object[i],
    	                               action_RADIO_BUTTON_STATE_CHANGED,
d272 2
a273 2
    	event_register_toolbox_handler(interface_object[i],
    	                               action_OPTION_BUTTON_STATE_CHANGED,
d275 2
a276 2
    	event_register_toolbox_handler(interface_object[i],
    	                               action_ACTION_BUTTON_SELECTED,
d298 2
a299 2
    	    	    	    	   action_OPTION_BUTTON_STATE_CHANGED,
    	    	    	    	   ifs_enable_handler, 0);
d302 2
a303 2
    	    	    	    	   action_WINDOW_DIALOGUE_COMPLETED,
    	    	    	    	   ifs_close_handler, 0);
d306 2
a307 2
    	    	    	    	   action_DefaultNetmask,
    	    	    	    	   default_netmask_handler, 0);
d310 2
a311 2
    	    	    	    	   action_WINDOW_ABOUT_TO_BE_SHOWN,
    	    	    	    	   ifs_show_handler, 0);*/
d338 1
a338 1
    	toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
d372 1
a372 1
    	interface_addrtype[i] = if_Manual;
d378 1
a378 1
    	gadget_set_flags(0, o, if_Address, gadget_FADED);
d381 1
a381 1
    	gadget_set_flags(0, o, if_Address, gadget_FADED);
d414 1
a414 1
    	optionbutton_set_state(0, o, if_Primary, TRUE);
d426 4
a429 4
    	if (interface_address[i][0] == '\0')
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, gadget_FADED);
    	else
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, 0);
d441 1
a441 1
    	toolbox_hide_object(0, interface_object[i]);
d455 2
a456 2
    	toolbox_hide_object(0, interface_object[id->this_cmp >> 8]);
    	interface_has_section[id->this_cmp >> 8] = 0;	/* ppp will NOT be saved */
d459 1
a459 1
        interface_has_section[id->this_cmp >> 8] = 1;	/* ppp will be saved */
d507 8
a514 8
    	radiobutton_action_state_changed *r =
    	                  (radiobutton_action_state_changed *) &action.data;
    	optionbutton_action_state_changed *opt =
    	                  (optionbutton_action_state_changed *) &action.data;

    	writablefield_set_value(0, id->this_obj, if_Address, interface_address[i]);
    	writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[i]);
    	if (interface_is_pp[i])
d532 2
a533 2
    	action.size = 16 + 4;
    	action.action_no = action_OPTION_BUTTON_STATE_CHANGED;
d535 3
a537 3
    	opt->on = primary_interface == i;
    	optionbutton_set_state(0, id->this_obj, if_Primary, opt->on);
    	toolbox_raise_toolbox_event(0, id->this_obj, if_Primary, &action);
d555 1
d558 2
a559 2
            	if (i != (int) handle &&
            	       my_radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
d561 2
a562 2
            	if (i != (int) handle &&
            	       radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
d564 4
a567 4
            	{
            	    radiobutton_set_state(0, interface_object[i], if_Manual, TRUE);
            	    gadget_set_flags(0, interface_object[i], if_Address, 0);
            	}
d573 1
d579 1
a579 1
            	gadget_set_focus(0, id->this_obj, if_Address);
d589 1
d591 14
a604 2
        /*else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
d609 1
d611 4
a614 2
        /*else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
d618 2
a619 1
      	if (r->on)
d621 4
a624 2
       /* else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
d637 11
a647 2
    if (id->this_cmp != if_RevARP && id->this_cmp != if_BOOTP && id->this_cmp != if_DHCP &&
        (r->previous_on == if_RevARP || r->previous_on == if_BOOTP || r->previous_on == if_DHCP))
d650 2
a651 2
        gadget_set_flags(0, id->this_obj, if_Netmask, 0);
        window_set_default_focus(0, id->this_obj, if_Address);
d655 4
a658 1
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
a660 5
    else if ((id->this_cmp == if_RevARP || id->this_cmp == if_BOOTP || id->this_cmp == if_DHCP) &&
             r->previous_on != if_RevARP && r->previous_on != if_BOOTP && r->previous_on != if_DHCP)
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, 0);
    }
d703 1
@


1.3
log
@  Merge of half a dozen separate branches to the trunk:
    Ursula
    Ursula_RiscPC
    StrongARM
    Daytona(!)
    sbrodie_InetSetup_dev-1_1_2_3
    ART
Detail:
  What a mess.
Admin:
  This is the Ursula plugin version.  It builds.

Version 0.28. Tagged as 'InetSetup-0_28'
@
text
@d32 1
d402 5
@


1.2
log
@Version RO_3_71 taken
@
text
@d37 6
d53 3
d80 2
d84 4
a87 1
    toolbox_position pos;
d89 1
d92 3
d160 3
d164 1
d168 6
a173 1
        if (interface_address[i][0] == '\0' && interface_addrtype[i] == 0 || !have_driver)
d175 6
d196 12
d218 1
d224 8
a231 2
        actionbutton_set_click_show(0, InterfacesObject, (i << 8) + 2,
                                                         interface_object[i], 0);
d238 5
d257 10
d275 1
d290 1
d305 1
d323 24
d350 1
d368 1
a368 1
    if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_RevARP)
d370 7
d378 1
a378 2
        writablefield_set_value(0, o, if_Address,
          msgs_lookup(interface_addrtype[i] == if_BOOTP ? "BOOTP" : "RevARP"));
d386 4
d392 1
d401 1
d459 1
d461 6
d471 10
d499 4
d505 1
d526 3
d530 1
d561 4
d567 1
d597 7
d621 2
a622 2
    if (id->this_cmp != if_RevARP && id->this_cmp != if_BOOTP &&
        (r->previous_on == if_RevARP || r->previous_on == if_BOOTP))
d633 2
a634 2
    else if ((id->this_cmp == if_RevARP || id->this_cmp == if_BOOTP) &&
             r->previous_on != if_RevARP && r->previous_on != if_BOOTP)
@


1.2.2.1
log
@Support added for PPP module and additional network cards.  Front end has also
been modified to fit style guide more closely.
@
text
@a36 9
/*  */
extern void my_actionbutton_set_click_show (bits flags,
      toolbox_o window,
      toolbox_c action_button,
      toolbox_o obj,
      bits show_flags);



d146 1
a146 6
        
        
        
        if (interface_address[i][0] == '\0' && 
            interface_addrtype[i] == 0 || 
            !have_driver)
a147 6
    	
    	/* PPP will allow blank fields so gadget will not be faded if interface type is PPP and it was found on startup */
    	if (interface_is_pp[i] == 2 && 
    	    interface_has_section[i]) g.flags &= ~gadget_FADED;
    	
    	
d178 2
a179 6
        my_actionbutton_set_click_show(0, 
                                       InterfacesObject, 
                                       (i << 8) + 2,
                                       interface_object[i], 
                                       0 
                                      );
a185 5
        
        /* PPP will allow blank fields so gadget will be ticked if interface type is PPP and it was found on startup*/
    	if (interface_is_pp[i] == 2 && 
    	    interface_has_section[i]) g.flags |= 4; /* Selected */
        
a351 1
    {
a352 6
    	interface_has_section[id->this_cmp >> 8] = 0;	/* ppp will NOT be saved */
    } else
    {
        interface_has_section[id->this_cmp >> 8] = 1;	/* ppp will be saved */
    }

@


1.2.2.2
log
@Now compatible with OSLib 4.8.

Ursula Configure plug-in interface added; updated sprites to Ursula design.

Windows now open from the position of the icon clicked on, as in the rest of
Configure.

In the AUN section (if any) of the generated Startup file,
   RMEnsure BBCEconet 0 RMReInit BBCEconet
is replaced with
   RMEnsure UtilityModule 3.80 RMEnsure BBCEconet 0 RMReInit BBCEconet
because there's no BBCEconet module in Ursula.
@
text
@d37 7
a43 1
#include "my_swis.h"
a45 3
#ifdef PlugIn
extern toolbox_o InternetObject;
#endif
a55 3
#ifdef PlugIn
static bool ifs_action_handler(bits, toolbox_action *, toolbox_block *, void *);
#endif
a79 2
    toolbox_position pos;
#ifndef PlugIn
d82 1
a82 4
#endif
#ifdef OSLib_4_8
    static my_gadget_OBJECT(4) g;
#else
a83 1
#endif
a85 3
#ifdef PlugIn
    event_register_toolbox_handler (InterfacesObject, action_ACTION_BUTTON_SELECTED, ifs_action_handler, 0);
#endif
a150 3
#ifdef OSLib_4_8
        ((label_object *) g.gadget)->label = interface_location[i];
#else
a151 1
#endif
a182 12
#ifdef OSLib_4_8
        #if IfsStyle == 1
        ((actionbutton_object *) g.gadget)->text = interface_name[i];
        ((actionbutton_object *) g.gadget)->text_limit = strlen(interface_name[i])+1;
        #elif IfsStyle == 2
        ((actionbutton_object *) g.gadget)->text = msgs_lookup("Conf");
        ((actionbutton_object *) g.gadget)->text_limit =
          strlen(((actionbutton_object *) g.gadget)->text) + 1;
        #endif
        ((actionbutton_object *) g.gadget)->click_show = 0;
        ((actionbutton_object *) g.gadget)->action = 0;
#else
a192 1
#endif
a197 1
#ifndef PlugIn
a203 1
#endif
a228 10
#ifdef OSLib_4_8
        #if IfsStyle == 1
        ((optionbutton_object *) g.gadget)->label = 0;
        ((optionbutton_object *) g.gadget)->label_limit = 0;
        #elif IfsStyle == 2
        ((optionbutton_object *) g.gadget)->label = interface_name[i];
        ((optionbutton_object *) g.gadget)->label_limit = strlen(interface_name[i]) + 1;
        #endif
        ((optionbutton_object *) g.gadget)->action = 0;
#else
a236 1
#endif
a250 1
#ifndef PlugIn
a264 1
#endif
a281 24

#ifdef PlugIn
    if (id)
    {
      wimp_window_state state;
      OpenWindowFromIcon (InterfacesObject, InternetObject, internet_Interfaces);
      state.w = window_get_wimp_handle (0, InterfacesObject);
      wimp_get_window_state (&state);
      pos.full.visible.x0 = state.visible.x0;
      #if IfsStyle == 1
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + 44 + 12;
      #elif IfsStyle == 2
      pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + config_width + 12;
      #endif
      pos.full.visible.y1 = state.visible.y1;
      pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
      pos.full.xscroll = state.xscroll;
      pos.full.yscroll = state.yscroll;
      pos.full.next = wimp_TOP;

      toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                          id->this_obj, id->this_cmp);
    }
#else
a284 1
#endif
a313 4
#ifdef OSLib_4_8
    if (!my_radiobutton_get_state(0, o, if_Manual, 0))
    	gadget_set_flags(0, o, if_Address, gadget_FADED);
#else
a315 1
#endif
a392 10
#ifdef PlugIn
static bool ifs_action_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    int i = (id->this_cmp) >> 8;
    OpenWindowFromIcon (interface_object[i], InterfacesObject, id->this_cmp);
    return TRUE;
}
#endif

a410 4
#ifdef OSLib_4_8
        my_radiobutton_get_state(0, interface_object[i], if_Manual,
                              &interface_addrtype[i]);
#else
a412 1
#endif
a432 3
#ifdef OSLib_4_8
        my_radiobutton_get_state(0, id->this_obj, if_Manual, &r->previous_on);
#else
a433 1
#endif
a463 4
#ifdef OSLib_4_8
            	if (i != (int) handle &&
            	       my_radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
#else
a465 1
#endif
@


1.2.2.2.2.1
log
@  Added support code for DHCP configurations.  Work in progress.
Detail:
  c.Load/c.Save: modified to use "dhcp" parameter to ifrconfig command in
      Choices:Internet.Startup
  c.IfsDbox: modified to handle gadget flags as appropriate for DHCP
      (just extends BootP/RevARP handler code with a third case)
  Resources/*/Res: Unfaded DHCP optionbutton.  Now controlled from code.
  Resources/*/Messages: Updated version number.
Admin:
  Work in progress - private development branch work not yet complete.

Version 0.22, 1.1.2.3.2.1. Tagged as 'InetSetup-0_22-1_1_2_3_2_1'
@
text
@d168 5
a172 5



        if (interface_address[i][0] == '\0' &&
            interface_addrtype[i] == 0 ||
d175 1
a175 1

d177 1
a177 1
    	if (interface_is_pp[i] == 2 &&
d179 2
a180 2


d225 2
a226 2
        my_actionbutton_set_click_show(0,
                                       InterfacesObject,
d228 2
a229 2
                                       interface_object[i],
                                       0
d238 1
a238 1

d240 1
a240 1
    	if (interface_is_pp[i] == 2 &&
d242 1
a242 1

d368 1
a368 1
    if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_RevARP || interface_addrtype[i] == if_DHCP)
a369 7
        char *msg;
        switch (interface_addrtype[i])
        {
           case if_BOOTP: msg = "BOOTP"; break;
           case if_DHCP: msg= "DHCP"; break;
           default: msg = "RevARP"; break;
        }
d371 2
a372 1
        writablefield_set_value(0, o, if_Address, msgs_lookup(msg));
a394 1
        gadget_set_flags(0, o, if_DHCP, gadget_FADED);
a589 7
      case if_DHCP:
        if (r->on)
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("DHCP"));
        /*else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
        break;

d607 2
a608 2
    if (id->this_cmp != if_RevARP && id->this_cmp != if_BOOTP && id->this_cmp != if_DHCP &&
        (r->previous_on == if_RevARP || r->previous_on == if_BOOTP || r->previous_on == if_DHCP))
d619 2
a620 2
    else if ((id->this_cmp == if_RevARP || id->this_cmp == if_BOOTP || id->this_cmp == if_DHCP) &&
             r->previous_on != if_RevARP && r->previous_on != if_BOOTP && r->previous_on != if_DHCP)
@


1.1
log
@file IfsDbox was initially added on branch RO_3_70_to_3_71.
@
text
@d1 548
@


1.1.4.1
log
@Version RO_3_71 taken
@
text
@a0 548
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <stdio.h>

#include "window.h"
#include "gadget.h"
#include "label.h"
#include "optionbutton.h"
#include "actionbutton.h"
#include "writablefield.h"
#include "radiobutton.h"

#include "event.h"
#include "Load.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Main.h"
#include "ModUtils.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

extern toolbox_o InterfacesObject;
toolbox_o interface_object[16];
toolbox_c interface_addrtype[16];

static void FillInterfaceDbox(toolbox_o, int);
static bool ifs_enable_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool ifs_close_handler(bits, toolbox_action *, toolbox_block *, void *);
//static bool ifs_show_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_button_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_option_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_action_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool default_netmask_handler(bits, toolbox_action *, toolbox_block *, void *);

/*
 * Two possible styles of Interfaces dbox:
 *
 * 1)     Serial [       SLIP      ] []       { The original and still the worst! }
 *           NIC [ Beebug Ethernet ] []
 *
 * 2)     Serial [] SLIP            [ Configure... ]    { Somewhat more intuitive }
 *           NIC [] Beebug Ethernet [ Configure... ]
 */
#define IfsStyle 2

void MakeIfsDbox(toolbox_block *id)
{
    int i, w;
    int label_width = 80, close_width;
    #if IfsStyle == 1
    int button_width = 320;
    #elif IfsStyle == 2
    int button_width = 0, config_width;
    #endif
    os_box box;
    toolbox_resource_file_object *obj;
    window_object *win;
    toolbox_position pos;
    static gadget_OBJECT(4) g;

    InterfacesObject = toolbox_create_object(0, (toolbox_id) "Interfaces");

    for (i=0; i < interfaces; i++)
    {
        /* RISC OS 3.5 SWI */
        if (WimpVersion >= 350) w = wimptextop_string_width(interface_location[i], 0);
        else w = strlen(interface_location[i]) * 16;
        if (w > label_width) label_width = w;

        if (WimpVersion >= 350) w = wimptextop_string_width(interface_name[i], 0);
        else w = strlen(interface_name[i]) * 16;
        if (w > button_width) button_width = w;
    }

    #if IfsStyle == 1
    label_width += 12;
    button_width += 32;
    #elif IfsStyle == 2
    label_width += 12;
    button_width += 24 + 44;
    if (WimpVersion >= 350) config_width = wimptextop_string_width(msgs_lookup("Conf"), 0) + 32;
    else config_width = strlen(msgs_lookup("Conf")) * 16 + 32;
    #endif

    gadget_get_bbox(0, InterfacesObject, ifs_Close, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;
    #if IfsStyle == 1
    box.x1 = 12 + label_width + 8 + button_width + 8 + 44;
    #elif IfsStyle == 2
    box.x1 = 12 + label_width + 8 + button_width + 8 + config_width;
    #endif
    box.x0 = box.x1 - close_width;

    gadget_move_gadget(0, InterfacesObject, ifs_Close, &box);

    gadget_get_bbox(0, InterfacesObject, ifs_Logo, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;

    gadget_move_gadget(0, InterfacesObject, ifs_Logo, &box);

    for (i = 0; i < interfaces; i++)
    {
        int have_driver;
        char buffer[256];

        sprintf(buffer, "System:Modules.Network.%s", interface_filename[i]);
        have_driver = RMFind(interface_module[i], buffer, interface_version[i]);

        g.flags = label_NO_BOX | label_RJUSTIFIED;
        if (!have_driver)
            g.flags |= gadget_FADED;
        g.class_no = class_LABEL;
        g.size = 0;
        g.bbox.x0 = 12;
        g.bbox.x1 = 12 + label_width;
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 1;
        g.help_message = 0;
        g.help_limit = 0;
        ((label_gadget *) g.gadget)->label = interface_location[i];
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        g.flags = actionbutton_IS_LOCAL;
        if (interface_address[i][0] == '\0' && interface_addrtype[i] == 0 || !have_driver)
    	    g.flags |= gadget_FADED;
        g.class_no = class_ACTION_BUTTON;
        g.size = 0;
    	#if IfsStyle == 1
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + button_width;
    	#elif IfsStyle == 2
    	g.bbox.x0 = 12 + label_width + 8 + button_width + 8;
        g.bbox.x1 = g.bbox.x0 + config_width;
    	#endif
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 2;
        sprintf(buffer, msgs_lookup("IfsHelp1"), interface_name[i]);
        g.help_message = buffer;
        g.help_limit = strlen(buffer)+1;
        #if IfsStyle == 1
        ((actionbutton_gadget *) g.gadget)->text = interface_name[i];
        ((actionbutton_gadget *) g.gadget)->text_limit = strlen(interface_name[i])+1;
        #elif IfsStyle == 2
        ((actionbutton_gadget *) g.gadget)->text = msgs_lookup("Conf");
        ((actionbutton_gadget *) g.gadget)->text_limit =
          strlen(((actionbutton_gadget *) g.gadget)->text) + 1;
        #endif
        ((actionbutton_gadget *) g.gadget)->click_show = 0;
        ((actionbutton_gadget *) g.gadget)->action = 0;
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        interface_object[i] = toolbox_create_object(0, (toolbox_id)
                                (interface_is_pp[i] ? "InterfacePP" : "Interface"));

        actionbutton_set_click_show(0, InterfacesObject, (i << 8) + 2,
                                                         interface_object[i], 0);

        g.flags = 1; /* Generate events */
        if (!have_driver)
            g.flags |= gadget_FADED;
        else if (Set(interface_address[i]) || interface_addrtype[i])
            g.flags |= 4; /* Selected */
        g.class_no = class_OPTION_BUTTON;
        g.size = 0;
        #if IfsStyle == 1
        g.bbox.x0 = g.bbox.x1 + 8;
        g.bbox.x1 = g.bbox.x0 + 44;
        #elif IfsStyle == 2
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + button_width;
        #endif
        g.bbox.y1 = -8 - (52+8) * i - 4;
        g.bbox.y0 = g.bbox.y1 - 44;
        g.cmp = (i << 8) + 3;
        g.help_message = msgs_lookup("IfsHelp2");
        g.help_limit = strlen(g.help_message)+1;
        #if IfsStyle == 1
        ((optionbutton_gadget *) g.gadget)->label = 0;
        ((optionbutton_gadget *) g.gadget)->label_limit = 0;
        #elif IfsStyle == 2
        ((optionbutton_gadget *) g.gadget)->label = interface_name[i];
        ((optionbutton_gadget *) g.gadget)->label_limit = strlen(interface_name[i]) + 1;
        #endif
        ((optionbutton_gadget *) g.gadget)->action = 0;
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        FillInterfaceDbox(interface_object[i], i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_RADIO_BUTTON_STATE_CHANGED,
                                       if_button_handler, (void *) i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_OPTION_BUTTON_STATE_CHANGED,
                                       if_option_handler, (void *) i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_ACTION_BUTTON_SELECTED,
                                       if_action_handler, (void *) i);
    }

    obj = (toolbox_resource_file_object *) toolbox_template_look_up(0, "Interfaces");
    win = (window_object *) obj->object;

    pos.full.visible.x0 = win->window.visible.x0;
    #if IfsStyle == 1
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + 44 + 12;
    #elif IfsStyle == 2
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + config_width + 12;
    #endif
    pos.full.visible.y1 = win->window.visible.y1;
    pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
    pos.full.xscroll = win->window.xscroll;
    pos.full.yscroll = win->window.yscroll;
    pos.full.next = wimp_TOP;

    event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_OPTION_BUTTON_STATE_CHANGED,
    	    	    	    	   ifs_enable_handler, 0);

    event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_WINDOW_DIALOGUE_COMPLETED,
    	    	    	    	   ifs_close_handler, 0);

    event_register_toolbox_handler(event_ANY,
    	    	    	    	   action_DefaultNetmask,
    	    	    	    	   default_netmask_handler, 0);

    /*event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_WINDOW_ABOUT_TO_BE_SHOWN,
    	    	    	    	   ifs_show_handler, 0);*/

    if (id)
    	toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                            id->this_obj, id->this_cmp);
}

static void FillInterfaceDbox(toolbox_o o, int i)
{
    char buffer[128];

    sprintf(buffer, "%s: %s", interface_location[i], interface_name[i]);
    window_set_title(0, o, buffer);
    if (interface_addrtype[i] == if_FromHostname)
        /* Because host name might have been changed... */
        writablefield_set_value(0, o, if_Address, HostName);
    else
        writablefield_set_value(0, o, if_Address, interface_address[i]);
    writablefield_set_value(0, o, if_Netmask, interface_netmask[i]);
    if (interface_is_pp[i])
        writablefield_set_value(0, o, if_LinkAddr, interface_linkaddr[i]);
    optionbutton_set_state(0, o, if_Primary, primary_interface == i);
    if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_RevARP)
    {
        gadget_set_flags(0, o, if_ICMP, 0);
        writablefield_set_value(0, o, if_Address,
          msgs_lookup(interface_addrtype[i] == if_BOOTP ? "BOOTP" : "RevARP"));
    }

    if (interface_addrtype[i] == 0)
    	interface_addrtype[i] = if_Manual;

    radiobutton_set_state(0, o, interface_addrtype[i], TRUE);

    if (!radiobutton_get_state(0, o, if_Manual, 0))
    	gadget_set_flags(0, o, if_Address, gadget_FADED);

    if (!interface_is_pp[i])
        gadget_set_flags(0, o, if_FromCMOS, CMOSIP ? 0 : gadget_FADED);

    if (!interface_is_pp[i] && !Exists("Inet:bin.IfRConfig"))
    {
        gadget_set_flags(0, o, if_RevARP, gadget_FADED);
        gadget_set_flags(0, o, if_BOOTP, gadget_FADED);
    }

    if (strcmp(interface_netmask[i], "zzzz") == 0)
    {
        strcpy(interface_netmask[i], "default");
        writablefield_set_value(0, o, if_Netmask, msgs_lookup("ICMPReq"));
        gadget_set_flags(0, o, if_Netmask, gadget_FADED);
        if (!interface_is_pp[i])
            optionbutton_set_state(0, o, if_ICMP, TRUE);
        window_set_default_focus(0, o, (toolbox_c) -2);
    }

    if (strcmp(interface_unit[i], "ec0") == 0)
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
    else if (interfaces == 1)
    {
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
    	optionbutton_set_state(0, o, if_Primary, TRUE);
    }
}

#if 0
static bool ifs_show_handler(bits event_code, toolbox_action *event,
                             toolbox_block *id, void *handle)
{
    int i;

    /* Window module bug - we can't seem to set the flags above */
    for (i = 0; i < interfaces; i++)
    	if (interface_address[i][0] == '\0')
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, gadget_FADED);
    	else
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, 0);

    return TRUE;
}
#endif

static bool ifs_close_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    int i;

    for (i = 0; i < interfaces; i++)
    	toolbox_hide_object(0, interface_object[i]);

    return FALSE;
}

static bool ifs_enable_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *optevent =
                     (optionbutton_action_state_changed *) &event->data;

    gadget_set_flags(0, id->this_obj, id->this_cmp - 1, optevent->on ? 0 : gadget_FADED);
    if (!optevent->on)
    	toolbox_hide_object(0, interface_object[id->this_cmp >> 8]);

    return TRUE;
}

static bool if_action_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    int i = (int) handle;

    if (event->flags & actionbutton_SELECTED_DEFAULT)
    {
        writablefield_get_value(0, interface_object[i], if_Address,
                                interface_address[i], sizeof interface_address[i]);
        writablefield_get_value(0, interface_object[i], if_Netmask,
                                interface_netmask[i], sizeof interface_netmask[i]);
        if (interface_is_pp[i])
            writablefield_get_value(0, interface_object[i], if_LinkAddr,
                                    interface_linkaddr[i], sizeof interface_linkaddr[i]);
        if (optionbutton_get_state(0, interface_object[i], if_Primary))
            primary_interface = i;
        else if (primary_interface == i)
            primary_interface = -1;
        radiobutton_get_state(0, interface_object[i], if_Manual,
                              &interface_addrtype[i]);

        return TRUE;
    }
    if (event->flags & actionbutton_SELECTED_CANCEL)
    {
        toolbox_action action;
    	radiobutton_action_state_changed *r =
    	                  (radiobutton_action_state_changed *) &action.data;
    	optionbutton_action_state_changed *opt =
    	                  (optionbutton_action_state_changed *) &action.data;

    	writablefield_set_value(0, id->this_obj, if_Address, interface_address[i]);
    	writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[i]);
    	if (interface_is_pp[i])
            writablefield_set_value(0, id->this_obj, if_LinkAddr, interface_linkaddr[i]);

        action.size = 16 + 8;
        action.action_no = action_RADIO_BUTTON_STATE_CHANGED;
        action.flags = radiobutton_STATE_CHANGED_SELECT;
        r->on = FALSE;
        radiobutton_get_state(0, id->this_obj, if_Manual, &r->previous_on);
        radiobutton_set_state(0, id->this_obj, interface_addrtype[i], TRUE);
        toolbox_raise_toolbox_event(0, id->this_obj, r->previous_on, &action);

        r->on = TRUE;
        toolbox_raise_toolbox_event(0, id->this_obj, interface_addrtype[i], &action);

    	action.size = 16 + 4;
    	action.action_no = action_OPTION_BUTTON_STATE_CHANGED;
        action.flags = optionbutton_STATE_CHANGED_SELECT;
    	opt->on = primary_interface == i;
    	optionbutton_set_state(0, id->this_obj, if_Primary, opt->on);
    	toolbox_raise_toolbox_event(0, id->this_obj, if_Primary, &action);
        return TRUE;
    }
    return FALSE;
}

static bool if_button_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    radiobutton_action_state_changed *r = (radiobutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_FromHostname:
        if (r->on)
        {
            int i;
            writablefield_set_value(0, id->this_obj, if_Address, HostName);
            for (i = 0; i < interfaces; i++)
            	if (i != (int) handle &&
            	       radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
            	{
            	    radiobutton_set_state(0, interface_object[i], if_Manual, TRUE);
            	    gadget_set_flags(0, interface_object[i], if_Address, 0);
            	}
        }
        break;

      case if_Manual:
        gadget_set_flags(0, id->this_obj, if_Address, r->on ? 0 : gadget_FADED);
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle]);
            if (toolbox_get_object_info(0, id->this_obj) & toolbox_INFO_SHOWING)
            	gadget_set_focus(0, id->this_obj, if_Address);
        }
        else
            writablefield_get_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle],
                                    sizeof interface_address[(int) handle]);
        break;

      case if_RevARP:
        if (r->on)
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("RevARP"));
        /*else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
        break;

      case if_BOOTP:
      	if (r->on)
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("BOOTP"));
       /* else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
        break;

      case if_FromCMOS:
        if (r->on)
        {
            /* Silliness */
            struct in_addr in;
            in.s_addr = CMOSIP;
            writablefield_set_value(0, id->this_obj, if_Address, inet_ntoa(in));
        }
    }

    if (id->this_cmp != if_RevARP && id->this_cmp != if_BOOTP &&
        (r->previous_on == if_RevARP || r->previous_on == if_BOOTP))
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, gadget_FADED);
        gadget_set_flags(0, id->this_obj, if_Netmask, 0);
        window_set_default_focus(0, id->this_obj, if_Address);
        if (optionbutton_get_state(0, id->this_obj, if_ICMP))
        {
            optionbutton_set_state(0, id->this_obj, if_ICMP, FALSE);
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
        }
    }
    else if ((id->this_cmp == if_RevARP || id->this_cmp == if_BOOTP) &&
             r->previous_on != if_RevARP && r->previous_on != if_BOOTP)
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, 0);
    }

    return TRUE;
}

static bool if_option_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *r = (optionbutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_Primary:
        if (r->on)
        {
            int i;

            for (i = 0; i < interfaces; i++)
            {
                if (interface_object[i] == id->this_obj)
                    continue;

                optionbutton_set_state(0, interface_object[i], if_Primary, FALSE);
            }
        }
        break;
      case if_ICMP:
        if (r->on)
        {
            xwimp_set_caret_position(window_get_wimp_handle(0, id->this_obj),
                                     (wimp_i) -1, 0, 0, (1<<25), 0);
            gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
            writablefield_get_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle], sizeof interface_netmask[(int) handle]);
            writablefield_set_value(0, id->this_obj, if_Netmask, msgs_lookup("ICMPReq"));
            window_set_default_focus(0, id->this_obj, (toolbox_c) -2);
        }
        else
        {
            gadget_set_flags(0, id->this_obj, if_Netmask, 0);
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
            gadget_set_focus(0, id->this_obj, if_Netmask);
            window_set_default_focus(0, id->this_obj, if_Address);
        }
    }

    return TRUE;
}

static bool default_netmask_handler(bits event_code, toolbox_action *event,
                                    toolbox_block *id, void *handle)
{
    writablefield_set_value(0, id->ancestor_obj, if_Netmask, "default");
    gadget_set_flags(0, id->ancestor_obj, if_Netmask, 0);
    xoptionbutton_set_state(0, id->ancestor_obj, if_ICMP, FALSE);

    return TRUE;
}
@


1.1.2.1
log
@Merged from 3.71 CD
@
text
@a0 548
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>
#include <stdio.h>

#include "window.h"
#include "gadget.h"
#include "label.h"
#include "optionbutton.h"
#include "actionbutton.h"
#include "writablefield.h"
#include "radiobutton.h"

#include "event.h"
#include "Load.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Main.h"
#include "ModUtils.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

extern toolbox_o InterfacesObject;
toolbox_o interface_object[16];
toolbox_c interface_addrtype[16];

static void FillInterfaceDbox(toolbox_o, int);
static bool ifs_enable_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool ifs_close_handler(bits, toolbox_action *, toolbox_block *, void *);
//static bool ifs_show_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_button_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_option_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool if_action_handler(bits, toolbox_action *, toolbox_block *, void *);
static bool default_netmask_handler(bits, toolbox_action *, toolbox_block *, void *);

/*
 * Two possible styles of Interfaces dbox:
 *
 * 1)     Serial [       SLIP      ] []       { The original and still the worst! }
 *           NIC [ Beebug Ethernet ] []
 *
 * 2)     Serial [] SLIP            [ Configure... ]    { Somewhat more intuitive }
 *           NIC [] Beebug Ethernet [ Configure... ]
 */
#define IfsStyle 2

void MakeIfsDbox(toolbox_block *id)
{
    int i, w;
    int label_width = 80, close_width;
    #if IfsStyle == 1
    int button_width = 320;
    #elif IfsStyle == 2
    int button_width = 0, config_width;
    #endif
    os_box box;
    toolbox_resource_file_object *obj;
    window_object *win;
    toolbox_position pos;
    static gadget_OBJECT(4) g;

    InterfacesObject = toolbox_create_object(0, (toolbox_id) "Interfaces");

    for (i=0; i < interfaces; i++)
    {
        /* RISC OS 3.5 SWI */
        if (WimpVersion >= 350) w = wimptextop_string_width(interface_location[i], 0);
        else w = strlen(interface_location[i]) * 16;
        if (w > label_width) label_width = w;

        if (WimpVersion >= 350) w = wimptextop_string_width(interface_name[i], 0);
        else w = strlen(interface_name[i]) * 16;
        if (w > button_width) button_width = w;
    }

    #if IfsStyle == 1
    label_width += 12;
    button_width += 32;
    #elif IfsStyle == 2
    label_width += 12;
    button_width += 24 + 44;
    if (WimpVersion >= 350) config_width = wimptextop_string_width(msgs_lookup("Conf"), 0) + 32;
    else config_width = strlen(msgs_lookup("Conf")) * 16 + 32;
    #endif

    gadget_get_bbox(0, InterfacesObject, ifs_Close, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;
    #if IfsStyle == 1
    box.x1 = 12 + label_width + 8 + button_width + 8 + 44;
    #elif IfsStyle == 2
    box.x1 = 12 + label_width + 8 + button_width + 8 + config_width;
    #endif
    box.x0 = box.x1 - close_width;

    gadget_move_gadget(0, InterfacesObject, ifs_Close, &box);

    gadget_get_bbox(0, InterfacesObject, ifs_Logo, &box);
    close_width = box.x1 - box.x0;

    box.y1 = -8 - (52+8) * interfaces - 8;
    box.y0 = box.y1 - 68;

    gadget_move_gadget(0, InterfacesObject, ifs_Logo, &box);

    for (i = 0; i < interfaces; i++)
    {
        int have_driver;
        char buffer[256];

        sprintf(buffer, "System:Modules.Network.%s", interface_filename[i]);
        have_driver = RMFind(interface_module[i], buffer, interface_version[i]);

        g.flags = label_NO_BOX | label_RJUSTIFIED;
        if (!have_driver)
            g.flags |= gadget_FADED;
        g.class_no = class_LABEL;
        g.size = 0;
        g.bbox.x0 = 12;
        g.bbox.x1 = 12 + label_width;
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 1;
        g.help_message = 0;
        g.help_limit = 0;
        ((label_gadget *) g.gadget)->label = interface_location[i];
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        g.flags = actionbutton_IS_LOCAL;
        if (interface_address[i][0] == '\0' && interface_addrtype[i] == 0 || !have_driver)
    	    g.flags |= gadget_FADED;
        g.class_no = class_ACTION_BUTTON;
        g.size = 0;
    	#if IfsStyle == 1
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + button_width;
    	#elif IfsStyle == 2
    	g.bbox.x0 = 12 + label_width + 8 + button_width + 8;
        g.bbox.x1 = g.bbox.x0 + config_width;
    	#endif
        g.bbox.y1 = -8 - (52+8) * i;
        g.bbox.y0 = g.bbox.y1 - 52;
        g.cmp = (i << 8) + 2;
        sprintf(buffer, msgs_lookup("IfsHelp1"), interface_name[i]);
        g.help_message = buffer;
        g.help_limit = strlen(buffer)+1;
        #if IfsStyle == 1
        ((actionbutton_gadget *) g.gadget)->text = interface_name[i];
        ((actionbutton_gadget *) g.gadget)->text_limit = strlen(interface_name[i])+1;
        #elif IfsStyle == 2
        ((actionbutton_gadget *) g.gadget)->text = msgs_lookup("Conf");
        ((actionbutton_gadget *) g.gadget)->text_limit =
          strlen(((actionbutton_gadget *) g.gadget)->text) + 1;
        #endif
        ((actionbutton_gadget *) g.gadget)->click_show = 0;
        ((actionbutton_gadget *) g.gadget)->action = 0;
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        interface_object[i] = toolbox_create_object(0, (toolbox_id)
                                (interface_is_pp[i] ? "InterfacePP" : "Interface"));

        actionbutton_set_click_show(0, InterfacesObject, (i << 8) + 2,
                                                         interface_object[i], 0);

        g.flags = 1; /* Generate events */
        if (!have_driver)
            g.flags |= gadget_FADED;
        else if (Set(interface_address[i]) || interface_addrtype[i])
            g.flags |= 4; /* Selected */
        g.class_no = class_OPTION_BUTTON;
        g.size = 0;
        #if IfsStyle == 1
        g.bbox.x0 = g.bbox.x1 + 8;
        g.bbox.x1 = g.bbox.x0 + 44;
        #elif IfsStyle == 2
        g.bbox.x0 = 12 + label_width + 8;
        g.bbox.x1 = g.bbox.x0 + button_width;
        #endif
        g.bbox.y1 = -8 - (52+8) * i - 4;
        g.bbox.y0 = g.bbox.y1 - 44;
        g.cmp = (i << 8) + 3;
        g.help_message = msgs_lookup("IfsHelp2");
        g.help_limit = strlen(g.help_message)+1;
        #if IfsStyle == 1
        ((optionbutton_gadget *) g.gadget)->label = 0;
        ((optionbutton_gadget *) g.gadget)->label_limit = 0;
        #elif IfsStyle == 2
        ((optionbutton_gadget *) g.gadget)->label = interface_name[i];
        ((optionbutton_gadget *) g.gadget)->label_limit = strlen(interface_name[i]) + 1;
        #endif
        ((optionbutton_gadget *) g.gadget)->action = 0;
        window_add_gadget(0, InterfacesObject, (gadget_object *) &g);

        FillInterfaceDbox(interface_object[i], i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_RADIO_BUTTON_STATE_CHANGED,
                                       if_button_handler, (void *) i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_OPTION_BUTTON_STATE_CHANGED,
                                       if_option_handler, (void *) i);
    	event_register_toolbox_handler(interface_object[i],
    	                               action_ACTION_BUTTON_SELECTED,
                                       if_action_handler, (void *) i);
    }

    obj = (toolbox_resource_file_object *) toolbox_template_look_up(0, "Interfaces");
    win = (window_object *) obj->object;

    pos.full.visible.x0 = win->window.visible.x0;
    #if IfsStyle == 1
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + 44 + 12;
    #elif IfsStyle == 2
    pos.full.visible.x1 = pos.full.visible.x0 + 12 + label_width + 8 + button_width + 8 + config_width + 12;
    #endif
    pos.full.visible.y1 = win->window.visible.y1;
    pos.full.visible.y0 = pos.full.visible.y1 - 8 - (52+8) * interfaces - 8 - 68 - 12;
    pos.full.xscroll = win->window.xscroll;
    pos.full.yscroll = win->window.yscroll;
    pos.full.next = wimp_TOP;

    event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_OPTION_BUTTON_STATE_CHANGED,
    	    	    	    	   ifs_enable_handler, 0);

    event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_WINDOW_DIALOGUE_COMPLETED,
    	    	    	    	   ifs_close_handler, 0);

    event_register_toolbox_handler(event_ANY,
    	    	    	    	   action_DefaultNetmask,
    	    	    	    	   default_netmask_handler, 0);

    /*event_register_toolbox_handler(InterfacesObject,
    	    	    	    	   action_WINDOW_ABOUT_TO_BE_SHOWN,
    	    	    	    	   ifs_show_handler, 0);*/

    if (id)
    	toolbox_show_object(0, InterfacesObject, toolbox_POSITION_FULL, &pos,
                            id->this_obj, id->this_cmp);
}

static void FillInterfaceDbox(toolbox_o o, int i)
{
    char buffer[128];

    sprintf(buffer, "%s: %s", interface_location[i], interface_name[i]);
    window_set_title(0, o, buffer);
    if (interface_addrtype[i] == if_FromHostname)
        /* Because host name might have been changed... */
        writablefield_set_value(0, o, if_Address, HostName);
    else
        writablefield_set_value(0, o, if_Address, interface_address[i]);
    writablefield_set_value(0, o, if_Netmask, interface_netmask[i]);
    if (interface_is_pp[i])
        writablefield_set_value(0, o, if_LinkAddr, interface_linkaddr[i]);
    optionbutton_set_state(0, o, if_Primary, primary_interface == i);
    if (interface_addrtype[i] == if_BOOTP || interface_addrtype[i] == if_RevARP)
    {
        gadget_set_flags(0, o, if_ICMP, 0);
        writablefield_set_value(0, o, if_Address,
          msgs_lookup(interface_addrtype[i] == if_BOOTP ? "BOOTP" : "RevARP"));
    }

    if (interface_addrtype[i] == 0)
    	interface_addrtype[i] = if_Manual;

    radiobutton_set_state(0, o, interface_addrtype[i], TRUE);

    if (!radiobutton_get_state(0, o, if_Manual, 0))
    	gadget_set_flags(0, o, if_Address, gadget_FADED);

    if (!interface_is_pp[i])
        gadget_set_flags(0, o, if_FromCMOS, CMOSIP ? 0 : gadget_FADED);

    if (!interface_is_pp[i] && !Exists("Inet:bin.IfRConfig"))
    {
        gadget_set_flags(0, o, if_RevARP, gadget_FADED);
        gadget_set_flags(0, o, if_BOOTP, gadget_FADED);
    }

    if (strcmp(interface_netmask[i], "zzzz") == 0)
    {
        strcpy(interface_netmask[i], "default");
        writablefield_set_value(0, o, if_Netmask, msgs_lookup("ICMPReq"));
        gadget_set_flags(0, o, if_Netmask, gadget_FADED);
        if (!interface_is_pp[i])
            optionbutton_set_state(0, o, if_ICMP, TRUE);
        window_set_default_focus(0, o, (toolbox_c) -2);
    }

    if (strcmp(interface_unit[i], "ec0") == 0)
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
    else if (interfaces == 1)
    {
        gadget_set_flags(0, o, if_Primary, gadget_FADED);
    	optionbutton_set_state(0, o, if_Primary, TRUE);
    }
}

#if 0
static bool ifs_show_handler(bits event_code, toolbox_action *event,
                             toolbox_block *id, void *handle)
{
    int i;

    /* Window module bug - we can't seem to set the flags above */
    for (i = 0; i < interfaces; i++)
    	if (interface_address[i][0] == '\0')
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, gadget_FADED);
    	else
    	    gadget_set_flags(0, InterfacesObject, (i << 8) + 2, 0);

    return TRUE;
}
#endif

static bool ifs_close_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    int i;

    for (i = 0; i < interfaces; i++)
    	toolbox_hide_object(0, interface_object[i]);

    return FALSE;
}

static bool ifs_enable_handler(bits event_code, toolbox_action *event,
                               toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *optevent =
                     (optionbutton_action_state_changed *) &event->data;

    gadget_set_flags(0, id->this_obj, id->this_cmp - 1, optevent->on ? 0 : gadget_FADED);
    if (!optevent->on)
    	toolbox_hide_object(0, interface_object[id->this_cmp >> 8]);

    return TRUE;
}

static bool if_action_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    int i = (int) handle;

    if (event->flags & actionbutton_SELECTED_DEFAULT)
    {
        writablefield_get_value(0, interface_object[i], if_Address,
                                interface_address[i], sizeof interface_address[i]);
        writablefield_get_value(0, interface_object[i], if_Netmask,
                                interface_netmask[i], sizeof interface_netmask[i]);
        if (interface_is_pp[i])
            writablefield_get_value(0, interface_object[i], if_LinkAddr,
                                    interface_linkaddr[i], sizeof interface_linkaddr[i]);
        if (optionbutton_get_state(0, interface_object[i], if_Primary))
            primary_interface = i;
        else if (primary_interface == i)
            primary_interface = -1;
        radiobutton_get_state(0, interface_object[i], if_Manual,
                              &interface_addrtype[i]);

        return TRUE;
    }
    if (event->flags & actionbutton_SELECTED_CANCEL)
    {
        toolbox_action action;
    	radiobutton_action_state_changed *r =
    	                  (radiobutton_action_state_changed *) &action.data;
    	optionbutton_action_state_changed *opt =
    	                  (optionbutton_action_state_changed *) &action.data;

    	writablefield_set_value(0, id->this_obj, if_Address, interface_address[i]);
    	writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[i]);
    	if (interface_is_pp[i])
            writablefield_set_value(0, id->this_obj, if_LinkAddr, interface_linkaddr[i]);

        action.size = 16 + 8;
        action.action_no = action_RADIO_BUTTON_STATE_CHANGED;
        action.flags = radiobutton_STATE_CHANGED_SELECT;
        r->on = FALSE;
        radiobutton_get_state(0, id->this_obj, if_Manual, &r->previous_on);
        radiobutton_set_state(0, id->this_obj, interface_addrtype[i], TRUE);
        toolbox_raise_toolbox_event(0, id->this_obj, r->previous_on, &action);

        r->on = TRUE;
        toolbox_raise_toolbox_event(0, id->this_obj, interface_addrtype[i], &action);

    	action.size = 16 + 4;
    	action.action_no = action_OPTION_BUTTON_STATE_CHANGED;
        action.flags = optionbutton_STATE_CHANGED_SELECT;
    	opt->on = primary_interface == i;
    	optionbutton_set_state(0, id->this_obj, if_Primary, opt->on);
    	toolbox_raise_toolbox_event(0, id->this_obj, if_Primary, &action);
        return TRUE;
    }
    return FALSE;
}

static bool if_button_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    radiobutton_action_state_changed *r = (radiobutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_FromHostname:
        if (r->on)
        {
            int i;
            writablefield_set_value(0, id->this_obj, if_Address, HostName);
            for (i = 0; i < interfaces; i++)
            	if (i != (int) handle &&
            	       radiobutton_get_state(0, interface_object[i], if_FromHostname, 0))
            	{
            	    radiobutton_set_state(0, interface_object[i], if_Manual, TRUE);
            	    gadget_set_flags(0, interface_object[i], if_Address, 0);
            	}
        }
        break;

      case if_Manual:
        gadget_set_flags(0, id->this_obj, if_Address, r->on ? 0 : gadget_FADED);
        if (r->on)
        {
            writablefield_set_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle]);
            if (toolbox_get_object_info(0, id->this_obj) & toolbox_INFO_SHOWING)
            	gadget_set_focus(0, id->this_obj, if_Address);
        }
        else
            writablefield_get_value(0, id->this_obj, if_Address,
                                    interface_address[(int) handle],
                                    sizeof interface_address[(int) handle]);
        break;

      case if_RevARP:
        if (r->on)
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("RevARP"));
        /*else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
        break;

      case if_BOOTP:
      	if (r->on)
            writablefield_set_value(0, id->this_obj, if_Address, msgs_lookup("BOOTP"));
       /* else
            writablefield_set_value(0, id->this_obj, if_Address, "");*/
        break;

      case if_FromCMOS:
        if (r->on)
        {
            /* Silliness */
            struct in_addr in;
            in.s_addr = CMOSIP;
            writablefield_set_value(0, id->this_obj, if_Address, inet_ntoa(in));
        }
    }

    if (id->this_cmp != if_RevARP && id->this_cmp != if_BOOTP &&
        (r->previous_on == if_RevARP || r->previous_on == if_BOOTP))
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, gadget_FADED);
        gadget_set_flags(0, id->this_obj, if_Netmask, 0);
        window_set_default_focus(0, id->this_obj, if_Address);
        if (optionbutton_get_state(0, id->this_obj, if_ICMP))
        {
            optionbutton_set_state(0, id->this_obj, if_ICMP, FALSE);
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
        }
    }
    else if ((id->this_cmp == if_RevARP || id->this_cmp == if_BOOTP) &&
             r->previous_on != if_RevARP && r->previous_on != if_BOOTP)
    {
        gadget_set_flags(0, id->this_obj, if_ICMP, 0);
    }

    return TRUE;
}

static bool if_option_handler(bits event_code, toolbox_action *event,
                              toolbox_block *id, void *handle)
{
    optionbutton_action_state_changed *r = (optionbutton_action_state_changed *) &event->data;

    switch (id->this_cmp)
    {
      case if_Primary:
        if (r->on)
        {
            int i;

            for (i = 0; i < interfaces; i++)
            {
                if (interface_object[i] == id->this_obj)
                    continue;

                optionbutton_set_state(0, interface_object[i], if_Primary, FALSE);
            }
        }
        break;
      case if_ICMP:
        if (r->on)
        {
            xwimp_set_caret_position(window_get_wimp_handle(0, id->this_obj),
                                     (wimp_i) -1, 0, 0, (1<<25), 0);
            gadget_set_flags(0, id->this_obj, if_Netmask, gadget_FADED);
            writablefield_get_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle], sizeof interface_netmask[(int) handle]);
            writablefield_set_value(0, id->this_obj, if_Netmask, msgs_lookup("ICMPReq"));
            window_set_default_focus(0, id->this_obj, (toolbox_c) -2);
        }
        else
        {
            gadget_set_flags(0, id->this_obj, if_Netmask, 0);
            writablefield_set_value(0, id->this_obj, if_Netmask, interface_netmask[(int) handle]);
            gadget_set_focus(0, id->this_obj, if_Netmask);
            window_set_default_focus(0, id->this_obj, if_Address);
        }
    }

    return TRUE;
}

static bool default_netmask_handler(bits event_code, toolbox_action *event,
                                    toolbox_block *id, void *handle)
{
    writablefield_set_value(0, id->ancestor_obj, if_Netmask, "default");
    gadget_set_flags(0, id->ancestor_obj, if_Netmask, 0);
    xoptionbutton_set_state(0, id->ancestor_obj, if_ICMP, FALSE);

    return TRUE;
}
@

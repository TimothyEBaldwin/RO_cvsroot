head	1.17;
access;
symbols
	Source-0_59:1.17
	Source-0_58:1.16
	Source-0_57:1.15
	Source-0_56:1.15
	Source-0_55:1.14
	Source-0_54:1.14
	Source-0_53:1.14
	Source-0_52:1.14
	Source-0_51:1.14
	Source-0_50:1.14
	Source-0_49:1.13
	InetSetup-0_49:1.13
	InetSetup-0_48:1.13
	InetSetup-0_47:1.12
	InetSetup-0_46:1.12
	InetSetup-0_45:1.12
	InetSetup-0_44:1.11
	InetSetup-0_43:1.10
	InetSetup-0_42:1.9
	InetSetup-0_41:1.9
	InetSetup-0_40:1.9
	InetSetup-0_39:1.8
	InetSetup-0_38:1.8
	InetSetup-0_37:1.8
	InetSetup-0_36:1.8
	InetSetup-0_35:1.8
	InetSetup-0_34:1.8
	InetSetup-0_33:1.7
	InetSetup-0_32:1.6
	InetSetup-0_31:1.5
	InetSetup-0_30:1.5
	InetSetup-0_29:1.4
	StrongARM_merge:1.1.4.1
	sbrodie_InetSetup_dev_merge:1.2.2.4.2.1
	Daytona_merge:1.2
	Ursula_merge:1.2.2.5
	InetSetup-0_28:1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.2.2.4
	Ursula_RiscPC:1.2.2.4.0.4
	InetSetup-0_22-1_1_2_4:1.2.2.5
	InetSetup-0_22-1_1_2_3_2_1:1.2.2.4.2.1
	sbrodie_InetSetup_dev-1_1_2_3:1.2.2.4.0.2
	sbrodie_InetSetup_dev-1_1_2_3_bp:1.2.2.4
	rthornb_UrsulaBuild-19Aug1998:1.2.2.4
	UrsulaBuild_FinalSoftload:1.2.2.4
	rthornb_UrsulaBuild-12Aug1998:1.2.2.4
	aglover_UrsulaBuild-05Aug1998:1.2.2.4
	rthornb_UrsulaBuild-29Jul1998:1.2.2.4
	rthornb_UrsulaBuild-22Jul1998:1.2.2.4
	InetSetup-0_22-1_1_2_3:1.2.2.4
	rthornb_UrsulaBuild-15Jul1998:1.2.2.3
	rthornb_UrsulaBuild-07Jul1998:1.2.2.3
	rthornb_UrsulaBuild-17Jun1998:1.2.2.3
	rthornb_UrsulaBuild-03Jun1998:1.2.2.3
	rthornb_UrsulaBuild-27May1998:1.2.2.3
	rthornb_UrsulaBuild-21May1998:1.2.2.3
	bavison_InetSetup-0_25:1.2.2.3
	rthornb_UrsulaBuild_01May1998:1.2.2.2
	celkins_InetSetup_0_24:1.2.2.2
	InetSetup-0_22-1_1_2_2:1.2.2.2
	Daytona:1.2.0.4
	Daytona_bp:1.2
	Ursula:1.2.0.2
	Ursula_bp:1.2
	StrongARM:1.1.0.4
	RO_3_71:1.1.4.1;
locks; strict;
comment	@# @;


1.17
date	2018.08.19.09.48.16;	author rsprowson;	state Exp;
branches;
next	1.16;
commitid	nIgrlmSwWmfUjIOA;

1.16
date	2017.01.07.17.24.51;	author rsprowson;	state Exp;
branches;
next	1.15;
commitid	AdZgvrr1LYvkM3Bz;

1.15
date	2015.12.11.20.49.43;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	DBivlqTKYN6OxzMy;

1.14
date	2013.10.03.20.07.09;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	iG3J3iBSU4UyZS7x;

1.13
date	2012.09.15.10.19.56;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	rCoFS9CCmPHm3Ckw;

1.12
date	2012.07.29.08.56.17;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	iMWPXwWp5h8n8rew;

1.11
date	2012.07.20.12.10.01;	author rgriffin;	state Exp;
branches;
next	1.10;
commitid	0DXnHqDQjQ2Kuidw;

1.10
date	2012.07.19.10.58.57;	author rgriffin;	state Exp;
branches;
next	1.9;
commitid	rX1BtXHrURun8adw;

1.9
date	2012.02.12.15.33.00;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	cZcnUFhp7sHeJSSv;

1.8
date	2003.01.17.15.32.21;	author rsprowson;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.19.20.31.28;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.27.15.55.59;	author nbingham;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.08.14.25.12;	author nbingham;	state Exp;
branches;
next	1.4;

1.4
date	99.08.11.14.38.08;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.08.10.16.05.04;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	97.05.06.17.27.23;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.30.18.43.30;	author kbracey;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.2.2.1
date	97.11.18.16.08.45;	author dbrown;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.12.17.15.15.49;	author celkins;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	98.05.18.14.56.59;	author bavison;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	98.07.21.15.23.18;	author sbrodie;	state Exp;
branches
	1.2.2.4.2.1;
next	1.2.2.5;

1.2.2.5
date	98.09.22.13.49.49;	author bavison;	state Exp;
branches;
next	;

1.2.2.4.2.1
date	98.09.02.11.37.02;	author sbrodie;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.30.18.43.31;	author kbracey;	state Exp;
branches;
next	;

1.1.4.1
date	97.05.06.17.11.10;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Fix NULL pointer dereference on error
Load.c: if the file didn't open, don't try fclose(NULL)
Found by cppcheck static analysis.
Save.c/Diagnose.c: sort netdb.h's header ordering

Version 0.59. Tagged as 'Source-0_59'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "osbyte.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "wimp.h"
#include "hourglass.h"
#include "TaskManager.h"

#include "ModUtils.h"
#include "Save.h"
#include "Main.h"
#include "Load.h"
#include "AUN.h"
#include "Versions.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Diagnose.h"

#include "sys/types.h"
#include "sys/socket.h"
#include "netdb.h"

#define MIN_RMASIZE (256*1024)
#define MIN_SYSTEMSIZE (8*1024)

static FILE *BootFile, *ConfigureFile;

static void SaveInterface(int, bool);
static void SaveResolve(void);
static void SaveResConf(void);

static os_error *SetupAccess(void)
{
    if (AccessEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
            	    "| Access\n"
            	    "|\n"
            	    "IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
            	    "RMFind Freeway %s System:Modules.Network.Freeway\n",
            	    VersionToString(v_Freeway));
            fprintf(ConfigureFile,
            	    "RMFind ShareFS %s System:Modules.Network.Share+\n",
            	    VersionToString(v_ShareFS));
    	    RMInsert("Freeway", v_Freeway);
    	    RMInsert("ShareFS", v_ShareFS);
        }
        else
        {
            bool got_f, got_s;

            got_f=RMInsert("Freeway", v_Freeway);
            got_s=RMInsert("ShareFS", v_ShareFS);
            if (!got_f || !got_s)
            {
            	fprintf(BootFile,
                    	"|\n"
            	    	"| Access\n"
            	    	"|\n"
            	    	"IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
            	    	"RMEnsure Freeway %s RMLoad System:Modules.Network.Freeway\n",
            	    	VersionToString(v_Freeway));
            	fprintf(BootFile,
            	    	"RMEnsure ShareFS %s RMLoad System:Modules.Network.Share+\n",
            	    	VersionToString(v_ShareFS));
            }
        }
        /* The next two are necessary to run Resources:$.Resources.ShareFS.!Boot */
        RMInsert("BootNet", 0);
        RMInsert("AUNMsgs", 0);
    }
    else
    {
        Unplug("ShareFS");
        Unplug("Freeway");
    }

    return 0;
}

static os_error *SetupAUN(void)
{
    int temp;
    extern toolbox_o AUNObject;

    if (AUNObject && (AUNEnabled || HaveEconet))
    	UpdateAUNCMOS();

    if (AUNEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
                    "| Econet\n"
                    "|\n"
                    "RMFind NetI %s System:Modules.Network.NetI\n"
                    "Run InetDBase:AUNMap\n"
                    "RMEnsure UtilityModule 3.80 RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
                    "RMEnsure NetFS 0 RMReInit NetFS\n"
                    "RMEnsure NetFS 5.79 RMEnsure NetUtils 0.99 "
                                    "Run System:Modules.Network.NetUtils\n"
                    "RMEnsure NetPrint 0 RMReInit NetPrint\n"
                    "RMEnsure NetFiler 0 RMReInit NetFiler\n",
                    VersionToString(v_NetI));
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
        }
        else
        {
            bool got_n;
            got_n=RMInsert("Net", v_Net);
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            if (got_n)
            	temp |= osbyte_CONFIGURE_BOOT_NET_MASK;
            else
            	temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
            if (!got_n)
            {
            	fprintf(BootFile,
            	        "|\n"
                        "| Econet\n"
                        "|\n"
                        "Set Net$Device %s\n"
                        "Run BootResources:!Internet.utils.BootNet\n",
                        "\"\"");
            }
        }
        RMInsert("BootNet", 0);
        RMInsert("NetFS", 0);
        RMInsert("NetPrint", 0);
        RMInsert("NetFiler", 0);
        RMInsert("NetStatus", 0);
        RMInsert("NetUtils", 0);
        RMInsert("BBCEconet", 0);
    }
    else
    {
        temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
        temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
        writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
    }

    return 0;
}

static os_error *SetupInternet(void)
{
    int i;
    bool dhcp_wanted = FALSE;
    bool dhcp_private_fallback = FALSE;

    if (InternetEnabled)
    {
        fputs("|================================================================|\n"
              "| Startup file for !Internet                                     |\n"
              "|                                                                |\n"
              "| This file was automatically generated by !InetSetup. Do not    |\n"
              "| edit it by hand unless you REALLY, REALLY, know what you're    |\n"
              "| doing. Comments and spacing are significant to !InetSetup.     |\n"
              "|                                                                |\n"
              "| If you want to add extra configuration options, place them in  |\n"
              "| the User file.                                                 |\n"
              "|================================================================|\n"
              "\n",
              ConfigureFile);

        /* RG: Load the DHCP module whether it's the primary interface or not */
        for (i=0; i<interfaces; ++i)
        {
            if (interface_addrtype[i] == if_DHCP)
            {
                dhcp_wanted = TRUE;
                dhcp_private_fallback = RMFind("DHCP", "System:Modules.Network.DHCP", v_DHCPPrivNet);
                fprintf(ConfigureFile, "|\n"
                                       "| DHCP pre-interface initialisation\n"
                                       "|\n"
                                       "RMEnsure DHCP %s RMLoad System:Modules.Network.DHCP\n",
                        dhcp_private_fallback ? VersionToString(v_DHCPPrivNet) : VersionToString(v_DHCP));
                break;
            }
        }

        fprintf(ConfigureFile, "|\n"
                               "| Host name\n"
                               "|\n"
                               "Set Inet$HostName %s\n", HostName);
        if (Set(LocalDomain))
            fprintf(ConfigureFile, "Set Inet$LocalDomain %s\n", LocalDomain);

    	if (primary_interface != -1)
    	{

    	  /* Need some kind of PPP special case if there is no IP address for primary interface */
    	  /* Will currently just put 'Set Inet$EtherIPAddr ' into a file if no IP address is specified */
    	    if (interface_filename[primary_interface][0] != '\0')
               fprintf(ConfigureFile, "Set Inet$EtherDevice %s\n",
                                       interface_filename[primary_interface]);
            if (interface_addrtype[primary_interface] == if_Manual ||
                interface_addrtype[primary_interface] == if_FromHostname)
            {
              /* I think this is where we will go if PPP is chosen */
              /* I have chosen to not write anything where an address is not present */
              if (strlen(interface_address[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n", interface_address[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr \"\"\n");

              if (strlen(interface_netmask[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPMask %s\n", interface_netmask[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPMask \"\"\n");
            }
            else if (interface_addrtype[primary_interface] == if_FromCMOS)
            {
                fprintf(ConfigureFile, "SetMacro Inet$EtherIPAddr <Inet$CMOSIPAddr>\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_netmask[primary_interface]);
            }
            else
            {
                const char *address_type;
                switch (interface_addrtype[primary_interface])
                {
                        case if_RevARP: address_type = "revarp"; break;
                        case if_DHCP: address_type = "dhcp"; break;
                        default: address_type = "bootp"; break;
                }
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       address_type,
                                       "default");
            }


            if (interface_is_pp[primary_interface])
            {
              if (interface_is_pp[primary_interface] == 2 && interface_address[primary_interface][0] == '\0')
              {
                /* The primary interface has no remote IP address */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr \"\"\n");
              } else
              {
                /* It's ok, either it's a normal PP interface or PPP */
                /* has a remote IP address set, dunno which tho :)   */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n", interface_linkaddr[primary_interface]);
              }
            }

            SaveInterface(primary_interface, dhcp_private_fallback);
        }
        fprintf(ConfigureFile, "Set Inet$EtherTypeA <Inet$EtherType>\n");

        for (i=0; i<interfaces; i++)
        {
            if (i==primary_interface)
                continue;

            SaveInterface(i, dhcp_private_fallback);
        }

        fputs("|\n"
              "| Loopback\n"
              "|\n"
              "IfConfig -e lo0 127.0.0.1\n"
              "CheckError\n"
              "Set Inet$EtherType <Inet$EtherTypeA>\n"
              "Unset Inet$EtherTypeA\n",
              ConfigureFile);

    	if (UseResolver)
    	{
    	    int i, count = 0;
    	    struct { char *mod, *fname; int *version; } rmods[RT_Count] =
    	                    { "Resolver",    "Resolver",   &v_Resolver,
    	                      "Resolve",     "Resolve",    &v_Resolve,
    	                      "InetDB",      "InetDB",     &v_InetDB,
    	                      "DNSResolver", "DNSResolve", &v_DNSResolver };

    	    fprintf(ConfigureFile, "|\n"
    	    	    	    	   "| Name resolver\n"
    	    	    	    	   "|\n");

            /* If we're using a resolver,always set the Inet$Resolver variable as this is how we
               remember whether the "Use resolver" icon is ticked and wont do any harm */
            fprintf(ConfigureFile, "If \"<Inet$Resolvers>\" = \"\" Then Set Inet$Resolvers");

    	    for (i=0; i<3; i++)
    	    {
    	        if (Set(Resolver[i]))
    	        {
    	          fprintf(ConfigureFile, " %s", Resolver[i]);
    	          count=1;
    	        }
    	    }
    	    if (count) fprintf(ConfigureFile, "\n");
    	    else       fprintf(ConfigureFile, " \"\"\n");



    	    fprintf(ConfigureFile,
    	            "Set Alias$InetLoadResolver \"If <Boot$OSVersion> > 370 Then X ResolverConfig Else RMEnsure %s %s RMLoad System:Modules.Network.%s\"\n",
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname/*,
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname*/);

            if (ResolverType == RT_Resolver)
                fprintf(ConfigureFile, "SetEval Inet$TestEval 1\nRMEnsure Resolver %s SetEval Inet$TestEval 0\n"
                	"If Inet$TestEval THEN ResolverConfig\nUnset Inet$TestEval\n",
                	VersionToString(*rmods[ResolverType].version));

    	    if (ResolverType == RT_InetDB || ResolverType == RT_DNSResolver)
    	        SaveResConf();
    	    else if (ResolverType == RT_Resolve)
    	        SaveResolve();

            /* Make sure it's plugged in */
            RMInsert(rmods[ResolverType].mod, *rmods[ResolverType].version);
    	}

    	fprintf(ConfigureFile, "|\n"
    	    	    	       "| Routing\n"
    	    	    	       "|\n");
    	if (Set(Gateway))
    	    fprintf(ConfigureFile, "Route -e add default %s\n"
    	                           "CheckError\n",
    	                           Gateway);

    	fprintf(ConfigureFile, "Run " CONFIGDIR_READ "Routes\n"
    	                       "CheckError\n"
    	                       "Set Inet$IsGateway %s\n"
    	                       "Set Inet$RouteDOptions %s\n",
    	                       AmRouter ? "Yes" : "\"\"",
    	                       UseRouteD ? RouteDoptions : "\"\"");

    	RMInsert("AUNMsgs", v_AUNMsgs);
    	RMInsert("MbufManager", v_MbufManager);
    	if (dhcp_wanted)
    	{
    	    RMInsert("Internet", v_InternetDHCP);
    	    RMInsert("DHCP", dhcp_private_fallback ? v_DHCPPrivNet : v_DHCP);
    	}
    	else
    	{
    	    RMInsert("Internet", v_Internet);
    	}

    	fprintf(BootFile, "Run BootResources:!Internet\n");
    }
    else if (AUNEnabled || AccessEnabled)
    {
        bool got_a, got_m, got_i, got_d = FALSE;

        got_a = RMInsert("AUNMsgs", v_AUNMsgs);
        got_m = RMInsert("MbufManager", v_MbufManager);
        got_i = RMInsert("Internet", v_Internet);

        for (i=0; i<interfaces; i++)
        {
            bool t = RMInsert(interface_module[i], interface_version[i]);
            if (!got_d)
                got_d = t;
        }

        if (!got_a || !got_m || !got_i || !got_d)
        {
            /* Prepare to soft load at least 1 module from !System */
            fprintf(BootFile,
                    "|\n"
              	    "| Internet\n"
              	    "|\n"
              	    "IF \"<BootResources$Path>\" = \"\" THEN Set BootResources$Path <Boot$Dir>.Resources.\n"
                    "IF \"<System$Path>\" = \"\" THEN Run BootResources:!System\n");
        }
        if (!got_m)
        {
            /* MbufManager, required by Internet */
            fprintf(BootFile,
                    "RMEnsure MbufManager %s RMLoad System:Modules.Network.MManager\n",
                    VersionToString(v_MbufManager));
        }
        if (!got_a)
        {
            /* AUNMsgs, required by Internet */
            if (RMFind("Internet", "System:Modules.Network.Internet", v_InternetMsgs) == 0)
            {
                /* The Internet we do have, whether in ROM or in !System, doesn't carry its
                 * own Messages so we must load AUNMsgs too.
                 * Note: when MbufManager was internationalised it carried its own Messages
                 * from the start, so there's no need to consider it here.
                 */
                fprintf(BootFile,
                        "RMEnsure AUNMsgs %s RMLoad System:Modules.Network.AUNMsgs\n",
                        VersionToString(v_AUNMsgs));
            }
        }
        if (!got_i)
        {
            /* Internet, required by AUN and Access */
            fprintf(BootFile,
                    "RMEnsure Internet %s RMLoad System:Modules.Network.Internet\n",
                    VersionToString(v_Internet));
        }
        if (!got_d)
        {
            /* Not got the driver, load primary */
            fprintf(BootFile,
                    "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                    interface_module[0],
                    VersionToString(interface_version[0]),
                    interface_filename[0]);
        }
        if (!got_a || !got_m || !got_i || !got_d)
        {
            fprintf(BootFile,
                    "Run Inet:utils.TriggerCBs\n");
        }
    }

    if (!InternetEnabled && !AUNEnabled && !AccessEnabled)
    {
        Unplug("Internet");
        Unplug("AUNMsgs");
        Unplug("MbufManager");
        Unplug("BootNet");
        Unplug("Net");
    }

    return 0;
}

void SaveSetup(void)
{
    int pagesize, size;
    int rmasize, systemsize;
    os_error e, *ep;
    char buts[64];
    int i;

    if (!Diagnose())
    	return;

    Unplug("InternetA");
    Unplug("Netmsgs");
    Unplug("Accmsgs");

    if (InternetEnabled)
    {
        osfile_create_dir(CONFIGDIR_STEM, 0);

        if (!Exists(CONFIGDIR_READ "User"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.User",
                             CONFIGDIR_WRITE "User",
                             0, 0, 0, 0, 0, 0);

        if (!Exists(CONFIGDIR_READ "Routes"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.Routes",
                             CONFIGDIR_WRITE "Routes",
                             0, 0, 0, 0, 0, 0);

    	ConfigureFile = fopen(CONFIGDIR_WRITE "Startup", "w");
        if (ConfigureFile == NULL)
        {
            ep = (os_error *) _kernel_last_oserror();
            if (ep)
                report_error(ep);
            else
                make_error("CantSaveSetup");
            return;
        }
    }
    BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "w");
    if (BootFile == NULL)
    {
        if (InternetEnabled)
            fclose(ConfigureFile);
        ep = (os_error *) _kernel_last_oserror();
        if (ep)
            report_error(ep);
        else
            make_error("CantSaveSetup");
        return;
    }
    SetupInternet();
    SetupAUN();
    SetupAccess();
    if (InternetEnabled && (AccessEnabled || AUNEnabled))
        fputs("SetEval Inet$KickFiler 1\n", ConfigureFile);
    if (InternetEnabled)
    {
    	fclose(ConfigureFile);
    	osfile_set_type(CONFIGDIR_WRITE "Startup", osfile_TYPE_OBEY);

        /*
         * Sort out memory configurations
         */
        os_read_mem_map_info(&pagesize, 0);

        rmasize = readCMOS(osbyte_CONFIGURE_RMA_SIZE) * pagesize;
        systemsize = readCMOS(osbyte_CONFIGURE_SYSTEM_SIZE) * pagesize;

        if (rmasize < MIN_RMASIZE)
            writeCMOS(osbyte_CONFIGURE_RMA_SIZE, MIN_RMASIZE / pagesize);

        if (systemsize < MIN_SYSTEMSIZE)
            writeCMOS(osbyte_CONFIGURE_SYSTEM_SIZE, MIN_SYSTEMSIZE / pagesize);
    }

    fclose(BootFile);
    osfile_set_type("<Boot$ToBeLoaded>.SetUpNet", osfile_TYPE_OBEY);
    osfile_read_stamped("<Boot$ToBeLoaded>.SetUpNet", 0, 0, &size, 0, 0);
    if (size == 0)
    {
      remove("<Boot$ToBeLoaded>.SetUpNet");
      if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
      {
        /* No networking - so put a blank SetUpNet in */
        osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                         "<Boot$ToBeLoaded>.SetUpNet",
                         0, 0, 0, 0, 0, 0);

        BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "a");

        if (BootFile != NULL)
        {
          if (RMFind("ShareFS",     NULL, 0) == 1) fprintf(BootFile, "Unplug ShareFS\n");
          if (RMFind("Freeway",     NULL, 0) == 1) fprintf(BootFile, "Unplug Freeway\n");
          if (RMFind("Net",         NULL, 0) == 1) fprintf(BootFile, "Unplug Net\n");
          if (RMFind("BootNet",     NULL, 0) == 1) fprintf(BootFile, "Unplug BootNet\n");
          if (RMFind("Internet",    NULL, 0) == 1) fprintf(BootFile, "Unplug Internet\n");
          if (RMFind("AUNMsgs",     NULL, 0) == 1) fprintf(BootFile, "Unplug AUNMsgs\n");
          if (RMFind("MbufManager", NULL, 0) == 1) fprintf(BootFile, "Unplug MbufManager\n");
          if (RMFind("DHCP",        NULL, 0) == 1) fprintf(BootFile, "Unplug DHCP\n");

          fclose(BootFile);
        }
      }
    }

    e.errnum = 0;
    strcpy(e.errmess, msgs_lookup("ResetPrompt"));
    strcpy(buts, msgs_lookup("ResetButs"));

    if (WimpVersion >= 322)
        i=wimp_report_error_by_category(&e,
           wimp_ERROR_BOX_CATEGORY_QUESTION << wimp_ERROR_BOX_CATEGORY_SHIFT,
           msgs_lookup("_TaskName"),
           "!inetsetup",
           (osspriteop_area *) 1,
           buts);
    else
        i=wimp_report_error(&e,
             wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
             msgs_lookup("_TaskName")) + 2;

    if (i==3)
    {
        /*
         * Nice shutdown - on versions that support it (TaskManager 1.36+)
         * bit 5 causes a reboot to occur after shutdown. If an older TM is in use,
         * the restart prompt will be displayed.
         */
        taskmanager_shutdown(taskmanager_SHUTDOWN_REBOOT | taskmanager_SHUTDOWN_SEND_MESSAGE);
    }
    else
        exit(0);
}

static void SaveInterface(int i, bool dhcp_private_fallback)
{
    bool DynamicNetmask;
    char buffer[200];
    char buffer2[32];
    char *msgtag;
    char *addrtype;

    if (interface_address[i][0] == '\0')
    {
#if 0
    	/* Can't do this - another protocol might need the driver! */
        Unplug(interface_module[i]);
#endif

        /* Exit function if driver has no address, with PPP we want to allow no address a special case is added */
        if (interface_is_pp[i] != 2)
          return;
        else
        {
          if (interface_has_section[i] == 0)
          return;
        }

    }

    RMInsert(interface_module[i], interface_version[i]);

    fprintf(ConfigureFile, "|\n"
                           "| Interface: %s\n"
                           "|\n"
                           "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                           interface_name[i],
                           interface_module[i],
                           VersionToString(interface_version[i]),
                           interface_filename[i]);

    if (strcmp(interface_unit[i], "ec0") == 0)
    {
        if (interface_addrtype[i] == if_Manual || interface_addrtype[i] == if_FromHostname)
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_address[i],
                                   interface_netmask[i]);
        else
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                                   "default");
    }

    // Yucko!
    DynamicNetmask = strcmp(interface_netmask[i], msgs_lookup("ICMPReq")) == 0;

    switch (interface_addrtype[i])
    {
      case if_FromHostname:
      case if_Manual:

        if (!interface_is_pp[i])
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_netmask[i]);
        }
        else
        {
          /* PP interface, PPP doesn't use IfConfig to set it up so skip it */
          if (interface_is_pp[i] == 1)
          {
            fprintf(ConfigureFile, "IfConfig -e %s %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_linkaddr[i],
                                    interface_netmask[i]);
          }
          else
          {
            if (strlen(interface_address[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr %s\n",
                                     interface_name[i],
                                     interface_address[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_linkaddr[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr %s\n",
                                     interface_name[i],
                                     interface_linkaddr[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_netmask[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPMask %s\n",
                                     interface_name[i],
                                     interface_netmask[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPMask \"\"\n",
                                     interface_name[i]);
          }
        }
        break;

      case if_FromCMOS:
        fprintf(ConfigureFile, "Run Inet:utils.ReadCMOSIP\n"
                               "IfConfig -e %s <Inet$CMOSIPAddr> netmask %s\n",
                               interface_unit[i],
                               interface_netmask[i]);
        break;

      case if_DHCP:
        strcpy(buffer2, msgs_lookup("DHCP"));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "DHCPExecute -e -b -w %s%s\n"
                               "CheckError\n"
                               "If \"<Inet$Gateway>\" <> \"\" Then do /Inet:bin.route -e add default <Inet$Gateway>\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               dhcp_private_fallback ? "-p " : "",
                               interface_unit[i]);
        break;

      case if_RevARP:
      case if_BOOTP:
        switch (interface_addrtype[i])
        {
          case if_RevARP: msgtag = "RevARP"; addrtype = "revarp"; break;
          default:        msgtag = "BOOTP";  addrtype = "bootp";  break;
        }
        strcpy(buffer2, msgs_lookup(msgtag));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "IfRConfig -e %s %s%s\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN "
                                        "Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               interface_unit[i],
                               addrtype,
                               DynamicNetmask ? " netmask" : "");
        if (!DynamicNetmask)
            fprintf(ConfigureFile, "If \"%s\" <> \"default\" Then IfConfig -e %s netmask %s\n"
                                   "CheckError\n",
                                   interface_netmask[i],
                                   interface_unit[i],
                                   interface_netmask[i]);
        break;
    }
}

void SaveResolve(void)
{
    FILE *f=fopen("InetDBase:resolve", "w");
    int i;

    if (f)
    {
        fprintf(f, "domain %s\n", LocalDomain);
        for (i = 0; i < 3; i++)
        {
            if (Resolver[i][0])
                fprintf(f, "nameserver %s\n", Resolver[i]);
        }
        fclose(f);
    }
}

void SaveResConf(void)
{
    FILE *f, *old;
    char buffer[256];
    char buf2[256];
    int ns=0;

    xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    xosfscontrol_rename("InetDBase:resconf", "<Wimp$ScrapDir>.OldResConf");

    f=fopen("InetDBase:resconf", "w");
    if (!f)
    {
        xosfscontrol_rename("<Wimp$ScrapDir>.OldResConf", "InetDBase:resconf");
        return;
    }

    old=fopen("<Wimp$ScrapDir>.OldResConf", "r");

    if (old)
    {
        while (fgets(buffer, sizeof buffer, old))
        {
            if (sscanf(buffer, "domain %s", buf2) == 1)
                fprintf(f, "domain     %s.\n", LocalDomain);
            else if (sscanf(buffer, "nameserver %s", buf2) == 1)
            {
                if (ns < 3 && Resolver[ns][0])
                    fprintf(f, "nameserver %s\n", Resolver[ns++]);
            }
            else
                fprintf(f, "%s", buffer);
        }
        fclose(old);
        xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    }
    else
    {
        fprintf(f, "domain     %s.\n", LocalDomain);
        fprintf(f, "cachesize  16k\n"
                   "cacheload  resboot rescache\n"
                   "cachesave  rescache\n"
                   "retry      3\n"
                   "timeout    3 12\n"
                   "lookup     file bind\n");
    }

    for (; ns < 3; ns++)
        if (Resolver[ns][0])
            fprintf(f, "nameserver %s\n", Resolver[ns]);

    fclose(f);

    f=fopen("InetDBase:resboot", "w");
    if (f)
    {
        struct hostent *hp=gethostbyname(HostName);

        fprintf(f, "$ORIGIN %s.\n", LocalDomain);
        fprintf(f, "%-40.40sIN A     %d.%d.%d.%d\n", HostName, hp->h_addr[0],
                                                               hp->h_addr[1],
                                                               hp->h_addr[2],
                                                               hp->h_addr[3]);
        sprintf(buffer, "%d.%d.%d.%d.in-addr.arpa.", hp->h_addr[3], hp->h_addr[2],
                                                     hp->h_addr[1], hp->h_addr[0]);
        fprintf(f, "%-40.40sIN PTR   %s\n", buffer, HostName);
        fclose(f);
    }
}
@


1.16
log
@Only ensure AUNMsgs when they're needed
When TCP/IP networking is disabled, but AUN or Access are enabled, the Internet module is loaded for its IP handling. In doing so, only load AUNMsgs if the Internet module to hand actually requires it.
Save.c:
  Check if the Internet module is new enough to contain its own messages, and don't load AUNMsgs if so.
Load.c/Versions.h/Messages:
  Populate v_InternetMsgs.
Main.h/Main.c:
  Turn the resolver types into an enum so the max value can be used instead of magic number 4.
SmallDrag.c:
  Don't look for Wimp_PlotIcon define, it's been in the headers for years.
UK/!Run:
  Simplify the check, !InetSetup doesn't need AUNMsgs itself.
Save.c/Routes/SetUpNet:
  Remove the hardwired version string of !Internet, since the files end up in Choices:, that way it can't be out of date ever again.

Version 0.58. Tagged as 'Source-0_58'
@
text
@d38 2
@


1.15
log
@Resource updates
The blank User and Routes files were referencing some ancient !Internet.
The Resolver test expressions were using variables not registered for the Internet module, moved from Test$Eval to Inet$TestEval.
The !Help was missing some detail, added.

Version 0.56. Tagged as 'Source-0_56'
@
text
@d115 1
a115 1
                    "| AUN\n"
d144 1
a144 1
                        "| AUN\n"
d178 1
a178 1
              "| Startup file for !Internet V5.49 (31-Aug-12)                   |\n"
d296 1
a296 1
    	    struct { char *mod, *fname; int *version; } rmods[4] =
d378 6
a383 5
        int temp;
    	got_a=RMInsert("AUNMsgs", v_AUNMsgs);
    	got_m=RMInsert("MbufManager", v_MbufManager);
    	got_i=RMInsert("Internet", v_Internet);
        for (temp = 0; temp < interfaces; temp++)
d385 1
a385 1
            bool t = RMInsert(interface_module[temp], interface_version[temp]);
d391 2
d399 1
a399 4
        if (!got_a)
            fprintf(BootFile,
              	    "RMEnsure AUNMsgs %s RMLoad System:Modules.Network.AUNMsgs\n",
              	    VersionToString(v_AUNMsgs));
d401 2
d404 18
a421 2
              	    "RMEnsure MbufManager %s RMLoad System:Modules.Network.MManager\n",
              	    VersionToString(v_MbufManager));
d423 9
d433 1
a433 6
              	    "RMEnsure Internet %s RMLoad System:Modules.Network.Internet\n",
              	    VersionToString(v_Internet));

    	if (!got_d)
    	    fprintf(BootFile,
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
d437 1
a437 1

d439 1
d441 2
a442 1
            	    "Run Inet:utils.TriggerCBs\n");
d559 2
@


1.14
log
@Add a live interface status/statistics view to the interface dialogue
This new button, 'status', to compliment the 'configure' button, shows various useful facts for an interface (packets, errors, link state, IP address) and updates every second.
Previously, obtaining this information required messing around with showstat or ifconfig at the command line.

Version 0.50. Tagged as 'Source-0_50'
@
text
@d88 1
a88 1
        // The next two are necessary to run Resources:$.Resources.ShareFS.!Boot
d333 2
a334 2
                fprintf(ConfigureFile, "SetEval Test$Eval 1\nRMEnsure Resolver %s SetEval Test$Eval 0\n"
                	"If Test$Eval THEN ResolverConfig\nUnset Test$Eval\n",
d418 1
a418 1
            	    "Run BootResources:!Internet.utils.TriggerCBs\n");
@


1.13
log
@Fix to work when DHCP doesn't support -p switch
The DHCP module uses OS_ReadArgs for switch matching, but in the CMHG table it strictly checks for max-args. The recently added '-p' switch therefore should not be output by !InetSetup when the available module doesn't support it.
Load.c: parse setup files with or without -p
Save.c: use RMFind() to figure out if -p is available, and omit it when not
Also
* Bumped up the !Internet version number in the comment block written out
* Make sure DHCP is plugged in during save (and unplugged if TCP/IP is actively disabled)
* Fixed the minimum DHCP version number, !InetSetup was always outputting -w even though that wasn't supported in the version that was being RMEnsure'd

Version 0.48. Tagged as 'InetSetup-0_48'
@
text
@d26 1
a39 2
#include "my_swis.h"

a556 16
#if 0
        int osversion;
        
        /*
         * The call to osfscontrol_shutdown was causing disc corruption on
         * Raspberry Pi, and shouldn't be needed anyway as we call TaskManager_Shutdown
         */
        xhourglass_on();
        osfscontrol_shutdown();
        xhourglass_off(); /* Not sure why I bother doing this :-) */
        osversion = osbyte1(osbyte_IN_KEY, 0, 255);
        if (osversion >= 0xA5) /* If we're on RISC OS 3.50 or later... */
            os_reset();
        else
            os_reset_old_machine();
#else
d558 1
a558 1
         * A nicer shutdown - on versions that support it (TaskManager 1.36+)
d562 1
a562 2
        _swix(TaskManager_Shutdown, _IN(0), (1<<5) | (1<<3));
#endif
@


1.12
log
@Employ bit 5 of TaskManager_Shutdown
Harmless on task managers that don't support it.
Uncurled some braces to match local style.
Don't compare "FILE *" with 0, uses NULL.
Switched out unused os_reset_old_machine assembler.

Version 0.45. Tagged as 'InetSetup-0_45'
@
text
@d46 1
a46 1
static void SaveInterface(int);
d173 2
a174 1
    bool wanted_dhcp = FALSE;
d179 1
a179 1
              "| Startup file for !Internet V5.39 (10-Jan-03)                   |\n"
d196 7
a202 3
                fprintf(ConfigureFile, "|\n| DHCP pre-interface initialisation\n|\nRMEnsure DHCP %s RMLoad System:Modules.Network.DHCP\n",
                        VersionToString(v_DHCP));
                wanted_dhcp = TRUE;
d273 1
a273 1
            SaveInterface(primary_interface);
d282 1
a282 1
            SaveInterface(i);
d364 9
a372 1
    	RMInsert("Internet", wanted_dhcp ? v_InetDHCP : v_Internet);
d526 1
a526 1
        if (BootFile)
d535 1
d586 1
a586 1
static void SaveInterface(int i)
d705 1
a705 1
                               "DHCPExecute -e -b -w -p %s\n"
d709 1
a709 2
                               "IF \"<Wimp$State>\" = \"commands\" THEN "
                                        "Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
d711 1
@


1.11
log
@Rmensure DHCP module if an interface is using DHCP, whether or not it's the primary interface.
Don't rmensure DHCP if interface is turned off.
Faded netmask box if DHCP or BOOTP are in use.
Call TaskManager_Shutdown instead of OS_Reset.
Removed call to osfscontrol_shutdown that was causing disc corruption on Raspberry Pi.

Version 0.44. Tagged as 'InetSetup-0_44'
@
text
@d191 10
a200 9
        for (i=0; i<interfaces; ++i) {
                if (interface_addrtype[i] == if_DHCP) {
                        fprintf(ConfigureFile, "|\n| DHCP pre-interface initialisation\n|\nRMEnsure DHCP %s RMLoad System:Modules.Network.DHCP\n",
                        	VersionToString(v_DHCP));
                        wanted_dhcp = TRUE;
                        break;
                }
        } // end for (i)

a427 1
    int osversion;
d451 1
a451 1
        if (ConfigureFile == 0)
d462 1
a462 1
    if (BootFile == 0)
d543 1
d545 14
a558 1
    	wimp_process_key(wimp_KEY_SHIFT|wimp_KEY_CONTROL|wimp_KEY_F12);
a559 13
    {
      /*
       * the call to osfscontrol_shutdown was causing disc corruption on
       * Raspberry Pi, and shouldn't be needed anyway as we call TaskManager_Shutdown
      */
//        xhourglass_on();
//        osfscontrol_shutdown();
//        xhourglass_off(); /* Not sure why I bother doing this :-) */
//        osversion = osbyte1(osbyte_IN_KEY, 0, 255);
//        if (osversion >= 0xA5) /* If we're on RISC OS 3.50 or later... */
//    	    os_reset();
//    	else
//    	    os_reset_old_machine();
d563 4
a566 6
         * the shutdown screen will be displayed.
         * NOTE - Current OS_Reset (which the TaskManager calls if bit 5 is set)
         * causes a data abort on Raspberry Pi, so bit 5 can't be used yet.
        */
        int flags = /*(1<<5) |*/ (1<<3);
        _swix(TaskManager_Shutdown, _IN(0), flags);
a567 1
#endif
d569 1
a569 1
    	exit(0);
@


1.10
log
@Added "-p" switch to DHCPExecute command in autogenerated setup file.

Version 0.43. Tagged as 'InetSetup-0_43'
@
text
@d19 1
d190 1
d192 1
a192 1
                if (interface_addrtype[primary_interface] == if_DHCP) {
d198 2
a199 1
        }
d547 21
a567 8
        xhourglass_on();
        osfscontrol_shutdown();
        xhourglass_off(); /* Not sure why I bother doing this :-) */
        osversion = osbyte1(osbyte_IN_KEY, 0, 255);
        if (osversion >= 0xA5) /* If we're on RISC OS 3.50 or later... */
    	    os_reset();
    	else
    	    os_reset_old_machine();
@


1.9
log
@Get focus right when opening AUN dialogue.
Was previously stuck at the window behind, so escape closed both.
Makefile recreated - now inserts version number into Messages at build time.
Some trivial warnings resolved.

Version 0.40. Tagged as 'InetSetup-0_40'
@
text
@d301 1
a301 1
         
d312 1
a312 1
    	 
d677 1
a677 1
                               "DHCPExecute -e -b -w %s\n"
@


1.8
log
@Delete a few !RunImages
Add CoSprite (rectangular pixel versions)
Docs and version number tweak
The resolver setup will now try to RMInsert any unplugged modules when
saving the settings.
Change to DNS window so that it remembers the "Use name servers also" icon
rather than having two forgetful radio icons.

Version 0.34. Tagged as 'InetSetup-0_34'
@
text
@d49 1
a49 1
static os_error *SetupAccess()
d101 1
a101 1
static os_error *SetupAUN()
d169 1
a169 1
static os_error *SetupInternet()
@


1.7
log
@Changes to the greying out behaviour in the "Obtain IP address" dialogue
as it was a real mess,particularly the behaviour when DHCP was selected.
UK Res file overhaul.
You can now drag the AUNMap to an editor and it will be loaded.
New Sprites files.

Version 0.33. Tagged as 'InetSetup-0_33'
@
text
@d177 1
a177 1
              "| Startup file for !Internet V5.xx (21st May 1996)               |\n"
d287 1
a287 1
    	    int i;
d298 7
a304 6
            if (ResolverType == RT_Resolver)
            {
                int count = 0;
                fprintf(ConfigureFile, "If \"<Inet$Resolvers>\" = \"\" Then Set Inet$Resolvers");

    	        for (i=0; i<3; i++)
d306 2
a307 5
    	            if (Set(Resolver[i]))
    	            {
    	              fprintf(ConfigureFile, " %s", Resolver[i]);
    	              count=1;
    	            }
a308 2
    	        if (count) fprintf(ConfigureFile, "\n");
    	        else       fprintf(ConfigureFile, " \"\"\n");
d310 3
d333 3
@


1.6
log
@  Bad InetSetup wasn't setting the default route if DHCP was enabled :-(
  Only taken a year for us to notice...
Detail:
  Default route set only if <Inet$Gateway> defined.
Admin:
  Tested on RiscOS 3.7 using EtherB & EtherH NICs.

Version 0.32. Tagged as 'InetSetup-0_32'
@
text
@d301 1
a301 1
                fprintf(ConfigureFile, "If \"<Inet$Resolvers>\" = \"\" Then Set Inet$Resolvers ");
d308 1
a308 1
    	              count++;
d312 1
a312 1
    	        else       fprintf(ConfigureFile, "\"\"\n");
d317 1
a317 1
    	            "Set Alias$InetLoadResolver \"If <Boot$OSVersion> > 370 Then /Inet:bin.X ResolverConfig Else RMEnsure %s %s RMLoad System:Modules.Network.%s\"\n",
@


1.5
log
@  Update to DHCP support.
Detail:
  When configuring a host for DHCP the '-w' flag is now passed to
  *dhcpexecute.
Admin:
  Tested briefly on Ursula.

Version 0.30. Tagged as 'InetSetup-0_30'
@
text
@d677 2
@


1.4
log
@  DHCP support added.
Detail:
  The DHCP button in the interface configuration window is now unfaded
    as long as InetSetup can locate Internet 5.31 or later and DHCP
    0.11 and later.  Any number of interfaces may use DHCP to configure
    their interfaces,
Admin:
  Tested in Risc PCs

Version 0.29. Tagged as 'InetSetup-0_29'
@
text
@d675 1
a675 1
                               "DHCPExecute -e -b %s\n"
@


1.3
log
@  Merge of half a dozen separate branches to the trunk:
    Ursula
    Ursula_RiscPC
    StrongARM
    Daytona(!)
    sbrodie_InetSetup_dev-1_1_2_3
    ART
Detail:
  What a mess.
Admin:
  This is the Ursula plugin version.  It builds.

Version 0.28. Tagged as 'InetSetup-0_28'
@
text
@d172 1
d189 9
d353 1
a353 1
    	RMInsert("Internet", v_Internet);
d671 12
a684 1
      case if_DHCP:
a687 1
          case if_DHCP:   msgtag = "DHCP";   addrtype = "dhcp";   break;
@


1.2
log
@Version RO_3_71 taken
@
text
@d38 2
a48 2
extern void os_reset_old_machine(void);

d59 1
a59 2
            	    "IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    "Run Resources:$.Resources.ShareFS.!Boot\n"
d80 1
a80 2
            	    	"IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    	"Run Resources:$.Resources.ShareFS.!Boot\n"
d119 1
a119 1
                    "RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
d176 1
a176 1
              "| Startup file for !Internet V5.00 (21st May 1996)               |\n"
d179 1
a179 1
              "| edit it by hand unless you really, REALLY, know what you're    |\n"
d197 3
d206 11
a216 4
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_address[primary_interface],
                                       interface_netmask[primary_interface]);
d226 7
d235 1
a235 1
                                       interface_addrtype[primary_interface] == if_RevARP ? "revarp" : "bootp",
d238 2
d241 12
a252 2
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n",
                                       interface_linkaddr[primary_interface]);
d290 2
a291 1
                fprintf(ConfigureFile, "Set Inet$Resolvers");
d296 4
a299 1
    	                fprintf(ConfigureFile, " %s", Resolver[i]);
d301 2
a302 1
    	        fprintf(ConfigureFile, "\n");
d305 1
d307 4
a310 1
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
d313 6
a318 1
    	            rmods[ResolverType].fname);
d488 11
a498 2
    	remove("<Boot$ToBeLoaded>.SetUpNet");
        if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
d500 7
a506 4
            /* No networking - so put a blank SetUpNet in */
            osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                             "<Boot$ToBeLoaded>.SetUpNet",
                             0, 0, 0, 0, 0, 0);
d508 1
d551 2
d560 10
a569 1
        return;
d604 1
d615 3
d624 27
d663 8
a670 1
        strcpy(buffer2, msgs_lookup(interface_addrtype[i] == if_RevARP?"RevARP":"BOOTP"));
d679 1
a679 1
                               interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
d682 1
a682 1
            fprintf(ConfigureFile, "IfConfig -e %s netmask %s\n"
d684 1
@


1.2.2.1
log
@Support added for PPP module and additional network cards.  Front end has also
been modified to fit style guide more closely.
@
text
@a58 1
            	    /*
a60 2
            	    */
            	    "IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
a198 3

    	  /* Need some kind of PPP special case if there is no IP address for primary interface */
    	  /* Will currently just put 'Set Inet$EtherIPAddr ' into a file if no IP address is specified */
d205 4
a208 11
              /* I think this is where we will go if PPP is chosen */
              /* I have chosen to not write anything where an address is not present */
              if (strlen(interface_address[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n", interface_address[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr \"\"\n");

              if (strlen(interface_netmask[primary_interface]) > 0)
                fprintf(ConfigureFile, "Set Inet$EtherIPMask %s\n", interface_netmask[primary_interface]);
              else
                fprintf(ConfigureFile, "Set Inet$EtherIPMask \"\"\n");
a222 2


d224 2
a225 12
            {
              if (interface_is_pp[primary_interface] == 2 && interface_address[primary_interface][0] == '\0')
              {
                /* The primary interface has no remote IP address */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr \"\"\n");
              } else
              {
                /* It's ok, either it's a normal PP interface or PPP */
                /* has a remote IP address set, dunno which tho :)   */
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n", interface_linkaddr[primary_interface]);
              }
            }
d263 1
a263 2
                int count = 0;
                fprintf(ConfigureFile, "Set Inet$Resolvers ");
d268 1
a268 4
    	            {
    	              fprintf(ConfigureFile, " %s", Resolver[i]);
    	              count++;
    	            }
d270 1
a270 2
    	        if (count) fprintf(ConfigureFile, "\n");
    	        else       fprintf(ConfigureFile, "\"\"\n");
a272 1

d274 1
a274 5
//    	            "| RMEnsure %s %s RMLoad System:Modules.Network.%s\n"
    	            "Set Alias$InetLoadResolver \"RMEnsure %s %s RMLoad System:Modules.Network.%s\"\n",
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname,
d447 2
a448 11
      remove("<Boot$ToBeLoaded>.SetUpNet");
      if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
      {
        /* No networking - so put a blank SetUpNet in */
        osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                         "<Boot$ToBeLoaded>.SetUpNet",
                         0, 0, 0, 0, 0, 0);

        BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "a");

        if (BootFile)
d450 4
a453 7
          if (RMFind("ShareFS",     NULL, 0) == 1) fprintf(BootFile, "Unplug ShareFS\n");
          if (RMFind("Freeway",     NULL, 0) == 1) fprintf(BootFile, "Unplug Freeway\n");
          if (RMFind("Net",         NULL, 0) == 1) fprintf(BootFile, "Unplug Net\n");
          if (RMFind("BootNet",     NULL, 0) == 1) fprintf(BootFile, "Unplug BootNet\n");
          if (RMFind("Internet",    NULL, 0) == 1) fprintf(BootFile, "Unplug Internet\n");
          if (RMFind("AUNMsgs",     NULL, 0) == 1) fprintf(BootFile, "Unplug AUNMsgs\n");
          if (RMFind("MbufManager", NULL, 0) == 1) fprintf(BootFile, "Unplug MbufManager\n");
a454 1
      }
a503 3

        /* Exit function if driver has no address, with PPP we want to allow no address a special case is added */
        if (interface_is_pp[i] != 2)
a504 6
        else
        {
          if (interface_has_section[i] == 0)
          return;
        }

a538 1

a548 3
          /* PP interface, PPP doesn't use IfConfig to set it up so skip it */
          if (interface_is_pp[i] == 1)
          {
a554 26
          } else
          {
            if (strlen(interface_address[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr %s\n",
                                     interface_name[i],
                                     interface_address[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_linkaddr[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr %s\n",
                                     interface_name[i],
                                     interface_linkaddr[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$LinkIPAddr \"\"\n",
                                     interface_name[i]);

            if (strlen(interface_netmask[i]) > 0)
              fprintf(ConfigureFile, "Set Inet$%s$IPMask %s\n",
                                     interface_name[i],
                                     interface_netmask[i]);
            else
              fprintf(ConfigureFile, "Set Inet$%s$IPMask \"\"\n",
                                     interface_name[i]);
          }
@


1.2.2.2
log
@This is version 0.23 (15-Dec-97) of !InetSetup.
Principle changes in this version are that :-
a) 'use DNS' is now chosen by default, provided that a DNS client is available.
b) PPP is no longer considered a suitable candidate for 'default' interface -
   whilst in practice, it may be the only interface, it will not have a default
   netmask setup for it, and it will not be marked as 'set IP address from
   hostname'.
c) Certain incorrect values in the table of known interfaces were removed.
d) Certain headers appeared to be missing - these have been added to the local
   headers directory, rather than relying upon OSLib's example programs
   headers being in some 'appropriate' place.

Version 0.22, 1.1.2.2. Tagged as 'InetSetup-0_22-1_1_2_2'
@
text
@d59 4
d84 2
a85 1
            	    	"IfThere Resources:$.Resources.ShareFS.!Boot then Run Resources:$.Resources.ShareFS.!Boot\n"
d181 1
a181 1
              "| Startup file for !Internet V5.xx (21st May 1996)               |\n"
d184 1
a184 1
              "| edit it by hand unless you REALLY, REALLY, know what you're    |\n"
d305 1
d555 1
a555 1
          return;
d616 1
a616 2
          }
          else
@


1.2.2.3
log
@Now compatible with OSLib 4.8.

Ursula Configure plug-in interface added; updated sprites to Ursula design.

Windows now open from the position of the icon clicked on, as in the rest of
Configure.

In the AUN section (if any) of the generated Startup file,
   RMEnsure BBCEconet 0 RMReInit BBCEconet
is replaced with
   RMEnsure UtilityModule 3.80 RMEnsure BBCEconet 0 RMReInit BBCEconet
because there's no BBCEconet module in Ursula.
@
text
@a37 2
#include "my_swis.h"

d47 2
d119 1
a119 1
                    "RMEnsure UtilityModule 3.80 RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
d303 1
a303 1
    	            rmods[ResolverType].fname/*,
d306 1
a306 1
    	            rmods[ResolverType].fname*/);
@


1.2.2.4
log
@* InetSetup is now aware that it needs to issue *ResolverConfig commands
  if a new-enough Acorn Resolver module is present in ROM and it changes
  pertinent Inet system variables.
* InetSetup now knows that Resolver 0.55 is the latest version to date.
  Application version number incremented to 0.26.  Probably it ought to
  be told about the latest versions of other stuff too, but I haven't
  done that.

Version 0.22, 1.1.2.3. Tagged as 'InetSetup-0_22-1_1_2_3'
@
text
@a307 5
            if (ResolverType == RT_Resolver)
                fprintf(ConfigureFile, "SetEval Test$Eval 1\nRMEnsure Resolver %s SetEval Test$Eval 0\n"
                	"If Test$Eval THEN ResolverConfig\nUnset Test$Eval\n",
                	VersionToString(*rmods[ResolverType].version));

@


1.2.2.5
log
@Now sets Alias$InetLoadResolver to do a *ResolverConfig instead of a *RMEnsure
if running on a >3.70 OS. (This simplifies the boot sequence.)
Blanks.CVS should no longer appear in installation.
WimpSlot updated to reflect memory actually needed.

Version 0.22, 1.1.2.4. Tagged as 'InetSetup-0_22-1_1_2_4'
@
text
@d300 1
a300 1
    	            "Set Alias$InetLoadResolver \"If <Boot$OSVersion> > 370 Then /Inet:bin.X ResolverConfig Else RMEnsure %s %s RMLoad System:Modules.Network.%s\"\n",
@


1.2.2.4.2.1
log
@  Added support code for DHCP configurations.  Work in progress.
Detail:
  c.Load/c.Save: modified to use "dhcp" parameter to ifrconfig command in
      Choices:Internet.Startup
  c.IfsDbox: modified to handle gadget flags as appropriate for DHCP
      (just extends BootP/RevARP handler code with a third case)
  Resources/*/Res: Unfaded DHCP optionbutton.  Now controlled from code.
  Resources/*/Messages: Updated version number.
Admin:
  Work in progress - private development branch work not yet complete.

Version 0.22, 1.1.2.3.2.1. Tagged as 'InetSetup-0_22-1_1_2_3_2_1'
@
text
@a225 7
                const char *address_type;
                switch (interface_addrtype[primary_interface])
                {
                        case if_RevARP: address_type = "revarp"; break;
                        case if_DHCP: address_type = "dhcp"; break;
                        default: address_type = "bootp"; break;
                }
d228 1
a228 1
                                       address_type,
d284 1
a284 1
                fprintf(ConfigureFile, "If \"<Inet$Resolvers>\" = \"\" Then Set Inet$Resolvers ");
a543 2
    char *msgtag;
    char *addrtype;
d654 1
a654 8
      case if_DHCP:
        switch (interface_addrtype[i])
        {
          case if_RevARP: msgtag = "RevARP"; addrtype = "revarp"; break;
          case if_DHCP:   msgtag = "DHCP";   addrtype = "dhcp";   break;
          default:        msgtag = "BOOTP";  addrtype = "bootp";  break;
        }
        strcpy(buffer2, msgs_lookup(msgtag));
d663 1
a663 1
                               addrtype,
d666 1
a666 1
            fprintf(ConfigureFile, "If \"%s\" <> \"default\" Then IfConfig -e %s netmask %s\n"
a667 1
                                   interface_netmask[i],
@


1.1
log
@file Save was initially added on branch RO_3_70_to_3_71.
@
text
@d1 672
@


1.1.4.1
log
@Version RO_3_71 taken
@
text
@a0 672
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"

#include "osbyte.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "wimp.h"
#include "hourglass.h"

#include "ModUtils.h"
#include "Save.h"
#include "Main.h"
#include "Load.h"
#include "AUN.h"
#include "Versions.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Diagnose.h"

#include "netdb.h"

#define MIN_RMASIZE (256*1024)
#define MIN_SYSTEMSIZE (8*1024)

static FILE *BootFile, *ConfigureFile;

static void SaveInterface(int);
static void SaveResolve(void);
static void SaveResConf(void);

extern void os_reset_old_machine(void);

static os_error *SetupAccess()
{
    if (AccessEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
            	    "| Access\n"
            	    "|\n"
            	    "IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    "Run Resources:$.Resources.ShareFS.!Boot\n"
            	    "RMFind Freeway %s System:Modules.Network.Freeway\n",
            	    VersionToString(v_Freeway));
            fprintf(ConfigureFile,
            	    "RMFind ShareFS %s System:Modules.Network.Share+\n",
            	    VersionToString(v_ShareFS));
    	    RMInsert("Freeway", v_Freeway);
    	    RMInsert("ShareFS", v_ShareFS);
        }
        else
        {
            bool got_f, got_s;

            got_f=RMInsert("Freeway", v_Freeway);
            got_s=RMInsert("ShareFS", v_ShareFS);
            if (!got_f || !got_s)
            {
            	fprintf(BootFile,
                    	"|\n"
            	    	"| Access\n"
            	    	"|\n"
            	    	"IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    	"Run Resources:$.Resources.ShareFS.!Boot\n"
            	    	"RMEnsure Freeway %s RMLoad System:Modules.Network.Freeway\n",
            	    	VersionToString(v_Freeway));
            	fprintf(BootFile,
            	    	"RMEnsure ShareFS %s RMLoad System:Modules.Network.Share+\n",
            	    	VersionToString(v_ShareFS));
            }
        }
        // The next two are necessary to run Resources:$.Resources.ShareFS.!Boot
        RMInsert("BootNet", 0);
        RMInsert("AUNMsgs", 0);
    }
    else
    {
        Unplug("ShareFS");
        Unplug("Freeway");
    }

    return 0;
}

static os_error *SetupAUN()
{
    int temp;
    extern toolbox_o AUNObject;

    if (AUNObject && (AUNEnabled || HaveEconet))
    	UpdateAUNCMOS();

    if (AUNEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
                    "| AUN\n"
                    "|\n"
                    "RMFind NetI %s System:Modules.Network.NetI\n"
                    "Run InetDBase:AUNMap\n"
                    "RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
                    "RMEnsure NetFS 0 RMReInit NetFS\n"
                    "RMEnsure NetFS 5.79 RMEnsure NetUtils 0.99 "
                                    "Run System:Modules.Network.NetUtils\n"
                    "RMEnsure NetPrint 0 RMReInit NetPrint\n"
                    "RMEnsure NetFiler 0 RMReInit NetFiler\n",
                    VersionToString(v_NetI));
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
        }
        else
        {
            bool got_n;
            got_n=RMInsert("Net", v_Net);
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            if (got_n)
            	temp |= osbyte_CONFIGURE_BOOT_NET_MASK;
            else
            	temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
            if (!got_n)
            {
            	fprintf(BootFile,
            	        "|\n"
                        "| AUN\n"
                        "|\n"
                        "Set Net$Device %s\n"
                        "Run BootResources:!Internet.utils.BootNet\n",
                        "\"\"");
            }
        }
        RMInsert("BootNet", 0);
        RMInsert("NetFS", 0);
        RMInsert("NetPrint", 0);
        RMInsert("NetFiler", 0);
        RMInsert("NetStatus", 0);
        RMInsert("NetUtils", 0);
        RMInsert("BBCEconet", 0);
    }
    else
    {
        temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
        temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
        writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
    }

    return 0;
}

static os_error *SetupInternet()
{
    int i;

    if (InternetEnabled)
    {
        fputs("|================================================================|\n"
              "| Startup file for !Internet V5.00 (21st May 1996)               |\n"
              "|                                                                |\n"
              "| This file was automatically generated by !InetSetup. Do not    |\n"
              "| edit it by hand unless you really, REALLY, know what you're    |\n"
              "| doing. Comments and spacing are significant to !InetSetup.     |\n"
              "|                                                                |\n"
              "| If you want to add extra configuration options, place them in  |\n"
              "| the User file.                                                 |\n"
              "|================================================================|\n"
              "\n",
              ConfigureFile);

        fprintf(ConfigureFile, "|\n"
                               "| Host name\n"
                               "|\n"
                               "Set Inet$HostName %s\n", HostName);
        if (Set(LocalDomain))
            fprintf(ConfigureFile, "Set Inet$LocalDomain %s\n", LocalDomain);

    	if (primary_interface != -1)
    	{
    	    if (interface_filename[primary_interface][0] != '\0')
               fprintf(ConfigureFile, "Set Inet$EtherDevice %s\n",
                                       interface_filename[primary_interface]);
            if (interface_addrtype[primary_interface] == if_Manual ||
                interface_addrtype[primary_interface] == if_FromHostname)
            {
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_address[primary_interface],
                                       interface_netmask[primary_interface]);
            }
            else if (interface_addrtype[primary_interface] == if_FromCMOS)
            {
                fprintf(ConfigureFile, "SetMacro Inet$EtherIPAddr <Inet$CMOSIPAddr>\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_netmask[primary_interface]);
            }
            else
            {
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_addrtype[primary_interface] == if_RevARP ? "revarp" : "bootp",
                                       "default");
            }
            if (interface_is_pp[primary_interface])
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n",
                                       interface_linkaddr[primary_interface]);

            SaveInterface(primary_interface);
        }
        fprintf(ConfigureFile, "Set Inet$EtherTypeA <Inet$EtherType>\n");

        for (i=0; i<interfaces; i++)
        {
            if (i==primary_interface)
                continue;

            SaveInterface(i);
        }

        fputs("|\n"
              "| Loopback\n"
              "|\n"
              "IfConfig -e lo0 127.0.0.1\n"
              "CheckError\n"
              "Set Inet$EtherType <Inet$EtherTypeA>\n"
              "Unset Inet$EtherTypeA\n",
              ConfigureFile);

    	if (UseResolver)
    	{
    	    int i;
    	    struct { char *mod, *fname; int *version; } rmods[4] =
    	                    { "Resolver",    "Resolver",   &v_Resolver,
    	                      "Resolve",     "Resolve",    &v_Resolve,
    	                      "InetDB",      "InetDB",     &v_InetDB,
    	                      "DNSResolver", "DNSResolve", &v_DNSResolver };

    	    fprintf(ConfigureFile, "|\n"
    	    	    	    	   "| Name resolver\n"
    	    	    	    	   "|\n");

            if (ResolverType == RT_Resolver)
            {
                fprintf(ConfigureFile, "Set Inet$Resolvers");

    	        for (i=0; i<3; i++)
    	        {
    	            if (Set(Resolver[i]))
    	                fprintf(ConfigureFile, " %s", Resolver[i]);
    	        }
    	        fprintf(ConfigureFile, "\n");
    	    }

    	    fprintf(ConfigureFile,
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname);

    	    if (ResolverType == RT_InetDB || ResolverType == RT_DNSResolver)
    	        SaveResConf();
    	    else if (ResolverType == RT_Resolve)
    	        SaveResolve();
    	}

    	fprintf(ConfigureFile, "|\n"
    	    	    	       "| Routing\n"
    	    	    	       "|\n");
    	if (Set(Gateway))
    	    fprintf(ConfigureFile, "Route -e add default %s\n"
    	                           "CheckError\n",
    	                           Gateway);

    	fprintf(ConfigureFile, "Run " CONFIGDIR_READ "Routes\n"
    	                       "CheckError\n"
    	                       "Set Inet$IsGateway %s\n"
    	                       "Set Inet$RouteDOptions %s\n",
    	                       AmRouter ? "Yes" : "\"\"",
    	                       UseRouteD ? RouteDoptions : "\"\"");

    	RMInsert("AUNMsgs", v_AUNMsgs);
    	RMInsert("MbufManager", v_MbufManager);
    	RMInsert("Internet", v_Internet);

    	fprintf(BootFile, "Run BootResources:!Internet\n");
    }
    else if (AUNEnabled || AccessEnabled)
    {
        bool got_a, got_m, got_i, got_d = FALSE;
        int temp;
    	got_a=RMInsert("AUNMsgs", v_AUNMsgs);
    	got_m=RMInsert("MbufManager", v_MbufManager);
    	got_i=RMInsert("Internet", v_Internet);
        for (temp = 0; temp < interfaces; temp++)
        {
            bool t = RMInsert(interface_module[temp], interface_version[temp]);
            if (!got_d)
                got_d = t;
        }

        if (!got_a || !got_m || !got_i || !got_d)
            fprintf(BootFile,
                    "|\n"
              	    "| Internet\n"
              	    "|\n"
              	    "IF \"<BootResources$Path>\" = \"\" THEN Set BootResources$Path <Boot$Dir>.Resources.\n"
                    "IF \"<System$Path>\" = \"\" THEN Run BootResources:!System\n");
        if (!got_a)
            fprintf(BootFile,
              	    "RMEnsure AUNMsgs %s RMLoad System:Modules.Network.AUNMsgs\n",
              	    VersionToString(v_AUNMsgs));
        if (!got_m)
            fprintf(BootFile,
              	    "RMEnsure MbufManager %s RMLoad System:Modules.Network.MManager\n",
              	    VersionToString(v_MbufManager));
        if (!got_i)
            fprintf(BootFile,
              	    "RMEnsure Internet %s RMLoad System:Modules.Network.Internet\n",
              	    VersionToString(v_Internet));

    	if (!got_d)
    	    fprintf(BootFile,
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                    interface_module[0],
                    VersionToString(interface_version[0]),
                    interface_filename[0]);

        if (!got_a || !got_m || !got_i || !got_d)
            fprintf(BootFile,
            	    "Run BootResources:!Internet.utils.TriggerCBs\n");
    }

    if (!InternetEnabled && !AUNEnabled && !AccessEnabled)
    {
        Unplug("Internet");
        Unplug("AUNMsgs");
        Unplug("MbufManager");
        Unplug("BootNet");
        Unplug("Net");
    }

    return 0;
}

void SaveSetup(void)
{
    int pagesize, size;
    int rmasize, systemsize;
    os_error e, *ep;
    char buts[64];
    int i;
    int osversion;

    if (!Diagnose())
    	return;

    Unplug("InternetA");
    Unplug("Netmsgs");
    Unplug("Accmsgs");

    if (InternetEnabled)
    {
        osfile_create_dir(CONFIGDIR_STEM, 0);

        if (!Exists(CONFIGDIR_READ "User"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.User",
                             CONFIGDIR_WRITE "User",
                             0, 0, 0, 0, 0, 0);

        if (!Exists(CONFIGDIR_READ "Routes"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.Routes",
                             CONFIGDIR_WRITE "Routes",
                             0, 0, 0, 0, 0, 0);

    	ConfigureFile = fopen(CONFIGDIR_WRITE "Startup", "w");
        if (ConfigureFile == 0)
        {
            ep = (os_error *) _kernel_last_oserror();
            if (ep)
                report_error(ep);
            else
                make_error("CantSaveSetup");
            return;
        }
    }
    BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "w");
    if (BootFile == 0)
    {
        if (InternetEnabled)
            fclose(ConfigureFile);
        ep = (os_error *) _kernel_last_oserror();
        if (ep)
            report_error(ep);
        else
            make_error("CantSaveSetup");
        return;
    }
    SetupInternet();
    SetupAUN();
    SetupAccess();
    if (InternetEnabled && (AccessEnabled || AUNEnabled))
        fputs("SetEval Inet$KickFiler 1\n", ConfigureFile);
    if (InternetEnabled)
    {
    	fclose(ConfigureFile);
    	osfile_set_type(CONFIGDIR_WRITE "Startup", osfile_TYPE_OBEY);

        /*
         * Sort out memory configurations
         */
        os_read_mem_map_info(&pagesize, 0);

        rmasize = readCMOS(osbyte_CONFIGURE_RMA_SIZE) * pagesize;
        systemsize = readCMOS(osbyte_CONFIGURE_SYSTEM_SIZE) * pagesize;

        if (rmasize < MIN_RMASIZE)
            writeCMOS(osbyte_CONFIGURE_RMA_SIZE, MIN_RMASIZE / pagesize);

        if (systemsize < MIN_SYSTEMSIZE)
            writeCMOS(osbyte_CONFIGURE_SYSTEM_SIZE, MIN_SYSTEMSIZE / pagesize);
    }

    fclose(BootFile);
    osfile_set_type("<Boot$ToBeLoaded>.SetUpNet", osfile_TYPE_OBEY);
    osfile_read_stamped("<Boot$ToBeLoaded>.SetUpNet", 0, 0, &size, 0, 0);
    if (size == 0)
    {
    	remove("<Boot$ToBeLoaded>.SetUpNet");
        if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
        {
            /* No networking - so put a blank SetUpNet in */
            osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                             "<Boot$ToBeLoaded>.SetUpNet",
                             0, 0, 0, 0, 0, 0);
        }
    }

    e.errnum = 0;
    strcpy(e.errmess, msgs_lookup("ResetPrompt"));
    strcpy(buts, msgs_lookup("ResetButs"));

    if (WimpVersion >= 322)
        i=wimp_report_error_by_category(&e,
           wimp_ERROR_BOX_CATEGORY_QUESTION << wimp_ERROR_BOX_CATEGORY_SHIFT,
           msgs_lookup("_TaskName"),
           "!inetsetup",
           (osspriteop_area *) 1,
           buts);
    else
        i=wimp_report_error(&e,
             wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
             msgs_lookup("_TaskName")) + 2;

    if (i==3)
#if 0
    	wimp_process_key(wimp_KEY_SHIFT|wimp_KEY_CONTROL|wimp_KEY_F12);
#else
    {
        xhourglass_on();
        osfscontrol_shutdown();
        xhourglass_off(); /* Not sure why I bother doing this :-) */
        osversion = osbyte1(osbyte_IN_KEY, 0, 255);
        if (osversion >= 0xA5) /* If we're on RISC OS 3.50 or later... */
    	    os_reset();
    	else
    	    os_reset_old_machine();
    }
#endif
    else
    	exit(0);
}

static void SaveInterface(int i)
{
    bool DynamicNetmask;
    char buffer[200];
    char buffer2[32];

    if (interface_address[i][0] == '\0')
    {
#if 0
    	/* Can't do this - another protocol might need the driver! */
        Unplug(interface_module[i]);
#endif
        return;
    }

    RMInsert(interface_module[i], interface_version[i]);

    fprintf(ConfigureFile, "|\n"
                           "| Interface: %s\n"
                           "|\n"
                           "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                           interface_name[i],
                           interface_module[i],
                           VersionToString(interface_version[i]),
                           interface_filename[i]);

    if (strcmp(interface_unit[i], "ec0") == 0)
    {
        if (interface_addrtype[i] == if_Manual || interface_addrtype[i] == if_FromHostname)
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_address[i],
                                   interface_netmask[i]);
        else
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                                   "default");
    }

    // Yucko!
    DynamicNetmask = strcmp(interface_netmask[i], msgs_lookup("ICMPReq")) == 0;

    switch (interface_addrtype[i])
    {
      case if_FromHostname:
      case if_Manual:
        if (!interface_is_pp[i])
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_netmask[i]);
        }
        else
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_linkaddr[i],
                                    interface_netmask[i]);
        }
        break;

      case if_FromCMOS:
        fprintf(ConfigureFile, "Run Inet:utils.ReadCMOSIP\n"
                               "IfConfig -e %s <Inet$CMOSIPAddr> netmask %s\n",
                               interface_unit[i],
                               interface_netmask[i]);
        break;

      case if_RevARP:
      case if_BOOTP:
        strcpy(buffer2, msgs_lookup(interface_addrtype[i] == if_RevARP?"RevARP":"BOOTP"));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "IfRConfig -e %s %s%s\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN "
                                        "Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               interface_unit[i],
                               interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                               DynamicNetmask ? " netmask" : "");
        if (!DynamicNetmask)
            fprintf(ConfigureFile, "IfConfig -e %s netmask %s\n"
                                   "CheckError\n",
                                   interface_unit[i],
                                   interface_netmask[i]);
        break;
    }
}

void SaveResolve(void)
{
    FILE *f=fopen("InetDBase:resolve", "w");
    int i;

    if (f)
    {
        fprintf(f, "domain %s\n", LocalDomain);
        for (i = 0; i < 3; i++)
        {
            if (Resolver[i][0])
                fprintf(f, "nameserver %s\n", Resolver[i]);
        }
        fclose(f);
    }
}

void SaveResConf(void)
{
    FILE *f, *old;
    char buffer[256];
    char buf2[256];
    int ns=0;

    xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    xosfscontrol_rename("InetDBase:resconf", "<Wimp$ScrapDir>.OldResConf");

    f=fopen("InetDBase:resconf", "w");
    if (!f)
    {
        xosfscontrol_rename("<Wimp$ScrapDir>.OldResConf", "InetDBase:resconf");
        return;
    }

    old=fopen("<Wimp$ScrapDir>.OldResConf", "r");

    if (old)
    {
        while (fgets(buffer, sizeof buffer, old))
        {
            if (sscanf(buffer, "domain %s", buf2) == 1)
                fprintf(f, "domain     %s.\n", LocalDomain);
            else if (sscanf(buffer, "nameserver %s", buf2) == 1)
            {
                if (ns < 3 && Resolver[ns][0])
                    fprintf(f, "nameserver %s\n", Resolver[ns++]);
            }
            else
                fprintf(f, "%s", buffer);
        }
        fclose(old);
        xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    }
    else
    {
        fprintf(f, "domain     %s.\n", LocalDomain);
        fprintf(f, "cachesize  16k\n"
                   "cacheload  resboot rescache\n"
                   "cachesave  rescache\n"
                   "retry      3\n"
                   "timeout    3 12\n"
                   "lookup     file bind\n");
    }

    for (; ns < 3; ns++)
        if (Resolver[ns][0])
            fprintf(f, "nameserver %s\n", Resolver[ns]);

    fclose(f);

    f=fopen("InetDBase:resboot", "w");
    if (f)
    {
        struct hostent *hp=gethostbyname(HostName);

        fprintf(f, "$ORIGIN %s.\n", LocalDomain);
        fprintf(f, "%-40.40sIN A     %d.%d.%d.%d\n", HostName, hp->h_addr[0],
                                                               hp->h_addr[1],
                                                               hp->h_addr[2],
                                                               hp->h_addr[3]);
        sprintf(buffer, "%d.%d.%d.%d.in-addr.arpa.", hp->h_addr[3], hp->h_addr[2],
                                                     hp->h_addr[1], hp->h_addr[0]);
        fprintf(f, "%-40.40sIN PTR   %s\n", buffer, HostName);
        fclose(f);
    }
}
@


1.1.2.1
log
@Merged from 3.71 CD
@
text
@a0 672
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"

#include "osbyte.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "wimp.h"
#include "hourglass.h"

#include "ModUtils.h"
#include "Save.h"
#include "Main.h"
#include "Load.h"
#include "AUN.h"
#include "Versions.h"
#include "Gadgets.h"
#include "IfsDbox.h"
#include "Diagnose.h"

#include "netdb.h"

#define MIN_RMASIZE (256*1024)
#define MIN_SYSTEMSIZE (8*1024)

static FILE *BootFile, *ConfigureFile;

static void SaveInterface(int);
static void SaveResolve(void);
static void SaveResConf(void);

extern void os_reset_old_machine(void);

static os_error *SetupAccess()
{
    if (AccessEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
            	    "| Access\n"
            	    "|\n"
            	    "IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    "Run Resources:$.Resources.ShareFS.!Boot\n"
            	    "RMFind Freeway %s System:Modules.Network.Freeway\n",
            	    VersionToString(v_Freeway));
            fprintf(ConfigureFile,
            	    "RMFind ShareFS %s System:Modules.Network.Share+\n",
            	    VersionToString(v_ShareFS));
    	    RMInsert("Freeway", v_Freeway);
    	    RMInsert("ShareFS", v_ShareFS);
        }
        else
        {
            bool got_f, got_s;

            got_f=RMInsert("Freeway", v_Freeway);
            got_s=RMInsert("ShareFS", v_ShareFS);
            if (!got_f || !got_s)
            {
            	fprintf(BootFile,
                    	"|\n"
            	    	"| Access\n"
            	    	"|\n"
            	    	"IF \"<ShareFS$Path>\" = \"\" THEN "
            	    	    	    	    	"Run Resources:$.Resources.ShareFS.!Boot\n"
            	    	"RMEnsure Freeway %s RMLoad System:Modules.Network.Freeway\n",
            	    	VersionToString(v_Freeway));
            	fprintf(BootFile,
            	    	"RMEnsure ShareFS %s RMLoad System:Modules.Network.Share+\n",
            	    	VersionToString(v_ShareFS));
            }
        }
        // The next two are necessary to run Resources:$.Resources.ShareFS.!Boot
        RMInsert("BootNet", 0);
        RMInsert("AUNMsgs", 0);
    }
    else
    {
        Unplug("ShareFS");
        Unplug("Freeway");
    }

    return 0;
}

static os_error *SetupAUN()
{
    int temp;
    extern toolbox_o AUNObject;

    if (AUNObject && (AUNEnabled || HaveEconet))
    	UpdateAUNCMOS();

    if (AUNEnabled)
    {
        if (InternetEnabled)
        {
            fprintf(ConfigureFile,
                    "|\n"
                    "| AUN\n"
                    "|\n"
                    "RMFind NetI %s System:Modules.Network.NetI\n"
                    "Run InetDBase:AUNMap\n"
                    "RMEnsure BBCEconet 0 RMReInit BBCEconet\n"
                    "RMEnsure NetFS 0 RMReInit NetFS\n"
                    "RMEnsure NetFS 5.79 RMEnsure NetUtils 0.99 "
                                    "Run System:Modules.Network.NetUtils\n"
                    "RMEnsure NetPrint 0 RMReInit NetPrint\n"
                    "RMEnsure NetFiler 0 RMReInit NetFiler\n",
                    VersionToString(v_NetI));
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
        }
        else
        {
            bool got_n;
            got_n=RMInsert("Net", v_Net);
            temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
            if (got_n)
            	temp |= osbyte_CONFIGURE_BOOT_NET_MASK;
            else
            	temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
            writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
            if (!got_n)
            {
            	fprintf(BootFile,
            	        "|\n"
                        "| AUN\n"
                        "|\n"
                        "Set Net$Device %s\n"
                        "Run BootResources:!Internet.utils.BootNet\n",
                        "\"\"");
            }
        }
        RMInsert("BootNet", 0);
        RMInsert("NetFS", 0);
        RMInsert("NetPrint", 0);
        RMInsert("NetFiler", 0);
        RMInsert("NetStatus", 0);
        RMInsert("NetUtils", 0);
        RMInsert("BBCEconet", 0);
    }
    else
    {
        temp = readCMOS(osbyte_CONFIGURE_BOOT_NET);
        temp &= ~osbyte_CONFIGURE_BOOT_NET_MASK;
        writeCMOS(osbyte_CONFIGURE_BOOT_NET, temp);
    }

    return 0;
}

static os_error *SetupInternet()
{
    int i;

    if (InternetEnabled)
    {
        fputs("|================================================================|\n"
              "| Startup file for !Internet V5.00 (21st May 1996)               |\n"
              "|                                                                |\n"
              "| This file was automatically generated by !InetSetup. Do not    |\n"
              "| edit it by hand unless you really, REALLY, know what you're    |\n"
              "| doing. Comments and spacing are significant to !InetSetup.     |\n"
              "|                                                                |\n"
              "| If you want to add extra configuration options, place them in  |\n"
              "| the User file.                                                 |\n"
              "|================================================================|\n"
              "\n",
              ConfigureFile);

        fprintf(ConfigureFile, "|\n"
                               "| Host name\n"
                               "|\n"
                               "Set Inet$HostName %s\n", HostName);
        if (Set(LocalDomain))
            fprintf(ConfigureFile, "Set Inet$LocalDomain %s\n", LocalDomain);

    	if (primary_interface != -1)
    	{
    	    if (interface_filename[primary_interface][0] != '\0')
               fprintf(ConfigureFile, "Set Inet$EtherDevice %s\n",
                                       interface_filename[primary_interface]);
            if (interface_addrtype[primary_interface] == if_Manual ||
                interface_addrtype[primary_interface] == if_FromHostname)
            {
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_address[primary_interface],
                                       interface_netmask[primary_interface]);
            }
            else if (interface_addrtype[primary_interface] == if_FromCMOS)
            {
                fprintf(ConfigureFile, "SetMacro Inet$EtherIPAddr <Inet$CMOSIPAddr>\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_netmask[primary_interface]);
            }
            else
            {
                fprintf(ConfigureFile, "Set Inet$EtherIPAddr %s\n"
                                       "Set Inet$EtherIPMask %s\n",
                                       interface_addrtype[primary_interface] == if_RevARP ? "revarp" : "bootp",
                                       "default");
            }
            if (interface_is_pp[primary_interface])
                fprintf(ConfigureFile, "Set Inet$LinkIPAddr %s\n",
                                       interface_linkaddr[primary_interface]);

            SaveInterface(primary_interface);
        }
        fprintf(ConfigureFile, "Set Inet$EtherTypeA <Inet$EtherType>\n");

        for (i=0; i<interfaces; i++)
        {
            if (i==primary_interface)
                continue;

            SaveInterface(i);
        }

        fputs("|\n"
              "| Loopback\n"
              "|\n"
              "IfConfig -e lo0 127.0.0.1\n"
              "CheckError\n"
              "Set Inet$EtherType <Inet$EtherTypeA>\n"
              "Unset Inet$EtherTypeA\n",
              ConfigureFile);

    	if (UseResolver)
    	{
    	    int i;
    	    struct { char *mod, *fname; int *version; } rmods[4] =
    	                    { "Resolver",    "Resolver",   &v_Resolver,
    	                      "Resolve",     "Resolve",    &v_Resolve,
    	                      "InetDB",      "InetDB",     &v_InetDB,
    	                      "DNSResolver", "DNSResolve", &v_DNSResolver };

    	    fprintf(ConfigureFile, "|\n"
    	    	    	    	   "| Name resolver\n"
    	    	    	    	   "|\n");

            if (ResolverType == RT_Resolver)
            {
                fprintf(ConfigureFile, "Set Inet$Resolvers");

    	        for (i=0; i<3; i++)
    	        {
    	            if (Set(Resolver[i]))
    	                fprintf(ConfigureFile, " %s", Resolver[i]);
    	        }
    	        fprintf(ConfigureFile, "\n");
    	    }

    	    fprintf(ConfigureFile,
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
    	            rmods[ResolverType].mod,
    	            VersionToString(*rmods[ResolverType].version),
    	            rmods[ResolverType].fname);

    	    if (ResolverType == RT_InetDB || ResolverType == RT_DNSResolver)
    	        SaveResConf();
    	    else if (ResolverType == RT_Resolve)
    	        SaveResolve();
    	}

    	fprintf(ConfigureFile, "|\n"
    	    	    	       "| Routing\n"
    	    	    	       "|\n");
    	if (Set(Gateway))
    	    fprintf(ConfigureFile, "Route -e add default %s\n"
    	                           "CheckError\n",
    	                           Gateway);

    	fprintf(ConfigureFile, "Run " CONFIGDIR_READ "Routes\n"
    	                       "CheckError\n"
    	                       "Set Inet$IsGateway %s\n"
    	                       "Set Inet$RouteDOptions %s\n",
    	                       AmRouter ? "Yes" : "\"\"",
    	                       UseRouteD ? RouteDoptions : "\"\"");

    	RMInsert("AUNMsgs", v_AUNMsgs);
    	RMInsert("MbufManager", v_MbufManager);
    	RMInsert("Internet", v_Internet);

    	fprintf(BootFile, "Run BootResources:!Internet\n");
    }
    else if (AUNEnabled || AccessEnabled)
    {
        bool got_a, got_m, got_i, got_d = FALSE;
        int temp;
    	got_a=RMInsert("AUNMsgs", v_AUNMsgs);
    	got_m=RMInsert("MbufManager", v_MbufManager);
    	got_i=RMInsert("Internet", v_Internet);
        for (temp = 0; temp < interfaces; temp++)
        {
            bool t = RMInsert(interface_module[temp], interface_version[temp]);
            if (!got_d)
                got_d = t;
        }

        if (!got_a || !got_m || !got_i || !got_d)
            fprintf(BootFile,
                    "|\n"
              	    "| Internet\n"
              	    "|\n"
              	    "IF \"<BootResources$Path>\" = \"\" THEN Set BootResources$Path <Boot$Dir>.Resources.\n"
                    "IF \"<System$Path>\" = \"\" THEN Run BootResources:!System\n");
        if (!got_a)
            fprintf(BootFile,
              	    "RMEnsure AUNMsgs %s RMLoad System:Modules.Network.AUNMsgs\n",
              	    VersionToString(v_AUNMsgs));
        if (!got_m)
            fprintf(BootFile,
              	    "RMEnsure MbufManager %s RMLoad System:Modules.Network.MManager\n",
              	    VersionToString(v_MbufManager));
        if (!got_i)
            fprintf(BootFile,
              	    "RMEnsure Internet %s RMLoad System:Modules.Network.Internet\n",
              	    VersionToString(v_Internet));

    	if (!got_d)
    	    fprintf(BootFile,
    	            "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                    interface_module[0],
                    VersionToString(interface_version[0]),
                    interface_filename[0]);

        if (!got_a || !got_m || !got_i || !got_d)
            fprintf(BootFile,
            	    "Run BootResources:!Internet.utils.TriggerCBs\n");
    }

    if (!InternetEnabled && !AUNEnabled && !AccessEnabled)
    {
        Unplug("Internet");
        Unplug("AUNMsgs");
        Unplug("MbufManager");
        Unplug("BootNet");
        Unplug("Net");
    }

    return 0;
}

void SaveSetup(void)
{
    int pagesize, size;
    int rmasize, systemsize;
    os_error e, *ep;
    char buts[64];
    int i;
    int osversion;

    if (!Diagnose())
    	return;

    Unplug("InternetA");
    Unplug("Netmsgs");
    Unplug("Accmsgs");

    if (InternetEnabled)
    {
        osfile_create_dir(CONFIGDIR_STEM, 0);

        if (!Exists(CONFIGDIR_READ "User"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.User",
                             CONFIGDIR_WRITE "User",
                             0, 0, 0, 0, 0, 0);

        if (!Exists(CONFIGDIR_READ "Routes"))
            osfscontrol_copy("<InetSetup$Dir>.Blanks.Routes",
                             CONFIGDIR_WRITE "Routes",
                             0, 0, 0, 0, 0, 0);

    	ConfigureFile = fopen(CONFIGDIR_WRITE "Startup", "w");
        if (ConfigureFile == 0)
        {
            ep = (os_error *) _kernel_last_oserror();
            if (ep)
                report_error(ep);
            else
                make_error("CantSaveSetup");
            return;
        }
    }
    BootFile = fopen("<Boot$ToBeLoaded>.SetUpNet", "w");
    if (BootFile == 0)
    {
        if (InternetEnabled)
            fclose(ConfigureFile);
        ep = (os_error *) _kernel_last_oserror();
        if (ep)
            report_error(ep);
        else
            make_error("CantSaveSetup");
        return;
    }
    SetupInternet();
    SetupAUN();
    SetupAccess();
    if (InternetEnabled && (AccessEnabled || AUNEnabled))
        fputs("SetEval Inet$KickFiler 1\n", ConfigureFile);
    if (InternetEnabled)
    {
    	fclose(ConfigureFile);
    	osfile_set_type(CONFIGDIR_WRITE "Startup", osfile_TYPE_OBEY);

        /*
         * Sort out memory configurations
         */
        os_read_mem_map_info(&pagesize, 0);

        rmasize = readCMOS(osbyte_CONFIGURE_RMA_SIZE) * pagesize;
        systemsize = readCMOS(osbyte_CONFIGURE_SYSTEM_SIZE) * pagesize;

        if (rmasize < MIN_RMASIZE)
            writeCMOS(osbyte_CONFIGURE_RMA_SIZE, MIN_RMASIZE / pagesize);

        if (systemsize < MIN_SYSTEMSIZE)
            writeCMOS(osbyte_CONFIGURE_SYSTEM_SIZE, MIN_SYSTEMSIZE / pagesize);
    }

    fclose(BootFile);
    osfile_set_type("<Boot$ToBeLoaded>.SetUpNet", osfile_TYPE_OBEY);
    osfile_read_stamped("<Boot$ToBeLoaded>.SetUpNet", 0, 0, &size, 0, 0);
    if (size == 0)
    {
    	remove("<Boot$ToBeLoaded>.SetUpNet");
        if (!InternetEnabled && !AccessEnabled && !AUNEnabled)
        {
            /* No networking - so put a blank SetUpNet in */
            osfscontrol_copy("<InetSetup$Dir>.Blanks.SetUpNet",
                             "<Boot$ToBeLoaded>.SetUpNet",
                             0, 0, 0, 0, 0, 0);
        }
    }

    e.errnum = 0;
    strcpy(e.errmess, msgs_lookup("ResetPrompt"));
    strcpy(buts, msgs_lookup("ResetButs"));

    if (WimpVersion >= 322)
        i=wimp_report_error_by_category(&e,
           wimp_ERROR_BOX_CATEGORY_QUESTION << wimp_ERROR_BOX_CATEGORY_SHIFT,
           msgs_lookup("_TaskName"),
           "!inetsetup",
           (osspriteop_area *) 1,
           buts);
    else
        i=wimp_report_error(&e,
             wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
             msgs_lookup("_TaskName")) + 2;

    if (i==3)
#if 0
    	wimp_process_key(wimp_KEY_SHIFT|wimp_KEY_CONTROL|wimp_KEY_F12);
#else
    {
        xhourglass_on();
        osfscontrol_shutdown();
        xhourglass_off(); /* Not sure why I bother doing this :-) */
        osversion = osbyte1(osbyte_IN_KEY, 0, 255);
        if (osversion >= 0xA5) /* If we're on RISC OS 3.50 or later... */
    	    os_reset();
    	else
    	    os_reset_old_machine();
    }
#endif
    else
    	exit(0);
}

static void SaveInterface(int i)
{
    bool DynamicNetmask;
    char buffer[200];
    char buffer2[32];

    if (interface_address[i][0] == '\0')
    {
#if 0
    	/* Can't do this - another protocol might need the driver! */
        Unplug(interface_module[i]);
#endif
        return;
    }

    RMInsert(interface_module[i], interface_version[i]);

    fprintf(ConfigureFile, "|\n"
                           "| Interface: %s\n"
                           "|\n"
                           "RMEnsure %s %s RMLoad System:Modules.Network.%s\n",
                           interface_name[i],
                           interface_module[i],
                           VersionToString(interface_version[i]),
                           interface_filename[i]);

    if (strcmp(interface_unit[i], "ec0") == 0)
    {
        if (interface_addrtype[i] == if_Manual || interface_addrtype[i] == if_FromHostname)
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_address[i],
                                   interface_netmask[i]);
        else
            fprintf(ConfigureFile, "Set Inet$EcoIPAddr %s\n"
                               	   "Set Inet$EcoIPMask %s\n",
                                   interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                                   "default");
    }

    // Yucko!
    DynamicNetmask = strcmp(interface_netmask[i], msgs_lookup("ICMPReq")) == 0;

    switch (interface_addrtype[i])
    {
      case if_FromHostname:
      case if_Manual:
        if (!interface_is_pp[i])
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_netmask[i]);
        }
        else
        {
            fprintf(ConfigureFile, "IfConfig -e %s %s %s netmask %s\n"
                                    "CheckError\n",
                                    interface_unit[i],
                                    interface_address[i],
                                    interface_linkaddr[i],
                                    interface_netmask[i]);
        }
        break;

      case if_FromCMOS:
        fprintf(ConfigureFile, "Run Inet:utils.ReadCMOSIP\n"
                               "IfConfig -e %s <Inet$CMOSIPAddr> netmask %s\n",
                               interface_unit[i],
                               interface_netmask[i]);
        break;

      case if_RevARP:
      case if_BOOTP:
        strcpy(buffer2, msgs_lookup(interface_addrtype[i] == if_RevARP?"RevARP":"BOOTP"));
        sprintf(buffer, msgs_lookup("Contacting"), buffer2, interface_name[i]);
        fprintf(ConfigureFile, "IF \"<Wimp$State>\" = \"commands\" THEN Echo %s\n"
                               "IfRConfig -e %s %s%s\n"
                               "CheckError\n"
                               "IF \"<Wimp$State>\" = \"commands\" THEN "
                                        "Echo <11><23><8><5><6><0><0><0><0><0><0><11>\n",
                               buffer,
                               interface_unit[i],
                               interface_addrtype[i] == if_RevARP ? "revarp" : "bootp",
                               DynamicNetmask ? " netmask" : "");
        if (!DynamicNetmask)
            fprintf(ConfigureFile, "IfConfig -e %s netmask %s\n"
                                   "CheckError\n",
                                   interface_unit[i],
                                   interface_netmask[i]);
        break;
    }
}

void SaveResolve(void)
{
    FILE *f=fopen("InetDBase:resolve", "w");
    int i;

    if (f)
    {
        fprintf(f, "domain %s\n", LocalDomain);
        for (i = 0; i < 3; i++)
        {
            if (Resolver[i][0])
                fprintf(f, "nameserver %s\n", Resolver[i]);
        }
        fclose(f);
    }
}

void SaveResConf(void)
{
    FILE *f, *old;
    char buffer[256];
    char buf2[256];
    int ns=0;

    xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    xosfscontrol_rename("InetDBase:resconf", "<Wimp$ScrapDir>.OldResConf");

    f=fopen("InetDBase:resconf", "w");
    if (!f)
    {
        xosfscontrol_rename("<Wimp$ScrapDir>.OldResConf", "InetDBase:resconf");
        return;
    }

    old=fopen("<Wimp$ScrapDir>.OldResConf", "r");

    if (old)
    {
        while (fgets(buffer, sizeof buffer, old))
        {
            if (sscanf(buffer, "domain %s", buf2) == 1)
                fprintf(f, "domain     %s.\n", LocalDomain);
            else if (sscanf(buffer, "nameserver %s", buf2) == 1)
            {
                if (ns < 3 && Resolver[ns][0])
                    fprintf(f, "nameserver %s\n", Resolver[ns++]);
            }
            else
                fprintf(f, "%s", buffer);
        }
        fclose(old);
        xosfile_delete("<Wimp$ScrapDir>.OldResConf", 0, 0, 0, 0, 0);
    }
    else
    {
        fprintf(f, "domain     %s.\n", LocalDomain);
        fprintf(f, "cachesize  16k\n"
                   "cacheload  resboot rescache\n"
                   "cachesave  rescache\n"
                   "retry      3\n"
                   "timeout    3 12\n"
                   "lookup     file bind\n");
    }

    for (; ns < 3; ns++)
        if (Resolver[ns][0])
            fprintf(f, "nameserver %s\n", Resolver[ns]);

    fclose(f);

    f=fopen("InetDBase:resboot", "w");
    if (f)
    {
        struct hostent *hp=gethostbyname(HostName);

        fprintf(f, "$ORIGIN %s.\n", LocalDomain);
        fprintf(f, "%-40.40sIN A     %d.%d.%d.%d\n", HostName, hp->h_addr[0],
                                                               hp->h_addr[1],
                                                               hp->h_addr[2],
                                                               hp->h_addr[3]);
        sprintf(buffer, "%d.%d.%d.%d.in-addr.arpa.", hp->h_addr[3], hp->h_addr[2],
                                                     hp->h_addr[1], hp->h_addr[0]);
        fprintf(f, "%-40.40sIN PTR   %s\n", buffer, HostName);
        fclose(f);
    }
}
@

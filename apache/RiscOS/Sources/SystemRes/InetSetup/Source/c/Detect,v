head	1.3;
access;
symbols
	Source-0_59:1.3
	Source-0_58:1.3
	Source-0_57:1.3
	Source-0_56:1.3
	Source-0_55:1.3
	Source-0_54:1.3
	Source-0_53:1.3
	Source-0_52:1.3
	Source-0_51:1.3
	Source-0_50:1.3
	Source-0_49:1.3
	InetSetup-0_49:1.3
	InetSetup-0_48:1.3
	InetSetup-0_47:1.3
	InetSetup-0_46:1.3
	InetSetup-0_45:1.3
	InetSetup-0_44:1.3
	InetSetup-0_43:1.3
	InetSetup-0_42:1.3
	InetSetup-0_41:1.3
	InetSetup-0_40:1.3
	InetSetup-0_39:1.3
	InetSetup-0_38:1.3
	InetSetup-0_37:1.3
	InetSetup-0_36:1.3
	InetSetup-0_35:1.3
	InetSetup-0_34:1.3
	InetSetup-0_33:1.3
	InetSetup-0_32:1.3
	InetSetup-0_31:1.3
	InetSetup-0_30:1.3
	InetSetup-0_29:1.3
	StrongARM_merge:1.1.4.1
	sbrodie_InetSetup_dev_merge:1.2.2.3
	Daytona_merge:1.2
	Ursula_merge:1.2.2.3
	InetSetup-0_28:1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.2.2.3
	Ursula_RiscPC:1.2.2.3.0.4
	InetSetup-0_22-1_1_2_4:1.2.2.3
	InetSetup-0_22-1_1_2_3_2_1:1.2.2.3
	sbrodie_InetSetup_dev-1_1_2_3:1.2.2.3.0.2
	sbrodie_InetSetup_dev-1_1_2_3_bp:1.2.2.3
	rthornb_UrsulaBuild-19Aug1998:1.2.2.3
	UrsulaBuild_FinalSoftload:1.2.2.3
	rthornb_UrsulaBuild-12Aug1998:1.2.2.3
	aglover_UrsulaBuild-05Aug1998:1.2.2.3
	rthornb_UrsulaBuild-29Jul1998:1.2.2.3
	rthornb_UrsulaBuild-22Jul1998:1.2.2.3
	InetSetup-0_22-1_1_2_3:1.2.2.3
	rthornb_UrsulaBuild-15Jul1998:1.2.2.3
	rthornb_UrsulaBuild-07Jul1998:1.2.2.3
	rthornb_UrsulaBuild-17Jun1998:1.2.2.3
	rthornb_UrsulaBuild-03Jun1998:1.2.2.3
	rthornb_UrsulaBuild-27May1998:1.2.2.3
	rthornb_UrsulaBuild-21May1998:1.2.2.3
	bavison_InetSetup-0_25:1.2.2.3
	rthornb_UrsulaBuild_01May1998:1.2.2.3
	celkins_InetSetup_0_24:1.2.2.3
	InetSetup-0_22-1_1_2_2:1.2.2.2
	Daytona:1.2.0.4
	Daytona_bp:1.2
	Ursula:1.2.0.2
	Ursula_bp:1.2
	StrongARM:1.1.0.4
	RO_3_71:1.1.4.1;
locks; strict;
comment	@# @;


1.3
date	99.08.10.16.04.56;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	97.05.06.17.27.15;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.30.18.43.19;	author kbracey;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.2.2.1
date	97.11.18.16.08.37;	author dbrown;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.12.17.15.15.43;	author celkins;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	98.02.05.19.23.00;	author celkins;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.30.18.43.20;	author kbracey;	state Exp;
branches;
next	;

1.1.4.1
date	97.05.06.17.11.00;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.3
log
@  Merge of half a dozen separate branches to the trunk:
    Ursula
    Ursula_RiscPC
    StrongARM
    Daytona(!)
    sbrodie_InetSetup_dev-1_1_2_3
    ART
Detail:
  What a mess.
Admin:
  This is the Ursula plugin version.  It builds.

Version 0.28. Tagged as 'InetSetup-0_28'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* File:    detect.c
 * Purpose: Detection of installed expansion cards and the CMOS IP address
 * Author:  K Bracey
 * History: 07-Nov-06: KJB: fixed for different cards with same driver
 *                          removed use of podule_read_info for RISC OS 3.1
 *
 *          04-Aug-97: DTAB: added kludgy support for PPP.  PPP is chosen
 *                           in preference to Slip if both are available
 *
 *          08-Sep-97: DTAB: added detection of additional network cards
 *                           and added additional comments
 *          15-Dec-97: RCE   corrected some errors in the card type table.
 *          09-Jan-97: RCE   corrected entries for Castle Technology cards.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"

#include "osbyte.h"
#include "podule.h"

#include "ModUtils.h"
#include "Load.h"
#include "Main.h"

static int count[12];

static struct
{
    const int type;          /* Podule product type */
    const char *description; /* Token for description lookup in messages file */
    const char *unit;
    const char *modules;     /* Required modules for this expansion card */
    int *const count;
}
known_types[] =
{
  /*    type  desc    unit                      modules      count */

    { 0x0003, "et",   "et", ":Ether1:4.00:Ether1",       &count[0]  }, /* Ethernet                                     */
/*    { 0x0031, "ev",   "ev", ":EtherV:0.00:EtherV",       &count[1]  },*/ /* WildAtoD?                                    */
    { 0x0061, "en",   "en", ":Ether2:3.55:Ether2",       &count[2]  }, /* Ethernet2                                    */
    { 0x00a4, "ea",   "ea", ":Ether3:4.23:Ether3-16",    &count[3]  }, /* AtomwideEtherA                               */
    { 0x00bd, "eh2" , "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLan200           ICubed                 */
    { 0x00c3, "er",   "er", ":EtherR:2.00:EtherR",       &count[4]  }, /* RISCDevEthernet                              */
    { 0x00cf, "eh1" , "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLan100           ICubed                 */
    { 0x00d4, "eh5",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* ICubedEtherLan500     expansion card         */
    { 0x00d8, "em"  , "em", ":EtherM:0.39:EtherM",       &count[10] }, /* AtomwideEtherM                               */
    { 0x00e4, "eb",   "eb", ":EtherB:4.23:EtherB",       &count[6]  }, /* ANTEtherB                                    */
    { 0x00e8, "cte8", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechIDE         Castle technology      */
    { 0x00e9, "cte9", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechEthernet                           */
    { 0x00ec, "eh6",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* ICubedEthernetMedusa  NIC                    */
    { 0x00f4, "ctf4", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechEtherSCSIDS Castle technology      */
    { 0x00f5, "ctf5", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechSCSI        Castle technology      */
    { 0x011c, "eh1a", "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLanA100          Acorn                  */
    { 0x011d, "eh2a", "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLanA200          Acorn                  */
    { 0x011e, "eh6",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA600          NIC (Acorn)            */
/*  { 0x011e, "eh6a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  },*/ /* NIC (Acorn) same product type as eh6         */
    { 0x011f, "eh5a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA500          expansion card (Acorn) */
    { 0x012e, "eh7a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA700          Acorn                  */
    { 0x012f, "eh7" , "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLan700           ICubed                 */
    { 0x0139, "ei"  , "ei", ":EtherI:2.00:EtherI",       &count[11] }, /* NC EtherI                                    */
/*  { 0xffff, "eo",   "eo", ":EtherO:4.00:EtherO",       &count[8]  },*/ /* Unknown podule id                            */
/*  { 0xffff, "ea8",  "ea", ":Ether3:4.20:Ether3-8",     &count[9]  }, *//* Unknown podule id                            */
    { 0, 0 },
};

/* Address stored is CMOS108.CMOS109.CMOS110.CMOS0 */

#define osbyte_CONFIGURE_IPADDRESS0 108
#define osbyte_CONFIGURE_IPADDRESS1 109
#define osbyte_CONFIGURE_IPADDRESS2 110
#define osbyte_CONFIGURE_IPADDRESS3 osbyte_CONFIGURE_STATION

/*************************************************/
/* ReadCMOSIP()                                  */
/*                                               */
/* Reads the IP address stored in CMOS ram and   */
/* returns it as an unsigned integer             */
/*                                               */
/* Returns: The IP address read                  */
/*************************************************/
static unsigned int ReadCMOSIP(void)
{
  unsigned int b0, b1, b2, b3;

  b0=readCMOS(osbyte_CONFIGURE_IPADDRESS0);
  b1=readCMOS(osbyte_CONFIGURE_IPADDRESS1);
  b2=readCMOS(osbyte_CONFIGURE_IPADDRESS2);
  b3=readCMOS(osbyte_CONFIGURE_IPADDRESS3);

  if (b0==0 && b1==0 && b2==0)
  {
    if (b3==0)
    {
      return 0;
    }
    else
    {
      /* Call it 10.0.0.x, an IANA assigned private block */
      return 10 | (b3 << 24);
    }
  }
  return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
}

/*************************************************/
/* ScanInterfaces()                              */
/*                                               */
/* Scans for a variety of interfaces and sets up */
/* appropriate system variables for each found.  */
/* After this the function sets up structures    */
/* for each detected interface                   */
/*************************************************/
os_error *ScanInterfaces(void)
{
    podule_section slot;
    podule_header header;
    int type, i;
    char *p, *p2;
    char buffer[256];

    memset(count, 0, sizeof count);

    /* Scan podule bus */
    for (slot = 0; slot <= 8; slot++)
    {
      if (xpodule_read_header(&header, slot)) continue; /* No card present */

      if ((header.b[0] & 0x78) != 0) continue;          /* Simple ID only */

      /* Construct podule type from header */
      type = header.b[3] + (header.b[4] << 8);

      /* Scan through known types for a match */
      for (i = 0; known_types[i].type; i++)
      {
        /* Is type regognised? */
        if (type == known_types[i].type)
        {
          char buffer[64];
          char buffer2[64];

          if (slot < 8)
          {
            /* podule number is less than 8 so it is a normal podule */
            sprintf(buffer2, msgs_lookup("Slot"), slot);
            sprintf(buffer, "InetSetup$Driver$%s", buffer2);
          }
          else
          {
            /* podule number is 8 so it is a NIC */
            sprintf(buffer, "InetSetup$Driver$%s", msgs_lookup("NIC"));
          }

          if (!getenv(buffer))
          {
            sprintf(buffer2, "%s:%s%d%s", msgs_lookup(known_types[i].description),
            known_types[i].unit,
            (*known_types[i].count)++,
            known_types[i].modules);
            _kernel_setenv(buffer, buffer2);
          }
          break;
        }
      }
    }

    /* Check for existance of Econet */
    if (RMLoaded("Econet"))
    {
      _kernel_setenv("InetSetup$Driver$Econet", "Econet:ec0:EconetA:0.00:EconetA");
      HaveEconet = TRUE;
    }

    /* Has InetSetup$Driver$Serial already been setup? */
    if (!getenv("InetSetup$Driver$Serial"))
    {
      /* Does PPP driver exist in directory */
      if (Exists("System:Modules.Network.PPP"))
      {
        /* Name it as InetSetup$Driver$Serial device */
        _kernel_setenv("InetSetup$Driver$Serial", "PPP:ppp0:PPP:1.13:PPP:P");
      }
      else
      {
        /* No PPP, then look for Slip after all it's better than nothing */
        if (Exists("System:Modules.Network.Slip"))
        {
          /* stick it in as InetSetup$Driver$Serial device */
          _kernel_setenv("InetSetup$Driver$Serial", "SLIP:sl0:Slip:2.07:Slip:P");
        }
      }
    }

    CMOSIP=ReadCMOSIP();

    /* Right, now to examine those variables, and any other ones that may have been set */

    p = 0;

    for (;;)
    {
      int len;
      if (xos_read_var_val("InetSetup$Driver$*", buffer, sizeof buffer, (int) p, 3, &len, (int *) &p, 0))
      {
        break;
      }

      buffer[len]='\0';

      strcpy(interface_location[interfaces], p + sizeof "InetSetup$Driver$" - 1);
      for (p2 = interface_location[interfaces]; *p2; p2++)
      {
        if (*p2 == '_') *p2 = ' ';
      }

      strcpy(interface_name[interfaces], strtok(buffer, ":"));
      strcpy(interface_unit[interfaces], strtok(0, ":"));
      if ((p2 = strtok(0, ":")) != 0)
      {
        strcpy(interface_module[interfaces], p2);
        interface_version[interfaces] = VersionToInt(strtok(0, ":"));
        if ((p2 = strtok(0, ":")) != 0)
        {
          strcpy(interface_filename[interfaces], p2);
          if ((p2 = strtok(0, ":")) != 0)
          {
            if (strchr(p2, 'P'))
            {
              /* Local and remote IP addresses not needed for PPP */
              if (strcmp(interface_name[interfaces], "PPP") == 0)
              {
                interface_is_pp[interfaces] = 2;
              }
              else
              {
                /* Typical PP devices have local and remote IP addresses */
                interface_is_pp[interfaces] = 1;
              }
            }
          }
        }
      }
      interfaces++;
    }

    return NULL;
}
@


1.2
log
@Version RO_3_71 taken
@
text
@d15 1
d21 8
d43 1
a43 1
static int count[10];
d47 2
a48 2
    const int type;
    const char *description;
d50 1
a50 1
    const char *modules;
d55 27
a81 14
    { 0x0003, "et", "et", ":Ether1:4.00:Ether1", &count[0] },
    { 0x0031, "ev", "ev", ":EtherV:0.00:EtherV", &count[1] },
    { 0x0061, "en", "en", ":Ether2:3.55:Ether2", &count[2] },
    { 0x00A4, "ea", "ea", ":Ether3:4.20:Ether3-16", &count[3] },
    { 0x00C3, "er", "er", ":EtherR:2.00:EtherR", &count[4] },
    { 0x00D4, "eh5", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* expansion card */
    { 0x00E4, "eb", "eb", ":EtherB:4.20:EtherB", &count[6] },
    { 0x00E8, "cte8", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00EC, "eh6", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* NIC */
    { 0x00F4, "ctf4", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00F5, "ctf5", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x011E, "eh6", "eh", ":EtherH:4.18:EtherH16", &count[5] }, /* NIC (Acorn) */
    { 0xffff, "eo", "eo", ":EtherO:4.00:EtherO", &count[8] },
    { 0xffff, "ea8", "ea", ":Ether3:4.20:Ether3-8", &count[9] },
a84 2


d92 8
d102 1
a102 1
    unsigned int b0, b1, b2, b3;
d104 10
a113 12
    b0=readCMOS(osbyte_CONFIGURE_IPADDRESS0);
    b1=readCMOS(osbyte_CONFIGURE_IPADDRESS1);
    b2=readCMOS(osbyte_CONFIGURE_IPADDRESS2);
    b3=readCMOS(osbyte_CONFIGURE_IPADDRESS3);

    if (b0==0 && b1==0 && b2==0)
    {
        if (b3==0)
            return 0;
        else
            /* Call it 10.0.0.x, an IANA assigned private block */
            return 10 | (b3 << 24);
d115 7
a121 2

    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
d124 8
d142 1
d145 1
a145 2
        if (xpodule_read_header(&header, slot))
            continue;                             /* No card present */
d147 1
a147 2
        if ((header.b[0] & 0x78) != 0)
            continue;                             /* Simple ID only */
d149 11
a159 1
        type = header.b[3] + (header.b[4] << 8);
d161 23
a183 23
        for (i = 0; known_types[i].type; i++)
            if (type == known_types[i].type)
            {
                char buffer[64];
                char buffer2[64];
                if (slot < 8)
                {
                    sprintf(buffer2, msgs_lookup("Slot"), slot);
                    sprintf(buffer, "InetSetup$Driver$%s", buffer2);
                }
                else
                    sprintf(buffer, "InetSetup$Driver$%s", msgs_lookup("NIC"));

    	    	if (!getenv(buffer))
    	    	{
    	    	    sprintf(buffer2, "%s:%s%d%s", msgs_lookup(known_types[i].description),
    	    	    	    	    	     	  known_types[i].unit,
    	    	    	    	    	     	  (*known_types[i].count)++,
    	    	    	    	    	     	  known_types[i].modules);
                    _kernel_setenv(buffer, buffer2);
                }
                break;
            }
d186 1
d189 2
a190 2
        _kernel_setenv("InetSetup$Driver$Econet", "Econet:ec0:EconetA:0.00:EconetA");
        HaveEconet = TRUE;
d193 19
a211 2
    if (!getenv("InetSetup$Driver$Serial") && Exists("System:Modules.Network.Slip"))
        _kernel_setenv("InetSetup$Driver$Serial", "SLIP:sl0:Slip:2.07:Slip:P");
d215 1
a215 3
    /* Right, now to examine those variables, and any other ones that may have been
       set */

d221 20
a240 13
        int len;
        if (xos_read_var_val("InetSetup$Driver$*", buffer, sizeof buffer, (int) p, 3,
            	    	     &len, (int *) &p, 0))
            break;

        buffer[len]='\0';

    	strcpy(interface_location[interfaces], p + sizeof "InetSetup$Driver$" - 1);
    	for (p2 = interface_location[interfaces]; *p2; p2++)
    	    if (*p2 == '_') *p2 = ' ';

        strcpy(interface_name[interfaces], strtok(buffer, ":"));
        strcpy(interface_unit[interfaces], strtok(0, ":"));
d243 4
a246 3
            strcpy(interface_module[interfaces], p2);
            interface_version[interfaces] = VersionToInt(strtok(0, ":"));
            if ((p2 = strtok(0, ":")) != 0)
d248 10
a257 4
            	strcpy(interface_filename[interfaces], p2);
                if ((p2 = strtok(0, ":")) != 0)
                    if (strchr(p2, 'P'))
                        interface_is_pp[interfaces] = 1;
d259 1
d261 2
a262 1
        interfaces++;
@


1.2.2.1
log
@Support added for PPP module and additional network cards.  Front end has also
been modified to fit style guide more closely.
@
text
@a0 15
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

a19 6
 *
 *          04-Aug-97: DTAB: added kludgy support for PPP.  PPP is chosen
 *                           in preference to Slip if both are available
 *
 *          08-Sep-97: DTAB: added detection of additional network cards
 *                           and added additional comments
d34 1
a34 1
static int count[12];
d38 2
a39 2
    const int type;          /* Podule product type */
    const char *description; /* Token for description lookup in messages file */
d41 1
a41 1
    const char *modules;     /* Required modules for this expansion card */
d46 14
a59 27
  /*    type  desc    unit                      modules      count */

    { 0x0003, "et",   "et", ":Ether1:4.00:Ether1",       &count[0]  }, /* Ethernet                                     */
    { 0x0031, "ev",   "ev", ":EtherV:0.00:EtherV",       &count[1]  }, /* WildAtoD?                                    */
    { 0x0061, "en",   "en", ":Ether2:3.55:Ether2",       &count[2]  }, /* Ethernet2                                    */
    { 0x00a4, "ea",   "ea", ":Ether3:4.23:Ether3-16",    &count[3]  }, /* AtomwideEtherA                               */
    { 0x00bd, "eh2" , "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLan200           ICubed                 */
    { 0x00c3, "er",   "er", ":EtherR:2.00:EtherR",       &count[4]  }, /* RISCDevEthernet                              */
    { 0x00cf, "eh1" , "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLan100           ICubed                 */
    { 0x00d4, "eh5",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* ICubedEtherLan500     expansion card         */
    { 0x00d8, "em"  , "em", ":EtherM:0.39:EtherM",       &count[10] }, /* AtomwideEtherM                               */
    { 0x00e4, "eb",   "eb", ":EtherB:4.23:EtherB",       &count[6]  }, /* ANTEtherB                                    */
    { 0x00e8, "cte8", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7]  }, /* CastleTechIDE         Castle technology      */
    { 0x00e9, "cte9", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7]  }, /* CastleTechEthernet                           */
    { 0x00eC, "eh6",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* ICubedEthernetMedusa  NIC                    */
    { 0x00f4, "ctf4", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7]  }, /* CastleTechEtherSCSIDS Castle technology      */
    { 0x00f5, "ctf5", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7]  }, /* CastleTechSCSI        Castle technology      */
    { 0x011c, "eh1a", "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLanA100          Acorn                  */
    { 0x011d, "eh2a", "eh", ":EtherH:4.16:EtherH8",      &count[5]  }, /* EtherLanA200          Acorn                  */
    { 0x011e, "eh6",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA600          NIC (Acorn)            */
//  { 0x011e, "eh6a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* NIC (Acorn) same product type as eh6         */
    { 0x011f, "eh5a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA500          expansion card (Acorn) */
    { 0x012e, "eh7a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLanA700          Acorn                  */
    { 0x012f, "eh7" , "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* EtherLan700           ICubed                 */
    { 0x0139, "ei"  , "ei", ":EtherI:2.00:EtherI",       &count[11] }, /* NC EtherI                                    */
//  { 0xffff, "eo",   "eo", ":EtherO:4.00:EtherO",       &count[8]  }, /* Unknown podule id                            */
//  { 0xffff, "ea8",  "ea", ":Ether3:4.20:Ether3-8",     &count[9]  }, /* Unknown podule id                            */
d63 2
a71 8
/*************************************************/
/* ReadCMOSIP()                                  */
/*                                               */
/* Reads the IP address stored in CMOS ram and   */
/* returns it as an unsigned integer             */
/*                                               */
/* Returns: The IP address read                  */
/*************************************************/
d74 1
a74 1
  unsigned int b0, b1, b2, b3;
d76 12
a87 10
  b0=readCMOS(osbyte_CONFIGURE_IPADDRESS0);
  b1=readCMOS(osbyte_CONFIGURE_IPADDRESS1);
  b2=readCMOS(osbyte_CONFIGURE_IPADDRESS2);
  b3=readCMOS(osbyte_CONFIGURE_IPADDRESS3);

  if (b0==0 && b1==0 && b2==0)
  {
    if (b3==0)
    {
      return 0;
d89 2
a90 7
    else
    {
      /* Call it 10.0.0.x, an IANA assigned private block */
      return 10 | (b3 << 24);
    }
  }
  return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
a92 8
/*************************************************/
/* ScanInterfaces()                              */
/*                                               */
/* Scans for a variety of interfaces and sets up */
/* appropriate system variables for each found.  */
/* After this the function sets up structures    */
/* for each detected interface                   */
/*************************************************/
a102 1
    /* Scan podule bus */
d105 2
a106 1
      if (xpodule_read_header(&header, slot)) continue; /* No card present */
d108 2
a109 1
      if ((header.b[0] & 0x78) != 0) continue;          /* Simple ID only */
d111 1
a111 2
      /* Construct podule type from header */
      type = header.b[3] + (header.b[4] << 8);
d113 23
a135 32
      /* Scan through known types for a match */
      for (i = 0; known_types[i].type; i++)
      {
        /* Is type regognised? */
        if (type == known_types[i].type)
        {
          char buffer[64];
          char buffer2[64];

          if (slot < 8)
          {
            /* podule number is less than 8 so it is a normal podule */
            sprintf(buffer2, msgs_lookup("Slot"), slot);
            sprintf(buffer, "InetSetup$Driver$%s", buffer2);
          }
          else
          {
            /* podule number is 8 so it is a NIC */
            sprintf(buffer, "InetSetup$Driver$%s", msgs_lookup("NIC"));
          }

          if (!getenv(buffer))
          {
            sprintf(buffer2, "%s:%s%d%s", msgs_lookup(known_types[i].description),
            known_types[i].unit,
            (*known_types[i].count)++,
            known_types[i].modules);
            _kernel_setenv(buffer, buffer2);
          }
          break;
        }
      }
a137 1
    /* Check for existance of Econet */
d140 2
a141 2
      _kernel_setenv("InetSetup$Driver$Econet", "Econet:ec0:EconetA:0.00:EconetA");
      HaveEconet = TRUE;
d144 2
a145 19
    /* Has InetSetup$Driver$Serial already been setup? */
    if (!getenv("InetSetup$Driver$Serial"))
    {
      /* Does PPP driver exist in directory */
      if (Exists("System:Modules.Network.PPP"))
      {
        /* Name it as InetSetup$Driver$Serial device */
        _kernel_setenv("InetSetup$Driver$Serial", "PPP:ppp0:PPP:1.13:PPP:P");
      }
      else
      {
        /* No PPP, then look for Slip after all it's better than nothing */
        if (Exists("System:Modules.Network.Slip"))
        {
          /* stick it in as InetSetup$Driver$Serial device */
          _kernel_setenv("InetSetup$Driver$Serial", "SLIP:sl0:Slip:2.07:Slip:P");
        }
      }
    }
d149 3
a151 1
    /* Right, now to examine those variables, and any other ones that may have been set */
d157 13
a169 20
      int len;
      if (xos_read_var_val("InetSetup$Driver$*", buffer, sizeof buffer, (int) p, 3, &len, (int *) &p, 0))
      {
        break;
      }

      buffer[len]='\0';

      strcpy(interface_location[interfaces], p + sizeof "InetSetup$Driver$" - 1);
      for (p2 = interface_location[interfaces]; *p2; p2++)
      {
        if (*p2 == '_') *p2 = ' ';
      }

      strcpy(interface_name[interfaces], strtok(buffer, ":"));
      strcpy(interface_unit[interfaces], strtok(0, ":"));
      if ((p2 = strtok(0, ":")) != 0)
      {
        strcpy(interface_module[interfaces], p2);
        interface_version[interfaces] = VersionToInt(strtok(0, ":"));
d172 3
a174 4
          strcpy(interface_filename[interfaces], p2);
          if ((p2 = strtok(0, ":")) != 0)
          {
            if (strchr(p2, 'P'))
d176 4
a179 10
              /* Local and remote IP addresses not needed for PPP */
              if (strcmp(interface_name[interfaces], "PPP") == 0)
              {
                interface_is_pp[interfaces] = 2;
              }
              else
              {
                /* Typical PP devices have local and remote IP addresses */
                interface_is_pp[interfaces] = 1;
              }
a180 1
          }
d182 1
a182 2
      }
      interfaces++;
@


1.2.2.2
log
@This is version 0.23 (15-Dec-97) of !InetSetup.
Principle changes in this version are that :-
a) 'use DNS' is now chosen by default, provided that a DNS client is available.
b) PPP is no longer considered a suitable candidate for 'default' interface -
   whilst in practice, it may be the only interface, it will not have a default
   netmask setup for it, and it will not be marked as 'set IP address from
   hostname'.
c) Certain incorrect values in the table of known interfaces were removed.
d) Certain headers appeared to be missing - these have been added to the local
   headers directory, rather than relying upon OSLib's example programs
   headers being in some 'appropriate' place.

Version 0.22, 1.1.2.2. Tagged as 'InetSetup-0_22-1_1_2_2'
@
text
@a26 1
 *          15-Dec-97: RCE   corrected some errors in the card type table.
d56 1
a56 1
/*    { 0x0031, "ev",   "ev", ":EtherV:0.00:EtherV",       &count[1]  },*/ /* WildAtoD?                                    */
d67 1
a67 1
    { 0x00ec, "eh6",  "eh", ":EtherH:4.18:EtherH16",     &count[5]  }, /* ICubedEthernetMedusa  NIC                    */
d73 1
a73 1
/*  { 0x011e, "eh6a", "eh", ":EtherH:4.18:EtherH16",     &count[5]  },*/ /* NIC (Acorn) same product type as eh6         */
d78 2
a79 2
/*  { 0xffff, "eo",   "eo", ":EtherO:4.00:EtherO",       &count[8]  },*/ /* Unknown podule id                            */
/*  { 0xffff, "ea8",  "ea", ":Ether3:4.20:Ether3-8",     &count[9]  }, *//* Unknown podule id                            */
@


1.2.2.3
log
@Updated 'detect' for Castle Tech. cards - unit name ez.
Alteration to the resources file to prevent an unknown component ID
error on opening the AUN dbox when AUN is unselected.
Forgot to update the RISCOS version number, so there'll be another ci RSN.
@
text
@a27 1
 *          09-Jan-97: RCE   corrected entries for Castle Technology cards.
d66 2
a67 2
    { 0x00e8, "cte8", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechIDE         Castle technology      */
    { 0x00e9, "cte9", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechEthernet                           */
d69 2
a70 2
    { 0x00f4, "ctf4", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechEtherSCSIDS Castle technology      */
    { 0x00f5, "ctf5", "ez", ":CTNetDrvr:0.50:CTNetDrvr", &count[7]  }, /* CastleTechSCSI        Castle technology      */
@


1.1
log
@file Detect was initially added on branch RO_3_70_to_3_71.
@
text
@d1 186
@


1.1.4.1
log
@Version RO_3_71 taken
@
text
@a0 186
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* File:    detect.c
 * Purpose: Detection of installed expansion cards and the CMOS IP address
 * Author:  K Bracey
 * History: 07-Nov-06: KJB: fixed for different cards with same driver
 *                          removed use of podule_read_info for RISC OS 3.1
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"

#include "osbyte.h"
#include "podule.h"

#include "ModUtils.h"
#include "Load.h"
#include "Main.h"

static int count[10];

static struct
{
    const int type;
    const char *description;
    const char *unit;
    const char *modules;
    int *const count;
}
known_types[] =
{
    { 0x0003, "et", "et", ":Ether1:4.00:Ether1", &count[0] },
    { 0x0031, "ev", "ev", ":EtherV:0.00:EtherV", &count[1] },
    { 0x0061, "en", "en", ":Ether2:3.55:Ether2", &count[2] },
    { 0x00A4, "ea", "ea", ":Ether3:4.20:Ether3-16", &count[3] },
    { 0x00C3, "er", "er", ":EtherR:2.00:EtherR", &count[4] },
    { 0x00D4, "eh5", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* expansion card */
    { 0x00E4, "eb", "eb", ":EtherB:4.20:EtherB", &count[6] },
    { 0x00E8, "cte8", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00EC, "eh6", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* NIC */
    { 0x00F4, "ctf4", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00F5, "ctf5", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x011E, "eh6", "eh", ":EtherH:4.18:EtherH16", &count[5] }, /* NIC (Acorn) */
    { 0xffff, "eo", "eo", ":EtherO:4.00:EtherO", &count[8] },
    { 0xffff, "ea8", "ea", ":Ether3:4.20:Ether3-8", &count[9] },
    { 0, 0 },
};



/* Address stored is CMOS108.CMOS109.CMOS110.CMOS0 */

#define osbyte_CONFIGURE_IPADDRESS0 108
#define osbyte_CONFIGURE_IPADDRESS1 109
#define osbyte_CONFIGURE_IPADDRESS2 110
#define osbyte_CONFIGURE_IPADDRESS3 osbyte_CONFIGURE_STATION

static unsigned int ReadCMOSIP(void)
{
    unsigned int b0, b1, b2, b3;

    b0=readCMOS(osbyte_CONFIGURE_IPADDRESS0);
    b1=readCMOS(osbyte_CONFIGURE_IPADDRESS1);
    b2=readCMOS(osbyte_CONFIGURE_IPADDRESS2);
    b3=readCMOS(osbyte_CONFIGURE_IPADDRESS3);

    if (b0==0 && b1==0 && b2==0)
    {
        if (b3==0)
            return 0;
        else
            /* Call it 10.0.0.x, an IANA assigned private block */
            return 10 | (b3 << 24);
    }

    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
}

os_error *ScanInterfaces(void)
{
    podule_section slot;
    podule_header header;
    int type, i;
    char *p, *p2;
    char buffer[256];

    memset(count, 0, sizeof count);

    for (slot = 0; slot <= 8; slot++)
    {
        if (xpodule_read_header(&header, slot))
            continue;                             /* No card present */

        if ((header.b[0] & 0x78) != 0)
            continue;                             /* Simple ID only */

        type = header.b[3] + (header.b[4] << 8);

        for (i = 0; known_types[i].type; i++)
            if (type == known_types[i].type)
            {
                char buffer[64];
                char buffer2[64];
                if (slot < 8)
                {
                    sprintf(buffer2, msgs_lookup("Slot"), slot);
                    sprintf(buffer, "InetSetup$Driver$%s", buffer2);
                }
                else
                    sprintf(buffer, "InetSetup$Driver$%s", msgs_lookup("NIC"));

    	    	if (!getenv(buffer))
    	    	{
    	    	    sprintf(buffer2, "%s:%s%d%s", msgs_lookup(known_types[i].description),
    	    	    	    	    	     	  known_types[i].unit,
    	    	    	    	    	     	  (*known_types[i].count)++,
    	    	    	    	    	     	  known_types[i].modules);
                    _kernel_setenv(buffer, buffer2);
                }
                break;
            }
    }

    if (RMLoaded("Econet"))
    {
        _kernel_setenv("InetSetup$Driver$Econet", "Econet:ec0:EconetA:0.00:EconetA");
        HaveEconet = TRUE;
    }

    if (!getenv("InetSetup$Driver$Serial") && Exists("System:Modules.Network.Slip"))
        _kernel_setenv("InetSetup$Driver$Serial", "SLIP:sl0:Slip:2.07:Slip:P");

    CMOSIP=ReadCMOSIP();

    /* Right, now to examine those variables, and any other ones that may have been
       set */


    p = 0;

    for (;;)
    {
        int len;
        if (xos_read_var_val("InetSetup$Driver$*", buffer, sizeof buffer, (int) p, 3,
            	    	     &len, (int *) &p, 0))
            break;

        buffer[len]='\0';

    	strcpy(interface_location[interfaces], p + sizeof "InetSetup$Driver$" - 1);
    	for (p2 = interface_location[interfaces]; *p2; p2++)
    	    if (*p2 == '_') *p2 = ' ';

        strcpy(interface_name[interfaces], strtok(buffer, ":"));
        strcpy(interface_unit[interfaces], strtok(0, ":"));
        if ((p2 = strtok(0, ":")) != 0)
        {
            strcpy(interface_module[interfaces], p2);
            interface_version[interfaces] = VersionToInt(strtok(0, ":"));
            if ((p2 = strtok(0, ":")) != 0)
            {
            	strcpy(interface_filename[interfaces], p2);
                if ((p2 = strtok(0, ":")) != 0)
                    if (strchr(p2, 'P'))
                        interface_is_pp[interfaces] = 1;
            }
        }
        interfaces++;
    }

    return NULL;
}
@


1.1.2.1
log
@Merged from 3.71 CD
@
text
@a0 186
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* File:    detect.c
 * Purpose: Detection of installed expansion cards and the CMOS IP address
 * Author:  K Bracey
 * History: 07-Nov-06: KJB: fixed for different cards with same driver
 *                          removed use of podule_read_info for RISC OS 3.1
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"

#include "osbyte.h"
#include "podule.h"

#include "ModUtils.h"
#include "Load.h"
#include "Main.h"

static int count[10];

static struct
{
    const int type;
    const char *description;
    const char *unit;
    const char *modules;
    int *const count;
}
known_types[] =
{
    { 0x0003, "et", "et", ":Ether1:4.00:Ether1", &count[0] },
    { 0x0031, "ev", "ev", ":EtherV:0.00:EtherV", &count[1] },
    { 0x0061, "en", "en", ":Ether2:3.55:Ether2", &count[2] },
    { 0x00A4, "ea", "ea", ":Ether3:4.20:Ether3-16", &count[3] },
    { 0x00C3, "er", "er", ":EtherR:2.00:EtherR", &count[4] },
    { 0x00D4, "eh5", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* expansion card */
    { 0x00E4, "eb", "eb", ":EtherB:4.20:EtherB", &count[6] },
    { 0x00E8, "cte8", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00EC, "eh6", "eh", ":EtherH:4.06:EtherH16", &count[5] }, /* NIC */
    { 0x00F4, "ctf4", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x00F5, "ctf5", "ct", ":CTNetDrvr:0.00:CTNetDrvr", &count[7] },
    { 0x011E, "eh6", "eh", ":EtherH:4.18:EtherH16", &count[5] }, /* NIC (Acorn) */
    { 0xffff, "eo", "eo", ":EtherO:4.00:EtherO", &count[8] },
    { 0xffff, "ea8", "ea", ":Ether3:4.20:Ether3-8", &count[9] },
    { 0, 0 },
};



/* Address stored is CMOS108.CMOS109.CMOS110.CMOS0 */

#define osbyte_CONFIGURE_IPADDRESS0 108
#define osbyte_CONFIGURE_IPADDRESS1 109
#define osbyte_CONFIGURE_IPADDRESS2 110
#define osbyte_CONFIGURE_IPADDRESS3 osbyte_CONFIGURE_STATION

static unsigned int ReadCMOSIP(void)
{
    unsigned int b0, b1, b2, b3;

    b0=readCMOS(osbyte_CONFIGURE_IPADDRESS0);
    b1=readCMOS(osbyte_CONFIGURE_IPADDRESS1);
    b2=readCMOS(osbyte_CONFIGURE_IPADDRESS2);
    b3=readCMOS(osbyte_CONFIGURE_IPADDRESS3);

    if (b0==0 && b1==0 && b2==0)
    {
        if (b3==0)
            return 0;
        else
            /* Call it 10.0.0.x, an IANA assigned private block */
            return 10 | (b3 << 24);
    }

    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
}

os_error *ScanInterfaces(void)
{
    podule_section slot;
    podule_header header;
    int type, i;
    char *p, *p2;
    char buffer[256];

    memset(count, 0, sizeof count);

    for (slot = 0; slot <= 8; slot++)
    {
        if (xpodule_read_header(&header, slot))
            continue;                             /* No card present */

        if ((header.b[0] & 0x78) != 0)
            continue;                             /* Simple ID only */

        type = header.b[3] + (header.b[4] << 8);

        for (i = 0; known_types[i].type; i++)
            if (type == known_types[i].type)
            {
                char buffer[64];
                char buffer2[64];
                if (slot < 8)
                {
                    sprintf(buffer2, msgs_lookup("Slot"), slot);
                    sprintf(buffer, "InetSetup$Driver$%s", buffer2);
                }
                else
                    sprintf(buffer, "InetSetup$Driver$%s", msgs_lookup("NIC"));

    	    	if (!getenv(buffer))
    	    	{
    	    	    sprintf(buffer2, "%s:%s%d%s", msgs_lookup(known_types[i].description),
    	    	    	    	    	     	  known_types[i].unit,
    	    	    	    	    	     	  (*known_types[i].count)++,
    	    	    	    	    	     	  known_types[i].modules);
                    _kernel_setenv(buffer, buffer2);
                }
                break;
            }
    }

    if (RMLoaded("Econet"))
    {
        _kernel_setenv("InetSetup$Driver$Econet", "Econet:ec0:EconetA:0.00:EconetA");
        HaveEconet = TRUE;
    }

    if (!getenv("InetSetup$Driver$Serial") && Exists("System:Modules.Network.Slip"))
        _kernel_setenv("InetSetup$Driver$Serial", "SLIP:sl0:Slip:2.07:Slip:P");

    CMOSIP=ReadCMOSIP();

    /* Right, now to examine those variables, and any other ones that may have been
       set */


    p = 0;

    for (;;)
    {
        int len;
        if (xos_read_var_val("InetSetup$Driver$*", buffer, sizeof buffer, (int) p, 3,
            	    	     &len, (int *) &p, 0))
            break;

        buffer[len]='\0';

    	strcpy(interface_location[interfaces], p + sizeof "InetSetup$Driver$" - 1);
    	for (p2 = interface_location[interfaces]; *p2; p2++)
    	    if (*p2 == '_') *p2 = ' ';

        strcpy(interface_name[interfaces], strtok(buffer, ":"));
        strcpy(interface_unit[interfaces], strtok(0, ":"));
        if ((p2 = strtok(0, ":")) != 0)
        {
            strcpy(interface_module[interfaces], p2);
            interface_version[interfaces] = VersionToInt(strtok(0, ":"));
            if ((p2 = strtok(0, ":")) != 0)
            {
            	strcpy(interface_filename[interfaces], p2);
                if ((p2 = strtok(0, ":")) != 0)
                    if (strchr(p2, 'P'))
                        interface_is_pp[interfaces] = 1;
            }
        }
        interfaces++;
    }

    return NULL;
}
@

head	1.13;
access;
symbols
	Source-0_59:1.13
	Source-0_58:1.12
	Source-0_57:1.11
	Source-0_56:1.11
	Source-0_55:1.11
	Source-0_54:1.10
	Source-0_53:1.10
	Source-0_52:1.10
	Source-0_51:1.10
	Source-0_50:1.10
	Source-0_49:1.10
	InetSetup-0_49:1.10
	InetSetup-0_48:1.10
	InetSetup-0_47:1.9
	InetSetup-0_46:1.9
	InetSetup-0_45:1.9
	InetSetup-0_44:1.8
	InetSetup-0_43:1.8
	InetSetup-0_42:1.7
	InetSetup-0_41:1.7
	InetSetup-0_40:1.7
	InetSetup-0_39:1.7
	InetSetup-0_38:1.7
	InetSetup-0_37:1.7
	InetSetup-0_36:1.7
	InetSetup-0_35:1.7
	InetSetup-0_34:1.7
	InetSetup-0_33:1.6
	InetSetup-0_32:1.5
	InetSetup-0_31:1.5
	InetSetup-0_30:1.5
	InetSetup-0_29:1.4
	StrongARM_merge:1.1.4.1
	sbrodie_InetSetup_dev_merge:1.2.2.2.2.1
	Daytona_merge:1.2
	Ursula_merge:1.2.2.2
	InetSetup-0_28:1.3
	mstphens_UrsulaRiscPCBuild_20Nov98:1.2.2.2
	Ursula_RiscPC:1.2.2.2.0.4
	InetSetup-0_22-1_1_2_4:1.2.2.2
	InetSetup-0_22-1_1_2_3_2_1:1.2.2.2.2.1
	sbrodie_InetSetup_dev-1_1_2_3:1.2.2.2.0.2
	sbrodie_InetSetup_dev-1_1_2_3_bp:1.2.2.2
	rthornb_UrsulaBuild-19Aug1998:1.2.2.2
	UrsulaBuild_FinalSoftload:1.2.2.2
	rthornb_UrsulaBuild-12Aug1998:1.2.2.2
	aglover_UrsulaBuild-05Aug1998:1.2.2.2
	rthornb_UrsulaBuild-29Jul1998:1.2.2.2
	rthornb_UrsulaBuild-22Jul1998:1.2.2.2
	InetSetup-0_22-1_1_2_3:1.2.2.2
	rthornb_UrsulaBuild-15Jul1998:1.2.2.2
	rthornb_UrsulaBuild-07Jul1998:1.2.2.2
	rthornb_UrsulaBuild-17Jun1998:1.2.2.2
	rthornb_UrsulaBuild-03Jun1998:1.2.2.2
	rthornb_UrsulaBuild-27May1998:1.2.2.2
	rthornb_UrsulaBuild-21May1998:1.2.2.2
	bavison_InetSetup-0_25:1.2.2.2
	rthornb_UrsulaBuild_01May1998:1.2.2.2
	celkins_InetSetup_0_24:1.2.2.2
	InetSetup-0_22-1_1_2_2:1.2.2.2
	Daytona:1.2.0.4
	Daytona_bp:1.2
	Ursula:1.2.0.2
	Ursula_bp:1.2
	StrongARM:1.1.0.4
	RO_3_71:1.1.4.1;
locks; strict;
comment	@# @;


1.13
date	2018.08.19.09.48.15;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	nIgrlmSwWmfUjIOA;

1.12
date	2017.01.07.17.24.51;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	AdZgvrr1LYvkM3Bz;

1.11
date	2015.12.11.20.45.06;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	kAWB24PG0dbewzMy;

1.10
date	2012.09.15.10.19.56;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	rCoFS9CCmPHm3Ckw;

1.9
date	2012.07.29.08.56.17;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	iMWPXwWp5h8n8rew;

1.8
date	2012.07.19.10.58.57;	author rgriffin;	state Exp;
branches;
next	1.7;
commitid	rX1BtXHrURun8adw;

1.7
date	2003.01.17.15.32.21;	author rsprowson;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.19.20.31.28;	author srevill;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.08.14.25.12;	author nbingham;	state Exp;
branches;
next	1.4;

1.4
date	99.08.11.14.38.06;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	99.08.10.16.05.02;	author sbrodie;	state Exp;
branches;
next	1.2;

1.2
date	97.05.06.17.27.20;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.30.18.43.26;	author kbracey;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.2.2.1
date	97.11.18.16.08.42;	author dbrown;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.12.17.15.15.45;	author celkins;	state Exp;
branches
	1.2.2.2.2.1;
next	;

1.2.2.2.2.1
date	98.09.02.11.37.00;	author sbrodie;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.30.18.43.26;	author kbracey;	state Exp;
branches;
next	;

1.1.4.1
date	97.05.06.17.11.05;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Fix NULL pointer dereference on error
Load.c: if the file didn't open, don't try fclose(NULL)
Found by cppcheck static analysis.
Save.c/Diagnose.c: sort netdb.h's header ordering

Version 0.59. Tagged as 'Source-0_59'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "os.h"
#include "toolbox.h"

#include "ModUtils.h"
#include "Main.h"
#include "Load.h"
#include "Versions.h"
#include "IfsDbox.h"
#include "Gadgets.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

char interface_location[16][32];
char interface_name[16][64];
char interface_unit[16][16];
char interface_module[16][32];
int interface_version[16];
char interface_filename[16][16];
char interface_address[16][64];
char interface_netmask[16][16];
char interface_linkaddr[16][16];
char interface_is_pp[16];
char interface_has_section[16];

int primary_interface = -1;
int interfaces;
int v_MbufManager, v_AUNMsgs, v_Internet, v_BootNet,
    v_Net, v_NetI, v_Freeway, v_ShareFS, v_Resolver,
    v_Resolve, v_InetDB, v_DNSResolver, v_RouteD,
    v_DHCP, v_DHCPPrivNet, v_InternetDHCP, v_InternetMsgs;
bool StartupExists;

void ScanInetStartup(void);
void GetHostName(FILE *);
void GetInterface(FILE *, char *);
void GetResolvers(FILE *);
void GetRouting(FILE *);
static void DefaultAnInterface(void);

os_error *CheckConfig(void)
{
    FILE *f;
    char buffer[256];

    #define GetVer(mod) v_##mod = VersionToInt(msgs_lookup("v_" #mod))
    GetVer(MbufManager);
    GetVer(AUNMsgs);
    GetVer(Internet);
    GetVer(InternetDHCP); /* Earliest version of Internet which supports DHCP */
    GetVer(InternetMsgs); /* Earliest version of Internet with its own Messages */
    GetVer(BootNet);
    GetVer(Net);
    GetVer(NetI);
    GetVer(Freeway);
    GetVer(ShareFS);
    GetVer(Resolver);
    GetVer(Resolve);
    GetVer(InetDB);
    GetVer(DNSResolver);
    GetVer(DHCP);
    GetVer(DHCPPrivNet);  /* Earliest version of DHCP which supports -p switch */
    GetVer(RouteD);

    if (RMFind("Resolver", "System:Modules.Network.Resolver", v_Resolver))
    	HaveResolver = TRUE;
    if (RMFind("Resolve", "System:Modules.Network.Resolve", v_Resolve))
    	HaveResolve = TRUE;
    if (RMFind("InetDB", "System:Modules.Network.InetDB", v_InetDB))
    	HaveInetDB = TRUE;
    if (RMFind("DNSResolver", "System:Modules.Network.DNSResolve", v_DNSResolver))
    	HaveDNSResolver = TRUE;

    HaveAResolver = HaveResolver || HaveResolve || HaveInetDB || HaveDNSResolver;

    if (RMFind("RouteD", "System:Modules.Network.RouteD", v_RouteD))
    	HaveRouteD = TRUE;

    InternetEnabled = FALSE;

    f=fopen("<Boot$ToBeLoaded>.SetUpNet", "r");

    if (f)
    {
        if (fgets(buffer, sizeof buffer, f) && strstr(buffer, "!Internet"))
            InternetEnabled = TRUE;
        fclose(f);
    }

    if (getenv("Inet$Path"))
    	ScanInetStartup();

    if (!StartupExists)
    	DefaultAnInterface();

    if (!InternetEnabled)
    {
        AccessEnabled = RMLoaded("ShareFS") && RMLoaded("Freeway");
        AUNEnabled = RMLoaded("Net");
    }

    return FALSE;
}

void ScanInetStartup(void)
{
    FILE *f;
    char buffer[256];
    char buffer2[20];

    f=fopen(CONFIGDIR_READ "Startup", "r");
    if (!f)
    	return;

    StartupExists = TRUE;

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0]=='|' && buffer[1]=='\n')
            break;
    }
  nextsection:
    if (feof(f))
    {
        fclose(f);
        return;
    }

    fgets(buffer, sizeof buffer, f);
    fgets(buffer2, sizeof buffer2, f);
    if (strstr(buffer, "Host name"))
    	GetHostName(f);
    else if (strstr(buffer, "Interface: "))
    	GetInterface(f, strstr(buffer, "Interface: ")+sizeof "Interface: "-1);
    else if (strstr(buffer, "Name resolver"))
    	GetResolvers(f);
    else if (strstr(buffer, "Routing"))
    	GetRouting(f);
    else if (strstr(buffer, "AUN"))
    	AUNEnabled=TRUE;
    else if (strstr(buffer, "Access"))
    	AccessEnabled=TRUE;

    goto nextsection;
}

void GetHostName(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
            return;

        if (strstr(buffer, "Inet$HostName"))
            sscanf(buffer, "Set Inet$HostName %s", HostName);
        else if (strstr(buffer, "Inet$LocalDomain"))
            sscanf(buffer, "Set Inet$LocalDomain %s", LocalDomain);
    }
}

void GetResolvers(FILE *f)
{
    char buffer[256];
    char *scan;

    while (fgets(buffer, sizeof buffer, f))
    {
        /* Were any of the known resolver modules found */
        if (!HaveAResolver)
            continue;

        scan = strstr(buffer, "Set Inet$Resolvers");
        if (scan)
        {
            sscanf(scan, "Set Inet$Resolvers %s %s %s", Resolver[0], Resolver[1], Resolver[2]);
            if (!strcmp(Resolver[0], "\"\"")) strcpy(Resolver[0], "");
            /* If at least the primary resolver exists it has been set up to do remote resolving */
            if (strlen(Resolver[0]) !=0 ) UseResolver=1;
        }
        else if (strstr(buffer, "RMEnsure Resolver"))
        {
            ResolverType=RT_Resolver;
        }
        else if (strstr(buffer, "RMEnsure Resolve"))
        {
            FILE *rf;
            ResolverType=RT_Resolve;
            rf=fopen("InetDBase:resolve", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1) continue;
                        if (sn<3) sscanf(buffer, "nameserver %s", Resolver[sn++]);
                    }
                }
                fclose(rf);
            }
        }
        else if (strstr(buffer, "RMEnsure InetDB"))
        {
            ResolverType=RT_InetDB;
            goto scanresconf;
        }
        else if (strstr(buffer, "RMEnsure DNSResolver"))
        {
            FILE *rf;
            ResolverType=RT_DNSResolver;
          scanresconf:
            rf=fopen("InetDBase:resconf", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1)
                        {
                            if (LocalDomain[strlen(LocalDomain)-1]=='.')
                                LocalDomain[strlen(LocalDomain)-1]='\0';
                            continue;
                        }
                        if (sn<3)
                        {
                            if (sscanf(buffer, "nameserver %s", Resolver[sn]) == 1)
                                sn++;
                        }
                    }
                }
                fclose(rf);
            }
        }
        if (buffer[0] == '|')
   	return;

    }
}

void GetRouting(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (strstr(buffer, "Route -e add default"))
            sscanf(buffer, "Route -e add default %s", Gateway);

        else if (strstr(buffer, "Set Inet$IsGateway Yes"))
            AmRouter = TRUE;

        else if (strstr(buffer, "Set Inet$RouteDOptions"))
        {
            sscanf(buffer, "Set Inet$RouteDOptions %s", RouteDoptions);
            if (strcmp(RouteDoptions, "\"\"") == 0)
                strcpy(RouteDoptions, ROUTED_DEFAULTOPTS);
            else
                UseRouteD = TRUE && HaveRouteD;
        }
    }
}

void GetInterface(FILE *f, char *s)
{
    char buffer[256];
    char unit[16];
    char name[16];
    char iptype[16];
    char therest[16];
    char *p;
    bool done = FALSE;
    bool halfdone = FALSE;
    int i = -1;

    /* Find which interface we're talking about */
    if ((p = strchr(s, '\n')) != 0)
    	*p = '\0';

    for(i = 0; i < interfaces; i++)
    {
      if (strcmp(interface_name[i], s) == 0)
      interface_has_section[i] = 1;
    }

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (done)
            continue;

        if (strstr(buffer, "Set Inet$"))
        {
          strtok(buffer, "$");
          strncpy(name, strtok(NULL, "$"), 15);

          strncpy(iptype, strtok(NULL, " "), 15);

          strncpy(therest, strtok(NULL, ""), 15);

          if (strstr(therest, "\"\""))
          {
            therest[0] = '\0';
          }

          for (i = 0; i < interfaces; i++)
    	  {
    	    if (interface_is_pp[i] == 2)
    	    {
        	if (strcmp(interface_name[i], name) == 0)
        	{
        	  if (strcmp(iptype, "IPAddr") == 0)
        	  {
        	    strcpy(interface_address[i], therest);
        	  } else
        	  {
        	    if (strcmp(iptype, "LinkIPAddr") == 0)
        	    {
        	      strcpy(interface_linkaddr[i], therest);
        	    } else
        	    {
        	      if (strcmp(iptype, "IPMask") == 0)
        	      {
        	        strcpy(interface_netmask[i], therest);
        	      }
        	    }
        	  }
        	}
        	break;	/* Found interface, don't keep looking */
            } else
            {
              /* Don't know what to do with Set Inet$ for non PPP entries */
            }
    	  }
        }

    	if (!halfdone && strstr(buffer, "IfConfig -e "))
    	{
    	    sscanf(buffer, "IfConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1 && strcmp(interface_unit[i], "ec0"))
    	    	primary_interface = i;

            if (!interface_is_pp[i])
    	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s netmask %s", interface_address[i], interface_netmask[i]);
    	    else
     	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s %s netmask %s", interface_address[i], interface_linkaddr[i],
    	                                   interface_netmask[i]);

    	    done = TRUE;

    	    if (strcmp(interface_address[i], HostName) == 0)
    	        interface_addrtype[i] = if_FromHostname;
            else if (strcmp(interface_address[i], "<Inet$CMOSIPAddr>") == 0)
            {
                struct in_addr in;
                in.s_addr = CMOSIP;
                interface_addrtype[i] = if_FromCMOS;
                strcpy(interface_address[i], inet_ntoa(in));
            }
    	    else
    	        interface_addrtype[i] = if_Manual;
        }
        else if (strstr(buffer, "IfRConfig -e "))
    	{
    	    sscanf(buffer, "IfRConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1)
    	    	primary_interface = i;

            if (strstr(buffer, "revarp"))
            {
                interface_addrtype[i] = if_RevARP;
            }
            else if (strstr(buffer, "bootp"))
            {
                strcpy(interface_netmask[i], "zzzz");
                interface_addrtype[i] = if_BOOTP;
            }
            else if (strstr(buffer, "dhcp"))
            {
                strcpy(interface_netmask[i], "zzzz");
                interface_addrtype[i] = if_DHCP;
            }
            if (strstr(buffer, "netmask"))
            {
                strcpy(interface_netmask[i], "zzzz");
                done = TRUE;
            }
            else
                halfdone = TRUE;
        }
        else if (strstr(buffer, "DHCPExecute -e -b -w"))
        {
            /* May encounter either form */
            sscanf(buffer, "DHCPExecute -e -b -w %s", unit);
            if (strcmp(unit, "-p") == 0) sscanf(buffer, "DHCPExecute -e -b -w -p %s", unit);
            
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1)
    	    	primary_interface = i;
            interface_addrtype[i] = if_DHCP;
            strcpy(interface_netmask[i], "default");
            done = TRUE;
        }
        else if (halfdone && strstr(buffer, "IfConfig -e"))
        {
            sscanf(strstr(buffer, "netmask"), "netmask %s", interface_netmask[i]);
            done = TRUE;
        }
    }
}

void DefaultAnInterface(void)
{
    int first_int = -1, first_pp = -1;
    int i;

    for (i = 0; i < interfaces; i++)
        if (first_int == -1 && !interface_is_pp[i])
            first_int = i;
        else if (first_pp == -1 && interface_is_pp[i] == 1)
            first_pp = i;

    /* Default the first non point-to-point interface, or failing that the
       first point-to-point interface (not PPP)
     */
    if (first_pp >= 0 && first_int == -1)
    	first_int = first_pp;

    if (first_int == -1)
    	return;

    primary_interface = first_int;

    strcpy(interface_netmask[first_int], "default");
    strcpy(interface_address[first_int], HostName);
    interface_addrtype[first_int] = if_FromHostname;
}
@


1.12
log
@Only ensure AUNMsgs when they're needed
When TCP/IP networking is disabled, but AUN or Access are enabled, the Internet module is loaded for its IP handling. In doing so, only load AUNMsgs if the Internet module to hand actually requires it.
Save.c:
  Check if the Internet module is new enough to contain its own messages, and don't load AUNMsgs if so.
Load.c/Versions.h/Messages:
  Populate v_InternetMsgs.
Main.h/Main.c:
  Turn the resolver types into an enum so the max value can be used instead of magic number 4.
SmallDrag.c:
  Don't look for Wimp_PlotIcon define, it's been in the headers for years.
UK/!Run:
  Simplify the check, !InetSetup doesn't need AUNMsgs itself.
Save.c/Routes/SetUpNet:
  Remove the hardwired version string of !Internet, since the files end up in Choices:, that way it can't be out of date ever again.

Version 0.58. Tagged as 'Source-0_58'
@
text
@d102 3
a104 2
    if (f && fgets(buffer, sizeof buffer, f))
        if (strstr(buffer, "!Internet"))
d106 2
a107 2

    fclose(f);
@


1.11
log
@Fade the 'Run RouteD' option when the RouteD module is missing
Ticking the option would cause an error during booting, since the module cannot be loaded.
Removed the default option text from the Res file, as it's not language specific, it's a CLI switch looked for by the module. Strictly speaking making it lowercase (like the "default" accepted as a netmask) is an incompatible change as disassembling a 1993 copy of the RouteD module shows it uses strcmp() on "DEFAULT", but since that wont run on anything even as recent as a StrongARM it's probably better to note that any new port should be using a case insensitive switch check.

Version 0.55. Tagged as 'Source-0_55'
@
text
@d50 1
a50 1
    v_DHCP, v_DHCPPrivNet, v_InternetDHCP;
d70 1
@


1.10
log
@Fix to work when DHCP doesn't support -p switch
The DHCP module uses OS_ReadArgs for switch matching, but in the CMHG table it strictly checks for max-args. The recently added '-p' switch therefore should not be output by !InetSetup when the available module doesn't support it.
Load.c: parse setup files with or without -p
Save.c: use RMFind() to figure out if -p is available, and omit it when not
Also
* Bumped up the !Internet version number in the comment block written out
* Make sure DHCP is plugged in during save (and unplugged if TCP/IP is actively disabled)
* Fixed the minimum DHCP version number, !InetSetup was always outputting -w even though that wasn't supported in the version that was being RMEnsure'd

Version 0.48. Tagged as 'InetSetup-0_48'
@
text
@d49 1
a49 1
    v_Resolve, v_InetDB, v_DNSResolver,
d81 1
d94 3
d283 1
a283 1
                strcpy(RouteDoptions, "DEFAULT");
d285 1
a285 1
                UseRouteD = TRUE;
@


1.9
log
@Employ bit 5 of TaskManager_Shutdown
Harmless on task managers that don't support it.
Uncurled some braces to match local style.
Don't compare "FILE *" with 0, uses NULL.
Switched out unused os_reset_old_machine assembler.

Version 0.45. Tagged as 'InetSetup-0_45'
@
text
@d49 2
a50 1
    v_Resolve, v_InetDB, v_DNSResolver, v_DHCP, v_InetDHCP;
d69 1
d80 1
a80 1
    GetVer(InetDHCP);
d441 1
a441 1
        else if (strstr(buffer, "DHCPExecute -e -b "))
d443 4
a446 1
            sscanf(buffer, "DHCPExecute -e -b -w -p %s", unit);
@


1.8
log
@Added "-p" switch to DHCPExecute command in autogenerated setup file.

Version 0.43. Tagged as 'InetSetup-0_43'
@
text
@d439 2
a440 1
        else if (strstr(buffer, "DHCPExecute -e -b ")) {
@


1.7
log
@Delete a few !RunImages
Add CoSprite (rectangular pixel versions)
Docs and version number tweak
The resolver setup will now try to RMInsert any unplugged modules when
saving the settings.
Change to DNS window so that it remembers the "Use name servers also" icon
rather than having two forgetful radio icons.

Version 0.34. Tagged as 'InetSetup-0_34'
@
text
@d440 1
a440 1
            sscanf(buffer, "DHCPExecute -e -b -w %s", unit);
@


1.6
log
@Changes to the greying out behaviour in the "Obtain IP address" dialogue
as it was a real mess,particularly the behaviour when DHCP was selected.
UK Res file overhaul.
You can now drag the AUNMap to an editor and it will be loaded.
New Sprites files.

Version 0.33. Tagged as 'InetSetup-0_33'
@
text
@d181 2
a182 1
        if (!HaveResolver)
d190 2
a194 1
            UseResolver=1;
a199 1
            UseResolver=1;
a218 1
            UseResolver=1;
a224 1
            UseResolver=1;
@


1.5
log
@  Update to DHCP support.
Detail:
  When configuring a host for DHCP the '-w' flag is now passed to
  *dhcpexecute.
Admin:
  Tested briefly on Ursula.

Version 0.30. Tagged as 'InetSetup-0_30'
@
text
@d177 1
d184 2
a185 1
        if (strstr(buffer, "Inet$Resolvers"))
d187 1
a187 1
            sscanf(buffer, "Set Inet$Resolvers %s %s %s", Resolver[0], Resolver[1], Resolver[2]);
d424 1
d429 1
@


1.4
log
@  DHCP support added.
Detail:
  The DHCP button in the interface configuration window is now unfaded
    as long as InetSetup can locate Internet 5.31 or later and DHCP
    0.11 and later.  Any number of interfaces may use DHCP to configure
    their interfaces,
Admin:
  Tested in Risc PCs

Version 0.29. Tagged as 'InetSetup-0_29'
@
text
@d437 1
a437 1
            sscanf(buffer, "DHCPExecute -e -b %s", unit);
@


1.3
log
@  Merge of half a dozen separate branches to the trunk:
    Ursula
    Ursula_RiscPC
    StrongARM
    Daytona(!)
    sbrodie_InetSetup_dev-1_1_2_3
    ART
Detail:
  What a mess.
Admin:
  This is the Ursula plugin version.  It builds.

Version 0.28. Tagged as 'InetSetup-0_28'
@
text
@d49 1
a49 1
    v_Resolve, v_InetDB, v_DNSResolver;
d77 2
d435 20
@


1.2
log
@Version RO_3_71 taken
@
text
@d43 2
a177 3
        if (buffer[0] == '|')
        	return;

d182 1
d184 2
d249 3
d285 3
d297 6
d311 45
d422 4
d450 1
a450 1
        else if (first_pp == -1 && interface_is_pp[i])
d454 1
a454 1
       first point-to-point interface
@


1.2.2.1
log
@Support added for PPP module and additional network cards.  Front end has also
been modified to fit style guide more closely.
@
text
@a42 2
char interface_has_section[16];

d176 3
a182 1
        {
a183 2
            if (!strcmp(Resolver[0], "\"\"")) strcpy(Resolver[0], "");
        }
a246 3
        if (buffer[0] == '|')
   	return;

a279 3
    char name[16];
    char iptype[16];
    char therest[16];
a288 6
    for(i = 0; i < interfaces; i++)
    {
      if (strcmp(interface_name[i], s) == 0)
      interface_has_section[i] = 1;
    }

a295 45

        if (strstr(buffer, "Set Inet$"))
        {
          strtok(buffer, "$");
          strncpy(name, strtok(NULL, "$"), 15);

          strncpy(iptype, strtok(NULL, " "), 15);

          strncpy(therest, strtok(NULL, ""), 15);

          if (strstr(therest, "\"\""))
          {
            therest[0] = '\0';
          }

          for (i = 0; i < interfaces; i++)
    	  {
    	    if (interface_is_pp[i] == 2)
    	    {
        	if (strcmp(interface_name[i], name) == 0)
        	{
        	  if (strcmp(iptype, "IPAddr") == 0)
        	  {
        	    strcpy(interface_address[i], therest);
        	  } else
        	  {
        	    if (strcmp(iptype, "LinkIPAddr") == 0)
        	    {
        	      strcpy(interface_linkaddr[i], therest);
        	    } else
        	    {
        	      if (strcmp(iptype, "IPMask") == 0)
        	      {
        	        strcpy(interface_netmask[i], therest);
        	      }
        	    }
        	  }
        	}
        	break;	/* Found interface, don't keep looking */
            } else
            {
              /* Don't know what to do with Set Inet$ for non PPP entries */
            }
    	  }
        }
@


1.2.2.2
log
@This is version 0.23 (15-Dec-97) of !InetSetup.
Principle changes in this version are that :-
a) 'use DNS' is now chosen by default, provided that a DNS client is available.
b) PPP is no longer considered a suitable candidate for 'default' interface -
   whilst in practice, it may be the only interface, it will not have a default
   netmask setup for it, and it will not be marked as 'set IP address from
   hostname'.
c) Certain incorrect values in the table of known interfaces were removed.
d) Certain headers appeared to be missing - these have been added to the local
   headers directory, rather than relying upon OSLib's example programs
   headers being in some 'appropriate' place.

Version 0.22, 1.1.2.2. Tagged as 'InetSetup-0_22-1_1_2_2'
@
text
@d446 1
a446 1
        else if (first_pp == -1 && interface_is_pp[i] == 1)
d450 1
a450 1
       first point-to-point interface (not PPP)
@


1.2.2.2.2.1
log
@  Added support code for DHCP configurations.  Work in progress.
Detail:
  c.Load/c.Save: modified to use "dhcp" parameter to ifrconfig command in
      Choices:Internet.Startup
  c.IfsDbox: modified to handle gadget flags as appropriate for DHCP
      (just extends BootP/RevARP handler code with a third case)
  Resources/*/Res: Unfaded DHCP optionbutton.  Now controlled from code.
  Resources/*/Messages: Updated version number.
Admin:
  Work in progress - private development branch work not yet complete.

Version 0.22, 1.1.2.3.2.1. Tagged as 'InetSetup-0_22-1_1_2_3_2_1'
@
text
@a421 4
            else if (strstr(buffer, "dhcp"))
            {
                interface_addrtype[i] = if_DHCP;
            }
@


1.1
log
@file Load was initially added on branch RO_3_70_to_3_71.
@
text
@d1 404
@


1.1.4.1
log
@Version RO_3_71 taken
@
text
@a0 404
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "os.h"
#include "toolbox.h"

#include "ModUtils.h"
#include "Main.h"
#include "Load.h"
#include "Versions.h"
#include "IfsDbox.h"
#include "Gadgets.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

char interface_location[16][32];
char interface_name[16][64];
char interface_unit[16][16];
char interface_module[16][32];
int interface_version[16];
char interface_filename[16][16];
char interface_address[16][64];
char interface_netmask[16][16];
char interface_linkaddr[16][16];
char interface_is_pp[16];
int primary_interface = -1;
int interfaces;
int v_MbufManager, v_AUNMsgs, v_Internet, v_BootNet,
    v_Net, v_NetI, v_Freeway, v_ShareFS, v_Resolver,
    v_Resolve, v_InetDB, v_DNSResolver;
bool StartupExists;

void ScanInetStartup(void);
void GetHostName(FILE *);
void GetInterface(FILE *, char *);
void GetResolvers(FILE *);
void GetRouting(FILE *);
static void DefaultAnInterface(void);

os_error *CheckConfig(void)
{
    FILE *f;
    char buffer[256];

    #define GetVer(mod) v_##mod = VersionToInt(msgs_lookup("v_" #mod))
    GetVer(MbufManager);
    GetVer(AUNMsgs);
    GetVer(Internet);
    GetVer(BootNet);
    GetVer(Net);
    GetVer(NetI);
    GetVer(Freeway);
    GetVer(ShareFS);
    GetVer(Resolver);
    GetVer(Resolve);
    GetVer(InetDB);
    GetVer(DNSResolver);

    if (RMFind("Resolver", "System:Modules.Network.Resolver", v_Resolver))
    	HaveResolver = TRUE;
    if (RMFind("Resolve", "System:Modules.Network.Resolve", v_Resolve))
    	HaveResolve = TRUE;
    if (RMFind("InetDB", "System:Modules.Network.InetDB", v_InetDB))
    	HaveInetDB = TRUE;
    if (RMFind("DNSResolver", "System:Modules.Network.DNSResolve", v_DNSResolver))
    	HaveDNSResolver = TRUE;

    HaveAResolver = HaveResolver || HaveResolve || HaveInetDB || HaveDNSResolver;

    InternetEnabled = FALSE;

    f=fopen("<Boot$ToBeLoaded>.SetUpNet", "r");

    if (f && fgets(buffer, sizeof buffer, f))
        if (strstr(buffer, "!Internet"))
            InternetEnabled = TRUE;

    fclose(f);

    if (getenv("Inet$Path"))
    	ScanInetStartup();

    if (!StartupExists)
    	DefaultAnInterface();

    if (!InternetEnabled)
    {
        AccessEnabled = RMLoaded("ShareFS") && RMLoaded("Freeway");
        AUNEnabled = RMLoaded("Net");
    }

    return FALSE;
}

void ScanInetStartup(void)
{
    FILE *f;
    char buffer[256];
    char buffer2[20];

    f=fopen(CONFIGDIR_READ "Startup", "r");
    if (!f)
    	return;

    StartupExists = TRUE;

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0]=='|' && buffer[1]=='\n')
            break;
    }
  nextsection:
    if (feof(f))
    {
        fclose(f);
        return;
    }

    fgets(buffer, sizeof buffer, f);
    fgets(buffer2, sizeof buffer2, f);
    if (strstr(buffer, "Host name"))
    	GetHostName(f);
    else if (strstr(buffer, "Interface: "))
    	GetInterface(f, strstr(buffer, "Interface: ")+sizeof "Interface: "-1);
    else if (strstr(buffer, "Name resolver"))
    	GetResolvers(f);
    else if (strstr(buffer, "Routing"))
    	GetRouting(f);
    else if (strstr(buffer, "AUN"))
    	AUNEnabled=TRUE;
    else if (strstr(buffer, "Access"))
    	AccessEnabled=TRUE;

    goto nextsection;
}

void GetHostName(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
            return;

        if (strstr(buffer, "Inet$HostName"))
            sscanf(buffer, "Set Inet$HostName %s", HostName);
        else if (strstr(buffer, "Inet$LocalDomain"))
            sscanf(buffer, "Set Inet$LocalDomain %s", LocalDomain);
    }
}

void GetResolvers(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (!HaveResolver)
            continue;

        if (strstr(buffer, "Inet$Resolvers"))
            sscanf(buffer, "Set Inet$Resolvers %s %s %s", Resolver[0], Resolver[1], Resolver[2]);
        else if (strstr(buffer, "RMEnsure Resolver"))
        {
            UseResolver=1;
            ResolverType=RT_Resolver;
        }
        else if (strstr(buffer, "RMEnsure Resolve"))
        {
            FILE *rf;
            UseResolver=1;
            ResolverType=RT_Resolve;
            rf=fopen("InetDBase:resolve", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1) continue;
                        if (sn<3) sscanf(buffer, "nameserver %s", Resolver[sn++]);
                    }
                }
                fclose(rf);
            }
        }
        else if (strstr(buffer, "RMEnsure InetDB"))
        {
            UseResolver=1;
            ResolverType=RT_InetDB;
            goto scanresconf;
        }
        else if (strstr(buffer, "RMEnsure DNSResolver"))
        {
            FILE *rf;
            UseResolver=1;
            ResolverType=RT_DNSResolver;
          scanresconf:
            rf=fopen("InetDBase:resconf", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1)
                        {
                            if (LocalDomain[strlen(LocalDomain)-1]=='.')
                                LocalDomain[strlen(LocalDomain)-1]='\0';
                            continue;
                        }
                        if (sn<3)
                        {
                            if (sscanf(buffer, "nameserver %s", Resolver[sn]) == 1)
                                sn++;
                        }
                    }
                }
                fclose(rf);
            }
        }
    }
}

void GetRouting(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (strstr(buffer, "Route -e add default"))
            sscanf(buffer, "Route -e add default %s", Gateway);

        else if (strstr(buffer, "Set Inet$IsGateway Yes"))
            AmRouter = TRUE;

        else if (strstr(buffer, "Set Inet$RouteDOptions"))
        {
            sscanf(buffer, "Set Inet$RouteDOptions %s", RouteDoptions);
            if (strcmp(RouteDoptions, "\"\"") == 0)
                strcpy(RouteDoptions, "DEFAULT");
            else
                UseRouteD = TRUE;
        }
    }
}

void GetInterface(FILE *f, char *s)
{
    char buffer[256];
    char unit[16];
    char *p;
    bool done = FALSE;
    bool halfdone = FALSE;
    int i = -1;

    /* Find which interface we're talking about */
    if ((p = strchr(s, '\n')) != 0)
    	*p = '\0';

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (done)
            continue;

    	if (!halfdone && strstr(buffer, "IfConfig -e "))
    	{
    	    sscanf(buffer, "IfConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1 && strcmp(interface_unit[i], "ec0"))
    	    	primary_interface = i;

            if (!interface_is_pp[i])
    	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s netmask %s", interface_address[i], interface_netmask[i]);
    	    else
     	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s %s netmask %s", interface_address[i], interface_linkaddr[i],
    	                                   interface_netmask[i]);

    	    done = TRUE;

    	    if (strcmp(interface_address[i], HostName) == 0)
    	        interface_addrtype[i] = if_FromHostname;
            else if (strcmp(interface_address[i], "<Inet$CMOSIPAddr>") == 0)
            {
                struct in_addr in;
                in.s_addr = CMOSIP;
                interface_addrtype[i] = if_FromCMOS;
                strcpy(interface_address[i], inet_ntoa(in));
            }
    	    else
    	        interface_addrtype[i] = if_Manual;
        }
        else if (strstr(buffer, "IfRConfig -e "))
    	{
    	    sscanf(buffer, "IfRConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1)
    	    	primary_interface = i;

            if (strstr(buffer, "revarp"))
            {
                interface_addrtype[i] = if_RevARP;
            }
            else if (strstr(buffer, "bootp"))
            {
                interface_addrtype[i] = if_BOOTP;
            }
            if (strstr(buffer, "netmask"))
            {
                strcpy(interface_netmask[i], "zzzz");
                done = TRUE;
            }
            else
                halfdone = TRUE;
        }
        else if (halfdone && strstr(buffer, "IfConfig -e"))
        {
            sscanf(strstr(buffer, "netmask"), "netmask %s", interface_netmask[i]);
            done = TRUE;
        }
    }
}

void DefaultAnInterface(void)
{
    int first_int = -1, first_pp = -1;
    int i;

    for (i = 0; i < interfaces; i++)
        if (first_int == -1 && !interface_is_pp[i])
            first_int = i;
        else if (first_pp == -1 && interface_is_pp[i])
            first_pp = i;

    /* Default the first non point-to-point interface, or failing that the
       first point-to-point interface
     */
    if (first_pp >= 0 && first_int == -1)
    	first_int = first_pp;

    if (first_int == -1)
    	return;

    primary_interface = first_int;

    strcpy(interface_netmask[first_int], "default");
    strcpy(interface_address[first_int], HostName);
    interface_addrtype[first_int] = if_FromHostname;
}
@


1.1.2.1
log
@Merged from 3.71 CD
@
text
@a0 404
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "os.h"
#include "toolbox.h"

#include "ModUtils.h"
#include "Main.h"
#include "Load.h"
#include "Versions.h"
#include "IfsDbox.h"
#include "Gadgets.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "arpa/inet.h"

char interface_location[16][32];
char interface_name[16][64];
char interface_unit[16][16];
char interface_module[16][32];
int interface_version[16];
char interface_filename[16][16];
char interface_address[16][64];
char interface_netmask[16][16];
char interface_linkaddr[16][16];
char interface_is_pp[16];
int primary_interface = -1;
int interfaces;
int v_MbufManager, v_AUNMsgs, v_Internet, v_BootNet,
    v_Net, v_NetI, v_Freeway, v_ShareFS, v_Resolver,
    v_Resolve, v_InetDB, v_DNSResolver;
bool StartupExists;

void ScanInetStartup(void);
void GetHostName(FILE *);
void GetInterface(FILE *, char *);
void GetResolvers(FILE *);
void GetRouting(FILE *);
static void DefaultAnInterface(void);

os_error *CheckConfig(void)
{
    FILE *f;
    char buffer[256];

    #define GetVer(mod) v_##mod = VersionToInt(msgs_lookup("v_" #mod))
    GetVer(MbufManager);
    GetVer(AUNMsgs);
    GetVer(Internet);
    GetVer(BootNet);
    GetVer(Net);
    GetVer(NetI);
    GetVer(Freeway);
    GetVer(ShareFS);
    GetVer(Resolver);
    GetVer(Resolve);
    GetVer(InetDB);
    GetVer(DNSResolver);

    if (RMFind("Resolver", "System:Modules.Network.Resolver", v_Resolver))
    	HaveResolver = TRUE;
    if (RMFind("Resolve", "System:Modules.Network.Resolve", v_Resolve))
    	HaveResolve = TRUE;
    if (RMFind("InetDB", "System:Modules.Network.InetDB", v_InetDB))
    	HaveInetDB = TRUE;
    if (RMFind("DNSResolver", "System:Modules.Network.DNSResolve", v_DNSResolver))
    	HaveDNSResolver = TRUE;

    HaveAResolver = HaveResolver || HaveResolve || HaveInetDB || HaveDNSResolver;

    InternetEnabled = FALSE;

    f=fopen("<Boot$ToBeLoaded>.SetUpNet", "r");

    if (f && fgets(buffer, sizeof buffer, f))
        if (strstr(buffer, "!Internet"))
            InternetEnabled = TRUE;

    fclose(f);

    if (getenv("Inet$Path"))
    	ScanInetStartup();

    if (!StartupExists)
    	DefaultAnInterface();

    if (!InternetEnabled)
    {
        AccessEnabled = RMLoaded("ShareFS") && RMLoaded("Freeway");
        AUNEnabled = RMLoaded("Net");
    }

    return FALSE;
}

void ScanInetStartup(void)
{
    FILE *f;
    char buffer[256];
    char buffer2[20];

    f=fopen(CONFIGDIR_READ "Startup", "r");
    if (!f)
    	return;

    StartupExists = TRUE;

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0]=='|' && buffer[1]=='\n')
            break;
    }
  nextsection:
    if (feof(f))
    {
        fclose(f);
        return;
    }

    fgets(buffer, sizeof buffer, f);
    fgets(buffer2, sizeof buffer2, f);
    if (strstr(buffer, "Host name"))
    	GetHostName(f);
    else if (strstr(buffer, "Interface: "))
    	GetInterface(f, strstr(buffer, "Interface: ")+sizeof "Interface: "-1);
    else if (strstr(buffer, "Name resolver"))
    	GetResolvers(f);
    else if (strstr(buffer, "Routing"))
    	GetRouting(f);
    else if (strstr(buffer, "AUN"))
    	AUNEnabled=TRUE;
    else if (strstr(buffer, "Access"))
    	AccessEnabled=TRUE;

    goto nextsection;
}

void GetHostName(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
            return;

        if (strstr(buffer, "Inet$HostName"))
            sscanf(buffer, "Set Inet$HostName %s", HostName);
        else if (strstr(buffer, "Inet$LocalDomain"))
            sscanf(buffer, "Set Inet$LocalDomain %s", LocalDomain);
    }
}

void GetResolvers(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (!HaveResolver)
            continue;

        if (strstr(buffer, "Inet$Resolvers"))
            sscanf(buffer, "Set Inet$Resolvers %s %s %s", Resolver[0], Resolver[1], Resolver[2]);
        else if (strstr(buffer, "RMEnsure Resolver"))
        {
            UseResolver=1;
            ResolverType=RT_Resolver;
        }
        else if (strstr(buffer, "RMEnsure Resolve"))
        {
            FILE *rf;
            UseResolver=1;
            ResolverType=RT_Resolve;
            rf=fopen("InetDBase:resolve", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1) continue;
                        if (sn<3) sscanf(buffer, "nameserver %s", Resolver[sn++]);
                    }
                }
                fclose(rf);
            }
        }
        else if (strstr(buffer, "RMEnsure InetDB"))
        {
            UseResolver=1;
            ResolverType=RT_InetDB;
            goto scanresconf;
        }
        else if (strstr(buffer, "RMEnsure DNSResolver"))
        {
            FILE *rf;
            UseResolver=1;
            ResolverType=RT_DNSResolver;
          scanresconf:
            rf=fopen("InetDBase:resconf", "r");
            if (rf)
            {
                int sn=0;

                while (fgets(buffer, sizeof buffer, rf))
                {
                    if (buffer[0] != ';') /* Speed optimization! */
                    {
                        if (sscanf(buffer, "domain %s", LocalDomain) == 1)
                        {
                            if (LocalDomain[strlen(LocalDomain)-1]=='.')
                                LocalDomain[strlen(LocalDomain)-1]='\0';
                            continue;
                        }
                        if (sn<3)
                        {
                            if (sscanf(buffer, "nameserver %s", Resolver[sn]) == 1)
                                sn++;
                        }
                    }
                }
                fclose(rf);
            }
        }
    }
}

void GetRouting(FILE *f)
{
    char buffer[256];

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (strstr(buffer, "Route -e add default"))
            sscanf(buffer, "Route -e add default %s", Gateway);

        else if (strstr(buffer, "Set Inet$IsGateway Yes"))
            AmRouter = TRUE;

        else if (strstr(buffer, "Set Inet$RouteDOptions"))
        {
            sscanf(buffer, "Set Inet$RouteDOptions %s", RouteDoptions);
            if (strcmp(RouteDoptions, "\"\"") == 0)
                strcpy(RouteDoptions, "DEFAULT");
            else
                UseRouteD = TRUE;
        }
    }
}

void GetInterface(FILE *f, char *s)
{
    char buffer[256];
    char unit[16];
    char *p;
    bool done = FALSE;
    bool halfdone = FALSE;
    int i = -1;

    /* Find which interface we're talking about */
    if ((p = strchr(s, '\n')) != 0)
    	*p = '\0';

    while (fgets(buffer, sizeof buffer, f))
    {
        if (buffer[0] == '|')
        	return;

        if (done)
            continue;

    	if (!halfdone && strstr(buffer, "IfConfig -e "))
    	{
    	    sscanf(buffer, "IfConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1 && strcmp(interface_unit[i], "ec0"))
    	    	primary_interface = i;

            if (!interface_is_pp[i])
    	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s netmask %s", interface_address[i], interface_netmask[i]);
    	    else
     	        sscanf(buffer + sizeof "IfConfig -e " - 1 + strlen(unit),
    	               "%s %s netmask %s", interface_address[i], interface_linkaddr[i],
    	                                   interface_netmask[i]);

    	    done = TRUE;

    	    if (strcmp(interface_address[i], HostName) == 0)
    	        interface_addrtype[i] = if_FromHostname;
            else if (strcmp(interface_address[i], "<Inet$CMOSIPAddr>") == 0)
            {
                struct in_addr in;
                in.s_addr = CMOSIP;
                interface_addrtype[i] = if_FromCMOS;
                strcpy(interface_address[i], inet_ntoa(in));
            }
    	    else
    	        interface_addrtype[i] = if_Manual;
        }
        else if (strstr(buffer, "IfRConfig -e "))
    	{
    	    sscanf(buffer, "IfRConfig -e %s", unit);
    	    for (i = 0; i < interfaces; i++)
    	    {
            	if (strcmp(interface_name[i], s) == 0 &&
            	    strcmp(interface_unit[i], unit) == 0)
            	    break;
            }
            if (i == interfaces)
            {
                done = TRUE;
                continue;
            }

    	    if (primary_interface == -1)
    	    	primary_interface = i;

            if (strstr(buffer, "revarp"))
            {
                interface_addrtype[i] = if_RevARP;
            }
            else if (strstr(buffer, "bootp"))
            {
                interface_addrtype[i] = if_BOOTP;
            }
            if (strstr(buffer, "netmask"))
            {
                strcpy(interface_netmask[i], "zzzz");
                done = TRUE;
            }
            else
                halfdone = TRUE;
        }
        else if (halfdone && strstr(buffer, "IfConfig -e"))
        {
            sscanf(strstr(buffer, "netmask"), "netmask %s", interface_netmask[i]);
            done = TRUE;
        }
    }
}

void DefaultAnInterface(void)
{
    int first_int = -1, first_pp = -1;
    int i;

    for (i = 0; i < interfaces; i++)
        if (first_int == -1 && !interface_is_pp[i])
            first_int = i;
        else if (first_pp == -1 && interface_is_pp[i])
            first_pp = i;

    /* Default the first non point-to-point interface, or failing that the
       first point-to-point interface
     */
    if (first_pp >= 0 && first_int == -1)
    	first_int = first_pp;

    if (first_int == -1)
    	return;

    primary_interface = first_int;

    strcpy(interface_netmask[first_int], "default");
    strcpy(interface_address[first_int], HostName);
    interface_addrtype[first_int] = if_FromHostname;
}
@

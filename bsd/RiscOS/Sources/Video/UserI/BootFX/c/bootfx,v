head	1.9;
access;
symbols
	BootFX-0_09:1.9
	BootFX-0_08:1.9
	BootFX-0_07:1.8
	BootFX-0_06:1.7
	BootFX-0_05:1.6
	BootFX-0_04:1.5
	BootFX-0_03:1.3
	BootFX-0_02:1.2
	BootFX-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2017.04.01.08.59.21;	author rool;	state Exp;
branches;
next	1.8;
commitid	KY009rEwUdDvhOLz;

1.8
date	2016.11.26.13.00.31;	author jlee;	state Exp;
branches;
next	1.7;
commitid	KHBAbvUs5CImFDvz;

1.7
date	2012.10.10.13.44.30;	author srevill;	state Exp;
branches;
next	1.6;
commitid	LNIA6imr7MYHnQnw;

1.6
date	2012.10.08.23.14.39;	author jlee;	state Exp;
branches;
next	1.5;
commitid	IMaQTLLu6hLlBDnw;

1.5
date	2012.10.08.00.35.12;	author srevill;	state Exp;
branches;
next	1.4;
commitid	vpDsoJwDY6eR4wnw;

1.4
date	2012.10.08.00.27.09;	author srevill;	state Exp;
branches;
next	1.3;
commitid	TNvgXLWitrR92wnw;

1.3
date	2012.09.13.00.16.41;	author srevill;	state Exp;
branches;
next	1.2;
commitid	2aCfQBJR03DrMikw;

1.2
date	2012.09.03.21.42.45;	author srevill;	state Exp;
branches;
next	1.1;
commitid	COfeqXcXbmrzd8jw;

1.1
date	2012.09.02.21.35.10;	author srevill;	state Exp;
branches
	1.1.1.1;
next	;
commitid	hu1BGsyNhEtVc0jw;

1.1.1.1
date	2012.09.02.21.35.10;	author srevill;	state Exp;
branches;
next	;
commitid	hu1BGsyNhEtVc0jw;


desc
@@


1.9
log
@Update Pi splash screen graphic
Detail:
  Revise trademark statement.
  Simplify makefile given more recent CModule INSTRES_FILES capability.
  Rename source Bar24 sprite to avoid relying on the search path order of InstRes.
Admin:
  Thanks to Richard Hallas for providing the new image.

Version 0.08. Tagged as 'BootFX-0_08'
@
text
@/* @@file BootFX.c
 *
 * This module provides features to enhance the existing boot sequence. It should
 * ideally be built into ROM and used in co-operation with a newer version of
 * BootCommands and ScreenFX in order to provide all of its functionality.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "Global/RISCOS.h"
#include "Global/NewErrors.h"
#include "Global/Services.h"
#include "Global/Sprite.h"
#include "Global/CMOS.h"
#include "Global/OSMem.h"
#include "Interface/HighFSI.h"
#include "swis.h"
#include "BootFXHdr.h"
#include "bootfx.h"

/** A quick macro to silence compiler warnings about unused parameters. */
#define IGNORE(x) do { (void)(x); } while(0)

/** Trap and return non-NULL RISC OS error block pointers. */
#define ERR(cmd) do { _kernel_oserror *err = cmd; if (err) return err; } while(0)

/** Trap an error and jump to an appropriate label to handle it. */
#define ERR_GOTO(cmd) do { err = cmd; if (err) goto error; } while(0)

/** Free a buffer (if non-NULL). */
#define FREE(ptr) do { if (ptr) { free(ptr); ptr = NULL; } } while (0)

/** Size (bytes) of our CLI buffer. */
#define CLI_BUF_SZ (512)

/** ID word at start of an Acorn Squash file. */
#define SQUASH_HEADER (0x48535153)

/** Filetype for an Acorn Squash file. */
#define TYPE_SQUASH (0xFCA)

/** Filetype for an Acorn Sprite file. */
#define TYPE_SPRITE (0xFF9)

/** Dynamic area name string for unsquashing sprite files. */
#define DA_NAME "BootFX sprites"

/** The root of ResourceFS */
#define RESFS_STR "Resources:$"

/** The location of our resource directory in ResourceFS. */
#define RESFS_PATH RESFS_STR ".Resources.BootFX."

/** Location of our logo JPEG. */
#define LOGO_JPEG_FILE RESFS_PATH "Logo"

/** Time to fade out before plotting splash screen (centiseconds). */
#define FADE_OUT_CS (10)

/** Time to fade in after plotting splash screen (centiseconds). */
#define FADE_IN_CS (200)

/** Flag bit for SWI BootFX_BarUpdate. */
#define FLAG_BarUpdate_NoWait (1)

/** These functions are autogenerated by ResGen, and return a pointer to a ResourceFS resource file data block. */
extern void *Resources(void);

/* Various potentially useful structures */
typedef struct sprite_area_s sprite_area_t;
typedef struct sprite_s sprite_t;
typedef struct mode_s mode_t;
typedef struct gclip_s __packed gclip_t;
typedef struct tclip_s __packed tclip_t;
typedef struct trans_s trans_t;
typedef struct squash_s squash_t;
typedef struct barinfo_s barinfo_t;
typedef struct infochain_s infochain_t;
typedef struct layout_s layout_t;

/** An OS sprite area structure.
 */
struct sprite_area_s
{
  uint32_t size;           /**< Area size (bytes). */
  uint32_t num_spr;        /**< Number of sprites in the area. */
  uint32_t sprite;         /**< Offset to first sprite. */
  uint32_t free;           /**< Offset to first free byte. */
};

/** An OS sprite control block structure.
 */
struct sprite_s
{
  uint32_t next;           /**< Offset to next sprite (bytes). */
  char     name[12];       /**< Sprite name string. */
  uint32_t width;          /**< Width (words) - 1. */
  uint32_t height;         /**< Height (scanlines) - 1. */
  uint32_t first_bit;      /**< First bit used (left). */
  uint32_t last_bit;       /**< Last bit used (right). */
  uint32_t image;          /**< Offset to sprite image (bytes). */
  uint32_t mask;           /**< Offset to sprite mask (bytes). */
  uint32_t type;           /**< Sprite type word. */
};

/** A structure to hold information about the current screen mode.
 */
struct mode_s
{
  int32_t   screen_x;      /**< Width of the current screen mode (OS units). */
  int32_t   screen_y;      /**< Height of the current screen mode (OS units). */
  uint32_t  bpp;           /**< Number of bits per pixel. */
  uint32_t  xeig;          /**< X eigen value. */
  uint32_t  yeig;          /**< Y eigen value. */
};

/** A structure to hold graphics clipping window information.
 */
struct gclip_s
{
  uint8_t vdu;             /**< VDU code (24). */
  int16_t xmin;            /**< Left edge (OS units, inclusive). */
  int16_t ymin;            /**< Bottom edge (OS units, inclusive). */
  int16_t xmax;            /**< Right edge (OS units, inclusive). */
  int16_t ymax;            /**< Top edge (OS units, inclusive). */
};

/** A structure to hold text window information.
 */
struct tclip_s
{
  uint8_t vdu;             /**< VDU code (28). */
  uint8_t xmin;            /**< Left edge (chracters, inclusive). */
  uint8_t ymin;            /**< Bottom edge (characters, inclusive). */
  uint8_t xmax;            /**< Right edge (characters, inclusive). */
  uint8_t ymax;            /**< Top edge (characters, inclusive). */
};

/** JPEG transformatio matrix for plotting scaled.
 */
struct trans_s
{
  int32_t mx;              /**< Horizontal multiplier. */
  int32_t my;              /**< Vertical multiplier. */
  int32_t dx;              /**< Horizontal divider. */
  int32_t dy;              /**< Vertical divider. */
};

/** Structure of a squash file header.
 */
struct squash_s
{
  uint32_t id;             /**< ID word "SQSH". */
  uint32_t size;           /**< Uncompressed size (bytes). */
  uint32_t load;           /**< Load address. */
  uint32_t exec;           /**< Exec address. */
  uint32_t attr;           /**< Attributes. */
};

/** Block of progress bar information.
 */
struct barinfo_s
{
  int32_t        x;                /**< Origin co-ordinates for progress bar (OS units). */
  int32_t        y;                /**< Origin co-ordinates for progress bar (OS units). */
  uint32_t       val;              /**< Percentage value for progress bar. */
  uint32_t       width;            /**< Width of the progress bar (OS units). */
  uint32_t       height;           /**< Height of the progress bar (OS units). */
  uint32_t       danum;            /**< Dynamic area number for the sprite area (if we unsquashed into a DA). */
  bool           resfs;            /**< Set to true when spr_area is pointing to a sprite area in ResourceFS. */
  sprite_area_t *spr_area;         /**< Progress bar sprite area pointer. */
  sprite_t      *border_spr;       /**< Progress bar 'border' sprite pointer. */
  sprite_t      *fill_spr;         /**< Progress bar 'fill' sprite pointer. */
  sprite_t      *bar_spr;          /**< Progress bar 'bar' sprite pointer. */
  uint32_t       user_scale[4];    /**< User-supplied scale factor block. */
  uint32_t       scale_matrix[4];  /**< Scale factor block (for current mode). */
  uint32_t       pixel_trans[4];   /**< Pixel translation table (for current mode). */
};

/** A node in the doubly-linked list of barinfo structures.
 */
struct infochain_s
{
  barinfo_t    info;
  infochain_t *prev;
  infochain_t *next;
};

/** Layout parameters
 */
struct layout_s
{
  uint16_t dimensions[2];      /**< Dimensions of layout (OS units) */
  uint16_t splash_x, splash_y; /**< Bottom-left corner of splash (OS units) */
  uint16_t splash_scale[2];    /**< Scale factor for splash */
  uint16_t bar_x, bar_y;       /**< Bottom-left corner of bar (OS units) */
  uint16_t bar_scale[2];       /**< Scale factor for bar */
  tclip_t  text_window;        /**< Text window to use (assuming 16x16 OS unit font) */
  uint8_t  min_row, min_col;   /**< Minimum text window size to consider acceptable */
  const char * splash_file;    /**< Path to splash file */
  const char * bar_file;       /**< Path to bar file */ 
};

/** The text window that we set up after the first mode change depends upon the UserIF at build time.
 */
#if (defined UserIF_Raspberry)
static const layout_t layouts[] =
{
  {
    .dimensions = {3840, 2160},
    .splash_x = 0,
    .splash_y = 0,
    .splash_scale = {1, 1},
    .bar_x = 1280,
    .bar_y = 786,
    .bar_scale = {1, 1},
    .text_window = {28, 80, 125, 159, 94},
    .min_row = 10,
    .min_col = 30,
    .splash_file = RESFS_PATH "1920x1080",
    .bar_file = RESFS_PATH "Bar24",
  },
  {
    .dimensions = {3840, 2880},
    .splash_x = 0,
    .splash_y = 1152,
    .splash_scale = {1, 1},
    .bar_x = 640,
    .bar_y = 1720,
    .bar_scale = {2, 1},
    .text_window = {28, 0, 179, 239, 108},
    .min_row = 10,
    .min_col = 30,
    .splash_file = RESFS_PATH "1920x1080",
    .bar_file = RESFS_PATH "Bar24",
  },
};
#else
static const layout_t layouts[] = {};
#endif

static _kernel_oserror *swi_bar_display(const uint32_t flags, barinfo_t * const barinfo, const int32_t x, const int32_t y);
static _kernel_oserror *swi_bar_load(const uint32_t flags, const char * const file, const uint32_t * const user_scale, barinfo_t **handle);

static mode_t         mode_info;               /**< Current screen mode information. */
static barinfo_t     *bootbar        = NULL;   /**< Default progress bar (during the boot sequence). */
static char          *msg_desc       = NULL;   /**< Messages file decriptor. */
static char          *cli_buf        = NULL;   /**< Buffer for CLI commands. */
static void          *logo_jpeg      = NULL;   /**< Pointer to the logo image JPEG data (NULL if none). */
static size_t         logo_size      = 0;      /**< Size (bytes) of the logo image JPEG data. */
static void          *splash_jpeg    = NULL;   /**< Pointer to the splash screen JPEG data (NULL if none). */
static size_t         splash_size    = 0;      /**< Size (bytes) of the splash screen JPEG data. */
static bool           splash_disable = false;  /**< BootFX has disabled its splash screen (and mode change) behaviour */
static void          *Workspace      = NULL;   /**< Module workspace pointer. */
static infochain_t   *infochain      = NULL;   /**< List of all allocated progress bar info blocks. */
static layout_t       layout;                  /**< Layout to use */


/********************************************************************************
 *
 * GENERAL STATIC FUNCTIONS
 *
 ********************************************************************************/


/** Perform a look-up of the specified token in our internationalised Messages file.
 *
 *  @@param token Pointer to zero-terminated message token to look-up.
 *
 *  @@return Pointer to buffer containing the look-up result (or an error message if the look-up failed).
 *
 *  Note: the string returned will only persist until the next call to this function,
 *  at which point the buffer contents are overwritten.
 */
static const char * const msg(const char * const token)
{
  static char buf[252];
  _kernel_oserror *err;
  uint32_t         length;

  err = _swix(MessageTrans_Lookup, _INR(0,7) | _OUT(3), msg_desc, token, buf, sizeof(buf), 0, 0, 0, 0, &length);
  if (err)
    return &(err->errmess[0]);

  buf[length] = '\0';

  return buf;
}


/** Perform a look-up of an internationalised error message and return the corresponding RISC OS error block.
 *
 *  @@param offset Handle of the error token to look-up.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 *
 *  Note: the error block returned will only persist until the next call to this
 *  function, at which point the buffer contents are overwritten.
 */
static _kernel_oserror *eblk(const uint8_t offset)
{
  static _kernel_oserror blk;
  char                   token[12];

  snprintf(token, sizeof(token), "E%02X", offset);

  blk.errnum = ErrorBase_BootFX + offset;
  strcpy(blk.errmess, msg(token));

  return &blk;
}


/** Attempt to allocate some memory and return an appropriate error block pointer if we fail.
 *
 *  @@param ptr  Pointer to the buffer pointer (updated by this function).
 *  @@param size Number of bytes to allocate (must be non-zero).
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *my_malloc(void **ptr, const size_t size)
{
  *ptr = size ? malloc(size) : NULL;

  return *ptr ? NULL : eblk(BOOTFX_ERR_MALLOC_FAIL);
}


/** Read information about the specified file.
 *
 *  @@param fname Pointer to zero-terminated filename string.
 *  @@param obj   Pointer to variable used to return the object type.
 *  @@param size  Pointer to variable used to return the object size (bytes).
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *file_info(const char * const fname, uint32_t *obj, size_t *size, uint32_t *type)
{
  /* Check the file exists and is non-zero size */
  ERR(_swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(2) | _OUT(4), OSFile_ReadNoPath, fname, obj, type, size));

  *type = (*type << 12) >> 20;
  return NULL;
}


/** Return a pointer and size for a file in ResourceFS (to save pointless loading into RAM).
 *
 *  @@param fname Filename for the file to load (zero-terminated).
 *  @@param jpg   Returned as a pointer to the file contents (NULL if failed).
 *  @@param size  Returned as the size of the file contents (bytes).
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *resfs_file_to_ptr_and_size(const char * const fname, void **ptr, size_t *size)
{
  uint32_t handle;
  uint32_t *addr;

  /* If anything goes wrong, ptr and size should be returned as NULL and 0 respectively */
  *ptr  = NULL;
  *size = 0;

  /* Hack - but the Wimp does it so it must be OK */
  ERR(_swix(OS_Find, _INR(0,1) | _OUT(0), OSFind_OpenIn, fname, &handle));
  ERR(_swix(OS_FSControl, _INR(0,1) | _OUT(1), FSControl_ReadFSHandle, handle, &addr));
  ERR(_swix(OS_Find, _INR(0,1), OSFind_Close, handle));

  /* Now we have a pointer direct to the file contents in ResourceFS... */
  *ptr = addr;

  /* ...and the size of the file in bytes */
  *size = addr[-1] - 4;

  return NULL;
}


/** Check to see if an object is not in ResourceFS.
 *
 *  @@param obj File or directory name (zero-terminated).
 *
 *  @@return Non-zero if not in ResourceFS, else return zero (in ResourceFS).
 */
static int32_t not_in_resourcefs(const char * const obj)
{
  _kernel_oserror *err;
  char            *buf = NULL;
  int32_t          ans;
  size_t           size;

  /* Canonicalise the object passed into this function */
  err = _swix(OS_FSControl, _INR(0,5) | _OUT(5), 37, obj, 0, 0, 0, 0, &size);
  if (err)
  {
    size = sizeof(RESFS_STR);
  }
  else
  {
    size = -size + 1;
  }

  /* Allocate a buffer to canonicalise (or copy) into */
  ERR_GOTO(my_malloc((void **)&buf, size));

  /* If this fails, we just copy the first part of the input string */
  err = _swix(OS_FSControl, _INR(0,5), 37, obj, buf, 0, 0, size);
  if (err)
  {
    (void) snprintf(buf, sizeof(RESFS_STR), "%s", obj);
  }
  else
  {
    /* Terminate to the same length as the string we're comparing against */
    if (size >= sizeof(RESFS_STR))
    {
      buf[sizeof(RESFS_STR) - 1] = '\0';
    }
  }

  /* Case-insensitive string compare */
  ERR_GOTO(_swix(Territory_Collate, _INR(0,3) | _OUT(0), -1, buf, RESFS_STR, 1, &ans));

  FREE(buf);

  return ans;

error:
  FREE(buf);
  return -1;
}


/** Load a squashed sprites file into memory and then decompress it.
 *
 *  @@param arg_string Pointer to argument string.
 *  @@param size       Size (bytes) of the file to load.
 *  @@param area       Returned: pointer to the sprite area pointer to return from this function.
 *  @@param danum      Returned: dynamic area number.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *load_squashed_sprites(const char *arg_string, const size_t size, sprite_area_t **area, uint32_t *danum)
{
  _kernel_oserror *err = NULL;
  char            *buf = NULL;
  uint32_t        *out = NULL;
  void            *wsp = NULL;
  squash_t        *hdr;
  uint32_t         out_sz;
  uint32_t         wsp_sz;
  uint32_t         status;

  *area  = NULL;
  *danum = 0;

  /* Allocate a buffer to load the squashed file into */
  ERR(my_malloc((void **)&buf, size));

  /* Load the file into our buffer */
  ERR_GOTO(_swix(OS_File, _INR(0,3), OSFile_LoadNoPath, arg_string, buf, 0));

  /* Check the squash file header looks sensible */
  hdr = (squash_t *)buf;
  if (
       (hdr->id != SQUASH_HEADER)
       ||
       (hdr->size < 16)
       ||
       (TYPE_SPRITE != ((hdr->load << 12) >> 20))
     )
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Allocate a buffer to unsquash the sprites into */
  out_sz = 64 + hdr->size;
  ERR(_swix(OS_DynamicArea, _INR(0,8) | _OUT(1) | _OUT(3), DAReason_Create, -1, out_sz, -1, 1<<7, out_sz, NULL, NULL, DA_NAME, danum, &out));

  /* Check how much workspace the decompress SWI needs */
  ERR_GOTO(_swix(Squash_Decompress, _INR(0,1) | _OUT(0), 1<<3, -1, &wsp_sz));

  /* Allocate some workspace */
  ERR_GOTO(my_malloc(&wsp, wsp_sz));

  /* Decompress the sprites into the output buffer */
  ERR_GOTO(_swix(Squash_Decompress, _INR(0,5) | _OUT(0), 1<<2, wsp, buf + sizeof(squash_t), size - sizeof(squash_t), out + 1, out_sz - sizeof(uint32_t), &status));

  /* Barf if the decompression failed */
  if (status)
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Free the input buffer and the workspace */
  FREE(buf);
  FREE(wsp);

  /* The first word of the output buffer is the sprite area size */
  *out  = out_sz;
  *area = (sprite_area_t *)out;

  return NULL;

error:
  FREE(wsp);
  FREE(buf);
  if (*danum)
  {
    (void) _swix(OS_DynamicArea, _INR(0,1), DAReason_Remove, *danum);
    *danum = 0;
  }
  return err;
}


/** Plot a JPEG at its mormal size, centred on screen.
 *
 *  @@param jpeg Pointer to the loaded JPEG data (NULL if failed).
 *  @@param size Size (bytes) of the JPEG data.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *plot_centred_jpeg(const void * const jpeg, const size_t size)
{
  int32_t j_width, j_height, j_xdpi, j_ydpi;
  int32_t x, y;
  trans_t trans;

  ERR(_swix(JPEG_Info, _INR(0,2) | _OUTR(2,5), 1, jpeg, size, &j_width, &j_height, &j_xdpi, &j_ydpi));

  trans.mx = 180 / (1 << mode_info.xeig);
  trans.my = 180 / (1 << mode_info.yeig);
  trans.dx = j_xdpi;
  trans.dy = j_ydpi;

  /* Convert screen dimensions from OS units to pixels */
  x          = mode_info.screen_x >> mode_info.xeig;
  y          = mode_info.screen_y >> mode_info.yeig;

  /* Convert JPEG pixel dimensions to the same DPI as the screen */
  j_width    = (j_width  * trans.mx) / trans.dx;
  j_height   = (j_height * trans.my) / trans.dy;

  /* Calculate the origin for a centred plot */
  x          = (x - j_width) >> 1;
  y          = (y - j_height) >> 1;

  /* Convert back up to OS units */
  x        <<= mode_info.xeig;
  y        <<= mode_info.yeig;

  return _swix(JPEG_PlotScaled, _INR(0,5), jpeg, x, y, &trans, size, 3);
}


/** Plot a JPEG, scaled and positioned for use as the splash image.
 *
 *  @@param jpeg Pointer to the loaded JPEG data (NULL if failed).
 *  @@param size Size (bytes) of the JPEG data.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *plot_splash_jpeg(const void * const jpeg, const size_t size)
{
  trans_t trans;

  trans.mx = layout.splash_scale[0];
  trans.my = layout.splash_scale[0];
  trans.dx = layout.splash_scale[1];
  trans.dy = layout.splash_scale[1];

  return _swix(JPEG_PlotScaled, _INR(0,5), jpeg, layout.splash_x, layout.splash_y, &trans, size, 3);
}


/** Create a new bar information structure (by adding a new node into the info chain).
 *
 *  @@param handle Returned: pointer to the bar info structure.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 *
 *  Side-effect: infochain updated to point at the new (head) node.
 */
static _kernel_oserror *new_barinfo(barinfo_t **handle)
{
  infochain_t *node = NULL;

  *handle = NULL;

  /* Claim a new node on the info chain */
  ERR(my_malloc((void **)&node, sizeof(infochain_t)));

  /* Initialise the node and link into the chain */
  if (NULL != infochain)
    infochain->prev = node;
  node->prev = NULL;
  node->next = infochain;
  infochain  = node;

  /* Initialise the barinfo part of the node */
  node->info.x          = 0;
  node->info.y          = 0;
  node->info.val        = 0;
  node->info.width      = 0;
  node->info.height     = 0;
  node->info.danum      = 0;
  node->info.resfs      = false;
  node->info.spr_area   = NULL;
  node->info.border_spr = NULL;
  node->info.fill_spr   = NULL;
  node->info.bar_spr    = NULL;

  /* Return a pointer to the barinfo structure */
  *handle = &node->info;

  return NULL;
}


/** Update the scale factors and pixel translation table for the specified progress bar.
 *
 *  @@param barinfo Pointer to the bar info structure.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *udpate_barinfo_for_mode(barinfo_t *barinfo)
{
  if (NULL != barinfo)
  {
    ERR(_swix(Wimp_ReadPixTrans, _INR(0,2) | _INR(6,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->scale_matrix, barinfo->pixel_trans));
    barinfo->scale_matrix[0] *= barinfo->user_scale[0];
    barinfo->scale_matrix[1] *= barinfo->user_scale[1];
    barinfo->scale_matrix[2] *= barinfo->user_scale[2];
    barinfo->scale_matrix[3] *= barinfo->user_scale[3];
  }
  return NULL;
}


/** Update scale factors and pixel translation tables for all active progress bars.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *update_infochain_for_mode(void)
{
  infochain_t *node = infochain;

  while (node)
  {
    ERR(udpate_barinfo_for_mode((barinfo_t *)node));
    node = node->next;
  }
  return NULL;
}


/** Remove an info chain node and release any memory associated with it.
 *
 *  @@param node Pointer to the info chain node to be removed.
 *
 *  Side-effect: infochain will be updated if it was the head node that was removed.
 */
static void remove_info_node(infochain_t *node)
{
  infochain_t *prev = node->prev;
  infochain_t *next = node->next;

  /* Delink */
  if (NULL != prev)
  {
    prev->next = next;
  }
  else
  {
    infochain = next;
  }
  if (NULL != next)
  {
    next->prev = prev;
  }

  /* Free */
  FREE(node);
}


/** Release all memory associated with the info chain.
 *
 *  Side-effect: infochain and bootbar are both set to NULL.
 */
static void release_infochain(void)
{
  while (NULL != infochain)
  {
    infochain_t *node = infochain->next;

    FREE(infochain);
    infochain = node;
  }
  bootbar = NULL;
}


/** Free and reset everything relating to the loaded progress bar sprites.
 *
 *  @@param barinfo Pointer to the bar info structure.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *free_sprites(barinfo_t *barinfo)
{
  _kernel_oserror *err = NULL;

  if (NULL != barinfo)
  {
    if (!barinfo->resfs)
    {
      if (barinfo->danum)
      {
        err               = _swix(OS_DynamicArea, _INR(0,1), DAReason_Remove, barinfo->danum);
        barinfo->danum    = 0;
        barinfo->spr_area = NULL;
      }
      else
      {
        FREE(barinfo->spr_area);
      }
    }

    /* Reset lots of stuff to defaults */
    barinfo->resfs      = false;

    barinfo->spr_area   = NULL;

    barinfo->border_spr = NULL;
    barinfo->fill_spr   = NULL;
    barinfo->bar_spr    = NULL;

    barinfo->width      = 0;
    barinfo->height     = 0;
    barinfo->val        = 0;
    barinfo->x          = 0;
    barinfo->y          = 0;

    /* Delink and remove this node from the info chain */
    remove_info_node((infochain_t *)barinfo);
  }
  return err;
}


/** Update some stored information about the current screen mode.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *read_mode_info(void)
{
  static const int32_t vdu_vars[] = { 11, 12, 4, 5, 9, -1 };
  static int32_t vdu_vals[sizeof vdu_vars];

  /* Read some mode variables */
  ERR(_swix(OS_ReadVduVariables, _INR(0,1), &vdu_vars, &vdu_vals));

  /* Record interesting information about the current screen mode */
  mode_info.xeig     = vdu_vals[2];
  mode_info.yeig     = vdu_vals[3];
  mode_info.screen_x = (1 + vdu_vals[0]) << mode_info.xeig;
  mode_info.screen_y = (1 + vdu_vals[1]) << mode_info.yeig;
  mode_info.bpp      = vdu_vals[4];

  return NULL;
}


/** Calculate the layout parameters for the current mode, based around the given template
 *
 *  @@param template Pointer to layout parameters to use as a template.
 *
 *  @@return Calculated layout parameters for the current mode.
 */
static layout_t calculate_layout(const layout_t * const template)
{
  layout_t ret = *template;
  ret.dimensions[0] = mode_info.screen_x;
  ret.dimensions[1] = mode_info.screen_y;
  uint16_t scale[2];
  uint16_t offset[2];
  /* Scale the reference layout, while maintaining aspect ratio */
  if (template->dimensions[0] * ret.dimensions[1] > template->dimensions[1] * ret.dimensions[0])
  {
    /* Screen aspect is taller, scale to fit width */
    scale[0] = ret.dimensions[0];
    scale[1] = template->dimensions[0];
    offset[0] = 0;
    offset[1] = (ret.dimensions[1]-((template->dimensions[1]*scale[0])/scale[1]))/2;
  }
  else
  {
    /* Screen aspect is wider, scale to fit height */
    scale[0] = ret.dimensions[1];
    scale[1] = template->dimensions[1];
    offset[0] = (ret.dimensions[0]-((template->dimensions[0]*scale[0])/scale[1]))/2;
    offset[1] = 0;
  }
  /* Adjust parameters */
  ret.splash_x = ((template->splash_x*scale[0])/scale[1])+offset[0];
  ret.splash_y = ((template->splash_y*scale[0])/scale[1])+offset[1];
  ret.splash_scale[0] *= scale[0];
  ret.splash_scale[1] *= scale[1];
  ret.bar_x = ((template->bar_x*scale[0])/scale[1])+offset[0];
  ret.bar_y = ((template->bar_y*scale[0])/scale[1])+offset[1];
  ret.bar_scale[0] *= scale[0];
  ret.bar_scale[1] *= scale[1];
  ret.text_window.xmin = ((template->text_window.xmin*scale[0])/scale[1])+(offset[0]>>4);
  uint32_t ymin = ((template->text_window.ymin*scale[0])/scale[1])+(offset[1]>>4);
  uint32_t xmax = ((template->text_window.xmax*scale[0])/scale[1])+(offset[0]>>4);
  ret.text_window.ymax = ((template->text_window.ymax*scale[0])/scale[1])+(offset[1]>>4);
  /* Currently the only way of setting the text window coordinates is via VDU 28, which uses bytes for the coordinate values. This causes problems for large modes (dimensions > 2048)
     Detect out-of-range values and set a zero-size window, this will cause us to fail the size check in pick_layout */
  if ((ymin > 255) || (xmax > 255))
  {
    ret.text_window.ymin = ret.text_window.ymax;
    ret.text_window.xmax = ret.text_window.xmin;
  }
  else
  {
    ret.text_window.ymin = ymin;
    ret.text_window.xmax = xmax;
  }
  return ret;
}

/** Return true if we are not in the desktop.
 *
 *  @@return As above. Also, if anything goes wrong, return false.
 */
static bool not_in_desktop(void)
{
  _kernel_oserror *err;
  uint32_t         state;

  err = _swix(Wimp_ReadSysInfo, _IN(0) | _OUT(0), 3, &state);
  return (err || state == 1) ? false : true;
}


/** Return true if the configured language is the "Desktop" module.
 *
 *  @@return as above. Also, if anything goes wrong, return false.
 */
static bool conf_lang_is_desktop(void)
{
  uint32_t desk_num;
  uint32_t lang_num;

  /* Look up the module number of the "Desktop" module - indexed from module 0 (Kernel) */
  if (_swix(OS_Module, _INR(0,1) | _OUT(1), ModHandReason_LookupName, "Desktop", &desk_num))
  {
    return false;
  }

  /* Read the configured 'language' (a module number, helpfully indexed from 1 - doh!) */
  if (_swix(OS_Byte, _INR(0,1) | _OUT(2), ReadCMOS, LanguageCMOS, &lang_num))
  {
    return false;
  }
  return desk_num == lang_num - 1;
}


/** Create a text window of the desired size.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *set_text_window(void)
{
  /* Set the text window */
  ERR(_swix(OS_WriteN, _INR(0,1), &layout.text_window, sizeof(layout.text_window)));

  /* Clear the text window to the text background colour */
  ERR(_swix(OS_WriteI+12, 0));

  return NULL;
}

/** Pick a layout to use for the current mode.
 *
 *  @@return True if a suitable layout was selected
 */
static bool pick_layout(void)
{
  /* Forget any current splash */
  splash_jpeg = NULL;
  splash_size = 0;

  /* Pick the layout that has the closest aspect ratio to the current mode and which passes our criteria */
  uint32_t mode_aspect = (mode_info.screen_x<<16)/mode_info.screen_y;
  int32_t best_diff = INT32_MAX;

  for (int i=0;i < sizeof(layouts)/sizeof(layouts[0]); i++)
  {
    /* Check aspect ratio */
    uint32_t candidate_aspect = (layouts[i].dimensions[0]<<16)/layouts[i].dimensions[1];
    int32_t diff = candidate_aspect - mode_aspect;
    if (diff < 0)
    {
      diff = -diff;
    }
    if (diff >= best_diff)
    {
      continue;
    }

    layout_t candidate = calculate_layout(&layouts[i]);

    /* Check layout criteria */
    if ((candidate.text_window.xmax+1-candidate.text_window.xmin < candidate.min_col)
     || (candidate.text_window.ymin+1-candidate.text_window.ymax < candidate.min_row))
    {
      continue;
    }

    layout = candidate;
    best_diff = diff;
  }

  if (best_diff != INT32_MAX)
  {
    /* Try and load the relevant files */
    free_sprites(bootbar);
    bootbar = NULL;
    uint32_t scale[4];
    scale[0] = scale[1] = layout.bar_scale[0];
    scale[2] = scale[3] = layout.bar_scale[1];
    if (swi_bar_load(1, layout.bar_file, scale, &bootbar) != NULL)
    {
      goto fail;
    }

    if (resfs_file_to_ptr_and_size(layout.splash_file, &splash_jpeg, &splash_size) != NULL)
    {
      goto fail;
    }
    
    return true;
  }

fail:
  /* Set some default scale factors for safety */
  layout = (layout_t) {
    .splash_scale = {1, 1},
    .bar_scale = {1, 1},
  };

  return false;
}


/** Do all sorts of stuff on a mode change.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 *
 *  Note: we ignore errors from the ScreenFX module in case it simply isn't present.
 */
static _kernel_oserror *mode_has_changed(void)
{
  _kernel_oserror *err;
  bool             predesk = not_in_desktop();

  /* Re-cache our mode information when there's a mode change */
  ERR(read_mode_info());

  /* Update the scale factors and pixel translation tables for all loaded progress bars  */
  ERR(update_infochain_for_mode());

  /* Exit here if we're in the desktop */
  if (!predesk || splash_disable)
  {
    return NULL;
  }

  /* Don't do anything special for this mode if we can't find a suitable layout */
  if (!pick_layout())
  {
    return NULL;
  }

  /* Fade quickly to black */
  (void) _swix(ScreenFX_Fade, _INR(0,3), 1, 0, 0, FADE_OUT_CS);

  /* Plot the splash screen JPEG full-screen */
  if (splash_jpeg)
  {
    ERR_GOTO(plot_splash_jpeg(splash_jpeg, splash_size));
  }

  /* Plot the booting progress bar at the default position */
  if (bootbar)
  {
    ERR(swi_bar_display(0, bootbar, layout.bar_x, layout.bar_y));
  }

  /* Fade in from black (more slowly and in the background) */
  (void) _swix(ScreenFX_Fade, _INR(0,3), 0, 0, 0xFFFFFF00, FADE_IN_CS);

  /* Set up the text window and fade (quickly) to black */
  ERR(set_text_window());

  return NULL;

error:
  (void) _swix(ScreenFX_Fade, _INR(0,3), 1, 0, 0xFFFFFF00, 1);
  return err;
}


/********************************************************************************
 *
 * SOFTWARE INTERRUPTS
 *
 ********************************************************************************/


/** Load some progress bar sprites and return a handle for this progress bar.
 *
 *  @@param flags      Flags word.
 *  @@param file       Pointer to zero-terminated filename string.
 *  @@param user_scale User-provided scale factors (optional)
 *  @@param handle     Returned: pointer to the progress bar information block.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_load(const uint32_t flags, const char * const file, const uint32_t * const user_scale, barinfo_t **handle)
{
  _kernel_oserror *err = NULL;
  barinfo_t       *barinfo;
  uint32_t         obj;
  size_t           size;
  uint32_t         type;

  /* If anything goes wrong, make sure we return a null handle */
  *handle = NULL;

  /* Create the empty barinfo structure */
  ERR(new_barinfo(&barinfo));

  /* Check the file exists and is non-zero size */
  ERR(file_info(file, &obj, &size, &type));

  /* Sanity checks */
  if (obj != object_file || !size)
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Treat squashed sprites as a special case */
  if (type == TYPE_SQUASH)
  {
    ERR(load_squashed_sprites(file, size, &barinfo->spr_area, &barinfo->danum));
  }
  else if (type == TYPE_SPRITE)
  {
    /* If we're loading our sprites from ResourcesFS, we don't really need to load them */
    if (not_in_resourcefs(file))
    {
      /* Allocate some memory for the sprite area */
      size += 64;
      ERR(my_malloc((void **)&barinfo->spr_area, size));

      /* Initialise the sprite area */
      barinfo->spr_area->size    = size;
      barinfo->spr_area->num_spr = 0;
      barinfo->spr_area->sprite  = 16;
      barinfo->spr_area->free    = 16;

      /* Load the sprite file into our sprite area */
      ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2), 256 + SpriteReason_LoadSpriteFile, barinfo->spr_area, file));
    }
    else
    {
      void *ptr;

      ERR(resfs_file_to_ptr_and_size(file, &ptr, &size));
      barinfo->resfs    = true;
      barinfo->spr_area = (sprite_area_t *)((uint32_t)ptr - 4);
    }
  }
  else
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Verify the sprite area */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,1), 256 + SpriteReason_CheckSpriteArea, barinfo->spr_area));

  /* Look-up the address of the two sprites we're interested in */
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "border", &barinfo->border_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "fill", &barinfo->fill_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, barinfo->spr_area, "bar", &barinfo->bar_spr);

  if (!barinfo->border_spr || !barinfo->fill_spr || !barinfo->bar_spr)
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Read the dimensions of the border sprite */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2) | _OUTR(3,4), 512 + SpriteReason_ReadSpriteSize, barinfo->spr_area, barinfo->border_spr, &barinfo->width, &barinfo->height));

  /* Initialise the scale factors and pixel translation table for plotting this progress bar */
  if (flags & 1)
  {
    barinfo->user_scale[0] = user_scale[0];
    barinfo->user_scale[1] = user_scale[1];
    barinfo->user_scale[2] = user_scale[2];
    barinfo->user_scale[3] = user_scale[3];
  }
  else
  {
    barinfo->user_scale[0] = barinfo->user_scale[1] = barinfo->user_scale[2] = barinfo->user_scale[3] = 1;
  }
  ERR_GOTO(udpate_barinfo_for_mode(barinfo));

  *handle = barinfo;

  return NULL;

error:
  (void) free_sprites(barinfo);
  return err;
}


/** Update the progress bar to the specified %age position.
 *
 *  @@param flags   Flags word (currently unused).
 *  @@param barinfo Pointer to the progress bar information block.
 *  @@param percent Percentage value to update the progress bar to.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 *
 *  TODO: this function can't yet cope with the progress bar moving downwards to a lower %age.
 */
static _kernel_oserror *swi_bar_update(const uint32_t flags, barinfo_t * barinfo, int32_t percent)
{
  int32_t offset;
  gclip_t vdu;

  /* Cludge: this magic value is used by BootCommands to update the booting progress bar using
   * a SWI call rather than the CLI command.
   */
  if (BOOTFX_MAGIC_HANDLE == (uint32_t)barinfo)
  {
    barinfo = bootbar;
  }

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  /* A bit of over-engineering */
  if (!barinfo->fill_spr)
    return eblk(BOOTFX_ERR_NO_SPRITES);

  /* Range checks */
  if (percent < 0)
    percent = 0;
  else if (percent > 100)
    percent = 100;

  /* Calculate scaled bar size */
  int32_t width = (barinfo->width*barinfo->user_scale[0])/barinfo->user_scale[2];
  int32_t height = (barinfo->height*barinfo->user_scale[1])/barinfo->user_scale[3];

  /* Calculate how far back (pixels) the bar needs to be plotted from the origin of the border */
  offset       = -width + ((width * percent) / 100);
  barinfo->val = (int32_t)percent;

  /* Create the graphics clipping rectangle */
  vdu.vdu  = 24;
  vdu.xmin = barinfo->x;
  vdu.ymin = barinfo->y;
  vdu.xmax = barinfo->x + ((width + offset) << mode_info.xeig);
  vdu.ymax = barinfo->y + (height << mode_info.yeig);

  /* Set the graphics clipping rectangle */
  ERR(_swix(OS_WriteN, _INR(0,1), &vdu, sizeof(vdu)));

  /* Wait for a vsync */
  if (0 == (flags & FLAG_BarUpdate_NoWait))
  {
    ERR(_swix(OS_Byte, _IN(0), 19));
  }

  /* Plot the background fill */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->fill_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  /* Plot the progress bar */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->bar_spr, barinfo->x + (offset << mode_info.xeig), barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  /* Plot the border */
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

  return NULL;
}


/** Display the progress bar at the specified co-ordinates.
 *
 *  @@param flags   Flags word (currently unused).
 *  @@param barinfo Pointer to the progress bar information block.
 *  @@param x       Position of left edge (OS units).
 *  @@param y       Position of bottom edge (OS units).
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_display(const uint32_t flags, barinfo_t * const barinfo, const int32_t x, const int32_t y)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  if (barinfo->spr_area)
  {
    barinfo->x = x;
    barinfo->y = y;

    /* (Re)plot the progress bar border and fill */
    ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->border_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));
    ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, barinfo->spr_area, barinfo->fill_spr, barinfo->x, barinfo->y, 8, barinfo->scale_matrix, barinfo->pixel_trans));

    /* If the progress bar is at a non-zero position, replot it */
    if (barinfo->val)
    {
      ERR(swi_bar_update(0, barinfo, barinfo->val));
    }
  }
  return NULL;
}


/** Free any memory associated with this progress bar.
 *
 *  @@param flags   Flags word (currently unused).
 *  @@param barinfo Pointer to the progress bar information block.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_free(const uint32_t flags, barinfo_t * const barinfo)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }
  return free_sprites(barinfo);
}


/** Return information about the specified progress bar.
 *
 *  @@param flags   Flags word (currently unused).
 *  @@param barinfo Pointer to the progress bar information block.
 *  @@param val     Returned: current percentage.
 *  @@param x       Returned: current left edge (OS units).
 *  @@param y       Returned: current bottom edge (OS units).
 *  @@param width   Returned: total width (OS units).
 *  @@param height  Returned: total height (OS units).
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *swi_bar_readinfo(const uint32_t flags, barinfo_t * const barinfo, int32_t *val, int32_t *x, int32_t *y, int32_t *width, int32_t *height)
{
  IGNORE(flags);

  if (NULL == barinfo)
  {
    ERR(eblk(BOOTFX_ERR_BAD_BAR_HANDLE));
  }

  *val    = barinfo->val;
  *x      = barinfo->x;
  *y      = barinfo->y;
  *width  = (barinfo->width*barinfo->user_scale[0])/barinfo->user_scale[2];
  *height = (barinfo->height*barinfo->user_scale[1])/barinfo->user_scale[3];

  return NULL;
}


/********************************************************************************
 *
 * CLI COMMANDS
 *
 ********************************************************************************/


/** Discard any memory associated with the progress bar graphics and reset its state.
 *
 *  @@param arg_string Pointer to argument string.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_free(const char *arg_string)
{
  IGNORE(arg_string);

  ERR(free_sprites(bootbar));
  bootbar = NULL;

  return NULL;
}


/** Load a sprite file containing the graphics to use for the progress bar.
 *
 *  @@param arg_string Pointer to argument string.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_load(const char *arg_string)
{
  ERR(free_sprites(bootbar));
  bootbar = NULL;

  return swi_bar_load(0, arg_string, NULL, &bootbar);
}


/** Display the progress bar at the specified co-ordinates.
 *
 *  @@param arg_string Pointer to argument string.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_display(const char *arg_string)
{
  int32_t x, y;
  int     ret = sscanf(arg_string, "%d %d", &x, &y);

  if (ret != 2)
  {
    ERR(eblk(BOOTFX_ERR_SYN_POS));
  }
  return swi_bar_display(0, bootbar, x, y);
}


/** Command handler to update the position of the progress bar.
 *
 *  @@param arg_string Pointer to argument string.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_bar_update(const char *arg_string)
{
  int32_t val;
  int     ret = sscanf(arg_string, "%d", &val);

  if (ret != 1)
  {
    ERR(eblk(BOOTFX_ERR_SYN_PLOT));
  }
  return swi_bar_update(0, bootbar, val);
}


/** Output some internal debugging information.
 *
 *  @@param arg_string Pointer to argument string.
 *
 *  @@return Pointer to RISC OS error block or NULL if no error.
 */
static _kernel_oserror *cli_debug(const char *arg_string)
{
  IGNORE(arg_string);

  printf("BootFX state:\n");
  printf("  splash is %sdisabled\n", splash_disable ? "" : "not ");
  printf("  conf lang is%s desktop, ", conf_lang_is_desktop() ? "" : " not");
  printf("%sin desktop now\n", not_in_desktop() ? "not " : "");
  if (NULL == bootbar)
  {
    printf("  bar sprites not loaded\n");
  }
  else
  {
    printf("  bar sprites at &%08X (%sin resfs, DA num %u)\n", (uint32_t)bootbar->spr_area, bootbar->resfs ? "" : "not ", bootbar->danum);
  }
  printf("  logo JPEG at &%08X size = %d\n", (uint32_t)logo_jpeg, logo_size);
  printf("  splash JPEG at &%08X size = %d\n", (uint32_t)splash_jpeg, splash_size);
  printf("  layout:\n");
  printf("    dims %dx%d\n", layout.dimensions[0], layout.dimensions[1]);
  printf("    splash %d,%d scale %d:%d\n", layout.splash_x, layout.splash_y, layout.splash_scale[0], layout.splash_scale[1]);
  printf("    bar %d,%d scale %d:%d\n", layout.bar_x, layout.bar_y, layout.bar_scale[0], layout.bar_scale[1]);
  printf("    text window %d,%d %d,%d\n", layout.text_window.xmin, layout.text_window.ymin, layout.text_window.xmax, layout.text_window.ymax);
  return NULL;
}


/********************************************************************************
 *
 * MAIN EXTERN FUNCTIONS (see h.bootfxHdr)
 *
 ********************************************************************************/


/********************************************************************************
 */
_kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  static _kernel_oserror mfail = { 0, "Failed to claim RMA for message descriptor block" };
  _kernel_oserror *err;
  int8_t cursoff[] = { 23, 1, 0, 0, 0, 0, 0, 0, 0, 0 };

  IGNORE(cmd_tail);
  IGNORE(podule_base);

  /* Make a note of our private word pointer for vector handlers */
  Workspace = pw;

#ifndef ROM_MODULE
  /* In RAM builds, all resource files live in the module binary and need to be added to ResourceFS.
   * ROM builds don't need to do this because this module's resources are part of the Messages module.
   */
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), Resources()));
#endif

  /* Read information about the current screen mode */
  ERR(read_mode_info());

  /* Allocate a buffer for CLI processing */
  ERR(my_malloc((void **)&cli_buf, CLI_BUF_SZ));

  /* Allocate a message file descriptor block */
  msg_desc = malloc(16 + strlen(Module_MessagesFile) + 1);
  if (!msg_desc)
  {
    return &mfail;
  }
  strcpy(msg_desc + 16, Module_MessagesFile);

  /* Open our messages file */
  err = _swix(MessageTrans_OpenFile, _INR(0,2), msg_desc, msg_desc + 16, 0);
  if (err)
  {
    FREE(msg_desc);
    return err;
  }

  /* Set the BootFX path variable */
  ERR(_swix(OS_SetVarVal, _INR(0,4), BOOTFX_SYSVAR, RESFS_PATH, strlen(RESFS_PATH), 0, 0));

  /* We only do splash screen stuff if the machine is configured to boot in the normal way */
  if (conf_lang_is_desktop())
  {
    /* Look for the logo JPEG */
    if (NULL == resfs_file_to_ptr_and_size(LOGO_JPEG_FILE, &logo_jpeg, &logo_size))
    {
      /* If we're outside the desktop, we'll assume it's the ROMInit stage of booting */
      if (not_in_desktop())
      {
        /* Switch the cursor off */
        ERR(_swix(OS_WriteN, _INR(0,1), cursoff, sizeof cursoff));

        /* Plot the logo image */
        ERR(plot_centred_jpeg(logo_jpeg, logo_size));
      }
      else
      {
        splash_disable = true;
      }
    }
    else
    {
      splash_disable = true;
    }
  }
  return err;
}


/********************************************************************************
 */
_kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);

  /* Close our messages file */
  (void) _swix(MessageTrans_CloseFile, _IN(0), msg_desc);

  /* Free various buffers and lists */
  FREE(msg_desc);
  FREE(cli_buf);
  release_infochain();

  /* Deregister our ResourceFS stuff (in RAM builds only) */
#ifndef ROM_MODULE
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());

  /* For RAM builds, we should also unset the BootFX path variable */
  (void) _swix(OS_SetVarVal, _INR(0,4), BOOTFX_SYSVAR, NULL, -1, 0, 0);
#endif

  return NULL;
}


/********************************************************************************
 */
void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  switch (service_number)
  {
    case Service_ModeChange:
    {
      (void) mode_has_changed();
      break;
    }
    case Service_DesktopWelcome:
    {
      /* Stop doing splash screen plotting */
      if (splash_jpeg)
      {
        (void) plot_splash_jpeg(splash_jpeg, splash_size);
        splash_jpeg = NULL;
        splash_size = 0;
      }

      /* Discard the progress bar sprite data (and free the buffer) */
      (void) free_sprites(bootbar);
      bootbar = NULL;

      /* Remember that the desktop has now been reached */
      splash_disable = true;

      /* Claim this service call to stop the desktop banner window */
      r->r[1] = 0;
      break;
    }
  }
}


/********************************************************************************
 */
_kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  /* Call the appropriate handler function */
  switch (swi_offset)
  {
    case BootFX_BarLoad - BootFX_00:
    {
      barinfo_t *handle = NULL;

      ERR(swi_bar_load(r->r[0], (char *)r->r[1], (const uint32_t * const)r->r[2], &handle));
      r->r[0] = (int32_t)handle;

      return NULL;
    }
    case BootFX_BarDisplay - BootFX_00:
    {
      return swi_bar_display(r->r[0], (barinfo_t *)r->r[1], r->r[2], r->r[3]);
    }
    case BootFX_BarUpdate - BootFX_00:
    {
      return swi_bar_update(r->r[0], (barinfo_t *)r->r[1], r->r[2]);
    }
    case BootFX_BarFree - BootFX_00:
    {
      ERR(swi_bar_free(r->r[0], (barinfo_t *)r->r[1]));
      r->r[1] = 0;

      return NULL;
    }
    case BootFX_BarReadInfo - BootFX_00:
    {
      return swi_bar_readinfo(r->r[0], (barinfo_t *)r->r[1], &r->r[0], &r->r[1], &r->r[2], &r->r[3], &r->r[4]);
    }
  }
  return error_BAD_SWI;
}


/********************************************************************************
 */
_kernel_oserror *Module_Cmd(const char *arg_string, int argc, int cmd_no, void *pw)
{
  char *ptr;
  char *end = cli_buf + CLI_BUF_SZ;

  IGNORE(argc);
  IGNORE(pw);

  /* IMPORTANT NOTE: The arg_string may not be zero-terminated! */
  ptr = cli_buf;
  while (ptr < end && *arg_string >= ' ')
  {
    *ptr++ = *arg_string++;
  }
  *ptr = '\0';

  /* Call the appropriate handler function */
  switch (cmd_no)
  {
    case CMD_BootFX_BarFree:
      return cli_bar_free(cli_buf);
    case CMD_BootFX_BarLoad:
      return cli_bar_load(cli_buf);
    case CMD_BootFX_BarDisplay:
      return cli_bar_display(cli_buf);
    case CMD_BootFX_BarUpdate:
      return cli_bar_update(cli_buf);
    case CMD_BootFX_Debug:
      return cli_debug(cli_buf);
  }
  return NULL;
}
@


1.8
log
@Use different layouts for different screen modes
Detail:
  Rather than using a fixed layout (which assumes a fixed screen size), BootFX now supports multiple layouts, which are able to adjust their scale to fit the current screen.
  First the layout most appropriate to the aspect ratio is chosen, and then coordinates and scale factors are adjusted in order to account for any difference in resolution.
  If the scaling results in a text window which is deemed to be "too small" then another layout will be tried, or in extreme cases BootFX will give up and go inactive for that mode.
  For cases where there is an inexact aspect ratio match, borders will be added to the layout in order to allow it to maintain the correct aspect ratio. This may result in some wasted space but sufficient for most purposes.
  File changes:
  - Docs/Spec.txt - Document BootFX_BarLoad addition to allow custom bar scale factors to be used
  - c/bootfx - Move hard-coded layout parameters into layout_t structs, and implement the layout adjustment logic. Define two layouts for Raspberry Pi; 4:3 layout will crop off the top portion of the splash so that a large text window can be placed underneath.
  - h/bootfx - Remove a few constants which are defined elsewhere in shared headers
Admin:
  Tested on Raspberry Pi, in a variety of screen modes


Version 0.07. Tagged as 'BootFX-0_07'
@
text
@d22 1
a22 1
#include "bootfxHdr.h"
a71 3
extern void *SplashResources(void);
extern void *Bar24Resources(void);
extern void *LogoResources(void);
a1435 3
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), SplashResources()));
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), Bar24Resources()));
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), LogoResources()));
a1509 3
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), LogoResources());
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), Bar24Resources());
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), SplashResources());
@


1.7
log
@Major internal replumbing.

Detail:

Extended the SWI interface to cope with multiple clients using BootFX to plot
progress bars (as originally intended). This did mean making a non-backwards-
compatible change to the BarUpdate SWI call (should only affect BootCmds).

Also fixed some minor bugs.

Finally, added a specification to the Docs directory and an example program
to the Tests directory.

Admin:

Implies BootCmds 1.46later.

Version 0.06. Tagged as 'BootFX-0_06'
@
text
@d19 1
a60 6
/** Location of our splash screen JPEG. */
#define SPLASH_JPEG_FILE RESFS_PATH "1920x1080"

/** Location of our default progress bar sprite file (currently only 24bpp supported). */
#define SPRITE_FILE RESFS_PATH "Bar24"

d86 1
d124 1
a124 1
/** A structure to gold graphics clipping window information.
d135 1
a135 1
/** A structure to gold text window information.
d140 4
a143 4
  uint8_t xmin;            /**< Left edge (OS units, inclusive). */
  uint8_t ymin;            /**< Bottom edge (OS units, inclusive). */
  uint8_t xmax;            /**< Right edge (OS units, inclusive). */
  uint8_t ymax;            /**< Top edge (OS units, inclusive). */
d182 1
d196 15
d214 31
a244 3
#define BAR_X (1280)
#define BAR_Y (786)
static tclip_t text_window = { 28, 80, 125, 159, 94 };
d246 1
a246 3
#define BAR_X (400)
#define BAR_Y (400)
static tclip_t text_window = { 28, 0, 0, 255, 255 };
d250 1
d263 1
d485 1
a485 1
  ERR(_swix(OS_DynamicArea, _INR(0,8) | _OUT(1) | _OUT(3), OSDA_Create, -1, out_sz, -1, 1<<7, out_sz, NULL, NULL, DA_NAME, danum, &out));
d517 1
a517 1
    (void) _swix(OS_DynamicArea, _INR(0,1), OSDA_Remove, *danum);
d531 1
a531 1
static _kernel_oserror *plot_centred_jepg(const void * const jpeg, const size_t size)
d564 1
a564 1
/** Plot a JPEG, scaled to fit the whole screen.
d571 1
a571 1
static _kernel_oserror *plot_fullscreen_jepg(const void * const jpeg, const size_t size)
a572 1
  int32_t j_width, j_height;
d575 4
a578 1
  ERR(_swix(JPEG_Info, _INR(0,2) | _OUTR(2,3), 1, jpeg, size, &j_width, &j_height));
d580 1
a580 6
  trans.mx = mode_info.screen_x >> mode_info.xeig;
  trans.my = mode_info.screen_y >> mode_info.yeig;
  trans.dx = j_width;
  trans.dy = j_height;

  return _swix(JPEG_PlotScaled, _INR(0,5), jpeg, 0, 0, &trans, size, 3);
d634 1
a634 1
static _kernel_oserror *udpate_barinfo_for_mode(const barinfo_t * const barinfo)
d639 4
d728 1
a728 1
        err               = _swix(OS_DynamicArea, _INR(0,1), OSDA_Remove, barinfo->danum);
d783 58
d886 1
a886 1
  ERR(_swix(OS_WriteN, _INR(0,1), &text_window, sizeof(text_window)));
d894 72
d990 6
d1002 1
a1002 1
    ERR_GOTO(plot_fullscreen_jepg(splash_jpeg, splash_size));
d1008 1
a1008 1
    ERR(swi_bar_display(0, bootbar, BAR_X, BAR_Y));
d1034 4
a1037 3
 *  @@param flags   Flags word (currently unused).
 *  @@param file    Pointer to zero-terminated filename string.
 *  @@param handle  Returned: pointer to the progress bar information block.
d1041 1
a1041 1
static _kernel_oserror *swi_bar_load(const uint32_t flags, const char * const file, barinfo_t **handle)
a1048 2
  IGNORE(flags);

d1091 1
a1091 1
      ERR(resfs_file_to_ptr_and_size(SPRITE_FILE, &ptr, &size));
d1118 11
d1179 4
d1184 1
a1184 1
  offset       = -barinfo->width + ((barinfo->width * percent) / 100);
d1191 2
a1192 2
  vdu.xmax = barinfo->x + ((barinfo->width + offset) << mode_info.xeig);
  vdu.ymax = barinfo->y + (barinfo->height << mode_info.yeig);
d1296 2
a1297 2
  *width  = barinfo->width;
  *height = barinfo->height;
d1338 1
a1338 1
  return swi_bar_load(0, arg_string, &bootbar);
d1404 5
d1482 1
a1482 4
        ERR(plot_centred_jepg(logo_jpeg, logo_size));

        /* Load our default sprites from ResourceFS */
        ERR(cli_bar_load(SPRITE_FILE));
a1492 3

    /* Get a pointer to the splash screen JPEG (or disable splash screen if not found) */
    (void) resfs_file_to_ptr_and_size(SPLASH_JPEG_FILE, &splash_jpeg, &splash_size);
d1548 1
a1548 1
        (void) plot_fullscreen_jepg(splash_jpeg, splash_size);
d1582 1
a1582 1
      ERR(swi_bar_load(r->r[0], (char *)r->r[1], &handle));
@


1.6
log
@Fix text window remaining active after desktop has been reached
Detail:
  c/bootfx - Make sure not_in_desktop returns false once Service_DesktopWelcome has been seen. This ensures mode_has_changed doesn't fiddle with the text window or try to do anything else if single-tasking apps are run once the desktop has been reached.
Admin:
  Tested on Raspberry Pi
  F12 -> *BASIC -> MODE MODE, or executing mode changes from a double-clicked BASIC file, no longer results in BootFX's text window being applied.


Version 0.05. Tagged as 'BootFX-0_05'
@
text
@d72 3
a80 3
static _kernel_oserror *cli_bar_display(const char *arg_string);


d89 2
d171 28
d211 2
d214 1
a214 10
static int32_t        bar_x, bar_y   = 0;      /**< Origin co-ordinates for progress bar (OS units). */
static uint32_t       bar_val        = 0;      /**< %age value for progress bar. */
static uint32_t       bar_width      = 0;      /**< Width of the progress bar (OS units). */
static uint32_t       bar_height     = 0;      /**< Height of the progress bar (OS units). */
static uint32_t       spr_danum      = 0;      /**< Dynamic area number for the sprite area (if we unsquashed into a DA). */
static bool           spr_in_resfs   = false;  /**< Set to true when spr_area is pointing to our sprites in ResourceFS. */
static sprite_area_t *spr_area       = NULL;   /**< Progress bar sprite area pointer. */
static sprite_t      *bar_border_spr = NULL;   /**< Progress bar 'border' sprite pointer. */
static sprite_t      *bar_fill_spr   = NULL;   /**< Progress bar 'fill' sprite pointer. */
static sprite_t      *bar_bar_spr    = NULL;   /**< Progress bar 'bar' sprite pointer. */
d221 1
d223 1
a223 3
static uint32_t       scale_matrix[4];         /**< Scale factor block (for current mode). */
static uint32_t       pixel_trans[4];          /**< Pixel translation table (for current mode). */
static bool           desktop_welcome = false; /**< Seen Service_DesktopWelcome yet? */
d405 2
a406 1
 *  @@param area       Pointer to the sprite area pointer to return from this function.
d410 1
a410 1
static _kernel_oserror *load_squashed_sprites(const char *arg_string, const size_t size, sprite_area_t **area)
d421 2
a422 3
  /*  */
  spr_danum = 0;
  *area     = NULL;
d445 1
a445 1
  ERR(_swix(OS_DynamicArea, _INR(0,8) | _OUT(1) | _OUT(3), OSDA_Create, -1, out_sz, -1, 1<<7, out_sz, NULL, NULL, DA_NAME, &spr_danum, &out));
d475 1
a475 1
  if (spr_danum)
d477 2
a478 2
    (void) _swix(OS_DynamicArea, _INR(0,1), OSDA_Remove, spr_danum);
    spr_danum = 0;
d547 172
a737 5
  /* Calculate the scale factors and pixel translation table for plotting the progress bar in this mode */
  if (spr_area)
  {
    ERR(_swix(Wimp_ReadPixTrans, _INR(0,2) | _INR(6,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_border_spr, scale_matrix, pixel_trans));
  }
a750 5
  /* Always claim we're in the desktop once Service_DesktopWelcome has been seen
     Avoids us messing with things if a single-tasking app is run */
  if (desktop_welcome)
    return false;

d810 3
d814 1
a814 1
  if (!predesk)
d828 5
a832 3
  /* Plot the progress bar at the default position */
  sprintf(cli_buf, "%d %d", BAR_X, BAR_Y);
  ERR(cli_bar_display(cli_buf));
d850 1
a850 1
 * SWIS
d855 99
d956 3
a958 1
 *  @@param arg_string Pointer to array of registers for input and output.
d964 1
a964 1
static _kernel_oserror *swi_bar_update(_kernel_swi_regs *r)
d969 15
a983 1
  if (!bar_fill_spr)
d987 4
a990 4
  if (r->r[0] < 0)
    r->r[0] = 0;
  else if (r->r[0] > 100)
    r->r[0] = 100;
d993 2
a994 1
  offset   = -bar_width + ((bar_width * r->r[0]) / 100);
d998 4
a1001 4
  vdu.xmin = bar_x;
  vdu.ymin = bar_y;
  vdu.xmax = bar_x + ((bar_width + offset) << mode_info.xeig);
  vdu.ymax = bar_y + (bar_height << mode_info.yeig);
d1007 4
a1010 1
  ERR(_swix(OS_Byte, _IN(0), 19));
d1013 1
a1013 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_fill_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
d1016 1
a1016 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_bar_spr, bar_x + (offset << mode_info.xeig), bar_y, 8, scale_matrix, pixel_trans));
d1019 1
a1019 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_border_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
d1025 6
a1030 1
/** Free and reset everything relating to the loaded progress bar sprites.
d1034 1
a1034 1
static _kernel_oserror *free_sprites(void)
d1036 6
a1041 1
  _kernel_oserror *err = NULL;
d1043 1
a1043 1
  if (!spr_in_resfs)
d1045 9
a1053 1
    if (spr_danum)
d1055 1
a1055 7
      err       = _swix(OS_DynamicArea, _INR(0,1), OSDA_Remove, spr_danum);
      spr_danum = 0;
      spr_area  = NULL;
    }
    else
    {
      FREE(spr_area);
d1058 22
d1081 15
a1095 2
  /* Reset lots of stuff to defaults */
  spr_in_resfs   = false;
d1097 4
a1100 1
  spr_area       = NULL;
d1102 5
a1106 9
  bar_border_spr = NULL;
  bar_fill_spr   = NULL;
  bar_bar_spr    = NULL;

  bar_width      = 0;
  bar_height     = 0;
  bar_val        = 0;
  bar_x          = 0;
  bar_y          = 0;
d1108 1
a1108 1
  return err;
d1125 1
a1125 1
static _kernel_oserror *cli_free(const char *arg_string)
d1129 4
a1132 1
  return free_sprites();
d1144 2
a1145 16
  _kernel_oserror *err;
  uint32_t         obj;
  size_t           size;
  uint32_t         type;

  /* Remove any previously loaded sprites */
  ERR(cli_free(arg_string));

  /* Check the file exists and is non-zero size */
  ERR(file_info(arg_string, &obj, &size, &type));

  /* Sanity checks */
  if (obj != object_file || !size)
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }
d1147 1
a1147 61
  /* Treat squashed sprites as a special case */
  if (type == TYPE_SQUASH)
  {
    ERR(load_squashed_sprites(arg_string, size, &spr_area));
  }
  else if (type == TYPE_SPRITE)
  {
    /* If we're loading our sprites from ResourcesFS, we don't really need to load them */
    if (not_in_resourcefs(arg_string))
    {
      /* Allocate some memory for the sprite area */
      size += 64;
      ERR(my_malloc((void **)&spr_area, size));

      /* Initialise the sprite area */
      spr_area->size    = size;
      spr_area->num_spr = 0;
      spr_area->sprite  = 16;
      spr_area->free    = 16;

      /* Load the sprite file into our sprite area */
      ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2), 256 + SpriteReason_LoadSpriteFile, spr_area, arg_string));
    }
    else
    {
      void *ptr;

      ERR(resfs_file_to_ptr_and_size(SPRITE_FILE, &ptr, &size));
      spr_in_resfs = true;
      spr_area     = (sprite_area_t *)((uint32_t)ptr - 4);
    }
  }
  else
  {
    ERR(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Verify the sprite area */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,1), 256 + SpriteReason_CheckSpriteArea, spr_area));

  /* Look-up the address of the two sprites we're interested in */
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, spr_area, "border", &bar_border_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, spr_area, "fill", &bar_fill_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, spr_area, "bar", &bar_bar_spr);

  if (!bar_border_spr || !bar_fill_spr || !bar_bar_spr)
  {
    ERR_GOTO(eblk(BOOTFX_ERR_INVALID_SPRITES));
  }

  /* Read the dimensions of the border sprite */
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2) | _OUTR(3,4), 512 + SpriteReason_ReadSpriteSize, spr_area, bar_border_spr, &bar_width, &bar_height));

  /* Initialise the scale factors and pixel translation table for plotting this progress bar */
  ERR_GOTO(read_mode_info());

  return NULL;

error:
  (void) free_sprites();
  return err;
d1159 2
a1160 1
  int ret = sscanf(arg_string, "%d %d", &bar_x, &bar_y);
d1162 1
a1162 1
  if (ret == 2)
d1164 1
a1164 6
    if (spr_area)
    {
      ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_border_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
      ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, spr_area, bar_fill_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
    }
    return NULL;
d1166 1
a1166 1
  return eblk(BOOTFX_ERR_SYN_POS);
d1178 2
a1179 3
  _kernel_swi_regs r;
  uint32_t         val;
  int              ret = sscanf(arg_string, "%u", &val);
d1182 4
a1185 5
    return eblk(BOOTFX_ERR_SYN_PLOT);

  r.r[0] = val;

  return swi_bar_update(&r);
d1189 6
d1200 13
a1212 4
  printf("  conf_lang_is_desktop = %d\n", conf_lang_is_desktop());
  printf("  not_in_desktop       = %d\n", not_in_desktop());
  printf("  bar sprites &%08X resfs=%s\n", (uint32_t)spr_area, spr_in_resfs ? "yes" : "no");
  printf("  splash JPEG &%08X size =%d\n", (uint32_t)splash_jpeg, splash_size);
a1247 3
  /* Set the BootFX path variable */
  ERR(_swix(OS_SetVarVal, _INR(0,4), BOOTFX_SYSVAR, RESFS_PATH, strlen(RESFS_PATH), 0, 0));

d1257 1
d1259 1
d1270 3
d1291 8
d1319 1
a1319 1
  /* Free various buffers */
d1322 1
a1322 1
  (void) free_sprites();
d1360 1
a1360 1
        splash_jpeg = 0;
d1364 2
a1365 1
      (void) cli_free(NULL);
d1368 1
a1368 1
      desktop_welcome = true;
d1388 13
d1402 14
a1415 1
      return swi_bar_update(r);
d1442 2
@


1.5
log
@This time without the debug...
@
text
@d201 1
d562 5
d1064 3
@


1.4
log
@Lots of changes and improvements.

* Fixed the free error on killing the module;
* Presents a mono logo initially, then splash stuff later;
* Switches flashing cursor off on module init (if pre-desktop);
* Bar sprites are squashed in ROM to save space;
* Miscellaneous tidy-ups and tweaks.

Version 0.04. Tagged as 'BootFX-0_04'
@
text
@a406 2
printf("0");

a419 2
printf("1");

a423 2
printf("2");

a426 2
printf("3");

a429 2
printf("4");

a432 2
printf("5");

a438 2
printf("6");

@


1.3
log
@Simplify and improve a bit.

Version 0.03. Tagged as 'BootFX-0_03'
@
text
@d39 15
d55 4
a58 1
#define RESFS_PATH "Resources:$.Resources.BootFX."
d61 1
a61 1
#define SPLASH_JPEG_FILE "BootFX:1920x1080"
d64 1
a64 1
#define BAR_SPRITE_FILE "BootFX:Bar24"
d76 3
a78 1
extern void *PreDeskResources(void);
a79 15
#if 0
/** Table of the number of following bytes (parameters) for a given VDU code (the table index).
 */
static uint32_t vdu_params[32] =
{
  /*  0 */ 0, 1, 0, 0,
  /*  4 */ 0, 0, 0, 0,
  /*  8 */ 0, 0, 0, 0,
  /* 12 */ 0, 0, 0, 0,
  /* 16 */ 0, 1, 2, 5,
  /* 20 */ 0, 0, 1, 10,
  /* 24 */ 8, 5, 0, 0,
  /* 28 */ 4, 4, 0, 2
};
#endif
d88 1
d158 11
d171 3
a173 1
#if (defined UserIF_Raspberry) || (defined UserIF_Sovereign)
d176 2
d186 3
a188 2
static bool           bar_spr_resfs  = false;  /**< Set to true when bar_spr_area is pointing to our sprites in ResourceFS. */
static sprite_area_t *bar_spr_area   = NULL;   /**< Progress bar sprite area pointer. */
d194 2
a195 2
static uint32_t       scale_matrix[4];         /**< Scale factor block (for current mode). */
static uint32_t       pixel_trans[4];          /**< Pixel translation table (for current mode). */
d199 2
a200 1
//static bool           claimed_wrchv  = false;  /**< Flag to indicate we have claimed WrchV. */
d281 1
a281 1
static _kernel_oserror *file_info(const char * const fname, uint32_t *obj, size_t *size)
d284 4
a287 1
  return _swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(4), OSFile_ReadNoPath, fname, obj, size);
d304 4
d314 1
a314 1
  *ptr  = addr;
d323 192
d558 1
a558 1
  if (bar_spr_area)
d560 1
a560 1
    ERR(_swix(Wimp_ReadPixTrans, _INR(0,2) | _INR(6,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_border_spr, scale_matrix, pixel_trans));
a619 24
#if 0
static _kernel_oserror *claim_wrchv(void)
{
  if (!claimed_wrchv)
  {
    ERR(_swix(OS_Claim, _INR(0,2), WrchV, &oswrchv_entry, Workspace));
    claimed_wrchv = true;
  }
  return NULL;
}


static _kernel_oserror *release_wrchv(void)
{
  if (claimed_wrchv)
  {
    ERR(_swix(OS_Release, _INR(0,2), WrchV, &oswrchv_entry, Workspace));
    claimed_wrchv = false;
  }
  return NULL;
}
#endif


d634 1
d649 4
d713 1
a713 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_fill_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
d716 1
a716 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_bar_spr, bar_x + (offset << mode_info.xeig), bar_y, 8, scale_matrix, pixel_trans));
d719 1
a719 1
  ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_border_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
d725 41
d783 1
a783 15
  if (!bar_spr_resfs)
  {
    FREE(bar_spr_area);
  }
  bar_spr_resfs  = false;
  bar_border_spr = NULL;
  bar_fill_spr   = NULL;
  bar_bar_spr    = NULL;
  bar_width      = 0;
  bar_height     = 0;
  bar_val        = 0;
  bar_x          = 0;
  bar_y          = 0;

  return NULL;
d798 1
d804 1
a804 1
  ERR(file_info(arg_string, &obj, &size));
d808 3
a810 1
    return eblk(BOOTFX_ERR_INVALID_SPRITES);
d812 2
a813 2
  /* If we're loading our sprites from ResourcesFS, we don't really need to load them */
  if (0 == strcmp(arg_string, BAR_SPRITE_FILE))
d815 28
a842 4
    void *ptr;
    ERR(resfs_file_to_ptr_and_size(BAR_SPRITE_FILE, &ptr, &size));
    bar_spr_resfs = true;
    bar_spr_area  = (sprite_area_t *)((uint32_t)ptr - 4);
d846 1
a846 12
    /* Allocate some memory for the sprite area */
    size += 64;
    ERR(my_malloc((void **)&bar_spr_area, size));

    /* Initialise the sprite area */
    bar_spr_area->size    = size;
    bar_spr_area->num_spr = 0;
    bar_spr_area->sprite  = 16;
    bar_spr_area->free    = 16;

    /* Load the sprite file into our sprite area */
    ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2), 256 + SpriteReason_LoadSpriteFile, bar_spr_area, arg_string));
d850 1
a850 1
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,1), 256 + SpriteReason_CheckSpriteArea, bar_spr_area));
d853 4
a856 3
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, bar_spr_area, "border", &bar_border_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, bar_spr_area, "fill", &bar_fill_spr);
  (void) _swix(OS_SpriteOp, _INR(0,2) | _OUT(2), 256 + SpriteReason_SelectSprite, bar_spr_area, "bar", &bar_bar_spr);
d858 1
d860 1
d863 1
a863 1
  ERR_GOTO(_swix(OS_SpriteOp, _INR(0,2) | _OUTR(3,4), 512 + SpriteReason_ReadSpriteSize, bar_spr_area, bar_border_spr, &bar_width, &bar_height));
d871 1
a871 4
  if (!bar_spr_resfs)
  {
    FREE(bar_spr_area);
  }
d888 1
a888 1
    if (bar_spr_area)
d890 2
a891 2
      ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_border_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
      ERR(_swix(OS_SpriteOp, _INR(0,7), 0x200 + SpriteReason_PutSpriteScaled, bar_spr_area, bar_fill_spr, bar_x, bar_y, 8, scale_matrix, pixel_trans));
d927 1
a927 1
  printf("  bar sprites &%08X resfs=%s\n", (uint32_t)bar_spr_area, bar_spr_resfs ? "yes" : "no");
d946 1
d961 1
a961 1
  ERR(_swix(ResourceFS_RegisterFiles, _IN(0), PreDeskResources()));
d990 2
a991 2
    /* Get a pointer to the splash screen JPEG */
    if (resfs_file_to_ptr_and_size(SPLASH_JPEG_FILE, &splash_jpeg, &splash_size))
d993 1
a993 6
      /* Something went wrong loading. Mark the splash screen as not present and return without an error */
      splash_jpeg = NULL;
    }
    else
    {
      /* Plot the splash screen during ROM init (only if we're outside the desktop when initialised) */
d996 8
a1003 1
        ERR(plot_fullscreen_jepg(splash_jpeg, splash_size));
d1006 3
d1028 1
a1028 4
  if (!bar_spr_resfs)
  {
    FREE(bar_spr_area);
  }
d1032 1
a1032 1
  (void) _swix(ResourceFS_DeregisterFiles, _IN(0), PreDeskResources());
d1036 3
a1040 3
  /* Restore WrchV to its normal state */
  //(void) release_wrchv();

a1058 7
//    case Service_WimpReportError:
//    {
//      /* Restore WrchV to its normal state */
//      //(void) release_wrchv();
//
//      break;
//    }
a1060 3
      /* Restore WrchV to its normal state */
      //(void) release_wrchv();

d1066 1
a1066 2

//        ERR(claim_wrchv());
a1128 37


#if 0
/********************************************************************************
 *
 * This handler is entered for every character that passes through WrchV.
 */
extern int OSWrchV_Handler(_kernel_swi_regs *r, void *pw)
{
  static uint8_t params = 0;
  static int     pass   = 0;

  IGNORE(pw);

  /* We swallow all characters coming through this vector, including VDU codes,
   * unless it's a palette-setting sequence, because we need that to get through
   * as it's the thing that gets the mouse pointer looking correct. We also let
   * VDU 23 sequences through, because they are probably also important.
   */

  if (params)
  {
    params--;
  }
  else
  {
    uint8_t vdu = (uint8_t)r->r[0];

    if (vdu < 32)
    {
      params = vdu_params[vdu];
      pass   = vdu == 19 || vdu == 23;
    }
  }
  return pass;
}
#endif
@


1.2
log
@Disable the WrchV stuff in public CVS because that needs a lot more testing
than it's had up to now.

Version 0.02. Tagged as 'BootFX-0_02'
@
text
@d60 1
d74 1
a74 1

d176 2
a177 2
static void          *Workspace      = NULL;
static bool           claimed_wrchv  = false;
d398 1
a400 2
/* TODO: this bit needs a lot more testing, so disable it for now... */
#if 0
a405 1
#endif
d419 1
d431 1
d436 1
a436 2
  /* Only do this bit if we're not yet in the desktop */
  if (not_in_desktop())
d438 1
a438 5
    (void) _swix(ScreenFX_Fade, _INR(0,3), 1, 0, 0, FADE_OUT_CS);
  }
  else
  {
    ERR(claim_wrchv());
d440 3
d450 5
a454 5
  /* Only do this bit if we're not yet in the desktop */
  if (not_in_desktop())
  {
    /* Fade back in from black (more slowly and in the background) */
    (void) _swix(ScreenFX_Fade, _INR(0,3), 0, 0, 0xFFFFFF00, FADE_IN_CS);
a455 3
    /* Set up the text window and fade (quickly) to black */
    ERR(set_text_window());
  }
a775 1
  FREE(splash_jpeg);
d790 1
a790 1
  (void) release_wrchv();
d810 7
a816 7
    case Service_WimpReportError:
    {
      /* Restore WrchV to its normal state */
      (void) release_wrchv();

      break;
    }
d820 1
a820 1
      (void) release_wrchv();
d823 7
a829 1
      splash_jpeg = NULL;
d893 1
d927 1
@


1.1
log
@Initial revision
@
text
@d399 2
d406 1
@


1.1.1.1
log
@Initial import of the BootFX module.
@
text
@@

head	1.20;
access;
symbols
	OMAPVideo-0_41:1.20
	OMAPVideo-0_40:1.19
	OMAPVideo-0_39:1.19
	OMAPVideo-0_38:1.19
	OMAPVideo-0_37:1.19
	OMAPVideo-0_36:1.19
	OMAPVideo-0_35:1.19
	OMAPVideo-0_34:1.19
	OMAPVideo-0_33:1.18
	OMAPVideo-0_32:1.17
	OMAPVideo-0_31:1.16
	OMAPVideo-0_30:1.15
	OMAPVideo-0_29:1.14
	OMAPVideo-0_28:1.14
	OMAPVideo-0_27:1.13
	OMAPVideo-0_26:1.13
	OMAPVideo-0_25:1.12
	OMAPVideo-0_24:1.12
	OMAPVideo-0_23:1.12
	OMAPVideo-0_22:1.12
	OMAPVideo-0_21:1.11
	OMAPVideo-0_20:1.11
	OMAPVideo-0_19:1.10
	OMAPVideo-0_18:1.9
	OMAPVideo-0_17:1.9
	OMAPVideo-0_16:1.9
	OMAPVideo-0_15:1.9
	OMAPVideo-0_14:1.9
	OMAPVideo-0_13:1.9
	OMAPVideo-0_12:1.8
	OMAPVideo-0_11:1.7
	OMAPVideo-0_10:1.6
	OMAPVideo-0_09:1.5
	OMAPVideo-0_08:1.5
	OMAPVideo-0_07:1.4
	OMAPVideo-0_06:1.3
	OMAPVideo-0_05:1.3
	OMAPVideo-0_04:1.2
	OMAPVideo-0_03:1.2
	OMAPVideo-0_02:1.1
	OMAPVideo-0_01:1.1;
locks; strict;
comment	@# @;


1.20
date	2018.05.31.21.48.53;	author jlee;	state Exp;
branches;
next	1.19;
commitid	qHkabDo5zjgySuEA;

1.19
date	2015.05.17.17.50.09;	author jlee;	state Exp;
branches;
next	1.18;
commitid	J3i0xRSaySaJePly;

1.18
date	2014.08.04.19.32.28;	author jlee;	state Exp;
branches;
next	1.17;
commitid	mfVppAOwZpwQZ4Lx;

1.17
date	2014.07.20.14.00.53;	author jlee;	state Exp;
branches;
next	1.16;
commitid	x12yfJrE5UjZD7Jx;

1.16
date	2014.05.27.21.18.57;	author jlee;	state Exp;
branches;
next	1.15;
commitid	0xSjIUTNBETSNdCx;

1.15
date	2014.01.19.20.49.55;	author jlee;	state Exp;
branches;
next	1.14;
commitid	oXQLBLOQ0Vh1LLlx;

1.14
date	2013.12.15.22.56.06;	author jlee;	state Exp;
branches;
next	1.13;
commitid	4M7nRqPE9VC3Ahhx;

1.13
date	2012.11.07.23.37.06;	author jlee;	state Exp;
branches;
next	1.12;
commitid	54wvlBauRftgLurw;

1.12
date	2012.06.04.23.54.21;	author jlee;	state Exp;
branches;
next	1.11;
commitid	FoeSemiFbzb4Sr7w;

1.11
date	2012.05.06.09.20.43;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	Dmkx2IqcO2G8YD3w;

1.10
date	2012.05.06.09.16.44;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	imAmvVvRmuLKWD3w;

1.9
date	2011.10.23.21.01.50;	author jlee;	state Exp;
branches;
next	1.8;
commitid	0rwNv0ztfd3f9wEv;

1.8
date	2011.07.11.22.07.35;	author jlee;	state Exp;
branches;
next	1.7;
commitid	aeC42JvE4N46R9rv;

1.7
date	2011.03.19.18.19.47;	author jlee;	state Exp;
branches;
next	1.6;
commitid	kv85AixjkSL8gucv;

1.6
date	2011.02.19.22.30.04;	author jlee;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.31.20.17.57;	author jlee;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.14.21.12.56;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.29.17.53.04;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.22.20.42.58;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.28.19.01.15;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Big refactor, introduce GraphicsV overlay API support
Detail:
  This change introduces initial support for the GraphicsV overlay API.
  RGB & YUV overlays are supported, along with rotation and scaling.
  Vertical flipping isn't supported yet, and there are still a number of bugs to track down, along with some potential improvements.
  The code has also been refactored significantly, in an attempt to protect all critical state with spinlocks/mutexes (as appropriate), and to reduce the number of globals so that it's easier to see what's touching what. Previously very little locking was performed, which could lead to issues if VSyncs or synclost interrupts occurred during certain operations. Now, the data should be structured in such a way that this shouldn't cause problems.
  Notable things:
  * State which needs to be writable from interrupt handlers is protected by spinlocks
  * State which needs to be readable from interrupt handlers is protected by reader-writer spinlocks
  * State which doesn't need to be accessed from interrupt handlers is unprotected (mutexes can be introduced in the future to make the code SMP-safe)
  * Using non-alpha screen modes for the desktop will currently result in only "basic" overlays being supported (i.e. overlays which appear ontop of the desktop). In some cases this could be improved by falling back to a software pointer, but for now the only way to get Z-Order overlays is to use a screen mode with an alpha channel.
  * Memory allocation for overlays is abstracted via the buffer interface (h/buffer). This has three implementations: basic buffers for untransformed overlays, VRFB-transformed buffers for OMAP3, and TILER-transformed buffers for OMAP4.
  * Ultimately all overlay memory is allocated as physically contiguous pages within a PMP - although since TILER contains its own MMU this isn't strictly necessary on OMAP4
  * Overlay memory is mapped as write-through cacheable for CPU access; experimentation with different cache policies has yet to be performed. However a potential future optimisation would be to perform lazy unmapping of overlay buffers, reducing the map/unmap overhead in well-behaved code which only maps buffers when they're needed
Admin:
  Tested on BB-xM, Pandaboard


Version 0.41. Tagged as 'OMAPVideo-0_41'
@
text
@/*
 * Copyright (c) 2010, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <string.h>
#include <stddef.h>
#include "modhead.h"
#include "swis.h"

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/HALEntries.h"
#include "Global/GraphicsV.h"
#include "Global/VduExt.h"

#include "DebugLib/DebugLib.h"

#include "graphicsv.h"
#include "dispc.h"
#include "sdma.h"
#include "gvoverlay.h"
#include "mouse.h"
#include "consts.h"
#include "vars.h"
#include "globals.h"
#include "palette.h"

/* Extract the GraphicsV overlay number from a GraphicsV call register block */
#define GET_OVERLAY(r) (((r->r[4] >> 16) & 255) - TARGET_MAX)

static uint32_t vdu_init = ~0; /* Physical address of current VDU display bank */

#ifdef DEBUGLIB
/* Keep track of the max duration of GraphicsV calls, separately tracking calls which are made with IRQs disabled and those which are made with IRQs enabled */
#define NUM_GV_CALLS 32
static uint32_t gv_durations[NUM_GV_CALLS][2];

void graphicsv_debug(void)
{
	for(int i=0;i<NUM_GV_CALLS;i++)
	{
		for(int j=0;j<2;j++)
		{
			if (gv_durations[i][j])
			{
				printf(" GraphicsV %d: %uus, IRQs %s\n",i,gv_durations[i][j],(j ? "off" : "on"));
				gv_durations[i][j] = 0;
			}
		}
	}
}
#endif

static pixelformat getformat(const VIDCList3 *params)
{
	pixelformat_t format;
	format.log2bpp = params->PixelDepth;
	format.ncolour = (1<<(1<<params->PixelDepth))-1;
	format.modeflags = (params->PixelDepth==3?ModeFlag_FullPalette:0);
	const ControlList *c = params->ControlList;
	while(c->index != -1)
	{
		if(c->index == ControlList_NColour)
			format.ncolour = c->value;
		else if(c->index == ControlList_ModeFlags)
			format.modeflags = c->value;
		c++;
	}
	return findformat(format);
}

/* Return a mask of which overlays can support the given format, for the given target. Doesn't take into account the requirements of any other overlays which may be active. */
int checkformat(overlaytarget target, pixelformat format)
{
	/* If the same feature is required by both the target and format, make sure the settings are identical */
	const omapformat_t *omapformats = headattrs[target].formats;
	int mask = omapformats[format].features_mask & headattrs[target].features_mask;
	if ((omapformats[format].features_val & mask) != (headattrs[target].features_val & mask))
		return 0;
	return omapformats[format].overlays;
}

/* Returns true if an overlay of the given format can co-exist with the current overlays */
bool canhaveoverlay(pixelformat format, const modelocked_t *modelocked)
{
	const omapformat_t *omapformats = headattrs[modelocked->default_display].formats;
	const features_t *features = features_read_lock();

	int mask = omapformats[format].features_mask & features->head_masks[modelocked->default_display]; /* Features they both care about */
	bool ok = (omapformats[format].features_val & mask) == (features->head_vals[modelocked->default_display] & mask);

	features_read_unlock();

	return ok;
}

static int do_null(_kernel_swi_regs *r)
{
	/* Nothing */
	(void) r;
	return 0;
}

static int do_vsync(_kernel_swi_regs *r)
{
	/* Nothing */
	(void) r;
	return 1;
}

static int do_setmode(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	/* TODO - Needs updating for display rotation, etc. */
	/* TODO - Should verify mode and then abort if it's bad? */
	/* TODO - How best to ensure atomicity? */
	r->r[4] = 0;
	const VIDCList3 *params = (const VIDCList3 *) r->r[0];
	const lcdtimings_t *fixed_timings;
	overlaytarget default_display;
	/* TODO - Mark head as disabled so that nothing will interact with it (but, need to avoid fooling code into thinking it needs resetting completely during the mode change) */
	/* Kill all GraphicsV overlays */
	gvoverlay_shutdown();
	{
		/* Disable and reset all overlays */
		{
			modelocked_t *modelocked = modelocked_write_lock();
			default_display = modelocked->default_display;
			/* Stop IRQ code from trying to update the overlays while we're performing the mode change */
			modelocked->overlay_desktop = OVERLAY_MAX;
			modelocked->overlay_pointer = OVERLAY_MAX;
			/* Mark the head as disabled, just to make sure nothing tries interacting with it while this mode change is in progress */
			modelocked->heads[default_display].enabled = false;
		}
		const modelocked_t *modelocked = modelocked_write_to_read();
		irqlocked_t *irqlocked = irqlocked_lock();
		for(int i=0;i<OVERLAY_MAX;i++)
		{
			overlaycfg_t *o = &irqlocked->overlays[i];
			if (o->target != TARGET_NONE)
			{
				if (o->enabled)
				{
					o->enabled = false;
					dispc_update_overlay((overlayidx) i, modelocked, irqlocked);
				}
				o->target = TARGET_NONE;
				omap_update_features((overlayidx) i, TARGET_NONE, PIXELFORMAT_MAX);
			}
			overlaycfg_reset(o);
		}
		fixed_timings = (headattrs[default_display].fixedtimings)(default_display);
		irqlocked_unlock();
		modelocked_read_unlock();
	}
	/* Process control list to determine interlace setting */
	int interlace = 0;
	for(int i=0;params->ControlList[i].index != ControlList_Terminator;i++)
		switch(params->ControlList[i].index)
		{
		case ControlList_Interlaced:
			interlace = params->ControlList[i].value;
			break;
		}
	pixelformat format = getformat(params);
	dprintf(("","do_setmode: format %s\n",pixelformatnames[format]));

	/* Calculate final modelocked_head_t */
	modelocked_head_t newstate = {0};
	if(fixed_timings)
	{
		/* Use fixed timings */
		memcpy(&newstate.mode,fixed_timings,sizeof(lcdtimings_t));
	}
	else
	{
		/* Build lcdtimings struct ready for setting mode
		   Note that we're converting any interlace timings to progressive here - this will need revising once we have support for HDMI output (add interlace flag to lcdtimings?) */
		newstate.mode.pixelrate = (params->PixelRate*1000)<<interlace;
		newstate.mode.hsw = params->HorizSyncWidth;
		/* We don't yet have anything useful to do with the border values, so just combine them with the porch values like the NVidia module */
		newstate.mode.hfp = params->HorizFrontPorch+params->HorizRightBorder;
		newstate.mode.hbp = params->HorizBackPorch+params->HorizLeftBorder;
		newstate.mode.width = params->HorizDisplaySize;
		newstate.mode.vsw = params->VertiSyncWidth<<interlace;
		newstate.mode.vfp = (params->VertiFrontPorch+params->VertiBottomBorder)<<interlace;
		newstate.mode.vbp = (params->VertiBackPorch+params->VertiTopBorder)<<interlace;
		newstate.mode.height = params->VertiDisplaySize<<interlace;
		newstate.mode.syncpol = params->SyncPol;
		/* Clamp timings if LCD. This should really be done in headattrs[].setmode! */
		if(headattrs[default_display].flags & HEADATTR_CLAMPTIMINGS)
		{
			if(newstate.mode.hsw > hwconfig->max_sync)
			{
				dprintf(("","do_setmode: Clamping HSW %d -> %d\n",newstate.mode.hsw,hwconfig->max_sync));
				newstate.mode.hsw = hwconfig->max_sync;
			}
			if(newstate.mode.hfp > hwconfig->max_porch)
			{
				dprintf(("","do_setmode: Clamping HFP %d -> %d\n",newstate.mode.hfp,hwconfig->max_porch));
				newstate.mode.hfp = hwconfig->max_porch;
			}
			if(newstate.mode.hbp > hwconfig->max_porch)
			{
				dprintf(("","do_setmode: Clamping HBP %d -> %d\n",newstate.mode.hbp,hwconfig->max_porch));
				newstate.mode.hbp = hwconfig->max_porch;
			}
			if(newstate.mode.vsw > hwconfig->max_sync)
			{
				dprintf(("","do_setmode: Clamping VSW %d -> %d\n",newstate.mode.vsw,hwconfig->max_sync));
				newstate.mode.vsw = hwconfig->max_sync;
			}
			if(newstate.mode.vfp >= hwconfig->max_porch)
			{
				dprintf(("","do_setmode: Clamping VFP %d -> %d\n",newstate.mode.vfp,hwconfig->max_porch-1));
				newstate.mode.vfp = hwconfig->max_porch-1;
			}
			if(newstate.mode.vbp >= hwconfig->max_porch)
			{
				dprintf(("","do_setmode: Clamping VBP %d -> %d\n",newstate.mode.vbp,hwconfig->max_porch-1));
				newstate.mode.vbp = hwconfig->max_porch-1;
			}
		}
	}
	newstate.dw = newstate.mode.width;
	newstate.dh = newstate.mode.height;
	newstate.enabled = true;

	(headattrs[default_display].prepmode)(default_display,&newstate,format);

	/* Set the mode */
	(headattrs[default_display].setmode)(default_display,&newstate);

	/* Pick which overlays we want to use, and record the new state */
	{
		modelocked_t *modelocked = modelocked_write_lock();
		modelocked->heads[default_display] = newstate;
		omap_pick_overlays(default_display, format, modelocked);
	}

	const modelocked_t *modelocked = modelocked_write_to_read();

	/* Update head features */
	omap_update_features(modelocked->overlay_desktop,default_display,format);

	{
		irqlocked_t *irqlocked = irqlocked_lock();
		/* Re-program & re-apply the desktop overlay
		   The pointer overlay will configure itself as and when required */
		overlaycfg_t *o = &irqlocked->overlays[modelocked->overlay_desktop];
		o->buf_w = o->scaled_w = params->HorizDisplaySize;
		o->buf_h = o->scaled_h = params->VertiDisplaySize<<interlace;
		o->x = 0;
		o->y = 0;
		o->format = format;
		o->stride = (o->buf_w*pixel_format_bpp[o->format])>>3;
		o->target = default_display;
		o->highprio = true; /* TODO: Be more intelligent with how we assign priority (e.g. rotated, downscaled, or high BPP overlay may require more bandwidth per-pixel than desktop) */
		o->enabled = true;
		/* Enable the overlay */
		dispc_update_overlay(modelocked->overlay_desktop, modelocked, irqlocked);
		irqlocked_unlock();
	}

	modelocked_read_unlock();

	return 0;
}

static int do_setblank(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	r->r[4] = 0;
	const modelocked_t *modelocked = modelocked_read_lock();
	(headattrs[modelocked->default_display].setblank)(modelocked->default_display,(r->r[0] != 0),r->r[1]);
	/* Update overlays to toggle them on/off */
	{
		const irqlocked_t *irqlocked = irqlocked_lock();
		for(int i=0;i<OVERLAY_MAX;i++)
			dispc_update_overlay((overlayidx)i, modelocked, irqlocked);
		irqlocked_unlock();
	}
	modelocked_read_unlock();

	return 0;
}

static int do_updatepointer(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	const modelocked_t *modelocked = modelocked_read_lock();
	if (modelocked->overlay_pointer == OVERLAY_MAX)
	{
		/* Either this is a call that's occurred during a mode change (in which case we can probably safely ignore it), or we're using a software pointer */
		modelocked_read_unlock();
		return 1;
	}
	mouse_update((const gvupdatepointer_t *) r, modelocked);
	modelocked_read_unlock();
	r->r[4] = 0;
	return 0;
}

static int do_setdmaaddress(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	if(r->r[0] == 0)
	{
		const modelocked_t *modelocked = modelocked_read_lock();
		if (modelocked->overlay_desktop != OVERLAY_MAX)
		{
			/* If it's OVERLAY_MAX, assume this is an IRQ-triggered call that's occurred during a mode change, and ignore it (since the OS will reset the address once the mode change is complete) */
			irqlocked_t *irqlocked = irqlocked_lock();
			irqlocked->overlays[modelocked->overlay_desktop].ba = r->r[1];
			dispc_update_overlay(modelocked->overlay_desktop, modelocked, irqlocked);
			irqlocked_unlock();
		}
		modelocked_read_unlock();
	}
	else if(r->r[0] == 3)
	{
		vdu_init = r->r[1];
	}
	r->r[4] = 0;
	return 0;
}

static int do_vetmode(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	/* TODO - Needs updating for display rotation, etc. */
	r->r[4] = 0;
	const VIDCList3 *params = (const VIDCList3 *) r->r[0];
	/* Process control list to determine interlace setting */
	int interlace = 0;
	for(int i=0;params->ControlList[i].index != ControlList_Terminator;i++)
		switch(params->ControlList[i].index)
		{
		case ControlList_Interlaced:
			interlace = params->ControlList[i].value;
			/* Check value is sensible (0 or 1) */
			if((interlace>>1) != 0)
				return 1;
			break;
		}
	/* Check colour depth */
	pixelformat format = getformat(params);
	if(format == PIXELFORMAT_MAX)
		return 1;

	const modelocked_t *modelocked = modelocked_read_lock();
	bool ok = checkformat(modelocked->default_display,format) && (headattrs[modelocked->default_display].vetmode)(modelocked->default_display,params,interlace,format);
	modelocked_read_unlock();

	if (!ok)
		return 1;
	/* Mode looks good */
	r->r[0] = 0;
	return 0;
}

static int do_displayfeatures(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	r->r[0] = GVDisplayFeature_InterlaceWithProgressiveFramestore;
	r->r[1] = 0;
	const modelocked_t *modelocked = modelocked_read_lock();
	if (modelocked->overlay_pointer != OVERLAY_MAX)
		r->r[0] |= GVDisplayFeature_HardwarePointer;
	if(checkformat(modelocked->default_display,PIXELFORMAT_1_PAL))
		r->r[1] |= 1;
	if(checkformat(modelocked->default_display,PIXELFORMAT_2_PAL))
		r->r[1] |= 2;
	if(checkformat(modelocked->default_display,PIXELFORMAT_4_PAL))
		r->r[1] |= 4;
	if(checkformat(modelocked->default_display,PIXELFORMAT_8_PAL))
		r->r[1] |= 8;
	if(checkformat(modelocked->default_display,PIXELFORMAT_1555_TBGR))
		r->r[1] |= 16;
	if(checkformat(modelocked->default_display,PIXELFORMAT_8888_TBGR))
		r->r[1] |= 32;
	modelocked_read_unlock();
	r->r[2] = 32; /* 32 byte buffer alignment? */
	r->r[4] = 0;
	return 0;
}

static int do_framestoreaddress(_kernel_swi_regs *r)
{
	/* Nothing */
	(void) r;
	return 1;
}

static bool writepaletteentries(int type,uint32_t idx,uint32_t c,const uint32_t *pal)
{
	switch(type)
	{
	case GVPaletteType_Normal:
		(gfx_palette_func)(pal,idx,c);
		break;
	case GVPaletteType_Border:
		if(!idx && c)
		{
			const modelocked_t *modelocked = modelocked_read_lock();
			irqlocked_t *irqlocked = irqlocked_lock();
			if (*pal != irqlocked->heads[modelocked->default_display].background)
			{
				irqlocked->heads[modelocked->default_display].background = *pal;
				(headattrs[modelocked->default_display].setbackground)(modelocked->default_display,irqlocked);
			}
			irqlocked_unlock();
			modelocked_read_unlock();
		}
		break;
	case GVPaletteType_Pointer:
		mouse_palette_write(pal,idx,c);
		break;
	default:
		return false;
	}
	return true;
}

static int do_writepaletteentry(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	if (writepaletteentries(r->r[0],r->r[2],1,(const uint32_t *) &r->r[1]))
	{
		r->r[4] = 0;
		return 0;
	}
	return 1;
}

static int do_writepaletteentries(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	uint32_t idx = r->r[2];
	uint32_t c = r->r[3];
	const uint32_t *pal = (const uint32_t *) r->r[1];
	if (writepaletteentries(r->r[0],idx,c,pal))
	{
		r->r[4] = 0;
		return 0;
	}
	return 1;
}

static int do_readpaletteentry(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	switch(r->r[0])
	{
	case GVPaletteType_Normal:
	case GVPaletteType_Border:
	case GVPaletteType_Pointer:
		break;
	case GVPaletteType_ColourKey:
		{
			const modelocked_t *modelocked = modelocked_read_lock();
			irqlocked_t *irqlocked = irqlocked_lock();
			pixelformat format = irqlocked->overlays[modelocked->overlay_desktop].format;
			uint32_t mask = 0;
			uint32_t val = 0;
			if ((modelocked->default_display != TARGET_NONE) && (modelocked->overlay_desktop != OVERLAY_MAX))
			{
				/* With the current setup, alpha blending is always used (and TCK disabled) if we're in an alpha screen mode
				   Otherwise, assume TCK is in use */
				switch(format)
				{
				case PIXELFORMAT_4444_ABGR:
				case PIXELFORMAT_4444_ARGB:
					mask = 0xf000;
					break;
				case PIXELFORMAT_1555_ABGR:
				case PIXELFORMAT_1555_ARGB:
					mask = 0x8000;
					break;
				case PIXELFORMAT_8888_ABGR:
				case PIXELFORMAT_8888_ARGB:
					mask = 0xff000000;
					break;
				default:
					mask = 0xffffff & ((1<<pixel_format_bpp[format])-1);
					val = irqlocked->heads[modelocked->default_display].transparent;
					break;
				}
			}
			switch(r->r[2])
			{
			case 0:
				r->r[1] = val & mask;
				break;
			case 1:
				r->r[1] = mask;
				break;
			}
			irqlocked_unlock();
			modelocked_read_unlock();
		}
		break;
	default:
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_render(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	/* Grab a copy of the desktop overlay state, to avoid keeping IRQs disabled while we wait for the DMA
	   The overlay state shouldn't change in any significant way while we're here */
	overlaycfg_t o;
	o.target = TARGET_NONE;
	{
		const modelocked_t *modelocked = modelocked_read_lock();
		if (modelocked->overlay_desktop != OVERLAY_MAX)
		{
			o = irqlocked_lock()->overlays[modelocked->overlay_desktop];
			irqlocked_unlock();
		}
		modelocked_read_unlock();
	}
	if(!sdmachan || (o.target == TARGET_NONE) || (vdu_init == ~0)) /* Protect against (unlikely) event of lack of acceleration, or (likely) event of us not knowing the framebuffer setup yet */
		return 1;
	switch(r->r[1])
	{
	case GVRender_NOP:
		goto complete;
	case GVRender_CopyRectangle:
		if(!sdma_copyrect(&o,(copyrect_params_t *)r->r[2], vdu_init))
			break;
		goto complete;
	case GVRender_FillRectangle:
		if(!sdma_fillrect(&o,(fillrect_params_t *)r->r[2], vdu_init))
			break;
		goto complete;
	}
	if(r->r[0] & GVRender_SyncIfNotComplete)
		sdma_sync();
	return 1;
complete:
	if(r->r[0] & GVRender_SyncIfComplete)
		sdma_sync();
	r->r[4] = 0;
	return 0;
}

static int do_iicop(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	/* Play it safe and don't hold the lock while the IIC op is in progress */
	overlaytarget default_display = modelocked_read_lock()->default_display;;
	modelocked_read_unlock();
	(headattrs[default_display].iicop)(default_display,r);
	return (r->r[4]?1:0);
}

static int do_selecthead(_kernel_swi_regs *r)
{
	/* TODO? */
	(void) r;
	return 1;
}

static int do_pixelformats(_kernel_swi_regs *r)
{
	/* Only support head 0 */
	if (r->r[4] & 0xff0000)
	{
		return 1;
	}
	/* Tailor list depending on which head is in use for desktop */
	/* TODO - In the future, might also want to tailor by which overlay is in use (although this is complicated by omap_pick_overlays - we'd need to look for any of the overlays which can be chosen for the desktop) */
	static pixelformat_t pixelformats2[PIXELFORMAT_NORMAL_MAX];
	int j=0;
	const modelocked_t *modelocked = modelocked_read_lock();
	for(int i=0;i<PIXELFORMAT_NORMAL_MAX;i++)
	{
		if(checkformat(modelocked->default_display,(pixelformat) i))
			pixelformats2[j++] = pixelformats[i];
	}
	modelocked_read_unlock();
	r->r[0] = (int) pixelformats2;
	r->r[1] = j;
	r->r[4] = 0;
	return 0;
}

static int do_readinfo(_kernel_swi_regs *r)
{
	const void *src = NULL;
	int len = 0;
	int version = 0;
	int controllist[] = {
		ControlList_Interlaced,
		ControlList_NColour,
		ControlList_ModeFlags,
		ControlList_Terminator
	};
	switch(r->r[0])
	{
	case GVReadInfo_Version:
		src = &version;
		len = sizeof(version);
		for(int i=0,j=Module_VersionNumber;i<6;i++,j/=10)
			version |= (j % 10)<<(i*4+8);
		break;
	case GVReadInfo_ModuleName: /* Only one module instance assumed */
	case GVReadInfo_DriverName:
		src = Module_Title;
		len = sizeof(Module_Title); /* Includes terminator */
		break;
	case GVReadInfo_HardwareName:
		src = dev->dev.description;
		len = strlen(src)+1;
		break;
	case GVReadInfo_ControlListItems:
		src = controllist;
		len = sizeof(controllist);
		break;
	case GVReadInfo_MaxOverlays:
		src = &version;
		len = sizeof(version);
		version = GVOVERLAY_MAX;
		break;
	}
	if(!len)
		return 1;
	int copy = ((len < r->r[2])?len:r->r[2]);
	memcpy((void *) r->r[1],src,copy);
	r->r[2] -= len;
	r->r[4] = 0;
	return 0;
}

static int do_createoverlay(_kernel_swi_regs *r)
{
	const modeselector_t *desc = (const modeselector_t *) r->r[0];
	gvoverlay_create_vet_result_t result;
	const modelocked_t *modelocked = modelocked_read_lock();
	_kernel_oserror *e = gvoverlay_create(desc, r->r[1], r->r[2], r->r[3], modelocked, &result, &r->r[0]);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_createoverlay: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[0] += TARGET_MAX; /* Remap internal overlay number to not overlap head numbers */
	r->r[1] = result.return_flags;
	r->r[2] = result.min_w;
	r->r[3] = result.min_h;
	r->r[4] = 0;
	r->r[5] = result.max_w;
	r->r[6] = result.max_h;
	return 0;
}

static int do_vetoverlay(_kernel_swi_regs *r)
{
	const modeselector_t *desc = (const modeselector_t *) r->r[0];
	gvoverlay_create_vet_result_t result;
	const modelocked_t *modelocked = modelocked_read_lock();
	_kernel_oserror *e = gvoverlay_vet(desc, r->r[1], r->r[2], r->r[3], modelocked, &result);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_vetoverlay: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[1] = result.return_flags;
	r->r[2] = result.min_w;
	r->r[3] = result.min_h;
	r->r[4] = 0;
	r->r[5] = result.max_w;
	r->r[6] = result.max_h;
	return 0;
}

static int do_destroyoverlay(_kernel_swi_regs *r)
{
	_kernel_oserror *e;
	int min,max;
	if (r->r[4] & 0xff0000)
	{
		min = max = GET_OVERLAY(r);
	}
	else
	{
		min = 0;
		max = GVOVERLAY_MAX-1;
	}
	const modelocked_t *modelocked = modelocked_read_lock();
	do
	{
		e = gvoverlay_destroy(min, modelocked);
	} while (!e && (++min <= max));
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_destroyoverlay: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_setoverlayposition(_kernel_swi_regs *r)
{
	int x,y,bank;
	switch (r->r[1])
	{
	case 0:
		x=y=0;
		bank=-1;
		break;
	case 1:
		{
			int *arr = (int *) r->r[0];
			if (arr[0] != 0)
			{
				dprintf(("","do_setoverlayposition: bad head number\n"));
				return 1;
			}
			x = arr[1];
			y = arr[2];
			bank = r->r[2];
		}
		break;
	default:
		dprintf(("","do_setoverlayposition: bad head count\n"));
		return 1;
	}
	_kernel_oserror *e;
	const modelocked_t *modelocked = modelocked_read_lock();
	e = gvoverlay_setposition(GET_OVERLAY(r),x,y,bank,modelocked);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_setoverlayposition: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_mapoverlaybuffer(_kernel_swi_regs *r)
{
	_kernel_oserror *e = gvoverlay_map(GET_OVERLAY(r),r->r[0],(gvoverlay_plane_mapping_t **)(&r->r[0]));
	if (e)
	{
		dprintf(("","do_mapoverlaybuffer: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_unmapoverlaybuffer(_kernel_swi_regs *r)
{
	_kernel_oserror *e = gvoverlay_unmap(GET_OVERLAY(r),r->r[0]);
	if (e)
	{
		dprintf(("","do_unmapoverlaybuffer: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_discardoverlaybuffer(_kernel_swi_regs *r)
{
	const modelocked_t *modelocked = modelocked_read_lock();
	_kernel_oserror *e = gvoverlay_discard(GET_OVERLAY(r),r->r[0],modelocked);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_discardoverlaybuffer: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_setoverlaytransform(_kernel_swi_regs *r)
{
	const modelocked_t *modelocked = modelocked_read_lock();
	_kernel_oserror *e = gvoverlay_settransform(GET_OVERLAY(r),(gvoverlay_transform_t *) r->r,modelocked);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_setoverlaytransform: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

static int do_setoverlayzorder(_kernel_swi_regs *r)
{
	const modelocked_t *modelocked = modelocked_read_lock();
	_kernel_oserror *e = gvoverlay_setzorder((const uint8_t *) r->r[0],r->r[1],modelocked);
	modelocked_read_unlock();
	if (e)
	{
		dprintf(("","do_setoverlayzorder: err %08x %s\n",e->errnum,e->errmess));
		return 1;
	}
	r->r[4] = 0;
	return 0;
}

#ifdef DEBUGLIB
#define GVOVERLAYTRACE
#endif

int graphicsv_handler(_kernel_swi_regs *r,void *pw)
{
	(void) pw;
	if((((uint32_t)r->r[4])>>24) != graphicsv_driver_number)
		return 1;
	uint16_t func = (uint16_t) r->r[4];
#ifdef GVOVERLAYTRACE
	/* Output BASIC commands to allow activity to be replayed for easier debugging */
	if ((func == GraphicsV_CreateOverlay)
	 || (func == GraphicsV_SetOverlayPosition)
	 || (func == GraphicsV_SetOverlayTransform)
	 || (func == GraphicsV_SetOverlayZOrder))
	{
		int datlen = 0;
		if (func == GraphicsV_CreateOverlay)
		{
			datlen = sizeof(modeselector_t) + 64;
		}
		else if (func == GraphicsV_SetOverlayZOrder)
		{
			datlen = r->r[1];
		}
		else if (func == GraphicsV_SetOverlayPosition)
		{
			datlen = r->r[1]*12;
		}
		int i=0;
		const uint8_t *dat = (const uint8_t *) r->r[0];
		while (i < (datlen&~3))
		{
			dprintf(("","TRACE: b%%!%d=&%02x%02x%02x%02x\n",i,dat[i+3],dat[i+2],dat[i+1],dat[i]));
			i += 4;
		}
		while (i < datlen)
		{
			dprintf(("","TRACE: b%%?%d=&%02x\n",i,dat[i]));
			i++;
		}
		if (func == GraphicsV_CreateOverlay)
		{
			dprintf(("","TRACE: SYS \"OS_CallAVector\",b%%,&%x,&%x,&%x,&%x,,,,,42 TO o%%\n",r->r[1],r->r[2],r->r[3],r->r[4]));
		}
		else if (datlen)
		{
			/* R0 = buffer, R1, R2 = arguments */
			dprintf(("","TRACE: SYS \"OS_CallAVector\",b%%,&%x,&%x,,&%x + (o%%<<16),,,,,42\n",r->r[1],r->r[2],r->r[4] & ~0xff0000));
		}
		else if (func == GraphicsV_SetOverlayTransform)
		{
			/* R0-R7 = arguments */
			dprintf(("","TRACE: SYS \"OS_CallAVector\",&%x,&%x,&%x,&%x,&%x + (o%%<<16),&%x,&%x,&%x,,42\n",r->r[0],r->r[1],r->r[2],r->r[3],r->r[4] & ~0xff0000,r->r[5],r->r[6],r->r[7]));
		}
		else
		{
			/* R0-R2 = arguments */
			dprintf(("","TRACE: SYS \"OS_CallAVector\",&%x,&%x,&%x,,&%x + (o%%<<16),,,,,42\n",r->r[0],r->r[1],r->r[2],r->r[4] & ~0xff0000));
		}
		dprintf(("","TRACE: PROCstep\n"));
	}
#endif
	int ret = 1;
#ifdef DEBUGLIB
	uint32_t time = ((func < NUM_GV_CALLS) ? timer_read() : 0);
#endif
	switch(func)
	{
	case GraphicsV_Complete:		ret = do_null(r); break;
	case GraphicsV_VSync:			ret = do_vsync(r); break;
	case GraphicsV_SetMode:			ret = do_setmode(r); break;
	case GraphicsV_SetBlank:		ret = do_setblank(r); break;
	case GraphicsV_UpdatePointer:		ret = do_updatepointer(r); break;
	case GraphicsV_SetDMAAddress:		ret = do_setdmaaddress(r); break;
	case GraphicsV_VetMode:			ret = do_vetmode(r); break;
	case GraphicsV_DisplayFeatures:		ret = do_displayfeatures(r); break;
	case GraphicsV_FramestoreAddress:	ret = do_framestoreaddress(r); break;
	case GraphicsV_WritePaletteEntry:	ret = do_writepaletteentry(r); break;
	case GraphicsV_WritePaletteEntries:	ret = do_writepaletteentries(r); break;
	case GraphicsV_ReadPaletteEntry:	ret = do_readpaletteentry(r); break;
	case GraphicsV_Render:			ret = do_render(r); break;
	case GraphicsV_IICOp:			ret = do_iicop(r); break;
	case GraphicsV_SelectHead:		ret = do_selecthead(r); break;
	case GraphicsV_PixelFormats:		ret = do_pixelformats(r); break;
	case GraphicsV_ReadInfo:		ret = do_readinfo(r); break;
	case GraphicsV_CreateOverlay:		ret = do_createoverlay(r); break;
	case GraphicsV_DestroyOverlay:		ret = do_destroyoverlay(r); break;
	case GraphicsV_SetOverlayPosition:	ret = do_setoverlayposition(r); break;
	case GraphicsV_MapOverlayBuffer:	ret = do_mapoverlaybuffer(r); break;
	case GraphicsV_UnmapOverlayBuffer:	ret = do_unmapoverlaybuffer(r); break;
	case GraphicsV_DiscardOverlayBuffer:	ret = do_discardoverlaybuffer(r); break;
	case GraphicsV_VetOverlay:		ret = do_vetoverlay(r); break;
	case GraphicsV_SetOverlayTransform:	ret = do_setoverlaytransform(r); break;
	case GraphicsV_SetOverlayZOrder:	ret = do_setoverlayzorder(r); break;

	case GraphicsV_StartupMode:		/* Unimplemented */
	case GraphicsV_SetInterlace:		/* Deprecated */
	default:				ret = 1; break;
	}
#ifdef DEBUGLIB
	if (time)
	{
		time = time - timer_read();
		int idx = (_kernel_irqs_disabled() ? 1 : 0);
		if (gv_durations[func][idx] < time)
		{
			gv_durations[func][idx] = time;
		}
	}
#endif
	return ret;
}
@


1.19
log
@Big code refactor
Detail:
  Support for different OMAP revisions has now been abstracted, with code specific to a certain OMAP revision now located in the omap3 and omap4 folders. This has resulted in some code duplication, but greater readability due to the removal of the #defines that were in use before. This new structure should also make it easier to implement new features, especially those only supported by certain OMAPs.
  Each platform provides a headattrs struct and an overlayattrs struct, which are the primary interface the core code uses to control the backend. Eventually it may be possible to produce one build of the module which supports multiple OMAP revisions at runtime, but for now some #defines and OMAP-specific code remains in the common files.
  This change also adds support for extra pixel formats, gamma table support for OMAP4, and fixes several bugs.
Admin:
  Tested on BeagleBoard, PandaBoard


Version 0.34. Tagged as 'OMAPVideo-0_34'
@
text
@a40 1
#include "videodevice.h"
a41 1
#include "globals.h"
d44 11
d56 6
a61 1
static const pixelformat_t pixelformats[PIXELFORMAT_NORMAL_MAX] =
d63 13
a75 21
	{ 1, 0, 0 }, // PIXELFORMAT_1_PAL,
	{ 3, 0, 1 }, // PIXELFORMAT_2_PAL,
	{ 15, 0, 2 },// PIXELFORMAT_4_PAL,
	{ 255, ModeFlag_FullPalette, 3 }, // PIXELFORMAT_8_PAL,
	{ 4095, 0, 4 }, // PIXELFORMAT_4444_TBGR,
	{ 4095, ModeFlag_DataFormatSub_RGB, 4 }, // PIXELFORMAT_4444_TRGB,
	{ 4095, ModeFlag_DataFormatSub_Alpha, 4 }, // PIXELFORMAT_4444_ABGR,
	{ 4095, ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB, 4 }, // PIXELFORMAT_4444_ARGB,
	{ 65535, 0, 4 }, // PIXELFORMAT_1555_TBGR,
	{ 65535, ModeFlag_DataFormatSub_RGB, 4 }, // PIXELFORMAT_1555_TRGB,
	{ 65535, ModeFlag_DataFormatSub_Alpha, 4 }, // PIXELFORMAT_1555_ABGR,
	{ 65535, ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB, 4 }, // PIXELFORMAT_1555_ARGB,
	{ 65535, ModeFlag_64k, 4 }, // PIXELFORMAT_565_BGR,
	{ 65535, ModeFlag_64k+ModeFlag_DataFormatSub_RGB, 4 }, // PIXELFORMAT_565_RGB,
	{ 16777215, 0, 6 }, // PIXELFORMAT_888_BGR,
	{ 16777215, ModeFlag_DataFormatSub_RGB, 6 }, // PIXELFORMAT_888_RGB,
	{ -1, 0, 5 }, // PIXELFORMAT_8888_TBGR,
	{ -1, ModeFlag_DataFormatSub_RGB, 5 }, // PIXELFORMAT_8888_TRGB,
	{ -1, ModeFlag_DataFormatSub_Alpha, 5 }, // PIXELFORMAT_8888_ABGR,
	{ -1, ModeFlag_DataFormatSub_Alpha+ModeFlag_DataFormatSub_RGB, 5 }, // PIXELFORMAT_8888_ARGB,
};
d92 1
a92 10
	for(int i=0;i<PIXELFORMAT_NORMAL_MAX;i++)
	{
		if((format.ncolour == pixelformats[i].ncolour)
		 && (format.modeflags == pixelformats[i].modeflags)
		 && (format.log2bpp == pixelformats[i].log2bpp))
		{
			return (pixelformat) i;
		}
	}
	return PIXELFORMAT_MAX;
d95 2
a96 1
static int checkformat(overlaytarget target, pixelformat format)
d106 14
d136 5
d146 37
a182 4
	/* Disable any overlays that are currently using the default display? */
	for(int i=0;i<OVERLAY_MAX;i++)
		if(overlaycfgs[i].target == default_display)
			overlaycfgs[i].target = TARGET_NONE;
d192 5
a196 15
	/* TODO search for overlays to use for desktop, pointer, plus pick z order, etc. */
	/* Update (but don't apply) main overlay */
	overlaycfg_t *o = &overlaycfgs[overlay_desktop];
	o->width = params->HorizDisplaySize;
	o->height = params->VertiDisplaySize<<interlace;
	o->x = 0;
	o->y = 0;
	o->format = getformat(params);
	dprintf(("","do_setmode: format %s\n",pixelformatnames[o->format]));
	o->stride = (o->width*pixel_format_bpp[o->format])>>3;
	o->target = default_display;
	o->enabled = true;
	lcdtimings_t *timings = &headcfgs[default_display].mode;
	const lcdtimings_t *fixed_timings = (headattrs[default_display].fixedtimings)(default_display);
	
d200 1
a200 1
		memcpy(timings,fixed_timings,sizeof(lcdtimings_t));
d206 2
a207 2
		timings->pixelrate = (params->PixelRate*1000)<<interlace;
		timings->hsw = params->HorizSyncWidth;
d209 8
a216 8
		timings->hfp = params->HorizFrontPorch+params->HorizRightBorder;
		timings->hbp = params->HorizBackPorch+params->HorizLeftBorder;
		timings->width = params->HorizDisplaySize;
		timings->vsw = params->VertiSyncWidth<<interlace;
		timings->vfp = (params->VertiFrontPorch+params->VertiBottomBorder)<<interlace;
		timings->vbp = (params->VertiBackPorch+params->VertiTopBorder)<<interlace;
		timings->height = params->VertiDisplaySize<<interlace;
		timings->syncpol = params->SyncPol;
d220 1
a220 1
			if(timings->hsw > hwconfig->max_sync)
d222 2
a223 2
				dprintf(("","do_setmode: Clamping HSW %d -> %d\n",timings->hsw,hwconfig->max_sync));
				timings->hsw = hwconfig->max_sync;
d225 1
a225 1
			if(timings->hfp > hwconfig->max_porch)
d227 2
a228 2
				dprintf(("","do_setmode: Clamping HFP %d -> %d\n",timings->hfp,hwconfig->max_porch));
				timings->hfp = hwconfig->max_porch;
d230 1
a230 1
			if(timings->hbp > hwconfig->max_porch)
d232 2
a233 2
				dprintf(("","do_setmode: Clamping HBP %d -> %d\n",timings->hbp,hwconfig->max_porch));
				timings->hbp = hwconfig->max_porch;
d235 1
a235 1
			if(timings->vsw > hwconfig->max_sync)
d237 2
a238 2
				dprintf(("","do_setmode: Clamping VSW %d -> %d\n",timings->vsw,hwconfig->max_sync));
				timings->vsw = hwconfig->max_sync;
d240 1
a240 1
			if(timings->vfp >= hwconfig->max_porch)
d242 2
a243 2
				dprintf(("","do_setmode: Clamping VFP %d -> %d\n",timings->vfp,hwconfig->max_porch-1));
				timings->vfp = hwconfig->max_porch-1;
d245 1
a245 1
			if(timings->vbp >= hwconfig->max_porch)
d247 2
a248 2
				dprintf(("","do_setmode: Clamping VBP %d -> %d\n",timings->vbp,hwconfig->max_porch-1));
				timings->vbp = hwconfig->max_porch-1;
d252 42
a293 2
	/* Now set the mode, which will also re-apply overlay settings */
	(headattrs[default_display].setmode)(default_display);
d299 5
d305 2
a306 3
	headcfgs[default_display].blanked = (r->r[0] != 0);
	headcfgs[default_display].dpms = r->r[1];
	(headattrs[default_display].setblank)(default_display);
d308 7
a314 2
	for(int i=0;i<OVERLAY_MAX;i++)
		dispc_update_overlay((overlayidx)i);
d321 4
a324 91
	/* TODO - What if palette change isn't immediately followed by an updatepointer call? Need to stick something in IRQ handler that does a secondary update on vsync */
	/* TODO - Turn IRQs off at this level to avoid overlay array corruption? */
	/* TODO - Needs updating for alpha blending instead of TCK */
	shape_t *shape = ((shape_t *) r->r[3]);
	r->r[4] = 0;
	overlaycfg_t *o = &overlaycfgs[overlay_pointer];
	if(r->r[0] & 1)
	{
		/* Redo palette if needed */
		int dirty = 32*32/4; /* Number of dirty bytes */
		uint8_t *src = (uint8_t *) shape->buffLA;
		uint8_t *dest = mouse_image_soft;
		uint32_t *real = mouse_image_l;
		int incount=shape->height*32/4; /* Number of bytes left in input */
		if(incount > dirty)
			incount = dirty; /* Protect against dodgy heights */
		if(mouse_dirty)
		{
			uint32_t trans = mouse_palette_soft[0];
			while((trans == mouse_palette_soft[1]) || (trans == mouse_palette_soft[2]) || (trans == mouse_palette_soft[3]))
				trans = (trans+1)&0xffffff;
			mouse_palette_soft[0] = trans;
			if(headcfgs[default_display].transparent != trans)
			{
				headcfgs[default_display].transparent = trans;
				(headattrs[default_display].settransparent)(default_display);
			}
		}
		else if(r->r[0] & 2)
		{
			while(incount>0)
			{
				if(*((uint32_t *)src) != *((uint32_t *)dest)) /* Check words for speed */
					goto rebuild;
				src+=4;
				dest+=4;
				real+=16;
				dirty-=4;
				incount-=4;
			}
			while(dirty>0)
			{
				if(*((uint32_t *)dest))
					goto rebuild;
				dest+=4;
				real+=16;
				dirty-=4;
			}
		}
		/* Redo image if needed
		   Note that we always pad it out to 32x32; should make life easier once we have rotation support */
		/* TODO - Make faster - test each individual byte to see if it matches dest - should speed up most stuff where only small portions change (e.g. ourglass) */
		if(mouse_dirty)
		{
			rebuild:
			while(dirty-->0)
			{
				uint8_t data = (incount-->0?*src++:0);
				*dest++ = data;
				*real++ = mouse_palette_soft[data & 3];
				data = data >> 2;
				*real++ = mouse_palette_soft[data & 3];
				data = data >> 2;
				*real++ = mouse_palette_soft[data & 3];
				data = data >> 2;
				*real++ = mouse_palette_soft[data];
			}
			mouse_dirty = false;
		}
		/* Redo position & other overlay attribs if needed */
		int x = r->r[1]+overlaycfgs[overlay_desktop].x;
		int y = r->r[2]+overlaycfgs[overlay_desktop].y;
		if((o->x != x) || (o->y != y) || (o->target != default_display) || !o->enabled)
		{
			if(o->target != default_display)
			{
				headcfgs[default_display].transparent = mouse_palette_soft[0];
				(headattrs[default_display].settransparent)(default_display);
			}
			o->width = 32;
			o->height = 32;
			o->x = x;
			o->y = y;
			o->format = PIXELFORMAT_POINTER;
			o->ba = mouse_image_p;
			o->stride = 32*4;
			o->la = (uint8_t *) mouse_image_l; /* Logical address not really needed, but fill it in anyway */
			o->target = default_display;
			o->enabled = true;
			dispc_update_overlay(overlay_pointer);
		}
d326 2
a327 1
	else if(o->enabled)
d329 3
a331 2
		o->enabled = false;
		dispc_update_overlay(overlay_pointer);
d333 3
d341 5
d348 10
a357 8
		/* IRQs off for atomicity */
		int irqs = _kernel_irqs_disabled();
		if(!irqs)
			_kernel_irqs_off();
		overlaycfgs[overlay_desktop].ba = r->r[1];
		dispc_update_overlay(overlay_desktop);
		if(!irqs)
			_kernel_irqs_on();
d369 5
d393 6
a398 4
	if(!checkformat(default_display,format))
		return 1;
	/* Do display-specific checks */
	if(!(headattrs[default_display].vetmode)(default_display,params,interlace,format))
d407 6
a412 2
	r->r[0] = GVDisplayFeature_HardwarePointer
	        | GVDisplayFeature_InterlaceWithProgressiveFramestore;
d414 4
a417 1
	if(checkformat(default_display,PIXELFORMAT_1_PAL))
d419 1
a419 1
	if(checkformat(default_display,PIXELFORMAT_2_PAL))
d421 1
a421 1
	if(checkformat(default_display,PIXELFORMAT_4_PAL))
d423 1
a423 1
	if(checkformat(default_display,PIXELFORMAT_8_PAL))
d425 1
a425 1
	if(checkformat(default_display,PIXELFORMAT_1555_TBGR))
d427 1
a427 1
	if(checkformat(default_display,PIXELFORMAT_8888_TBGR))
d429 1
d442 1
a442 1
static int do_writepaletteentry(_kernel_swi_regs *r)
d444 1
a444 3
	r->r[4] = 0;
	uint32_t idx = r->r[2];
	switch(r->r[0])
d446 2
a447 2
	case 0:
		(gfx_palette_func)((uint32_t *) &r->r[1],idx,1);
d449 2
a450 2
	case 1:
		if(!idx && (r->r[1] != headcfgs[default_display].background))
d452 9
a460 2
			headcfgs[default_display].background = r->r[1];
			(headattrs[default_display].setbackground)(default_display);
d463 2
a464 2
	case 2:
		(mouse_palette_func)((uint32_t *) &r->r[1],idx,1);
d466 17
d484 1
a484 1
	return 0;
d489 5
a493 2
	/* TODO - Handle potential lack of CPR for border colour */
	r->r[4] = 0;
d496 16
a511 1
	uint32_t *pal = (uint32_t *) r->r[1];
d514 3
a516 2
	case 0:
		(gfx_palette_func)(pal,idx,c);
d518 1
a518 2
	case 1:
		if(!idx && c && (r->r[1] != headcfgs[default_display].background))
d520 40
a559 2
			headcfgs[default_display].background = r->r[1];
			(headattrs[default_display].setbackground)(default_display);
d562 2
a563 3
	case 2:
		(mouse_palette_func)(pal,idx,c);
		break;
a564 5
	return 0;
}

static int do_readpaletteentry(_kernel_swi_regs *r)
{
d571 19
a589 2
	overlaycfg_t *o = &overlaycfgs[overlay_desktop];
	if(!sdmachan || (o->target == TARGET_NONE) || (vdu_init == ~0)) /* Protect against (unlikely) event of lack of acceleration, or (likely) event of us not knowing the framebuffer setup yet */
d596 1
a596 1
		if(!sdma_copyrect(o,(copyrect_params_t *)r->r[2]))
d600 1
a600 1
		if(!sdma_fillrect(o,(fillrect_params_t *)r->r[2]))
d616 8
d632 1
a632 1
	return 0;
d637 5
d643 1
a643 1
	/* TODO - In the future, might also want to tailor by which overlay is in use */
d646 1
d649 1
a649 1
		if(checkformat(default_display,(pixelformat) i))
d652 1
d691 5
d706 180
d892 58
d952 26
a977 17
	case GraphicsV_Complete:		return do_null(r);
	case GraphicsV_VSync:			return do_vsync(r);
	case GraphicsV_SetMode:			return do_setmode(r);
	case GraphicsV_SetBlank:		return do_setblank(r);
	case GraphicsV_UpdatePointer:		return do_updatepointer(r);
	case GraphicsV_SetDMAAddress:		return do_setdmaaddress(r);
	case GraphicsV_VetMode:			return do_vetmode(r);
	case GraphicsV_DisplayFeatures:		return do_displayfeatures(r);
	case GraphicsV_FramestoreAddress:	return do_framestoreaddress(r);
	case GraphicsV_WritePaletteEntry:	return do_writepaletteentry(r);
	case GraphicsV_WritePaletteEntries:	return do_writepaletteentries(r);
	case GraphicsV_ReadPaletteEntry:	return do_readpaletteentry(r);
	case GraphicsV_Render:			return do_render(r);
	case GraphicsV_IICOp:			return do_iicop(r);
	case GraphicsV_SelectHead:		return do_selecthead(r);
	case GraphicsV_PixelFormats:		return do_pixelformats(r);
	case GraphicsV_ReadInfo:		return do_readinfo(r);
d981 11
a991 1
	default:				return 1;
d993 2
@


1.18
log
@Add GraphicsV_ReadInfo implementation
Detail:
  c/graphicsv - Added GraphicsV_ReadInfo implementation
Admin:
  Tested on BB-xM


Version 0.33. Tagged as 'OMAPVideo-0_33'
@
text
@d28 2
a31 2
#include <stddef.h>
#include <string.h>
a40 1
#include "regs.h"
a44 2
#include "dss.h"
#include "venc.h"
d47 23
d71 1
a71 1
static const pixelformat_t pixelformats[] =
d73 24
a96 9
#if OMAP==3
	{ 1, 0, 0 },
	{ 3, 0, 1 },
	{ 15, 0, 2 },
#endif
	{ 255, ModeFlag_FullPalette, 3 },
	{ 65535, 0, 4 },
	{ -1, 0, 5 },
};
d98 1
a98 1
static const pixelformat_t pixelformats_tvout[] =
d100 7
a106 9
#if OMAP==3
	{ 1, 0, 0 },
	{ 3, 0, 1 },
	{ 15, 0, 2 },
#endif
	{ 255, ModeFlag_FullPalette, 3 },
	{ 65535, ModeFlag_64k+ModeFlag_DataFormatSub_RGB, 4 },
	{ -1, ModeFlag_DataFormatSub_RGB, 5 },
};
a123 1
	/* TODO - Needs updating for TV output */
a125 2
	/* TODO - Should take into account fixed LCD */
	/* TODO - Need to decide what to do with border */
d128 1
a128 1
	VIDCList3 *params = (VIDCList3 *) r->r[0];
d131 2
a132 2
		if(overlays[i].target == default_display)
			overlays[i].target = TARGET_NONE;
d142 1
d144 1
a144 1
	overlay_t *o = &overlays[overlay_desktop];
d149 9
a157 1
	switch(params->PixelDepth)
d159 2
a160 23
	case VIDCLIST3_1BPP:
		o->format = OVERLAY_ATTRIBUTES_FORMAT_BMP1;
		break;
	case VIDCLIST3_2BPP:
		o->format = OVERLAY_ATTRIBUTES_FORMAT_BMP2;
		break;
	case VIDCLIST3_4BPP:
		o->format = OVERLAY_ATTRIBUTES_FORMAT_BMP4;
		break;
	case VIDCLIST3_8BPP:
		o->format = OVERLAY_ATTRIBUTES_FORMAT_BMP8;
		break;
	case VIDCLIST3_16BPP:
#if OMAP==3
		o->format = OVERLAY_ATTRIBUTES_FORMAT_RGB16_565;
#endif
#if OMAP==4
		o->format = OVERLAY_ATTRIBUTES_FORMAT_xRGB15_1555;
#endif
		break;
	case VIDCLIST3_32BPP:
		o->format = OVERLAY_ATTRIBUTES_FORMAT_xRGB24_8888;
		break;
d162 1
a162 7
	o->stride = (o->width*overlay_format_bpp[o->format>>OVERLAY_ATTRIBUTES_FORMAT_SHIFT])>>3;
	o->target = default_display;
	/* Select appropriate palette func for this new mode */
	if(overlay_desktop == OVERLAY_GFX)
		select_palette_func(o->format,(default_display == TARGET_LCD));
	/* Now set the mode, which will also re-apply overlay settings */
	if(default_display == TARGET_LCD)
d164 15
a178 6
		if(hwconfig->lcd_configs[current_lcd].lcd_timings)
		{
			/* Use fixed timings */
			dispc_set_lcdmode(hwconfig->lcd_configs[current_lcd].lcd_timings);
		}
		else
d180 1
a180 6
			/* Build lcdtimings struct ready for setting mode
			   Note that we assume these are progressive timings (interlace for LCD output will have been rejected by vetmode, but is acceptable for TV-out and will one day by acceptable for HDMI) */
			lcdtimings_t timings;
			timings.pixelrate = params->PixelRate*1000;
			timings.hsw = params->HorizSyncWidth;
			if(timings.hsw > hwconfig->max_sync)
d182 2
a183 2
				dprintf(("","do_setmode: Clamping HSW %d -> %d\n",timings.hsw,hwconfig->max_sync));
				timings.hsw = hwconfig->max_sync;
d185 1
a185 3
			/* We don't yet have anything useful to do with the border values, so just combine them with the porch values like the NVidia module */
			timings.hfp = params->HorizFrontPorch+params->HorizRightBorder;
			if(timings.hfp > hwconfig->max_porch)
d187 2
a188 2
				dprintf(("","do_setmode: Clamping HFP %d -> %d\n",timings.hfp,hwconfig->max_porch));
				timings.hfp = hwconfig->max_porch;
d190 1
a190 2
			timings.hbp = params->HorizBackPorch+params->HorizLeftBorder;
			if(timings.hbp > hwconfig->max_porch)
d192 2
a193 2
				dprintf(("","do_setmode: Clamping HBP %d -> %d\n",timings.hbp,hwconfig->max_porch));
				timings.hbp = hwconfig->max_porch;
d195 1
a195 3
			timings.width = params->HorizDisplaySize;
			timings.vsw = params->VertiSyncWidth;
			if(timings.vsw > hwconfig->max_sync)
d197 2
a198 2
				dprintf(("","do_setmode: Clamping VSW %d -> %d\n",timings.vsw,hwconfig->max_sync));
				timings.vsw = hwconfig->max_sync;
d200 1
a200 2
			timings.vfp = params->VertiFrontPorch+params->VertiBottomBorder;
			if(timings.vfp >= hwconfig->max_porch)
d202 2
a203 2
				dprintf(("","do_setmode: Clamping VFP %d -> %d\n",timings.vfp,hwconfig->max_porch-1));
				timings.vfp = hwconfig->max_porch-1;
d205 1
a205 2
			timings.vbp = params->VertiBackPorch+params->VertiTopBorder;
			if(timings.vbp >= hwconfig->max_porch)
d207 2
a208 2
				dprintf(("","do_setmode: Clamping VBP %d -> %d\n",timings.vbp,hwconfig->max_porch-1));
				timings.vbp = hwconfig->max_porch-1;
a209 3
			timings.height = params->VertiDisplaySize;
			timings.syncpol = params->SyncPol;
			dispc_set_lcdmode(&timings);
d212 2
a213 6
	else
	{
		venc_set_tvmode(current_tvmode,current_tvtype,false,params);
		/* Ensure LCD is off */
		(hwconfig->lcd_configs[current_lcd].power)(dev,0);
	}
d220 3
a222 43
	blanked = (r->r[0] != 0);
	if(default_display == TARGET_LCD)
	{
		/* TODO - Should make a better effort to reduce power consumption. E.g. disable DISPC entirely when blanking fixed panel. For now, just have global 'blanked' flag to allow us to disable the overlays? */
		int irqs;
		int dpms = r->r[1];
		/* If we're on a device with a fixed LCD, ignore the supplied
		   DPMS state and just turn the LCD off entirely */
		if(hwconfig->lcd_configs[current_lcd].lcd_timings)
		{
			(hwconfig->lcd_configs[current_lcd].power)(dev,(r->r[0]?0:65536));
			dpms = 3; /* Should be safe to gate all clocks if we've just turned off the LCD */
		}
		if(begin_quick_hardware_update(&irqs))
		{
#if OMAP==3
			uint32_t config = dispc->config1 & ~(DISPC_CONFIG_HSYNCGATED | DISPC_CONFIG_VSYNCGATED | DISPC_CONFIG_PIXELGATED);
#endif
#if OMAP==4
			uint32_t config = dispc->config2 & ~(DISPC_CONFIG_HSYNCGATED | DISPC_CONFIG_VSYNCGATED | DISPC_CONFIG_PIXELGATED);
#endif
			if(r->r[0])
			{
				/* Gate pixel clock */
				config |= DISPC_CONFIG_PIXELGATED;
				if(dpms & 1) /* Gate HSync */
					config |= DISPC_CONFIG_HSYNCGATED;
				if(dpms & 2) /* Gate VSync */
					config |= DISPC_CONFIG_VSYNCGATED;
			}
#if OMAP==3
			dispc->config1 = config;
			/* It looks like we might need to set the go bits for all of the updates to take effect, even though the TRM suggests otherwise */
			dispc->control1 |= DISPC_CONTROL_GOLCD;
#endif
#if OMAP==4
			dispc->config2 = config;
			/* It looks like we might need to set the go bits for all of the updates to take effect, even though the TRM suggests otherwise */
			dispc->control2 |= DISPC_CONTROL_GOLCD;
#endif
			end_quick_hardware_update(irqs);
		}
	}
d237 1
d253 6
a258 6
#if OMAP==3
			mouse_palette_soft[0] = dispc->trans_color[0] = dispc->trans_color[1] = trans;
#endif
#if OMAP==4
			mouse_palette_soft[0] = dispc->trans_color2 = dispc->trans_color[1] = trans;
#endif
d302 3
a304 2
		overlay_t *o = &overlays[overlay_pointer];
		if((o->x != r->r[1]) || (o->y != r->r[2]) || (o->target != default_display))
d306 5
d313 3
a315 3
			o->x = r->r[1]+overlays[overlay_desktop].x;
			o->y = r->r[2]+overlays[overlay_desktop].y;
			o->format = OVERLAY_ATTRIBUTES_FORMAT_xRGB24_8888;
d318 1
a318 1
			o->la = (uint8_t *) mouse_image_l; /* Not really needed */
d320 1
d324 1
a324 1
	else if(overlays[overlay_pointer].target != TARGET_NONE)
d326 1
a326 1
		overlays[overlay_pointer].target = TARGET_NONE;
d340 1
a340 1
		overlays[overlay_desktop].ba = r->r[1];
d355 1
a355 2
	/* TODO - Needs updating for TV output */
	/* TODO - Needs updating for if using video overlay instead of graphics, display rotation, etc. */
d357 1
a357 1
	VIDCList3 *params = (VIDCList3 *) r->r[0];
d365 1
d370 5
a374 53
	/* For the moment, ignore the mode timings if we're using TV out or fixed LCD */
	if((default_display != TARGET_TV) && (hwconfig->lcd_configs[current_lcd].max_pixelrate != 0))
	{
		/* Check interlace */
		if(interlace)
			return 1;
		/* Check pixel rate */
		if(params->PixelRate > hwconfig->lcd_configs[current_lcd].max_pixelrate)
			return 1;
		/* Use a lower limit of 15MHz on the pixel rate. The limiting factor appears to be the TFP410, which according to the datasheet only supports down to 25MHz, but appears to be stable down to 15MHz. Anything lower can result in picture instability.
		   https://www.riscosopen.org/forum/forums/3/topics/2583?page=1#posts-33233
		*/
		if(params->PixelRate < 15000)
			return 1;
		/* Check required REGM, REGN values */
		clock_divider_t div = calculate_dss_clock_divider(params->PixelRate*1000);
		if((div.regm > REG_MAX(DSI_PLL_CONFIGURATION1_DSI_PLL_REGM)) || (div.regn > REG_MAX(DSI_PLL_CONFIGURATION1_DSI_PLL_REGN)))
			return 1;
#if OMAP==4
		/* Check for BMP8 erratum (in connection with pcd==1) */
		if ((params->PixelDepth <= VIDCLIST3_8BPP) && (div.pcd == 1))
			return 1;
#endif
		/* Now check mode timings */
		if((params->HorizSyncWidth > hwconfig->max_sync)
		|| (params->HorizBackPorch+params->HorizLeftBorder > hwconfig->max_porch)
		|| (params->HorizFrontPorch+params->HorizRightBorder > hwconfig->max_porch)
		|| (params->VertiSyncWidth > hwconfig->max_sync)
		|| (params->VertiBackPorch+params->VertiTopBorder > hwconfig->max_porch)
		|| (params->VertiFrontPorch+params->VertiBottomBorder > hwconfig->max_porch))
			return 1;
		if((params->HorizSyncWidth < 1)
		|| (params->HorizBackPorch+params->HorizLeftBorder < 1)
		|| (params->HorizFrontPorch+params->HorizRightBorder < 1)
		|| (params->VertiSyncWidth < 1))
			return 1;
		/* Check (HBP+HSW+HFP)*PCD > 8 */
		uint32_t val = params->HorizBackPorch + params->HorizLeftBorder
					 + params->HorizSyncWidth + params->HorizFrontPorch
					 + params->HorizRightBorder;
#if OMAP==3
		if (val <= 4) /* We always used PCD of 2 */
			return 1;
#endif
#if OMAP==4
		if (val * div.pcd <= 8)
			return 1;
#endif
	}
	/* Check screen size */
	if((params->HorizDisplaySize-1 > REG_MAX(DISPC_SIZE_LCD_PPL))
	|| ((params->VertiDisplaySize<<interlace)-1 > REG_MAX(DISPC_SIZE_LCD_LPP))
	|| (params->HorizDisplaySize & 0x7)) /* Width must be multiple of 8 pixels for STALLMODE=0 */
d376 2
a377 11
	/* Check colour depth */
	switch(params->PixelDepth)
	{
	case VIDCLIST3_1BPP:
	case VIDCLIST3_2BPP:
	case VIDCLIST3_4BPP:
	case VIDCLIST3_8BPP:
	case VIDCLIST3_16BPP: /* TODO - Should be removed at some point! */
	case VIDCLIST3_32BPP:
		break;
	default:
d379 1
a379 2
	}
	/* Else we're good */
d388 13
a400 18
	if(overlay_desktop == OVERLAY_GFX)
	{
#if OMAP==3
		r->r[1] = 0x3f; /* 1, 2, 4, 8, 16, 32bpp */
#endif
#if OMAP==4
		/* OMAP4430 Silicon Errata Public RevD chapter 2.4
		 * BITMAP 1-2-4 formats not supported by the graphics pipeline
		 */
		r->r[1] = 0x38; /* 8, 16, 32bpp */
#endif
	}
	else
	{
		r->r[1] = 0x30; /* Only 16bpp, 32bpp */
	}
	if(default_display == TARGET_TV)
		r->r[1] &= 0xf; /* TV-out doesn't support VIDC 16bpp/32bpp */
a414 1
	/* TODO - Handle potential lack of CPR for border colour */
d423 5
a427 7
		if(!idx)
#if OMAP==3
			dispc->default_color[0] = dispc->default_color[1] = ((uint32_t) r->r[1]) >> 8;
#endif
#if OMAP==4
			dispc->default_color2 = dispc->default_color[1] = ((uint32_t) r->r[1]) >> 8;
#endif
d449 5
a453 7
		if(!idx && c)
#if OMAP==3
			dispc->default_color[0] = dispc->default_color[1] = (*pal) >> 8;
#endif
#if OMAP==4
			dispc->default_color2 = dispc->default_color[1] = (*pal) >> 8;
#endif
d470 1
a470 1
	overlay_t *o = &overlays[overlay_desktop];
d498 2
a499 10
	if(default_display == TARGET_TV)
		return 1;
	/* Call through to the HAL */
	/* TODO - Implement here instead */
	int count = r->r[2];
	_swix(OS_Hardware,_INR(0,2)|_INR(8,9)|_OUT(0),r->r[0],r->r[1],&count,OSHW_CallHAL,EntryNo_HAL_VideoIICOp,&r->r[0]);
	r->r[1] += count; /* Advance pointer */
	r->r[2] -= count; /* Bytes not transferred */
	r->r[4] = 0;
	return 0;
d511 5
a515 7
	/* Tailor list depending on which head/overlay is in use for desktop */
	if(default_display == TARGET_LCD)
	{
		r->r[0] = (int) pixelformats;
		r->r[1] = sizeof(pixelformats)/sizeof(pixelformats[0]);
	}
	else
d517 2
a518 2
		r->r[0] = (int) pixelformats_tvout;
		r->r[1] = sizeof(pixelformats_tvout)/sizeof(pixelformats_tvout[0]);
d520 2
d533 2
a534 2
		ControlList_NColour,   /* We don't currently validate these */
		ControlList_ModeFlags, /* two, but claim that we do! */
@


1.17
log
@Handle interlace control list item. TV-out fixes.
Detail:
  c/graphicsv - Handle the interlace control list item; interlace must be disabled for DVI output but can be specified for TV output (although we only use it to determine the overlay dimensions). Remove dummy GraphicsV_SetInterlace implementation. Fix GraphicsV_Features to return correct pixel formats for TV-out. Make GraphicsV_IICOp do nothing for TV-out.
Admin:
  Tested on BB-xM


Version 0.32. Tagged as 'OMAPVideo-0_32'
@
text
@d30 2
d632 42
d698 1
@


1.16
log
@Enforce a minimum pixel rate limit of 15MHz for the DVI output
Detail:
  c/graphicsv - do_vetmode() now rejects DVI modes which require a pixel rate lower than 15MHz. This appears to be the limit at which the TFP410 starts to fail.
Admin:
  Tested on BB-xM


Version 0.31. Tagged as 'OMAPVideo-0_31'
@
text
@d101 9
d113 1
a113 1
	o->height = params->VertiDisplaySize;
d157 2
a158 1
			/* Build lcdtimings struct ready for setting mode */
a212 7
static int do_setinterlace(_kernel_swi_regs *r)
{
	/* TODO! */
	(void) r;
	return 0;
}

d387 11
d401 3
d449 1
a449 1
	|| (params->VertiDisplaySize-1 > REG_MAX(DISPC_SIZE_LCD_LPP))
d490 2
d594 2
a640 1
	case GraphicsV_SetInterlace:		return do_setinterlace(r);
d656 1
@


1.15
log
@Fix GraphicsV_IICOp not updating R0 on exit
Detail:
  c/graphicsv - Updated the call to HAL_VideoIICOp so that the returned R0 value is now correctly passed on to the caller of GraphicsV_IICOp
Admin:
  Tested on BB-xM
  Should fix issue reported on forums with GraphicsV_IICOp misbehaving on PandaBoard:
  https://www.riscosopen.org/forum/forums/4/topics/2358


Version 0.30. Tagged as 'OMAPVideo-0_30'
@
text
@d390 5
@


1.14
log
@Update for new GraphicsV registration process. Remove VIDC20 16bpp gamma demangle code. Advertise red/blue swapped 16bpp & 32bpp modes when using TV-out.
Detail:
  c/cmodule - Updated to use new GraphicsV registration process and OS_Hardware reason code #defines
  c/dispc, c/venc, h/graphicsv, h/venc - Use Hdr:VIDCList instead of local VIDC list definition
  c/graphicsv - Implement GraphicsV_PixelFormats, and return an appropriate list based on whether TV-out is in use. Call through to the HAL for GraphicsV_IICOp instead of relying on the OS to call the HAL for us.
  c/palette - Remove VIDC20 16bpp gamma demangle code, the OS now supplies the data in a sensible format. Dont use mouse palette function intended for 555 mode emulation if CPR isn't in use (i.e. we're on TV-out, i.e. gamma won't be available either)
Admin:
  Tested in OMAP3 ROM on BB-xM
  OMAP4 version builds but is unstested
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.28. Tagged as 'OMAPVideo-0_28'
@
text
@d573 1
a573 1
	_swix(OS_Hardware,_INR(0,2)|_INR(8,9),r->r[0],r->r[1],&count,OSHW_CallHAL,EntryNo_HAL_VideoIICOp);
@


1.13
log
@Mode vetting fixes and improvements
Detail:
  c/graphicsv - Fix do_vetmode() incorrectly failing most modes due to wrong pixel rate being passed to calculate_dss_clock_divider(). Fix LCD vet rules being used when TV-out is in use. Add extra rule to check for minimum H/V timings.
Admin:
  Tested on BB-xM
  Numbered modes now work properly when selected (assuming suitable entries exists in MDF)


Version 0.26. Tagged as 'OMAPVideo-0_26'
@
text
@d35 1
d49 24
d96 1
a96 1
	vidclist3_t *params = (vidclist3_t *) r->r[0];
d383 1
a383 1
	vidclist3_t *params = (vidclist3_t *) r->r[0];
d450 2
a451 1
	r->r[0] = 0x6; /* Hardware pointer, interlace with progressive framestore */
d570 8
a577 3
	/* For now, just let the HAL handle it */
	(void) r;
	return 1;
d587 17
d628 3
@


1.12
log
@Improve TV-out support
Detail:
  c/cmodule, c/dispc, c/graphicsv, c/venc, h/venc - Updated TV-out code to center the desktop within the display, while also taking into account the border/porch timings in order to allow vertical shifting using *TV.
Admin:
  Tested on rev A2 BB-xM


Version 0.22. Tagged as 'OMAPVideo-0_22'
@
text
@d360 1
a360 1
	if((overlays[default_display].target != TARGET_TV) && (hwconfig->lcd_configs[current_lcd].max_pixelrate != 0))
d366 1
a366 1
		clock_divider_t div = calculate_dss_clock_divider(params->PixelRate);
d382 5
@


1.11
log
@Merge of OMAP3 and OMAP4 video driver sources.
With 85%+ shared code, tracking changes between these two modules was getting complicated, so now this single module will serve both OMAP3 targets and OMAP4.
At present, the differences are simply selected at compile time with a switch. This may make sense to further rationalise either with tidier macros or run time detection (since the HAL knows which controller is running).
Tested on OMAP3 in all 8 colour depths,
Tested by Willi Theiss on OMAP4.

Version 0.20. Tagged as 'OMAPVideo-0_20'
@
text
@d171 1
a171 1
		venc_set_tvmode(current_tvmode,current_tvtype,false);
d336 1
a336 1
		/* IRQs off for atomicity (mainly for dispc->control write) */
d340 2
a341 45
		/* TODO - Tidy this up when doing the new GraphicsV stuff. Currently we don't get told the DMA address until after the first mode change, so to protect against OCPERROR interrupts, dispc_update_overlay avoids enabling overlays which don't have a base address. This if() makes sure that when we do finally get told the address, the overlay gets enabled properly. */
		if(overlays[overlay_desktop].ba)
		{
			uint32_t ba = overlays[overlay_desktop].ba = r->r[1];
			if(overlays[overlay_desktop].target != TARGET_NONE)
			{
				volatile uint32_t *regs;
				switch (overlay_desktop)
				{
				default:
				case OVERLAY_GFX:
					regs = dispc->gfx.ba;
					break;
				case OVERLAY_VID1:
					regs = dispc->vid1.ba;
					break;
				case OVERLAY_VID2:
					regs = dispc->vid2.ba;
					break;
				}
				regs[1] = ba;
				regs[0] = ba + (overlays[overlay_desktop].target == TARGET_TV?overlays[overlay_desktop].stride:0);
				if(!ban_hardware_update)
				{
					if (overlays[overlay_desktop].target == TARGET_LCD)
					{
#if OMAP==3
						dispc->control1 |= DISPC_CONTROL_GOLCD;
#endif
#if OMAP==4
						dispc->control2 |= DISPC_CONTROL_GOLCD;
#endif
					}
					else
					{
						dispc->control1 |= DISPC_CONTROL_GODIGITAL;
					}
				}
			}
		}
		else
		{
			overlays[overlay_desktop].ba = r->r[1];
			dispc_update_overlay(overlay_desktop);
		}
@


1.10
log
@Merge of headers with OMAP4Video
For the most part, this is just adding "_t" suffixes to all the typedefs.
The OMAP4 controller registers are in "regs4.h" and OMAP3 in "regs3.h", they are selected between with a compile time switch - hence !MkROM becomes !Ms !MkRom3 and !MkRom4.
OMAP3 version tested & still works, OMAP4 will not work.

Version 0.19. Tagged as 'OMAPVideo-0_19'
@
text
@d6 1
a6 1
 * modification, are permitted provided that the following conditions are met: 
d15 1
a15 1
 * 
d97 6
a102 1
		o->format = OVERLAY_ATTRIBUTES_FORMAT_RGB16;
d105 1
a105 1
		o->format = OVERLAY_ATTRIBUTES_FORMAT_RGB24_32;
d203 6
a208 1
			int config = dispc->config & ~(DISPC_CONFIG_HSYNCGATED | DISPC_CONFIG_VSYNCGATED | DISPC_CONFIG_PIXELGATED);
d218 2
a219 1
			dispc->config = config;
d221 7
a227 1
			dispc->control |= DISPC_CONTROL_GOLCD;
d234 1
a234 1
	 
d260 1
d262 4
d316 1
a316 1
			o->format = OVERLAY_ATTRIBUTES_FORMAT_RGB24_32;
d363 15
a377 1
					dispc->control |= ((overlays[overlay_desktop].target == TARGET_LCD)?DISPC_CONTROL_GOLCD:DISPC_CONTROL_GODIGITAL);
d412 5
a416 1
		/* calculate_dss_clock_divider should make sure Fint is valid, so no need to check that */
d426 5
a430 1
		if(params->HorizBackPorch+params->HorizLeftBorder+params->HorizSyncWidth+params->HorizFrontPorch+params->HorizRightBorder <= 4) /* We always used PCD of 2 */
d432 5
d465 2
d468 8
d477 1
d479 1
d504 1
d506 4
d532 1
d534 4
d617 1
a617 1
	case GraphicsV_SelectHead:		return do_selecthead(r);      
@


1.9
log
@Fix black screen on boot issue. Use C99 number types.
Detail:
  c/dss - Fixed the cause of the black screens on boot on OMAP3 machines (DM37xx seems fine). It looks like the cause was due to skipping the step where you disable the LCD output before triggering the DSS reset.
  c/cmodule, c/dispc, c/dss, c/graphicsv, h/globals - Removed code relating to previous attempts to fix the black screen issue
  c/cmodule, c/dispc, c/dsi, c/dss, c/graphicsv, c/palette, c/regs, c/sdma, c/venc, h/dsi, h/dss, h/globals, h/graphicsv, h/palette, h/regs - Use the C99 number types instead of u32, u16, etc.
Admin:
  Tested on rev C2 BB, rev A2 BB-xM


Version 0.13. Tagged as 'OMAPVideo-0_13'
@
text
@d71 1
a71 1
	vidclist3 *params = (vidclist3 *) r->r[0];
d77 1
a77 1
	overlay *o = &overlays[overlay_desktop];
d119 1
a119 1
			lcdtimings timings;
d287 1
a287 1
		overlay *o = &overlays[overlay_pointer];
d365 1
a365 1
	vidclist3 *params = (vidclist3 *) r->r[0];
d373 1
a373 1
		clock_divider div = calculate_dss_clock_divider(params->PixelRate);
d483 1
a483 1
	overlay *o = &overlays[overlay_desktop];
d491 1
a491 1
		if(!sdma_copyrect(o,(copyrect_params *)r->r[2]))
d495 1
a495 1
		if(!sdma_fillrect(o,(fillrect_params *)r->r[2]))
@


1.8
log
@Fix GraphicsV_Render operations being performed on wrong screen bank
Detail:
  c/cmodule, c/graphicsv, c/sdma, h/globals - Fixed GraphicsV_Render code to perform render ops to the VDU screen bank instead of the display bank.
  Also disabled the slow left-to-right DMA copy code, since the kernels' assembler loop is many times faster.
Admin:
  Tested on rev A2 BB-xM. Fixes issue reported on forums:
  http://www.riscosopen.org/forum/forums/4/topics/691


Version 0.12. Tagged as 'OMAPVideo-0_12'
@
text
@d51 1
d58 1
a108 1
	exp_synclost_count=0;
d176 1
d232 3
a234 3
		u8 *src = (u8 *) shape->buffLA;
		u8 *dest = mouse_image_soft;
		u32 *real = mouse_image_l;
d240 1
a240 1
			u32 trans = mouse_palette_soft[0];
d249 1
a249 1
				if(*((u32 *)src) != *((u32 *)dest)) /* Check words for speed */
d259 1
a259 1
				if(*((u32 *)dest))
d274 1
a274 1
				u8 data = (incount-->0?*src++:0);
d297 1
a297 1
			o->la = (u8 *) mouse_image_l; /* Not really needed */
d321 1
a321 1
			u32 ba = overlays[overlay_desktop].ba = r->r[1];
d324 1
a324 1
				volatile u32 *regs;
d427 1
d435 1
a435 1
	u32 idx = r->r[2];
d439 1
a439 1
		(gfx_palette_func)((u32 *) &r->r[1],idx,1);
d443 1
a443 1
			dispc->default_color[0] = dispc->default_color[1] = ((u32) r->r[1]) >> 8;
d446 1
a446 1
		(mouse_palette_func)((u32 *) &r->r[1],idx,1);
d456 3
a458 3
	u32 idx = r->r[2];
	u32 c = r->r[3];
	u32 *pal = (u32 *) r->r[1];
d512 1
d519 1
d525 2
a526 1
	if((((u32)r->r[4])>>24) != graphicsv_driver_number)
@


1.7
log
@Fix GraphicsV_SetBlank. Improve SetBlank to turn off the overlays. Trim dead code.
Detail:
  c/cmodule, c/dispc, c/graphicsv, h/globals - Fixed do_setblank to set DISPC_CONTROL_GOLCD, to ensure the relevant clocks have their states updated. Added 'blanked' flag to allow the graphics overlays to be disabled entirely whenever the screen should be blanked.
  c/dispc - Trim some dead code related to trying to fix the IGEP display issues.
Admin:
  Tested on rev C2 BB, A2 BB-xM, C1 TouchBook.
  Fixes bug #263 - http://www.riscosopen.org/tracker/tickets/263


Version 0.11. Tagged as 'OMAPVideo-0_11'
@
text
@d350 4
d481 1
a481 1
	if(!sdmachan || (o->target == TARGET_NONE)) /* Protect against (unlikely) event of lack of acceleration, or (likely) event of us not knowing the framebuffer setup yet */
@


1.6
log
@Make GraphicsV_IICOp work
Detail:
  c/graphicsv - The GraphicsV_IICOp handler now just passes on the call, so that the kernel will call HAL_Video_IICOp instead.
Admin:
  Tested on rev A2 BB-xM


Version 0.10. Tagged as 'OMAPVideo-0_10'
@
text
@d181 1
d184 1
a184 1
		/* TODO - Should make a better effort to reduce power consumption. E.g. disable DISPC entirely when blanking fixed panel. */
d207 2
d212 4
@


1.5
log
@Improve OMAPVideo power saving abilities and palette handling
Detail:
  Makefile, c/palette, h/palette, c/cmodule, c/dispc, c/graphicsv, h/globals - Rewrote palette handling code to support multiple different transformations on palettes, to adapt the palettes from the RISC OS formats to the DISPC formats. This means that palettes and the mouse cursor are now correctly R/B swapped for TV-out, RISC OS's gamma correction tables are now supported, and clever use of gamma tables allows 16bpp modes to be displayed correctly by mapping RISC OS's 555 format to the OMAP's 565 format (but there'll only be 4 blue bits instead of 5)
  c/cmodule, c/dispc, c/graphicsv, h/globals - Add support for the HAL's new display power controls, and implement GraphicsV_SetBlank. For fixed LCDs this will ignore the requested DPMS state and instead just turn the power/backlight off.
  h/sdma - Marked the functions as extern.
Admin:
  Tested on rev C2 beagleboard, rev C1 touchbook.
  Requires OMAP3 HAL 0.34.


Version 0.08. Tagged as 'OMAPVideo-0_08'
@
text
@d497 2
a498 2
	/* TODO! */
	return 0;
@


1.4
log
@OMAPVideo fixes & tweaks
Detail:
  Makefile - now rewritten to use CModule fragment instead of obsolete RAMCModule/ROMCModule fragments
  c/cmodule - Make *videoregs print out a couple more regs
  c/dsi - Fix debug output when DSI requests time out. Fix HSDIVIDER not working on AM/DM37x.
  c/graphicsv - When setting the mode from a VIDC list, add the border values to the porch values to take into account the hardware's inability to emulate VIDC's coloured border facility. Behaviour matches that of NVidia module.
  h/regs - Add definitions for SMS registers (for display rotation)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.07. Tagged as 'OMAPVideo-0_07'
@
text
@d103 3
d166 2
d180 29
a208 1
	/* TODO! */
a213 1
	/* TODO - Needs updating for TV output */
d419 1
a419 1
	/* TODO - Handle lack of CPR on TV-out */
d425 1
a425 2
		if(idx < 256)
			gfx_palette_l[idx] = ((u32) r->r[1]) >> 8;
d432 1
a432 5
		if(idx < 4)
		{
			mouse_palette_soft[idx] = ((u32) r->r[1]) >> 8;
			mouse_dirty = true;
		}
d440 1
a440 1
	/* TODO - Handle lack of CPR on TV-out */
d448 1
a448 2
		while(c-- && (idx < 256))
			gfx_palette_l[idx++] = (*pal++) >> 8;
d455 1
a455 3
		while(c-- && (idx < 4))
			mouse_palette_soft[idx++] = (*pal++) >> 8;
		mouse_dirty = true;
@


1.3
log
@Fix OMAPVideo build error
Detail:
  c/graphicsv - somehow I managed to miss the fact that my previous change to this file was resulting in compile errors!
Admin:
  Tested on rev C2 beagleboard.


Version 0.05. Tagged as 'OMAPVideo-0_05'
@
text
@d123 2
a124 1
			timings.hfp = params->HorizFrontPorch;
d130 1
a130 1
			timings.hbp = params->HorizBackPorch;
d143 1
a143 1
			timings.vfp = params->VertiFrontPorch;
d149 1
a149 1
			timings.vbp = params->VertiBackPorch;
d334 2
a335 2
		|| (params->HorizBackPorch > hwconfig->max_porch)
		|| (params->HorizFrontPorch > hwconfig->max_porch)
d337 2
a338 2
		|| (params->VertiBackPorch > hwconfig->max_porch)
		|| (params->VertiFrontPorch > hwconfig->max_porch))
d341 1
a341 1
		if(params->HorizBackPorch+params->HorizSyncWidth+params->HorizFrontPorch <= 4) /* We always used PCD of 2 */
@


1.2
log
@Assorted OMAPVideo tweaks and fixes
Detail:
  c/dispc - Added some WIP code for programming scaling coefficients
  c/dispc, c/graphicsv - Fixed code to not allow the graphics overlay to be enabled before its DMA address had been set (as was happening on boot)
  c/dispc - Enable reporting of FIFO underflow & OCPERROR interrupts in debug builds, to help track down bugs
  c/dispc - Check in some disabled code that was an attempt to fix the IGEP display problems. Code was to force FIFO preload values to 0x100, and to force DISPC_POL_FREQ to 0.
  c/dsi - Keep the DSI complex I/O clock off
  c/dsi, c/dss, h/dss, h/regs - rewrote calculate_dss_clock_divider to remove data lane frequency restriction, and to increase speed/accuracy when calculating rates for tricky values like 25.175MHz. Also in another attempt to fix the IGEP issues, it mimics the Linux driver by trying to generate a 48MHz DSI clock.
  c/dss, c/venc - Tweaked DSS reset & VENC code to make sure VENC clcoks are enabled & disabled at the appropriate times.
  c/graphicsv - Fix GraphicsV_SetDMAAddress so it works properly no matter what overlay the desktop is on
  c/venc - A fix to get the PAL test card working, and a fudge to get PAL output working.
Admin:
  Tested on rev C2 beagleboard & IGEP.
  IGEP reported as showing no concrete improvement in display stability :(


Version 0.03. Tagged as 'OMAPVideo-0_03'
@
text
@d282 1
a282 1
				u32 *regs;
@


1.1
log
@Add initial version of OMAP video driver module
Detail:
  All-new OMAP video driver, written as a module in C.
  Functionality-wise it's basically the same as the original HAL-based driver, except it provides support for GraphicsV_Render via use of the OMAP SDMA controller, and there's currently no support for GraphicsV_IICOp.
  However under the hood the module is significantly different, to ensure it can be expanded to expose the full feature set of the video controller once the new GraphicsV API is ready.
Admin:
  Tested on rev C2 beagleboard.


Version 0.01. Tagged as 'OMAPVideo-0_01'
@
text
@a269 1
	/* TODO - Needs updating for interlace */
d276 2
a277 2
		u32 ba = overlays[overlay_desktop].ba = r->r[1];
		if(overlays[overlay_desktop].target != TARGET_NONE)
d279 27
a305 4
			dispc->gfx.ba[1] = ba;
			dispc->gfx.ba[0] = ba + (overlays[overlay_desktop].target == TARGET_TV?overlays[overlay_desktop].stride:0);
			if(!ban_hardware_update)
				dispc->control |= ((overlays[overlay_desktop].target == TARGET_LCD)?DISPC_CONTROL_GOLCD:DISPC_CONTROL_GODIGITAL);
@


head	1.22;
access;
symbols
	OMAPVideo-0_41:1.22
	OMAPVideo-0_40:1.21
	OMAPVideo-0_39:1.21
	OMAPVideo-0_38:1.20
	OMAPVideo-0_37:1.20
	OMAPVideo-0_36:1.19
	OMAPVideo-0_35:1.18
	OMAPVideo-0_34:1.17
	OMAPVideo-0_33:1.16
	OMAPVideo-0_32:1.16
	OMAPVideo-0_31:1.16
	OMAPVideo-0_30:1.16
	OMAPVideo-0_29:1.16
	OMAPVideo-0_28:1.16
	OMAPVideo-0_27:1.15
	OMAPVideo-0_26:1.14
	OMAPVideo-0_25:1.14
	OMAPVideo-0_24:1.14
	OMAPVideo-0_23:1.13
	OMAPVideo-0_22:1.13
	OMAPVideo-0_21:1.12
	OMAPVideo-0_20:1.11
	OMAPVideo-0_19:1.10
	OMAPVideo-0_18:1.9
	OMAPVideo-0_17:1.8
	OMAPVideo-0_16:1.8
	OMAPVideo-0_15:1.7
	OMAPVideo-0_14:1.7
	OMAPVideo-0_13:1.7
	OMAPVideo-0_12:1.6
	OMAPVideo-0_11:1.5
	OMAPVideo-0_10:1.4
	OMAPVideo-0_09:1.4
	OMAPVideo-0_08:1.4
	OMAPVideo-0_07:1.3
	OMAPVideo-0_06:1.2
	OMAPVideo-0_05:1.2
	OMAPVideo-0_04:1.2
	OMAPVideo-0_03:1.2
	OMAPVideo-0_02:1.2
	OMAPVideo-0_01:1.1;
locks; strict;
comment	@# @;


1.22
date	2018.05.31.21.48.53;	author jlee;	state Exp;
branches;
next	1.21;
commitid	qHkabDo5zjgySuEA;

1.21
date	2015.08.14.22.12.32;	author jlee;	state Exp;
branches;
next	1.20;
commitid	rcLw9SUqzfPpPhxy;

1.20
date	2015.06.14.13.52.06;	author jlee;	state Exp;
branches;
next	1.19;
commitid	I7TOmn2EUkLh1ppy;

1.19
date	2015.05.31.18.21.28;	author jlee;	state Exp;
branches;
next	1.18;
commitid	G8GT764JNtMBXCny;

1.18
date	2015.05.31.17.43.38;	author jlee;	state Exp;
branches;
next	1.17;
commitid	vMWraheejEtCKCny;

1.17
date	2015.05.17.17.50.08;	author jlee;	state Exp;
branches;
next	1.16;
commitid	J3i0xRSaySaJePly;

1.16
date	2013.12.15.22.56.06;	author jlee;	state Exp;
branches;
next	1.15;
commitid	4M7nRqPE9VC3Ahhx;

1.15
date	2013.11.18.21.59.39;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	5zJ1bSSJJkXu8Odx;

1.14
date	2012.07.18.22.57.45;	author jlee;	state Exp;
branches;
next	1.13;
commitid	2fZkhRJPBFVX86dw;

1.13
date	2012.06.04.23.54.21;	author jlee;	state Exp;
branches;
next	1.12;
commitid	FoeSemiFbzb4Sr7w;

1.12
date	2012.05.06.09.25.29;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	ZjNste9SF5CMZD3w;

1.11
date	2012.05.06.09.20.41;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	Dmkx2IqcO2G8YD3w;

1.10
date	2012.05.06.09.16.43;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	imAmvVvRmuLKWD3w;

1.9
date	2012.04.24.20.12.59;	author jlee;	state Exp;
branches;
next	1.8;
commitid	qD7TvahpwBYOX92w;

1.8
date	2012.01.15.08.26.38;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	1qzpEvf72ehOgfPv;

1.7
date	2011.10.23.21.01.50;	author jlee;	state Exp;
branches;
next	1.6;
commitid	0rwNv0ztfd3f9wEv;

1.6
date	2011.07.11.22.07.35;	author jlee;	state Exp;
branches;
next	1.5;
commitid	aeC42JvE4N46R9rv;

1.5
date	2011.03.19.18.19.47;	author jlee;	state Exp;
branches;
next	1.4;
commitid	kv85AixjkSL8gucv;

1.4
date	2010.10.31.20.17.57;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.14.21.12.55;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.23.00.39.15;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.28.19.01.14;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Big refactor, introduce GraphicsV overlay API support
Detail:
  This change introduces initial support for the GraphicsV overlay API.
  RGB & YUV overlays are supported, along with rotation and scaling.
  Vertical flipping isn't supported yet, and there are still a number of bugs to track down, along with some potential improvements.
  The code has also been refactored significantly, in an attempt to protect all critical state with spinlocks/mutexes (as appropriate), and to reduce the number of globals so that it's easier to see what's touching what. Previously very little locking was performed, which could lead to issues if VSyncs or synclost interrupts occurred during certain operations. Now, the data should be structured in such a way that this shouldn't cause problems.
  Notable things:
  * State which needs to be writable from interrupt handlers is protected by spinlocks
  * State which needs to be readable from interrupt handlers is protected by reader-writer spinlocks
  * State which doesn't need to be accessed from interrupt handlers is unprotected (mutexes can be introduced in the future to make the code SMP-safe)
  * Using non-alpha screen modes for the desktop will currently result in only "basic" overlays being supported (i.e. overlays which appear ontop of the desktop). In some cases this could be improved by falling back to a software pointer, but for now the only way to get Z-Order overlays is to use a screen mode with an alpha channel.
  * Memory allocation for overlays is abstracted via the buffer interface (h/buffer). This has three implementations: basic buffers for untransformed overlays, VRFB-transformed buffers for OMAP3, and TILER-transformed buffers for OMAP4.
  * Ultimately all overlay memory is allocated as physically contiguous pages within a PMP - although since TILER contains its own MMU this isn't strictly necessary on OMAP4
  * Overlay memory is mapped as write-through cacheable for CPU access; experimentation with different cache policies has yet to be performed. However a potential future optimisation would be to perform lazy unmapping of overlay buffers, reducing the map/unmap overhead in well-behaved code which only maps buffers when they're needed
Admin:
  Tested on BB-xM, Pandaboard


Version 0.41. Tagged as 'OMAPVideo-0_41'
@
text
@/*
 * Copyright (c) 2010, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include "modhead.h"
#include "swis.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/NewErrors.h"
#include "Global/HALDevice.h"
#include "Global/HALEntries.h"
#include "Global/GraphicsV.h"
#include "Global/VduExt.h"
#include "Global/OSMisc.h"
#include "Global/OSMem.h"

#include "DebugLib/DebugLib.h"

#include "graphicsv.h"
#include "dss.h"
#include "sdma.h"
#include "regs.h"
#include "gvoverlay.h"
#include "pmp.h"
#include "mouse.h"
#include "consts.h"
#include "vars.h"
#include "globals.h"
#include "utils.h"
#include "palette.h"
#include "dispc.h"

#if OMAP==3
#include "omap3/vrfb.h"
#include "omap3/venc.h"
#define SUPPORT_TV_MODE 1
#endif
#if OMAP==4
#include "omap4/tiler.h"
#endif

static uint32_t *pciram_block_l = NULL;

void (*dmb)(void);

#ifdef DEBUGLIB
static uint64_t timer_scale;

#define TIMER_NUMBER 1

static void timer_init(void)
{
	/* Set up a high-resolution timer that we can use for profiling code
	   The standard centisecond timer isn't sufficient, even if we resorted to peeking the underlying HAL timer value (hard to get accurate timings of over 1cs) */
	_swix(OS_Hardware,_INR(0,1)|_INR(8,9),TIMER_NUMBER,0x80000000,OSHW_CallHAL,EntryNo_HAL_TimerSetPeriod);
	uint32_t granularity;
	_swix(OS_Hardware,_IN(0)|_INR(8,9)|_OUT(0),TIMER_NUMBER,OSHW_CallHAL,EntryNo_HAL_TimerGranularity,&granularity);
	/* Scale factor to convert ticks to microseconds */
	timer_scale = (((uint64_t)1000000)<<32)/granularity;
}

uint32_t timer_read(void)
{
	uint32_t val;
	_swix(OS_Hardware,_IN(0)|_INR(8,9)|_OUT(0),TIMER_NUMBER,OSHW_CallHAL,EntryNo_HAL_TimerReadCountdown,&val);
	return (uint32_t) ((val*timer_scale)>>32);
}
#endif

_kernel_oserror* module_init (const char *cmd_tail, int podule_base, void *pw)
{
	(void) cmd_tail;

	_kernel_oserror* e = NULL;
	uint32_t mask=0;

	/* set up debugging */
	debug_initialise(Module_Title, "", "");
	debug_set_device(DADEBUG_OUTPUT);
	debug_set_unbuffered_files(TRUE);
#ifdef DEBUGLIB
	timer_init();
#endif
	lockdebug_init();

	instance = podule_base;

	private_word = pw;

	/* Get the DMB ARMop ptr */
	e = _swix(OS_MMUControl, _IN(0) | _OUT(0), MMUCReason_GetARMop + (ARMop_DMB_ReadWrite<<8), &dmb);
	if (e)
	{
		return e;
	}

	/* Find the AP value we want to use for framebuffers */
	e = _swix(OS_Memory, _INR(0,2) | _OUT(0), OSMemReason_FindAccessPrivilege, MemPermission_PrivR|MemPermission_PrivW|MemPermission_UserR|MemPermission_UserW, MemPermission_PrivR|MemPermission_PrivW|MemPermission_UserR|MemPermission_UserW, &memory_access_privilege);
	if (e)
	{
		return e;
	}

	/* Hunt for the HAL device */
	int pos=0;
	do {
		e = _swix(OS_Hardware, _INR(0,1) | _IN(8) | _OUTR(1,2), HALDeviceType_Video + HALDeviceVideo_VDU,pos,OSHW_DeviceEnumerate,&pos,&dev);
		if(e)
			goto error;
		if(pos == -1)
		{
			static const internaterr_t badhard = { ErrorNumber_BadHard, "BadHard" };

			return _swix(MessageTrans_ErrorLookup, _INR(0,2), &badhard, 0, 0);
		}
	} while(dev->dev.id != HALDeviceID_VDU_Desired);

	/* Create the PMP */
	e = pmp_init();
	if (e)
	{
		goto error;
	}

	/* Call the Activate entry to turn on the clocks and make sure everything's OK */
	if(!(dev->dev.Activate)(&dev->dev))
	{
		static const internaterr_t hwdep = { ErrorNumber_HardwareDepends, "HWDep" };

		e = _swix(MessageTrans_ErrorLookup, _INR(0,2), &hwdep, 0, 0);
		goto error;
	}

	/* Get boardconfig/hwconfig struct */
	hwconfig = (boardconfig_t *) dev->devicespecificfield;

	/* Turn all the displays off */
	for(int i=0;i<hwconfig->num_lcds;i++)
		(hwconfig->lcd_configs[i].power)(dev,0);

	/* Make sure overlays are marked as disabled */
	{
		irqlocked_t *irqlocked = irqlocked_lock();
		for(int i=0;i<OVERLAY_MAX;i++)
		{
			overlaycfg_reset(&irqlocked->overlays[i]);
		}
		irqlocked_unlock();
	}

	/* Set other default settings for some globals */
	gvoverlay_init();

	/* Get hardware addresses */
	dss = (dss_regs_t *) dev->dev.address;
#if OMAP==3
	dispc = (dispc_regs_t *) (((uint32_t)dev->dev.address)+0x400);
	rfbi = (rfbi_regs_t *) (((uint32_t)dev->dev.address)+0x800);
	venc = (venc_regs_t *) (((uint32_t)dev->dev.address)+0xc00);
	dsi = (dsi_regs_t *) (((uint32_t)dev->dev.address)-0x400);
	dsi_phy = (dsi_phy_regs_t *) (((uint32_t)dev->dev.address)-0x200);
	dsi_pll = (dsi_pll_regs_t *) (((uint32_t)dev->dev.address)-0x100);
	vrfb_init();
#endif
#if OMAP==4
	dispc = (dispc_regs_t *) (((uint32_t)dev->dev.address) + DISPC_BASE);
	rfbi = (rfbi_regs_t *) (((uint32_t)dev->dev.address) + RFBI_BASE);
	venc = (venc_regs_t *) (((uint32_t)dev->dev.address) + VENC_BASE);
	dsi = (dsi_regs_t *) (((uint32_t)dev->dev.address) + DSI2_PROTOCOL_ENGINE);
	dsi_phy = (dsi_phy_regs_t *) (((uint32_t)dev->dev.address) + DSI2_PHY);
	dsi_pll = (dsi_pll_regs_t *) (((uint32_t)dev->dev.address) + DSI2_PLLCTRL);
	tiler_init();
#endif
	sdma = hwconfig->dma_ptr;

	/* Get address of the sole DMA channel we use */
	mask = hwconfig->dma_chans;
	if(mask)
	{
		sdmachan = &sdma->chans[0];
		while(!(mask & 1))
		{
			sdmachan++;
			mask = mask>>1;
		}
		dprintf(("","Using DMA channel at %08x\n",(uint32_t)sdmachan));

		/* Make sure channel is in a sane state */
		sdma_sync();
		sdmachan->clnk_ctrl &= ~DMA4_CLNK_CTRL_ENABLE_LNK;
		sdmachan->cicr = 0;
	}
	else
		sdmachan = 0;

	/* Init platform code */
	omap_init();

	/* Perform a reset so that we can safely enable IRQs */
	e = dss_reset();

	if(e)
		goto error2;

	/* Get some workspace from the PCI module */
	uint32_t pciram_block_p;
	e = _swix(PCI_RAMAlloc, _INR(0,2) | _OUTR(0,1), 4*256+32*32*4, 32, 0, &pciram_block_l, &pciram_block_p);

	if(e)
		goto error2;

	palette_set_buffers(pciram_block_l,pciram_block_p); 
	mouse_set_buffers(pciram_block_l + 256,pciram_block_p + 256*4); 

	{
		/* Pick our initial palette func */
		const features_t *features = features_read_lock();
		select_palette_func(NULL, features);
		features_read_unlock();
	}

	/* Get a driver number */
	uint32_t temp;
	e = _swix (OS_ScreenMode, _INR(0,2)|_OUT(0), ScreenModeReason_RegisterDriver, 0, Module_Title, &temp);
	if(e)
		goto error3;
	graphicsv_driver_number = temp;

	/* Claim & enable IRQ */
	e = _swix (OS_ClaimDeviceVector, _INR(0,4), dev->dev.devicenumber, dispc_irq_entry, pw, 0, 0);

	if(e)
		goto error4;

	e = _swix (OS_Hardware, _IN(0) | _INR(8,9), dev->dev.devicenumber&~(1u<<31), OSHW_CallHAL, EntryNo_HAL_IRQEnable);

	if(e)
		goto error5;

	/* Get on GraphicsV! */
	e = _swix(OS_Claim, _INR(0,2), GraphicsV, graphicsv_entry, pw);

	if(e)
		goto error5;

	/* Pick default head/display */
	{
		overlaytarget default_display = omap_pick_display();
		modelocked_write_lock()->default_display = default_display;
		modelocked_write_unlock();
	}

	/* Tell the OS that we're ready */
	e = _swix(OS_ScreenMode, _INR(0,1), ScreenModeReason_StartDriver, graphicsv_driver_number);
	if(e)
		goto error6;

	dprintf(("", "Finished module initialisation, DSS regs=%08x\n",(uint32_t)dss));

	return 0;

error6:
	/* Get off GraphicsV */
	_swix(OS_Release, _INR(0,2), GraphicsV, graphicsv_entry, pw);
error5:
	/* Release IRQ */
	_swix (OS_ReleaseDeviceVector, _INR(0,4), dev->dev.devicenumber, dispc_irq_entry, pw, 0, 0);
error4:
	/* Release driver number */
	_swix (OS_ScreenMode, _INR(0,1), ScreenModeReason_DeregisterDriver, graphicsv_driver_number);
error3:
	/* Release memory */
	_swix(PCI_RAMFree, _IN(0), pciram_block_l);
	palette_set_buffers(NULL,0);
	mouse_set_buffers(NULL,0);
error2:
	/* Deactivate */
	(dev->dev.Deactivate)(&dev->dev);
	dev = 0;
error:
	/* Shutdown PMP */
	pmp_shutdown();
	dprintf(("","Failed initialisation: %s\n", e->errmess));
	return e;
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
	(void) podule;
	(void) fatal;

	_kernel_oserror* e = NULL;

	/* Tell the OS that we're shutting down */
	e = _swix(OS_ScreenMode, _INR(0,1), ScreenModeReason_StopDriver, graphicsv_driver_number);
	if(e)
		return e;

	/* Get off GraphicsV */
	_swix(OS_Release, _INR(0,2), GraphicsV, graphicsv_entry, pw);

	/* Destroy any overlays */
	gvoverlay_shutdown();

	if(dev)
	{
		/* Disable displays */
		for(int i=0;i<hwconfig->num_lcds;i++)
			(hwconfig->lcd_configs[i].power)(dev,0);

		e = _swix (OS_ReleaseDeviceVector, _INR(0,4), dev->dev.devicenumber, dispc_irq_entry, pw, 0, 0);
		if(e)
			return e;
		(dev->dev.Deactivate)(&dev->dev);
		dev = 0;
	}

	/* Release driver number */
	_swix(OS_ScreenMode, _INR(0,1), ScreenModeReason_DeregisterDriver, graphicsv_driver_number);

	if(pciram_block_l)
	{
		e = _swix(PCI_RAMFree, _IN(0), pciram_block_l);
		if(e)
			return e;
		palette_set_buffers(NULL,0);
		mouse_set_buffers(NULL,0);
	}

	pmp_shutdown();

	return NULL;
}

#ifdef DEBUGLIB

static const char *targetnames_[] = {
	"TARGET_NONE",
#if OMAP==3
	"TARGET_LCD",
	"TARGET_TV"
#endif
#if OMAP==4
	"TARGET_LCD2",
#endif
};
const char **targetnames = targetnames_+1;
const char *overlaynames[] = {
	"OVERLAY_GFX",
	"OVERLAY_VID1",
	"OVERLAY_VID2",
#if OMAP==4
	"OVERLAY_VID3",
#endif
	"OVERLAY_MAX",
};
const char *featurenames[] = {"FEATURE_CPR","FEATURE_ALPHA","FEATURE_PALETTE","FEATURE_GAMMAHACK"};
const char *pixelformatnames[PIXELFORMAT_MAX+1] = {
	"PIXELFORMAT_1_PAL",
	"PIXELFORMAT_2_PAL",
	"PIXELFORMAT_4_PAL",
	"PIXELFORMAT_8_PAL",
	"PIXELFORMAT_4444_TBGR",
	"PIXELFORMAT_4444_TRGB",
	"PIXELFORMAT_4444_ABGR",
	"PIXELFORMAT_4444_ARGB",
	"PIXELFORMAT_1555_TBGR",
	"PIXELFORMAT_1555_TRGB",
	"PIXELFORMAT_1555_ABGR",
	"PIXELFORMAT_1555_ARGB",
	"PIXELFORMAT_565_BGR",
	"PIXELFORMAT_565_RGB",
	"PIXELFORMAT_888_BGR",
	"PIXELFORMAT_888_RGB",
	"PIXELFORMAT_8888_TBGR",
	"PIXELFORMAT_8888_TRGB",
	"PIXELFORMAT_8888_ABGR",
	"PIXELFORMAT_8888_ARGB",
	"PIXELFORMAT_UYVY_601_full",
	"PIXELFORMAT_UYVY_601_video",
	"PIXELFORMAT_UYVY_709_full",
	"PIXELFORMAT_UYVY_709_video",
	"PIXELFORMAT_YUY2_601_full",
	"PIXELFORMAT_YUY2_601_video",
	"PIXELFORMAT_YUY2_709_full",
	"PIXELFORMAT_YUY2_709_video",
	"PIXELFORMAT_NV12_601_full",
	"PIXELFORMAT_NV12_601_video",
	"PIXELFORMAT_NV12_709_full",
	"PIXELFORMAT_NV12_709_video",
	"PIXELFORMAT_POINTER",
	"PIXELFORMAT_MAX",
};

_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
	(void)argc;
	(void)pw;
	(void)arg_string;

	switch (cmd_no) {
	case CMD_VideoRegs:
		omap_dump_videoregs();
		break;
	case CMD_TVMode:
#ifdef SUPPORT_TV_MODE
		{
		char *str;
		int mode = (int)strtoul(arg_string,&str,10);
		int type = (int)strtoul(str,&str,10);
		int testmode = (int)strtoul(str,0,10);
		/* Update configuration */
		venc_configure((tvmode) mode,(tvouttype) type,(bool) testmode);
		if (((tvouttype) type) == TVOUT_NONE)
		{
			/* Just turn off */
			venc_disable();
		}
		else
		{
			/* Re-prep mode */
			{
				modelocked_t *modelocked = modelocked_write_lock();
				modelocked_head_t head = modelocked->heads[TARGET_TV];
				/* Reconstruct original mode width/height so that centering will work */
				pixelformat format = PIXELFORMAT_8888_TBGR;
				if (modelocked->overlay_desktop != OVERLAY_MAX)
				{
					const irqlocked_t *irqlocked = irqlocked_lock();
					head.mode.width = head.dw;
					head.mode.height = head.dh;
					head.interlaced = false; /* Assume original mode timings weren't interlaced (if they were, the centering will be wrong) */
					format = irqlocked->overlays[modelocked->overlay_desktop].format;
					irqlocked_unlock();
				}
				venc_prepmode(&head,format);
				modelocked->heads[TARGET_TV] = head;
			}
			/* Now actually set the mode */
			const modelocked_t *modelocked = modelocked_write_to_read();
			(headattrs[TARGET_TV].setmode)(TARGET_TV,&modelocked->heads[TARGET_TV]);
			/* Also ensure desktop is centered correctly */
			const irqlocked_t *irqlocked = irqlocked_lock();
			dispc_update_overlay(modelocked->overlay_desktop,modelocked,irqlocked);
			irqlocked_unlock();
			modelocked_read_unlock();
		}
		}
#endif /* SUPPORT_TV_MODE */
		break;
	case CMD_TVRegs:
		omap_dump_tvregs();
		break;
	case CMD_VideoHead:
		for(int i=0;i<TARGET_MAX;i++)
		{
			int len = strlen(targetnames[i]);
			if(!strncmp(arg_string,targetnames[i],len) && (arg_string[len] <= 32))
			{
				printf("Head %s selected\n",targetnames[i]);
				modelocked_write_lock()->default_display = (overlaytarget) i;
				modelocked_write_unlock();
				/* Don't bother with hardware update for now */
				return 0;
			}
		}
		printf("Available heads:\n");
		{
			const modelocked_t *modelocked = modelocked_read_lock();
			for(int i=0;i<TARGET_MAX;i++)
			{
				printf("%s%s\n",targetnames[i],(i==modelocked->default_display?" (active)":""));
			}
			modelocked_read_unlock();
		}
		break;
	case CMD_SDMARegs:
		sdma_dump_sdmaregs();
		break;
	case CMD_VideoState:
		printf("Timing metrics:\n");
		graphicsv_debug();
		lockdebug_output();
		{
			const modelocked_t *modelocked = modelocked_read_lock();

			/* Take a copy of the IRQ-locked state so that we don't create a deadlock */
			irqlocked_t irqlocked = *irqlocked_lock();
			irqlocked_unlock();

			printf("Desktop: %s\n",overlaynames[modelocked->overlay_desktop]);
			printf("Pointer: %s\n",overlaynames[modelocked->overlay_pointer]);
			for(int i=0;i<TARGET_MAX;i++)
			{
				printf("Head %s:\n",targetnames[i]);
				printf(" %d x %d%s\n",modelocked->heads[i].mode.width,modelocked->heads[i].mode.height,(modelocked->heads[i].interlaced?" (interlaced)":""));
				printf(" overlay offset %d x %d\n",modelocked->heads[i].x,modelocked->heads[i].y);
				printf(" desktop clip size %d x %d\n",modelocked->heads[i].dw,modelocked->heads[i].dh);
				printf(" background %08x\n",irqlocked.heads[i].background);
				printf(" transparent %08x\n",irqlocked.heads[i].transparent);
				printf(" blanked %d dpms %d\n",irqlocked.heads[i].blanked,irqlocked.heads[i].dpms);
				printf(" enabled %d\n",modelocked->heads[i].enabled);
				const features_t *features = features_read_lock();
				for(int j=0;j<sizeof(featurenames)/sizeof(featurenames[0]);j++)
				{
					if((features->head_vals[i] | features->head_masks[i]) & (1<<j))
						printf(" %s=%d\n",featurenames[j],(features->head_vals[i] & (1<<j))?1:0);
				}
				features_read_unlock();
				printf("\n");
			}
			for(int i=0;i<OVERLAY_MAX;i++)
			{
				printf("Overlay %s:\n",overlaynames[i]);
				printf(" buf %d x %d\n",irqlocked.overlays[i].buf_w,irqlocked.overlays[i].buf_h);
				printf(" scaled %d x %d\n",irqlocked.overlays[i].scaled_w,irqlocked.overlays[i].scaled_h);
				printf(" pos %d,%d\n",irqlocked.overlays[i].x,irqlocked.overlays[i].y);
				printf(" %s\n",pixelformatnames[irqlocked.overlays[i].format]);
				printf(" ba %08x la %08x\n",irqlocked.overlays[i].ba,(int) irqlocked.overlays[i].la);
				printf(" stride %08x\n",irqlocked.overlays[i].stride);
				printf(" target %s\n",targetnames[irqlocked.overlays[i].target]);
				printf(" enabled %d\n",irqlocked.overlays[i].enabled);
				printf(" bandwidth %dKB/s\n",bandwidth_estimate(&irqlocked.overlays[i],modelocked));
				printf("\n");
			}
			modelocked_read_unlock();
		}
		for(int i=0;i<GVOVERLAY_MAX;i++)
		{
			const gvoverlay_t *gvoverlay = &gvoverlays[i]; 
			if (gvoverlay->overlay == OVERLAY_MAX)
			{
				continue;
			}
			printf("GV overlay %d:\n",i);
			printf(" flags %08x\n",gvoverlay->flags);
			printf(" -> phys overlay %s\n",overlaynames[gvoverlay->overlay]);
			printf(" display bank: %d\n",gvoverlay->display);
			buffer_describe(gvoverlay->buffer);
		}
		break;
	}

	return 0;
}
#endif
@


1.21
log
@Add memory barriers to GraphicsV acceleration
Detail:
  c/sdma - Use a read/write barrier at the start and end of any DMA op, to ensure things are ready for switching screen memory to Normal, non-cacheable
  c/cmodule, h/globals - Get the DMB_ReadWrite ARMop ptr on startup
Admin:
  Tested on BB-xM, PandaBoard


Version 0.39. Tagged as 'OMAPVideo-0_39'
@
text
@d43 1
a46 1
#include "globals.h"
a48 1
#include "venc.h"
d51 9
d62 2
d66 3
d70 6
a75 2
void *private_word;
int instance;
d77 1
a77 29
vdu_device_t *dev=NULL;
uint8_t graphicsv_driver_number = 0;
const boardconfig_t *hwconfig=NULL;

overlaycfg_t overlaycfgs[OVERLAY_MAX];
headcfg_t headcfgs[TARGET_MAX];
uint32_t vdu_init = ~0;
uint32_t dsi_pll_current_pixel_rate=0;
lcdtimings_t current_timings;
int current_lcd=0;
tvmode current_tvmode = TVMODE_NTSC_601;
tvouttype current_tvtype = TVOUT_NONE;
bool testcard = false;
transparencycfg current_transparencycfgs[TARGET_MAX];
overlayidx overlay_desktop = OVERLAY_GFX;
overlayidx overlay_pointer = OVERLAY_VID2;
overlaytarget default_display;

uint32_t *gfx_palette_l;
uint32_t gfx_palette_p;
uint32_t gfx_palette_ro[256];
palette_func_t gfx_palette_func = NULL;
uint32_t mouse_palette_soft[4];
bool mouse_dirty;
uint32_t *mouse_image_l;
uint32_t mouse_image_p;
uint8_t mouse_image_soft[32*32/4];
uint32_t mouse_palette_ro[4];
palette_func_t mouse_palette_func = NULL;
d79 10
a88 1
void (*dmb)(void);
d90 7
a96 23
const uint8_t pixel_format_bpp[PIXELFORMAT_MAX] = {
	1, //PIXELFORMAT_1_PAL,
	2, //PIXELFORMAT_2_PAL,
	4, //PIXELFORMAT_4_PAL,
	8, //PIXELFORMAT_8_PAL,
	16, //PIXELFORMAT_4444_TBGR,
	16, //PIXELFORMAT_4444_TRGB,
	16, //PIXELFORMAT_4444_ABGR,
	16, //PIXELFORMAT_4444_ARGB,
	16, //PIXELFORMAT_1555_TBGR,
	16, //PIXELFORMAT_1555_TRGB,
	16, //PIXELFORMAT_1555_ABGR,
	16, //PIXELFORMAT_1555_ARGB,
	16, //PIXELFORMAT_565_BGR,
	16, //PIXELFORMAT_565_RGB,
	24, //PIXELFORMAT_888_BGR,
	24, //PIXELFORMAT_888_RGB,
	32, //PIXELFORMAT_8888_TBGR,
	32, //PIXELFORMAT_8888_TRGB,
	32, //PIXELFORMAT_8888_ABGR,
	32, //PIXELFORMAT_8888_ARGB,
	32, //PIXELFORMAT_POINTER,
};
d107 1
a107 1
	debug_set_device(HAL_OUTPUT);
d109 4
d125 7
d146 7
d158 2
a159 1
		return _swix(MessageTrans_ErrorLookup, _INR(0,2), &hwdep, 0, 0);
a169 1
	for(int i=0;i<OVERLAY_MAX;i++)
d171 6
a176 8
		memset(&overlaycfgs[i],0,sizeof(overlaycfg_t));
		overlaycfgs[i].target = TARGET_NONE;
	}

	/* Make sure heads are marked as disabled */
	for(int i=0;i<TARGET_MAX;i++)
	{
		memset(&headcfgs[i],0,sizeof(headcfg_t));
d179 2
a180 5
	/* Set default transparency settings */
	for(int i=0;i<TARGET_MAX;i++)
	{
		current_transparencycfgs[i] = TRANSPARENCY_TCK_VIDSRC;
	}
d191 1
d200 1
d224 3
d234 2
a235 1
	e = _swix(PCI_RAMAlloc, _INR(0,2) | _OUTR(0,1), 4*256+32*32*4, 32, 0, &gfx_palette_l, &gfx_palette_p);
d240 2
a241 2
	mouse_image_l = gfx_palette_l + 256;
	mouse_image_p = gfx_palette_p + 256*4;
d243 6
a248 2
	/* Pick our initial palette func */
	select_palette_func(NULL);
d275 5
a279 1
	default_display = omap_pick_display();
d301 3
a303 3
	_swix(PCI_RAMFree, _IN(0), gfx_palette_l);
	gfx_palette_l = mouse_image_l = NULL;
	gfx_palette_p = mouse_image_p = 0;
d309 2
d330 3
d349 1
a349 1
	if(gfx_palette_l)
d351 1
a351 1
		e = _swix(PCI_RAMFree, _IN(0), gfx_palette_l);
d354 2
a355 2
		gfx_palette_l = mouse_image_l = NULL;
		gfx_palette_p = mouse_image_p = 0;
d358 2
d376 9
a384 1
const char *overlaynames[] = {"OVERLAY_GFX","OVERLAY_VID1","OVERLAY_VID2"};
d407 12
d440 36
a475 1
		venc_set_tvmode((tvmode) mode,(tvouttype) type,(bool) testmode);
d489 2
a490 1
				default_display = (overlaytarget) i;
a495 1
		for(int i=0;i<TARGET_MAX;i++)
d497 6
a502 1
			printf("%s%s\n",targetnames[i],(i==default_display?" (active)":""));
d509 3
a511 1
		for(int i=0;i<TARGET_MAX;i++)
d513 28
a540 7
			printf("Head %s:\n",targetnames[i]);
			printf(" %d x %d\n",headcfgs[i].mode.width,headcfgs[i].mode.height);
			printf(" background %08x\n",headcfgs[i].background);
			printf(" transparent %08x\n",headcfgs[i].transparent);
			printf(" blanked %d dpms %d\n",headcfgs[i].blanked,headcfgs[i].dpms);
			printf(" enabled %d\n",headcfgs[i].enabled);
			for(int j=0;j<sizeof(featurenames)/sizeof(featurenames[0]);j++)
d542 11
a552 2
				if(headcfgs[i].features & (1<<j))
					printf(" %s\n",featurenames[j]);
d554 1
a554 2
			printf(" interlaced %d\n",headcfgs[i].interlaced);
			printf("\n");
d556 1
a556 1
		for(int i=0;i<OVERLAY_MAX;i++)
d558 10
a567 9
			printf("Overlay %s:\n",overlaynames[i]);
			printf(" %d x %d\n",overlaycfgs[i].width,overlaycfgs[i].height);
			printf(" pos %d,%d\n",overlaycfgs[i].x,overlaycfgs[i].y);
			printf(" %s\n",pixelformatnames[overlaycfgs[i].format]);
			printf(" ba %08x la %08x\n",overlaycfgs[i].ba,(int) overlaycfgs[i].la);
			printf(" stride %08x\n",overlaycfgs[i].stride);
			printf(" target %s\n",targetnames[overlaycfgs[i].target]);
			printf(" enabled %d\n",overlaycfgs[i].enabled);
			printf("\n");
@


1.20
log
@Misc tweaks
Detail:
  c/cmodule, c/sdma, h/regs, h/sdma, omap3/c/omap, omap4/c/omap - Move *SDMARegs handling from c/cmodule to c/sdma. Define DUMPREG in h/regs instead of in each individual file that uses it.
  omap3/c/dispc_plat, omap4/c/dispc_plat - Fix setting of GO bits in dispc_flush_transparency_cfg()
  omap4/c/dss - Update comment
  omap4/c/omap - Use designated initialisers for omapformats array to ensure it stays in sync with enum ordering. Strip dead code.
Admin:
  Changes supplied by Willi Theiss
  Tested on BB-xM


Version 0.37. Tagged as 'OMAPVideo-0_37'
@
text
@d42 1
d90 2
d132 7
@


1.19
log
@Add chip-specific functions for *VideoRegs and *TVRegs. Change some OMAP3 register names.
Detail:
  c/cmodule, h/globals, omap3/c/omap, omap4/c/omap - Get rid of all the ugly #if's in *VideoRegs handling by moving video & TV register dump logic into chip-specific functions (omap_dump_videoregs, omap_dump_tvregs).
  h/regs3, omap3/c/dispc_plat, omap3/c/dss, omap3/c/omap, omap3/c/venc - Remove '1' from DISPC control & config register names, was only present for OMAP4 compatibility.
  omap4/c/dsi - Fix debug compile error due to DSI PLL regmf removal
Admin:
  OMAP3/OMAP4 debug/ROM versions all build correctly
  Untested at runtime


Version 0.36. Tagged as 'OMAPVideo-0_36'
@
text
@a376 2
#define DUMPREG(BANK,REG) printf("%08x: %08x %s.%s\n",(uint32_t) &(BANK->REG),BANK->REG,#BANK,#REG)

d420 1
a420 31
		DUMPREG(sdma,irqstatus[0]);
		DUMPREG(sdma,irqstatus[1]);
		DUMPREG(sdma,irqstatus[2]);
		DUMPREG(sdma,irqstatus[3]);
		DUMPREG(sdma,irqenable[0]);
		DUMPREG(sdma,irqenable[1]);
		DUMPREG(sdma,irqenable[2]);
		DUMPREG(sdma,irqenable[3]);
		DUMPREG(sdma,sysstatus);
		DUMPREG(sdma,ocp_sysconfig);
		DUMPREG(sdma,gcr);
		DUMPREG(sdmachan,ccr);
		DUMPREG(sdmachan,clnk_ctrl);
		DUMPREG(sdmachan,cicr);
		DUMPREG(sdmachan,csr);
		DUMPREG(sdmachan,csdp);
		DUMPREG(sdmachan,cen);
		DUMPREG(sdmachan,cfn);
		DUMPREG(sdmachan,cssa);
		DUMPREG(sdmachan,cdsa);
		DUMPREG(sdmachan,csei);
		DUMPREG(sdmachan,csfi);
		DUMPREG(sdmachan,cdei);
		DUMPREG(sdmachan,cdfi);
		DUMPREG(sdmachan,csac);
		DUMPREG(sdmachan,cdac);
		DUMPREG(sdmachan,ccen);
		DUMPREG(sdmachan,ccfn);
		DUMPREG(sdmachan,color);
		printf("%d fills\n%d copy 1\n%d copy 2\n%d copy 3\n",sdma_stats[0],sdma_stats[1],sdma_stats[2],sdma_stats[3]);
		memset(sdma_stats,0,sizeof(sdma_stats));
@


1.18
log
@OMAP4 tweaks and fixes
Detail:
  c/cmodule - Debug code updated to use new register names
  h/dss - Remove regmf field from clock_divider_t
  h/regs3 - Correct typo in OVERLAY_ATTRIBUTES register field
  h/regs4 - Rename many registers to match the name used in the OMAP4 TRM (previously used OMAP3 naming due to shared code being used for both chips). Fix the occasional mistake. Also removed configuration4 register from DSI PLL (not mentioned in recent TRMs)
  omap4/c/dispc_plat - Updated for new register names
  omap4/c/dsi - Remove setting of DSI PLL configuration4 register
  omap4/c/dss - Update for new register names. Removal of regm4 from clock_divider_t. Update FIFO configuration so that the larger WB FIFO is used instead of the GFX one.
  omap4/c/omap - Update for new register names and FIFO setup. Fix omap4_vetmode_ldc2() returning true for invalid widths instead of false.
Admin:
  Changes supplied by Willi Theiss
  Tested on Pandaboard


Version 0.35. Tagged as 'OMAPVideo-0_35'
@
text
@d387 1
a387 184
#if OMAP==3
		DUMPREG(dss,sysconfig);
		DUMPREG(dss,sysstatus);
		DUMPREG(dss,irqstatus);
		DUMPREG(dss,control);
		DUMPREG(dss,sdi_control);
		DUMPREG(dss,pll_control);
		DUMPREG(dss,sdi_status);
#endif
#if OMAP==4
		DUMPREG(dss,sysstatus);
		DUMPREG(dss,ctrl);
		DUMPREG(dss,status);
#endif
		DUMPREG(dispc,sysconfig);
		DUMPREG(dispc,sysstatus);
		DUMPREG(dispc,irqstatus);
		DUMPREG(dispc,irqenable);
		DUMPREG(dispc,control1);
		DUMPREG(dispc,config1);
#if OMAP==3
		DUMPREG(dispc,default_color[0]);
#endif
		DUMPREG(dispc,default_color[1]);
#if OMAP==3
		DUMPREG(dispc,trans_color[0]);
#endif
		DUMPREG(dispc,trans_color[1]);
#if OMAP==4
		DUMPREG(dispc,control2);
		DUMPREG(dispc,config2);
		DUMPREG(dispc,default_color2);
		DUMPREG(dispc,trans_color2);
#endif
		DUMPREG(dispc,line_status);
		DUMPREG(dispc,line_number);
#if OMAP==3
		DUMPREG(dispc,timing_h);
		DUMPREG(dispc,timing_v);
		DUMPREG(dispc,pol_freq);
		DUMPREG(dispc,divisor);
#endif
#if OMAP==4
		DUMPREG(dispc,timing_h2);
		DUMPREG(dispc,timing_v2);
		DUMPREG(dispc,pol_freq2);
		DUMPREG(dispc,divisor2);
#endif
		DUMPREG(dispc,global_alpha);
#if OMAP==3
		DUMPREG(dispc,size_dig);
		DUMPREG(dispc,size_lcd);
#endif
#if OMAP==4
		DUMPREG(dispc,size_tv);
		DUMPREG(dispc,size_lcd2);
#endif
		DUMPREG(dispc,gfx.ba[0]);
		DUMPREG(dispc,gfx.ba[1]);
		DUMPREG(dispc,gfx.position);
		DUMPREG(dispc,gfx.size);
		DUMPREG(dispc,gfx.attributes);
#if OMAP==3
		DUMPREG(dispc,gfx.fifo_threshold);
		DUMPREG(dispc,gfx.fifo_size_status);
#endif
#if OMAP==4
		DUMPREG(dispc,gfx.buf_threshold);
		DUMPREG(dispc,gfx.buf_size_status);
#endif
		DUMPREG(dispc,gfx.row_inc);
		DUMPREG(dispc,gfx.pixel_inc);
		DUMPREG(dispc,gfx.window_skip);
		DUMPREG(dispc,gfx.table_ba);
		DUMPREG(dispc,vid1.ba[0]);
		DUMPREG(dispc,vid1.ba[1]);
		DUMPREG(dispc,vid1.position);
		DUMPREG(dispc,vid1.size);
		DUMPREG(dispc,vid1.attributes);
#if OMAP==3
		DUMPREG(dispc,vid1.fifo_threshold);
		DUMPREG(dispc,vid1.fifo_size_status);
#endif
#if OMAP==4
		DUMPREG(dispc,vid1.buf_threshold);
		DUMPREG(dispc,vid1.buf_size_status);
#endif
		DUMPREG(dispc,vid1.row_inc);
		DUMPREG(dispc,vid1.pixel_inc);
		DUMPREG(dispc,vid1.fir);
		DUMPREG(dispc,vid1.picture_size);
//		DUMPREG(dispc,vid1.accui[0]);
//		DUMPREG(dispc,vid1.accui[1]);
//		DUMPREG(dispc,vid1.fir_coef[0].h);
//		DUMPREG(dispc,vid1.fir_coef[0].hv);
//		DUMPREG(dispc,vid1.fir_coef[1].h);
//		DUMPREG(dispc,vid1.fir_coef[1].hv);
//		DUMPREG(dispc,vid1.fir_coef[2].h);
//		DUMPREG(dispc,vid1.fir_coef[2].hv);
//		DUMPREG(dispc,vid1.fir_coef[3].h);
//		DUMPREG(dispc,vid1.fir_coef[3].hv);
//		DUMPREG(dispc,vid1.fir_coef[4].h);
//		DUMPREG(dispc,vid1.fir_coef[4].hv);
//		DUMPREG(dispc,vid1.fir_coef[5].h);
//		DUMPREG(dispc,vid1.fir_coef[5].hv);
//		DUMPREG(dispc,vid1.fir_coef[6].h);
//		DUMPREG(dispc,vid1.fir_coef[6].hv);
//		DUMPREG(dispc,vid1.fir_coef[7].h);
//		DUMPREG(dispc,vid1.fir_coef[7].hv);
//		DUMPREG(dispc,vid1.conv_coef[0]);
//		DUMPREG(dispc,vid1.conv_coef[1]);
//		DUMPREG(dispc,vid1.conv_coef[2]);
//		DUMPREG(dispc,vid1.conv_coef[3]);
//		DUMPREG(dispc,vid1.conv_coef[4]);
		DUMPREG(dispc,vid2.ba[0]);
		DUMPREG(dispc,vid2.ba[1]);
		DUMPREG(dispc,vid2.position);
		DUMPREG(dispc,vid2.size);
		DUMPREG(dispc,vid2.attributes);
#if OMAP==3
		DUMPREG(dispc,vid2.fifo_threshold);
		DUMPREG(dispc,vid2.fifo_size_status);
#endif
#if OMAP==4
		DUMPREG(dispc,vid2.buf_threshold);
		DUMPREG(dispc,vid2.buf_size_status);
#endif
		DUMPREG(dispc,vid2.row_inc);
		DUMPREG(dispc,vid2.pixel_inc);
		DUMPREG(dispc,vid2.fir);
		DUMPREG(dispc,vid2.picture_size);
//		DUMPREG(dispc,vid2.accui[0]);
//		DUMPREG(dispc,vid2.accui[1]);
//		DUMPREG(dispc,vid2.fir_coef[0].h);
//		DUMPREG(dispc,vid2.fir_coef[0].hv);
//		DUMPREG(dispc,vid2.fir_coef[1].h);
//		DUMPREG(dispc,vid2.fir_coef[1].hv);
//		DUMPREG(dispc,vid2.fir_coef[2].h);
//		DUMPREG(dispc,vid2.fir_coef[2].hv);
//		DUMPREG(dispc,vid2.fir_coef[3].h);
//		DUMPREG(dispc,vid2.fir_coef[3].hv);
//		DUMPREG(dispc,vid2.fir_coef[4].h);
//		DUMPREG(dispc,vid2.fir_coef[4].hv);
//		DUMPREG(dispc,vid2.fir_coef[5].h);
//		DUMPREG(dispc,vid2.fir_coef[5].hv);
//		DUMPREG(dispc,vid2.fir_coef[6].h);
//		DUMPREG(dispc,vid2.fir_coef[6].hv);
//		DUMPREG(dispc,vid2.fir_coef[7].h);
//		DUMPREG(dispc,vid2.fir_coef[7].hv);
//		DUMPREG(dispc,vid2.conv_coef[0]);
//		DUMPREG(dispc,vid2.conv_coef[1]);
//		DUMPREG(dispc,vid2.conv_coef[2]);
//		DUMPREG(dispc,vid2.conv_coef[3]);
//		DUMPREG(dispc,vid2.conv_coef[4]);
#if OMAP==3
		DUMPREG(dispc,data_cycle[0]);
		DUMPREG(dispc,data_cycle[1]);
		DUMPREG(dispc,data_cycle[2]);
		DUMPREG(dispc,cpr_coef_r);
		DUMPREG(dispc,cpr_coef_g);
		DUMPREG(dispc,cpr_coef_b);
#endif
#if OMAP==4
		DUMPREG(dispc,data2_cycle[0]);
		DUMPREG(dispc,data2_cycle[1]);
		DUMPREG(dispc,data2_cycle[2]);
		DUMPREG(dispc,cpr2_coef_r);
		DUMPREG(dispc,cpr2_coef_g);
		DUMPREG(dispc,cpr2_coef_b);
#endif
		DUMPREG(dispc,gfx_preload);
		DUMPREG(dispc,vid_preload[0]);
		DUMPREG(dispc,vid_preload[1]);
		DUMPREG(dsi,ctrl);
		DUMPREG(dsi,clk_ctrl);
		DUMPREG(dsi_pll,control);
		DUMPREG(dsi_pll,status);
		DUMPREG(dsi_pll,go);
		DUMPREG(dsi_pll,configuration1);
		DUMPREG(dsi_pll,configuration2);
#if OMAP==4
		DUMPREG(dsi_pll, configuration3);
#endif
		printf("Ban state: %08x\n",ban_hardware_update);
d401 1
a401 44
		DUMPREG(venc,status);
		DUMPREG(venc,f_control);
		DUMPREG(venc,vidout_ctrl);
		DUMPREG(venc,sync_ctrl);
		DUMPREG(venc,llen);
		DUMPREG(venc,flens);
		DUMPREG(venc,hfltr_ctrl);
		DUMPREG(venc,cc_carr_wss_carr);
		DUMPREG(venc,c_phase);
		DUMPREG(venc,gain_u);
		DUMPREG(venc,gain_y);
		DUMPREG(venc,gain_v);
		DUMPREG(venc,black_level);
		DUMPREG(venc,blank_level);
		DUMPREG(venc,x_color);
		DUMPREG(venc,m_control);
		DUMPREG(venc,bstamp_wss_data);
		DUMPREG(venc,s_carr);
		DUMPREG(venc,line21);
		DUMPREG(venc,ln_sel);
		DUMPREG(venc,l21_wc_ctl);
		DUMPREG(venc,htrigger_vtrigger);
		DUMPREG(venc,savid_eavid);
		DUMPREG(venc,flen_fal);
		DUMPREG(venc,lal_phase_reset);
		DUMPREG(venc,hs_int_start_stop_x);
		DUMPREG(venc,hs_ext_start_stop_x);
		DUMPREG(venc,vs_int_start_x);
		DUMPREG(venc,vs_int_stop_x_vs_int_start_y);
		DUMPREG(venc,vs_int_stop_y_vs_ext_start_x);
		DUMPREG(venc,vs_ext_stop_x_vs_ext_start_y);
		DUMPREG(venc,vs_ext_stop_y);
		DUMPREG(venc,avid_start_stop_x);
		DUMPREG(venc,avid_start_stop_y);
		DUMPREG(venc,fid_int_start_x_fid_int_start_y);
		DUMPREG(venc,fid_int_offset_y_fid_ext_start_x);
		DUMPREG(venc,fid_ext_start_y_fid_ext_offset_y);
		DUMPREG(venc,tvdetgp_int_start_stop_x);
		DUMPREG(venc,tvdetgp_int_start_stop_y);
		DUMPREG(venc,gen_ctrl);
		DUMPREG(venc,output_control);
		DUMPREG(venc,output_test);
                DUMPREG(dispc,control1);
		DUMPREG(dss,control);
@


1.17
log
@Big code refactor
Detail:
  Support for different OMAP revisions has now been abstracted, with code specific to a certain OMAP revision now located in the omap3 and omap4 folders. This has resulted in some code duplication, but greater readability due to the removal of the #defines that were in use before. This new structure should also make it easier to implement new features, especially those only supported by certain OMAPs.
  Each platform provides a headattrs struct and an overlayattrs struct, which are the primary interface the core code uses to control the backend. Eventually it may be possible to produce one build of the module which supports multiple OMAP revisions at runtime, but for now some #defines and OMAP-specific code remains in the common files.
  This change also adds support for extra pixel formats, gamma table support for OMAP4, and fixes several bugs.
Admin:
  Tested on BeagleBoard, PandaBoard


Version 0.34. Tagged as 'OMAPVideo-0_34'
@
text
@d119 1
a119 1
    
d126 1
a126 1
    
d128 1
a128 1
    
d142 1
a142 1
    
d150 1
a150 1
    
d157 1
a157 1
    
d176 1
a176 1
    
d196 1
a196 1
    
d216 1
a216 1
    
d222 1
a222 1
    
d241 1
a241 1
    
d252 1
a252 1
    
d266 1
a266 1
    
d268 1
a268 1
    
d273 1
a273 1
	_swix(OS_Release, _INR(0,2), GraphicsV, graphicsv_entry, pw);    
d308 1
a308 1
    
d324 1
a324 1
    
d333 1
a333 1
    
d398 1
a398 1
		DUMPREG(dss,control);
d436 1
a437 1
#if OMAP==3
d441 1
d449 1
d452 5
d466 1
d469 5
d506 1
d509 5
a568 1
		DUMPREG(dsi_pll, configuration4);
d711 1
a711 1
	
@


1.16
log
@Update for new GraphicsV registration process. Remove VIDC20 16bpp gamma demangle code. Advertise red/blue swapped 16bpp & 32bpp modes when using TV-out.
Detail:
  c/cmodule - Updated to use new GraphicsV registration process and OS_Hardware reason code #defines
  c/dispc, c/venc, h/graphicsv, h/venc - Use Hdr:VIDCList instead of local VIDC list definition
  c/graphicsv - Implement GraphicsV_PixelFormats, and return an appropriate list based on whether TV-out is in use. Call through to the HAL for GraphicsV_IICOp instead of relying on the OS to call the HAL for us.
  c/palette - Remove VIDC20 16bpp gamma demangle code, the OS now supplies the data in a sensible format. Dont use mouse palette function intended for 555 mode emulation if CPR isn't in use (i.e. we're on TV-out, i.e. gamma won't be available either)
Admin:
  Tested in OMAP3 ROM on BB-xM
  OMAP4 version builds but is unstested
  Requires HdrSrc-2_38 and Kernel-5_35-4_79_2_203


Version 0.28. Tagged as 'OMAPVideo-0_28'
@
text
@a40 1
#include "Global/Countries.h"
d50 1
d63 2
a64 1
overlay_t overlays[OVERLAY_MAX];
d72 1
a72 1
transparencycfg current_transparencycfgs[TARGET_MAX] = {TRANSPARENCY_TCK_VIDSRC,TRANSPARENCY_TCK_VIDSRC};
d75 1
a75 2
overlaytarget default_display = TARGET_LCD;
bool blanked = false;
d89 22
a110 40
#if OMAP==3
const uint8_t overlay_format_bpp[16] = {1,2,4,8,16,16,16,0,32,24,64,64,32,32,32,0};
const uint16_t fifo_preload_for_lcd[LCD_MAX] = {0, 0x60, 0x72, 0xE0, 0xE0};
const uint32_t transparency_lut[TARGET_MAX][TRANSPARENCY_MAX] =
{
	{
		0,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_TCKLCDSELECTION,
		DISPC_CONFIG_TCKLCDENABLE,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_LCDALPHABLENDERENABLE,
		DISPC_CONFIG_LCDALPHABLENDERENABLE,
	},
	{
		0,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TCKDIGSELECTION,
		DISPC_CONFIG_TCKDIGENABLE,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TVALPHABLENDERENABLE,
		DISPC_CONFIG_TVALPHABLENDERENABLE,
	},
};
#endif
#if OMAP==4
const uint8_t overlay_format_bpp[16] = {1,2,4,8,16,16,16,16,32,24,16,16,32,32,32,16};
const uint16_t fifo_preload_for_lcd[LCD_MAX] = {0, 0x100, 0x72, 0xE0, 0xE0};
const uint32_t transparency_lut[TARGET_MAX][TRANSPARENCY_MAX] =
{
	{
		0,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_TCKLCDSELECTION,
		DISPC_CONFIG_TCKLCDENABLE,
		DISPC_CONFIG_TCKLCDENABLE | DISPC_CONFIG_LCDALPHABLENDERENABLE,
		DISPC_CONFIG_LCDALPHABLENDERENABLE,
	},
	{
		0,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TCKDIGSELECTION,
		DISPC_CONFIG_TCKDIGENABLE,
		DISPC_CONFIG_TCKDIGENABLE | DISPC_CONFIG_TVALPHABLENDERENABLE,
		DISPC_CONFIG_TVALPHABLENDERENABLE,
	},
a111 104
#endif

#ifdef SUPPORT_TV_MODE
static bool get_default_tv_mode(tvmode *mode,tvouttype *type)
{
	/* Prefer S-Video over composite output */
	if(hwconfig->flags & BOARDCONFIG_SVIDEO)
		*type = TVOUT_SVIDEO;
	else if(hwconfig->flags & BOARDCONFIG_COMPOSITE)
		*type = TVOUT_COMPOSITE;
	else
		return false;
	/* Use configured territory to decide which signal mode to use
	   TODO - Add as SWI to territory manager */
	uint32_t territory;
	if(_swix(Territory_Number,_OUT(0),&territory))
		return false;
	/* We can only handle PAL and NTSC, and currently don't care too much about different variants
	   However anecdotal evidence suggests many SECAM TVs are dual-standard, so try using PAL in SECAM territories */
#define MODE_PAL *mode = TVMODE_PAL_601; break;
#define MODE_NTSC *mode = TVMODE_NTSC_601; break;
#define MODE_SECAM *mode = TVMODE_PAL_601; break;
#define MODE(x,y) MODE_ ## x
	/* Partial list of territories - some non-countries like 'Master', 'Compact', 'Esperanto', etc. ignored
	   Information from http://countrycode.org/tv-standards */
	switch(territory)
	{
	default:
		return false;
	case TerritoryNum_Albania:	MODE(PAL,BG);
	case TerritoryNum_Arabic:	MODE(PAL,BG); /* Most Arabic nations appear to use PAL B/G */
	case TerritoryNum_Australia:	MODE(PAL,BG);
	case TerritoryNum_Austria:	MODE(PAL,BG);
	case TerritoryNum_Belgium:	MODE(PAL,BH)
	case TerritoryNum_Bengal:	MODE(PAL,B) /* (Bangladesh) */
	case TerritoryNum_Brazil:	MODE(PAL,M)
	case TerritoryNum_Bulgaria:	MODE(PAL,_)
	case TerritoryNum_ByeloRuss:	MODE(SECAM,DK) /* (Belarus?) */
	case TerritoryNum_Canada1:	MODE(NTSC,M)
	case TerritoryNum_Canada2:	MODE(NTSC,M)
	case TerritoryNum_Canada:	MODE(NTSC,M)
	case TerritoryNum_China:	MODE(PAL,D)
	case TerritoryNum_Czech:	MODE(PAL,BGDK)
	case TerritoryNum_Denmark:	MODE(PAL,BG)
	case TerritoryNum_Devanag:	MODE(PAL,B) /* (Devanagari -> Sanskrit -> India) */
	case TerritoryNum_Estonia:	MODE(PAL,BG)
	case TerritoryNum_Faroe:	MODE(PAL,BG) /* (Faroes -> Denmark) */
	case TerritoryNum_Farsi:	MODE(PAL,B) /* Most Persian nations appear to use PAL B(/G) */
	case TerritoryNum_Finland:	MODE(PAL,BG)
	case TerritoryNum_France:	MODE(SECAM,L)
	case TerritoryNum_Gaelic:	MODE(PAL,I)
	case TerritoryNum_Germany:	MODE(PAL,BG)
	case TerritoryNum_Greece:	MODE(PAL,BG)
	case TerritoryNum_GreeceAnct:	MODE(PAL,BG)
	case TerritoryNum_Greenland:	MODE(PAL,B)
	case TerritoryNum_Gujarati:	MODE(PAL,B) /* (India) */
	case TerritoryNum_HongKong:	MODE(PAL,I)
	case TerritoryNum_Hungary:	MODE(PAL,K)
	case TerritoryNum_Iceland:	MODE(PAL,BG)
	case TerritoryNum_Ireland:	MODE(PAL,I)
	case TerritoryNum_Israel:	MODE(PAL,BG)
	case TerritoryNum_Italy:	MODE(PAL,BG)      
	case TerritoryNum_Japan:	MODE(NTSC,M)
	case TerritoryNum_Korea:	MODE(NTSC,M) /* (South) */
	case TerritoryNum_Lapp:		MODE(PAL,BG) /* (Sami) */
	case TerritoryNum_Latvia:	MODE(PAL,BG)
	case TerritoryNum_Lithuania:	MODE(PAL,BG)
	case TerritoryNum_Macedonia:	MODE(PAL,BH)
	case TerritoryNum_Malta:	MODE(PAL,B)
	case TerritoryNum_Maori:	MODE(PAL,BG) /* (New Zealand) */
	case TerritoryNum_Mexico:	MODE(NTSC,M)
	case TerritoryNum_MiddleEast:	MODE(PAL,BG) /* Most/all middle-eastern countries appear to use PAL B/G */
	case TerritoryNum_Netherland:	MODE(NTSC,M)
	case TerritoryNum_Norway:	MODE(PAL,BG)
	case TerritoryNum_Poland:	MODE(PAL,DK)
	case TerritoryNum_Portugal:	MODE(PAL,BG)
	case TerritoryNum_Punjab:	MODE(PAL,B) /* (India/Pakistan) */
	case TerritoryNum_Romania:	MODE(PAL,DG)
	case TerritoryNum_Russia2:	MODE(SECAM,DK)
	case TerritoryNum_Russia:	MODE(SECAM,DK)
	case TerritoryNum_SAfrica2:	MODE(PAL,I)
	case TerritoryNum_SAfrica:	MODE(PAL,I)
	case TerritoryNum_SerboCroat:	MODE(PAL,B) /* Serbia: PAL B/G, Croatia: PAL B/H */
	case TerritoryNum_Slovak:	MODE(PAL,BG)
	case TerritoryNum_Slovene:	MODE(PAL,BH)
	case TerritoryNum_Spain:	MODE(PAL,BG)
	case TerritoryNum_Sweden:	MODE(PAL,BG)
	case TerritoryNum_Swiss1:	MODE(SECAM,L) /* (French) */
	case TerritoryNum_Swiss2:	MODE(PAL,BG) /* (German) */
	case TerritoryNum_Swiss3:	MODE(PAL,BG) /* (Italian) */
	case TerritoryNum_Swiss4:	MODE(PAL,BG) /* (Romansch) */
	case TerritoryNum_Switzerland:	MODE(PAL,BG)
	case TerritoryNum_Taiwan:	MODE(NTSC,_)
	case TerritoryNum_Tamil:	MODE(PAL,_)
	case TerritoryNum_Turkey:	MODE(PAL,B)
	case TerritoryNum_UK:		MODE(PAL,I)
	case TerritoryNum_Ukraine:	MODE(SECAM,DK)
	case TerritoryNum_USA:		MODE(NTSC,M)
	case TerritoryNum_Wales2:	MODE(PAL,I)
	case TerritoryNum_Wales:	MODE(PAL,I)
	}
	return true;
}
#endif /* SUPPORT_TV_MODE */
a118 1
	uint32_t mode;
d161 14
a174 2
		memset(&overlays[i],0,sizeof(overlay_t));
		overlays[i].target = TARGET_NONE;
d233 1
a233 1
	select_palette_func(OVERLAY_ATTRIBUTES_FORMAT_BMP1,true);
d259 2
a260 28
#ifdef SUPPORT_TV_MODE
	/* If we're running on a board that supports TV-out, use that for output if a TV is detected */
	tvouttype tv_type;
	tvmode tv_mode;
	if((hwconfig->mysize > offsetof(boardconfig_t,tvdet_func)) && (hwconfig->tvdet_func) && get_default_tv_mode(&tv_mode,&tv_type))
	{
		/* Wake up TV output */
		venc_set_tvmode(tv_mode,tv_type,false,NULL);
		/* Enable TV detection */
		venc->gen_ctrl |= VENC_GEN_CTRL_EN;
		/* Wait a few frames to ensure result is valid */
		_swix(OS_Hardware,_IN(0)|_INR(8,9),100000,OSHW_CallHAL,EntryNo_HAL_CounterDelay);
		/* Poll relevant GPIO */
		bool result = (hwconfig->tvdet_func)(dev);
		/* Disable TV detection */
		venc->gen_ctrl &= ~ VENC_GEN_CTRL_EN;
		dprintf(("", "TV detection result: %d\n",result));
		/* Check result */
		if(result)
		{
			default_display = TARGET_TV;
		}
		else
		{
			venc_set_tvmode(tv_mode,TVOUT_NONE,false,NULL);
		}
	}
#endif /* SUPPORT_TV_MODE */
d270 1
a270 1
    
d300 1
a300 1
    
d339 38
a382 1
#ifndef SUPPORT_TV_MODE
a383 1
#endif /* !SUPPORT_TV_MODE */
d561 1
a561 1
		venc_set_tvmode((tvmode) mode,(tvouttype) type,(bool) testmode,NULL);
d611 14
a624 2
	case CMD_TVOut:
#ifdef SUPPORT_TV_MODE
d626 1
a626 3
		int mode = (int)strtoul(arg_string,0,10);
		default_display = (mode?TARGET_TV:TARGET_LCD);
		/* Don't bother with hardware update for now */
a627 1
#endif /* SUPPORT_TV_MODE */
d662 30
@


1.15
log
@Internationalised
The failure to activate error message is a little tenuous, but distinct and non zero.
Built, but not tested.

Version 0.27. Tagged as 'OMAPVideo-0_27'
@
text
@d42 1
d255 1
a255 1
		e = _swix(OS_Hardware, _INR(0,1) | _IN(8) | _OUTR(1,2), HALDeviceType_Video + HALDeviceVideo_VDU,pos,4,&pos,&dev);
d345 7
d353 1
a353 1
	/* Claim & enable */
d357 1
a357 1
		goto error3;
d359 1
a359 1
	e = _swix (OS_Hardware, _IN(0) | _INR(8,9), dev->dev.devicenumber&~(1u<<31), 0, EntryNo_HAL_IRQEnable);
d362 1
a362 1
		goto error4;
d368 1
a368 1
		goto error4;
d381 1
a381 1
		_swix(OS_Hardware,_IN(0)|_INR(8,9),100000,0,EntryNo_HAL_CounterDelay);
d399 4
a402 7
	/* Perform a mode change so we get something on screen ASAP */
	e = _swix(OS_ScreenMode, _IN(0)|_OUT(1), 1, &mode);
	if(!e)
	{
		dprintf(("", "Setting initial mode to %08x\n",mode));
		_swix(OS_ScreenMode, _INR(0,1), 0, mode);
	}
d408 4
a411 1
error4:
d414 3
d438 6
d458 3
@


1.14
log
@Add support for TV detection and automatic TV mode selection on OMAP3. Make boardconfig_t struct extensible.
Detail:
  c/cmodule - If TV support is enabled (i.e. OMAP3 build), and the boardconfig_t indicates that TV-out is supported, the module will now use the TV detection feature to check if a TV is connected on startup. If a TV is found then a suitable TV mode will be chosen from the configured territory, and the TV output will be set as the main display.
  h/globals - Modified boardconfig_t to make the structure extensible - two padding bytes are now used to store the size of the struct as reported by the HAL device. Added new entry to boardconfig_t for the TV detection function.
Admin:
  Tested on BB-xM with high processor vectors


Version 0.24. Tagged as 'OMAPVideo-0_24'
@
text
@d37 1
d259 3
a261 1
			return (_kernel_oserror*) "\0\0\0\0No OMAP video devices found";
d268 3
a270 1
		return (_kernel_oserror*) "\0\0\0\0Video device failed to activate";
@


1.13
log
@Improve TV-out support
Detail:
  c/cmodule, c/dispc, c/graphicsv, c/venc, h/venc - Updated TV-out code to center the desktop within the display, while also taking into account the border/porch timings in order to allow vertical shifting using *TV.
Admin:
  Tested on rev A2 BB-xM


Version 0.22. Tagged as 'OMAPVideo-0_22'
@
text
@d40 1
d50 4
d130 103
d357 29
a392 9

#if 0
	/* Wake up TV output */
	venc_set_tvmode(TVMODE_PAL_601,TVOUT_SVIDEO,false,NULL);
	default_display = TARGET_TV;
	e = _swix(OS_ScreenMode, _IN(0)|_OUT(1), 1, &mode);
	if(!e)
		_swix(OS_ScreenMode, _INR(0,1), 0, mode);
#endif
a449 3
#if OMAP==3
#define SUPPORT_TV_MODE 1
#endif
@


1.12
log
@Some pointers initialised to NULL rather than 0.
Compiles, not tested.

Version 0.21. Tagged as 'OMAPVideo-0_21'
@
text
@d256 9
d512 1
a512 1
		venc_set_tvmode((tvmode) mode,(tvouttype) type,(bool) testmode);
@


1.11
log
@Merge of OMAP3 and OMAP4 video driver sources.
With 85%+ shared code, tracking changes between these two modules was getting complicated, so now this single module will serve both OMAP3 targets and OMAP4.
At present, the differences are simply selected at compile time with a switch. This may make sense to further rationalise either with tidier macros or run time detection (since the HAL knows which controller is running).
Tested on OMAP3 in all 8 colour depths,
Tested by Willi Theiss on OMAP4.

Version 0.20. Tagged as 'OMAPVideo-0_20'
@
text
@d52 1
a52 1
vdu_device_t *dev=0;
d54 1
a54 1
const boardconfig_t *hwconfig=0;
d129 1
a129 1
	_kernel_oserror* e = 0;
d283 1
a283 1
	_kernel_oserror* e = 0;
@


1.10
log
@Merge of headers with OMAP4Video
For the most part, this is just adding "_t" suffixes to all the typedefs.
The OMAP4 controller registers are in "regs4.h" and OMAP3 in "regs3.h", they are selected between with a compile time switch - hence !MkROM becomes !Ms !MkRom3 and !MkRom4.
OMAP3 version tested & still works, OMAP4 will not work.

Version 0.19. Tagged as 'OMAPVideo-0_19'
@
text
@d82 1
d102 22
d152 1
a152 1
	} while(dev->dev.id != HALDeviceID_VDU_OMAP3);
d176 1
d183 9
d204 2
a205 1
		dprintf(("","Using DMA channel at %08x\n",sdmachan));
d313 4
a316 1
extern int sdma_stats[4];
d321 6
a326 1
	(void) pw;
d329 1
d337 6
d347 3
a349 2
		DUMPREG(dispc,control);
		DUMPREG(dispc,config);
d351 1
d353 1
d355 1
d357 6
d365 1
d370 7
d379 1
d381 4
d464 1
d471 9
d490 4
d497 1
d500 3
a502 3
		int mode = strtoul(arg_string,&str,10);
		int type = strtoul(str,&str,10);
		int testmode = strtoul(str,0,10);
d505 1
d550 1
a550 1
		DUMPREG(dispc,control);
d554 1
d556 1
a556 1
		int mode = strtoul(arg_string,0,10);
d560 1
@


1.9
log
@Activate display on module startup
Detail:
  c/cmodule - Issue a dummy mode change on module startup in order to activate the screen earlier on in the ROM boot sequence. Should make it clearer that the machine hasn't crashed, and increase the chances of users spotting any fatal ROM initialisation errors.
Admin:
  Tested on rev A2 BB-xM


Version 0.18. Tagged as 'OMAPVideo-0_18'
@
text
@d52 1
a52 1
vdu_device *dev=0;
d54 1
a54 1
const boardconfig *hwconfig=0;
d56 1
a56 1
overlay overlays[OVERLAY_MAX];
d59 1
a59 1
lcdtimings current_timings;
d73 1
a73 1
palette_func gfx_palette_func=NULL;
d80 1
a80 1
palette_func mouse_palette_func=NULL;
d83 1
a83 1
const uint8_t fifo_preload_for_lcd[LCD_MAX] = {0, 0x60, 0x72, 0xE0, 0xE0};
d138 1
a138 1
	hwconfig = (boardconfig *) dev->devicespecificfield;
d147 1
a147 1
		memset(&overlays[i],0,sizeof(overlay));
d152 7
a158 7
	dss = (dss_regs *) dev->dev.address;
	dispc = (dispc_regs *) (((uint32_t)dev->dev.address)+0x400);
	rfbi = (rfbi_regs *) (((uint32_t)dev->dev.address)+0x800);
	venc = (venc_regs *) (((uint32_t)dev->dev.address)+0xc00);
	dsi = (dsi_regs *) (((uint32_t)dev->dev.address)-0x400);
	dsi_phy = (dsi_phy_regs *) (((uint32_t)dev->dev.address)-0x200);
	dsi_pll = (dsi_pll_regs *) (((uint32_t)dev->dev.address)-0x100);
@


1.8
log
@When disabling CLNK only clear the enable bit rather than the whole register.

Version 0.16. Tagged as 'OMAPVideo-0_16'
@
text
@d108 1
d214 8
@


1.7
log
@Fix black screen on boot issue. Use C99 number types.
Detail:
  c/dss - Fixed the cause of the black screens on boot on OMAP3 machines (DM37xx seems fine). It looks like the cause was due to skipping the step where you disable the LCD output before triggering the DSS reset.
  c/cmodule, c/dispc, c/dss, c/graphicsv, h/globals - Removed code relating to previous attempts to fix the black screen issue
  c/cmodule, c/dispc, c/dsi, c/dss, c/graphicsv, c/palette, c/regs, c/sdma, c/venc, h/dsi, h/dss, h/globals, h/graphicsv, h/palette, h/regs - Use the C99 number types instead of u32, u16, etc.
Admin:
  Tested on rev C2 BB, rev A2 BB-xM


Version 0.13. Tagged as 'OMAPVideo-0_13'
@
text
@d173 1
a173 1
		sdmachan->clnk_ctrl = 0;
@


1.6
log
@Fix GraphicsV_Render operations being performed on wrong screen bank
Detail:
  c/cmodule, c/graphicsv, c/sdma, h/globals - Fixed GraphicsV_Render code to perform render ops to the VDU screen bank instead of the display bank.
  Also disabled the slow left-to-right DMA copy code, since the kernels' assembler loop is many times faster.
Admin:
  Tested on rev A2 BB-xM. Fixes issue reported on forums:
  http://www.riscosopen.org/forum/forums/4/topics/691


Version 0.12. Tagged as 'OMAPVideo-0_12'
@
text
@d57 2
a58 2
u32 vdu_init = ~0;
u32 dsi_pll_current_pixel_rate=0;
d70 3
a72 3
u32 *gfx_palette_l;
u32 gfx_palette_p;
u32 gfx_palette_ro[256];
d74 1
a74 1
u32 mouse_palette_soft[4];
d76 4
a79 4
u32 *mouse_image_l;
u32 mouse_image_p;
u8 mouse_image_soft[32*32/4];
u32 mouse_palette_ro[4];
d82 3
a84 3
const u8 overlay_format_bpp[16] = {1,2,4,8,16,16,16,0,32,24,64,64,32,32,32,0};
const u8 fifo_preload_for_lcd[LCD_MAX] = {0, 0x60, 0x72, 0xE0, 0xE0};
const u32 transparency_lut[TARGET_MAX][TRANSPARENCY_MAX] =
a101 2
int exp_synclost_count=0;

d104 2
d107 1
a107 1
	u32 mask=0;
d152 6
a157 6
	dispc = (dispc_regs *) (((u32)dev->dev.address)+0x400);
	rfbi = (rfbi_regs *) (((u32)dev->dev.address)+0x800);
	venc = (venc_regs *) (((u32)dev->dev.address)+0xc00);
	dsi = (dsi_regs *) (((u32)dev->dev.address)-0x400);
	dsi_phy = (dsi_phy_regs *) (((u32)dev->dev.address)-0x200);
	dsi_pll = (dsi_pll_regs *) (((u32)dev->dev.address)-0x100);
d214 1
a214 1
	dprintf(("", "Finished module initialisation, DSS regs=%08x\n",(u32)dss));
d237 3
d271 1
a271 1
#define DUMPREG(BANK,REG) printf("%08x: %08x %s.%s\n",(u32) &(BANK->REG),BANK->REG,#BANK,#REG)
d275 1
@


1.5
log
@Fix GraphicsV_SetBlank. Improve SetBlank to turn off the overlays. Trim dead code.
Detail:
  c/cmodule, c/dispc, c/graphicsv, h/globals - Fixed do_setblank to set DISPC_CONTROL_GOLCD, to ensure the relevant clocks have their states updated. Added 'blanked' flag to allow the graphics overlays to be disabled entirely whenever the screen should be blanked.
  c/dispc - Trim some dead code related to trying to fix the IGEP display issues.
Admin:
  Tested on rev C2 BB, A2 BB-xM, C1 TouchBook.
  Fixes bug #263 - http://www.riscosopen.org/tracker/tickets/263


Version 0.11. Tagged as 'OMAPVideo-0_11'
@
text
@d57 1
@


1.4
log
@Improve OMAPVideo power saving abilities and palette handling
Detail:
  Makefile, c/palette, h/palette, c/cmodule, c/dispc, c/graphicsv, h/globals - Rewrote palette handling code to support multiple different transformations on palettes, to adapt the palettes from the RISC OS formats to the DISPC formats. This means that palettes and the mouse cursor are now correctly R/B swapped for TV-out, RISC OS's gamma correction tables are now supported, and clever use of gamma tables allows 16bpp modes to be displayed correctly by mapping RISC OS's 555 format to the OMAP's 565 format (but there'll only be 4 blue bits instead of 5)
  c/cmodule, c/dispc, c/graphicsv, h/globals - Add support for the HAL's new display power controls, and implement GraphicsV_SetBlank. For fixed LCDs this will ignore the requested DPMS state and instead just turn the power/backlight off.
  h/sdma - Marked the functions as extern.
Admin:
  Tested on rev C2 beagleboard, rev C1 touchbook.
  Requires OMAP3 HAL 0.34.


Version 0.08. Tagged as 'OMAPVideo-0_08'
@
text
@d67 1
@


1.3
log
@OMAPVideo fixes & tweaks
Detail:
  Makefile - now rewritten to use CModule fragment instead of obsolete RAMCModule/ROMCModule fragments
  c/cmodule - Make *videoregs print out a couple more regs
  c/dsi - Fix debug output when DSI requests time out. Fix HSDIVIDER not working on AM/DM37x.
  c/graphicsv - When setting the mode from a VIDC list, add the border values to the porch values to take into account the hardware's inability to emulate VIDC's coloured border facility. Behaviour matches that of NVidia module.
  h/regs - Add definitions for SMS registers (for display rotation)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.07. Tagged as 'OMAPVideo-0_07'
@
text
@d54 1
a54 1
boardconfig *hwconfig=0;
d70 2
d77 2
d136 4
d191 3
d241 4
@


1.2
log
@Fix makefile to allow debug builds of OMAPVideo, and change default DebugLib output device to HAL_OUTPUT
Detail:
  Makefile - fixed a couple of mistakes that prevented debug builds of the module from being compiled
  c/cmodule - changed default debug output device to HAL_OUTPUT to avoid PRINTF_OUTPUT interfering with the screen and potentially breaking stuff
Admin:
  Tested in OMAP ROM on rev C2 beagleboard


Version 0.02. Tagged as 'OMAPVideo-0_02'
@
text
@d371 2
@


1.1
log
@Add initial version of OMAP video driver module
Detail:
  All-new OMAP video driver, written as a module in C.
  Functionality-wise it's basically the same as the original HAL-based driver, except it provides support for GraphicsV_Render via use of the OMAP SDMA controller, and there's currently no support for GraphicsV_IICOp.
  However under the hood the module is significantly different, to ensure it can be expanded to expose the full feature set of the video controller once the new GraphicsV API is ready.
Admin:
  Tested on rev C2 beagleboard.


Version 0.01. Tagged as 'OMAPVideo-0_01'
@
text
@d105 1
a105 4
//	debug_set_options(2,0,115200);
//	debug_set_device(SERIAL_OUTPUT);
//	debug_set_device(DADEBUG_OUTPUT);
	debug_set_device(PRINTF_OUTPUT);
@


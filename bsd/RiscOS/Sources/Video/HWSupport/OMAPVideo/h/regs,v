head	1.9;
access;
symbols
	OMAPVideo-0_41:1.9
	OMAPVideo-0_40:1.8
	OMAPVideo-0_39:1.8
	OMAPVideo-0_38:1.8
	OMAPVideo-0_37:1.8
	OMAPVideo-0_36:1.7
	OMAPVideo-0_35:1.7
	OMAPVideo-0_34:1.7
	OMAPVideo-0_33:1.6
	OMAPVideo-0_32:1.6
	OMAPVideo-0_31:1.6
	OMAPVideo-0_30:1.6
	OMAPVideo-0_29:1.6
	OMAPVideo-0_28:1.6
	OMAPVideo-0_27:1.6
	OMAPVideo-0_26:1.6
	OMAPVideo-0_25:1.6
	OMAPVideo-0_24:1.6
	OMAPVideo-0_23:1.6
	OMAPVideo-0_22:1.6
	OMAPVideo-0_21:1.6
	OMAPVideo-0_20:1.6
	OMAPVideo-0_19:1.5
	OMAPVideo-0_18:1.4
	OMAPVideo-0_17:1.4
	OMAPVideo-0_16:1.4
	OMAPVideo-0_15:1.4
	OMAPVideo-0_14:1.4
	OMAPVideo-0_13:1.4
	OMAPVideo-0_12:1.3
	OMAPVideo-0_11:1.3
	OMAPVideo-0_10:1.3
	OMAPVideo-0_09:1.3
	OMAPVideo-0_08:1.3
	OMAPVideo-0_07:1.3
	OMAPVideo-0_06:1.2
	OMAPVideo-0_05:1.2
	OMAPVideo-0_04:1.2
	OMAPVideo-0_03:1.2
	OMAPVideo-0_02:1.1
	OMAPVideo-0_01:1.1;
locks; strict;
comment	@# @;


1.9
date	2018.05.31.21.48.57;	author jlee;	state Exp;
branches;
next	1.8;
commitid	qHkabDo5zjgySuEA;

1.8
date	2015.06.14.13.52.08;	author jlee;	state Exp;
branches;
next	1.7;
commitid	I7TOmn2EUkLh1ppy;

1.7
date	2015.05.17.17.50.16;	author jlee;	state Exp;
branches;
next	1.6;
commitid	J3i0xRSaySaJePly;

1.6
date	2012.05.06.09.20.46;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	Dmkx2IqcO2G8YD3w;

1.5
date	2012.05.06.09.16.47;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	imAmvVvRmuLKWD3w;

1.4
date	2011.10.23.21.01.57;	author jlee;	state Exp;
branches;
next	1.3;
commitid	0rwNv0ztfd3f9wEv;

1.3
date	2010.09.14.21.12.58;	author jlee;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.22.20.42.59;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.28.19.01.19;	author jlee;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Big refactor, introduce GraphicsV overlay API support
Detail:
  This change introduces initial support for the GraphicsV overlay API.
  RGB & YUV overlays are supported, along with rotation and scaling.
  Vertical flipping isn't supported yet, and there are still a number of bugs to track down, along with some potential improvements.
  The code has also been refactored significantly, in an attempt to protect all critical state with spinlocks/mutexes (as appropriate), and to reduce the number of globals so that it's easier to see what's touching what. Previously very little locking was performed, which could lead to issues if VSyncs or synclost interrupts occurred during certain operations. Now, the data should be structured in such a way that this shouldn't cause problems.
  Notable things:
  * State which needs to be writable from interrupt handlers is protected by spinlocks
  * State which needs to be readable from interrupt handlers is protected by reader-writer spinlocks
  * State which doesn't need to be accessed from interrupt handlers is unprotected (mutexes can be introduced in the future to make the code SMP-safe)
  * Using non-alpha screen modes for the desktop will currently result in only "basic" overlays being supported (i.e. overlays which appear ontop of the desktop). In some cases this could be improved by falling back to a software pointer, but for now the only way to get Z-Order overlays is to use a screen mode with an alpha channel.
  * Memory allocation for overlays is abstracted via the buffer interface (h/buffer). This has three implementations: basic buffers for untransformed overlays, VRFB-transformed buffers for OMAP3, and TILER-transformed buffers for OMAP4.
  * Ultimately all overlay memory is allocated as physically contiguous pages within a PMP - although since TILER contains its own MMU this isn't strictly necessary on OMAP4
  * Overlay memory is mapped as write-through cacheable for CPU access; experimentation with different cache policies has yet to be performed. However a potential future optimisation would be to perform lazy unmapping of overlay buffers, reducing the map/unmap overhead in well-behaved code which only maps buffers when they're needed
Admin:
  Tested on BB-xM, Pandaboard


Version 0.41. Tagged as 'OMAPVideo-0_41'
@
text
@/*
 * Copyright (c) 2010, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef OMAPVIDEO_REGS_H
#define OMAPVIDEO_REGS_H

#include <stdbool.h>
#include <stdint.h>

typedef struct fir_coef {
	uint32_t h;
	uint32_t hv;
} fir_coef_t;

#if OMAP==3
 #include "regs3.h"
 #define HALDeviceID_VDU_Desired   HALDeviceID_VDU_OMAP3
#else
 #if OMAP==4
  #include "regs4.h"
  #define HALDeviceID_VDU_Desired  HALDeviceID_VDU_OMAP4
 #else
  #error "Not a supported OMAP variant"
 #endif
#endif

#ifdef DEBUGLIB
#define DUMPREG(BANK,REG) printf("%08x: %08x %s.%s\n",(uint32_t) &(BANK->REG),BANK->REG,#BANK,#REG)
#endif

/* Register blocks */
extern volatile struct dss_regs      *dss;
extern volatile struct dispc_regs    *dispc;
extern volatile struct rfbi_regs     *rfbi;
extern volatile struct venc_regs     *venc;
extern volatile struct dsi_regs      *dsi;
extern volatile struct dsi_phy_regs  *dsi_phy;
extern volatile struct dsi_pll_regs  *dsi_pll;
extern volatile struct sdma_regs     *sdma;
extern volatile struct sdmachan_regs *sdmachan; /* Only using 1 channel */

/* Update control */

#define BHUB_OFF		0x1 /* Ban hardware update due to hardware being off */
#define BHUB_SYNCLOST		0x2 /* Ban hardware update due to SYNCLOST IRQ */
#define BHUB_SYNCLOSTDIGITAL	0x4 /* Ban hardware update due to SYNCLOSTDIGITAL IRQ */

extern uint32_t ban_hardware_update; /* Bitflags used to ban hardware updates (GOLCD/GODIGITAL, etc) */

extern void set_ban(uint32_t flags); /* Set ban flags */
extern void clear_ban(uint32_t flags); /* Clear ban flags */
extern bool begin_quick_hardware_update(int *irqstate); /* Return true for success, false for failure. Disables IRQs and stores old state in irqstate */
extern void end_quick_hardware_update(int irqstate);
extern bool begin_slow_hardware_update(int *irqstate); /* Return true for success, false for failure. Disables DISPC IRQs and stores old state in irqstate */
extern void end_slow_hardware_update(int irqstate);

#endif
@


1.8
log
@Misc tweaks
Detail:
  c/cmodule, c/sdma, h/regs, h/sdma, omap3/c/omap, omap4/c/omap - Move *SDMARegs handling from c/cmodule to c/sdma. Define DUMPREG in h/regs instead of in each individual file that uses it.
  omap3/c/dispc_plat, omap4/c/dispc_plat - Fix setting of GO bits in dispc_flush_transparency_cfg()
  omap4/c/dss - Update comment
  omap4/c/omap - Use designated initialisers for omapformats array to ensure it stays in sync with enum ordering. Strip dead code.
Admin:
  Changes supplied by Willi Theiss
  Tested on BB-xM


Version 0.37. Tagged as 'OMAPVideo-0_37'
@
text
@d34 5
a64 1
//extern volatile struct sms_regs *sms;
@


1.7
log
@Big code refactor
Detail:
  Support for different OMAP revisions has now been abstracted, with code specific to a certain OMAP revision now located in the omap3 and omap4 folders. This has resulted in some code duplication, but greater readability due to the removal of the #defines that were in use before. This new structure should also make it easier to implement new features, especially those only supported by certain OMAPs.
  Each platform provides a headattrs struct and an overlayattrs struct, which are the primary interface the core code uses to control the backend. Eventually it may be possible to produce one build of the module which supports multiple OMAP revisions at runtime, but for now some #defines and OMAP-specific code remains in the common files.
  This change also adds support for extra pixel formats, gamma table support for OMAP4, and fixes several bugs.
Admin:
  Tested on BeagleBoard, PandaBoard


Version 0.34. Tagged as 'OMAPVideo-0_34'
@
text
@d46 4
@


1.6
log
@Merge of OMAP3 and OMAP4 video driver sources.
With 85%+ shared code, tracking changes between these two modules was getting complicated, so now this single module will serve both OMAP3 targets and OMAP4.
At present, the differences are simply selected at compile time with a switch. This may make sense to further rationalise either with tidier macros or run time detection (since the HAL knows which controller is running).
Tested on OMAP3 in all 8 colour depths,
Tested by Willi Theiss on OMAP4.

Version 0.20. Tagged as 'OMAPVideo-0_20'
@
text
@d47 10
a56 10
extern volatile dss_regs_t      *dss;
extern volatile dispc_regs_t    *dispc;
extern volatile rfbi_regs_t     *rfbi;
extern volatile venc_regs_t     *venc;
extern volatile dsi_regs_t      *dsi;
extern volatile dsi_phy_regs_t  *dsi_phy;
extern volatile dsi_pll_regs_t  *dsi_pll;
extern volatile sdma_regs_t     *sdma;
extern volatile sdmachan_regs_t *sdmachan; /* Only using 1 channel */
//extern volatile sms_regs_t *sms;
@


1.5
log
@Merge of headers with OMAP4Video
For the most part, this is just adding "_t" suffixes to all the typedefs.
The OMAP4 controller registers are in "regs4.h" and OMAP3 in "regs3.h", they are selected between with a compile time switch - hence !MkROM becomes !Ms !MkRom3 and !MkRom4.
OMAP3 version tested & still works, OMAP4 will not work.

Version 0.19. Tagged as 'OMAPVideo-0_19'
@
text
@d6 1
a6 1
 * modification, are permitted provided that the following conditions are met: 
d15 1
a15 1
 * 
d36 1
d40 1
d59 5
@


1.4
log
@Fix black screen on boot issue. Use C99 number types.
Detail:
  c/dss - Fixed the cause of the black screens on boot on OMAP3 machines (DM37xx seems fine). It looks like the cause was due to skipping the step where you disable the LCD output before triggering the DSS reset.
  c/cmodule, c/dispc, c/dss, c/graphicsv, h/globals - Removed code relating to previous attempts to fix the black screen issue
  c/cmodule, c/dispc, c/dsi, c/dss, c/graphicsv, c/palette, c/regs, c/sdma, c/venc, h/dsi, h/dss, h/globals, h/graphicsv, h/palette, h/regs - Use the C99 number types instead of u32, u16, etc.
Admin:
  Tested on rev C2 BB, rev A2 BB-xM


Version 0.13. Tagged as 'OMAPVideo-0_13'
@
text
@d34 9
a42 1078
/* Return max value for given register (assuming _MASK and _SHIFT macros exist) */
#define REG_MAX(REG) (REG ## _MASK >> REG ## _SHIFT)
/* Extract field from register (assuming _MASK and _SHIFT macros exist) */
#define REG_EXTRACT(VAL,REG) (((VAL) & REG ## _MASK)>>REG ## _SHIFT)

/* General registers */

#define SYSCONFIG_AUTOIDLE		0x0001	/* DSS, DISPC, SMS */
#define SYSCONFIG_SOFTRESET		0x0002	/* DSS, DISPC, SMS */
#define SYSCONFIG_ENWAKEUP		0x0004	/* DISPC */
#define SYSCONFIG_SIDLEMODE_MASK	0x0018	/* DISPC, SMS */
#define SYSCONFIG_SIDLEMODE_FORCE	0x0000
#define SYSCONFIG_SIDLEMODE_NO		0x0008
#define SYSCONFIG_SIDLEMODE_SMART	0x0010
#define SYSCONFIG_CLOCKACTIVITY_MASK	0x0300	/* DISPC */
#define SYSCONFIG_CLOCKACTIVITY_IF0	0x0000
#define SYSCONFIG_CLOCKACTIVITY_I1F0	0x0100
#define SYSCONFIG_CLOCKACTIVITY_I0F1	0x0200
#define SYSCONFIG_CLOCKACTIVITY_IF1	0x0300
#define SYSCONFIG_MIDLEMODE_MASK	0x3000	/* DISPC */
#define SYSCONFIG_MIDLEMODE_FORCE	0x0000
#define SYSCONFIG_MIDLEMODE_NO		0x1000
#define SYSCONFIG_MIDLEMODE_SMART	0x2000

#define SYSSTATUS_RESETDONE		1	/* DSS, SMS */

/* DSS registers */

typedef struct {
	uint32_t _pad[4];
	uint32_t sysconfig;
	uint32_t sysstatus;
	uint32_t irqstatus;
	uint32_t _pad2[(0x40-0x1c)>>2];
	uint32_t control;
	uint32_t sdi_control;
	uint32_t pll_control;
	uint32_t _pad3[(0x5c-0x4c)>>2];
	uint32_t sdi_status;
} dss_regs;

#define DSS_IRQSTATUS_DISPC_IRQ			0x1
#define DSS_IRQSTATUS_DSI_IRQ			0x2

#define DSS_CONTROL_DISPC_CLK_SWITCH		0x01
#define DSS_CONTROL_DSI_CLK_SWITCH		0x02
#define DSS_CONTROL_VENC_CLOCK_MODE		0x04
#define DSS_CONTROL_VENC_CLOCK_4X_ENABLE	0x08
#define DSS_CONTROL_DAC_DEMEN			0x10
#define DSS_CONTROL_DAC_POWERDN_BGZ		0x20
#define DSS_CONTROL_VENC_OUT_SEL		0x40

#define DSS_SDI_CONTROL_SDI_BWSEL_MASK		0x00003
#define DSS_SDI_CONTROL_SDI_BWSEL_24BPP		0x00002
#define DSS_SDI_CONTROL_SDI_PRESEL_MASK		0x0000c
#define DSS_SDI_CONTROL_SDI_PRESEL_1PAIR	0x00000
#define DSS_SDI_CONTROL_SDI_PRESEL_2PAIR	0x00004
#define DSS_SDI_CONTROL_SDI_PRESEL_3PAIR	0x00008
#define DSS_SDI_CONTROL_SDI_AUTOSTDBY		0x00800
#define DSS_SDI_CONTROL_SDI_RBITS_F0		0x01000
#define DSS_SDI_CONTROL_SDI_RBITS_F1		0x02000
#define DSS_SDI_CONTROL_SDI_PHYLPMODE		0x04000
#define DSS_SDI_CONTROL_SDI_PDIV_MASK		0xF8000
#define DSS_SDI_CONTROL_SDI_PDIV_SHIFT		15

#define DSS_PLL_CONTROL_SDI_PLL_IDLE		0x00000001
#define DSS_PLL_CONTROL_SDI_PLL_REGM_MASK	0x000007FE
#define DSS_PLL_CONTROL_SDI_PLL_REGM_SHIFT	1
#define DSS_PLL_CONTROL_SDI_PLL_REGN_MASK	0x0001F800
#define DSS_PLL_CONTROL_SDI_PLL_REGN_SHIFT	11
#define DSS_PLL_CONTROL_SDI_PLL_STOPMODE	0x00020000
#define DSS_PLL_CONTROL_SDI_PLL_SYSRESET	0x00040000
#define DSS_PLL_CONTROL_SDI_PLL_HIGHFREQ	0x00080000
#define DSS_PLL_CONTROL_SDI_PLL_LOWCURRSTBY	0x00100000
#define DSS_PLL_CONTROL_SDI_PLL_PLLLPMODE	0x00200000
#define DSS_PLL_CONTROL_SDI_PLL_FREQSEL_MASK	0x03C00000
#define DSS_PLL_CONTROL_SDI_PLL_FREQSEL_SHIFT	22
#define DSS_PLL_CONTROL_SDI_PLL_LOCKSEL_MASK	0x0C000000
#define DSS_PLL_CONTROL_SDI_PLL_LOCKSEL_PHASE	0x00000000
#define DSS_PLL_CONTROL_SDI_PLL_LOCKSEL_FINE	0x04000000
#define DSS_PLL_CONTROL_SDI_PLL_LOCKSEL_FREQ	0x08000000
#define DSS_PLL_CONTROL_SDI_PLL_GOBIT		0x10000000

#define DSS_SDI_STATUS_DSS_DISPC_CLK1_STATUS	0x001
#define DSS_SDI_STATUS_DSI_PLL_CLK1_STATUS	0x002
#define DSS_SDI_STATUS_SDI_RESET_DONE		0x004
#define DSS_SDI_STATUS_SDI_ERROR		0x008
#define DSS_SDI_STATUS_SDI_PLL_RECAL		0x010
#define DSS_SDI_STATUS_SDI_PLL_LOCK		0x020
#define DSS_SDI_STATUS_SDI_PLL_BUSYFLAG		0x040
#define DSS_SDI_STATUS_DSS_DSI_CLK1_STATUS	0x080
#define DSS_SDI_STATUS_DSI_PLL_CLK2_STATUS	0x100

/* DISPC registers */

typedef struct {
	uint32_t ba[2];
	uint32_t position;
	uint32_t size;
	uint32_t pad[4];
	uint32_t attributes;
	uint32_t fifo_threshold;
	uint32_t fifo_size_status;
	uint32_t row_inc;
	uint32_t pixel_inc;
	uint32_t window_skip;
	uint32_t table_ba;
} gfx_regs;

typedef struct {
	uint32_t ba[2];
	uint32_t position;
	uint32_t size;
	uint32_t attributes;
	uint32_t fifo_threshold;
	uint32_t fifo_size_status;
	uint32_t row_inc;
	uint32_t pixel_inc;
	uint32_t fir;
	uint32_t picture_size;
	uint32_t accui[2];
	struct {
		uint32_t h;
		uint32_t hv;
	} fir_coef[8];
	uint32_t conv_coef[5];
} vid_regs;

typedef struct {
	uint32_t _pad[4];
	uint32_t sysconfig;
	uint32_t sysstatus;
	uint32_t irqstatus;
	uint32_t irqenable;
	uint32_t _pad2[8];
	uint32_t control;
	uint32_t config;
	uint32_t _pad3;
	uint32_t default_color[2];
	uint32_t trans_color[2];
	uint32_t line_status;
	uint32_t line_number;
	uint32_t timing_h;
	uint32_t timing_v;
	uint32_t pol_freq;
	uint32_t divisor;
	uint32_t global_alpha;
	uint32_t size_dig;
	uint32_t size_lcd;
	gfx_regs gfx;
	vid_regs vid1;
	uint32_t _pad4[2];
	vid_regs vid2;
	uint32_t data_cycle[3];
	uint32_t vid_fir_coef_v[2][8];
	uint32_t cpr_coef_r;
	uint32_t cpr_coef_g;
	uint32_t cpr_coef_b;
	uint32_t gfx_preload;
	uint32_t vid_preload[2];
} dispc_regs;

/* IRQ status/enable */
#define DISPC_IRQ_FRAMEDONE		0x00001
#define DISPC_IRQ_VSYNC			0x00002
#define DISPC_IRQ_EVSYNC_EVEN		0x00004
#define DISPC_IRQ_EVSYNC_ODD		0x00008
#define DISPC_IRQ_ACBIASCOUNTSTATUS	0x00010
#define DISPC_IRQ_PROGRAMMEDLINENUMBER	0x00020
#define DISPC_IRQ_GFXFIFOUNDERFLOW	0x00040
#define DISPC_IRQ_GFXENDWINDOW		0x00080
#define DISPC_IRQ_PALETTEGAMMALOADING	0x00100
#define DISPC_IRQ_OCPERROR		0x00200
#define DISPC_IRQ_VID1FIFOUNDERFLOW	0x00400
#define DISPC_IRQ_VID1ENDWINDOW		0x00800
#define DISPC_IRQ_VID2FIFOUNDERFLOW	0x01000
#define DISPC_IRQ_VID2ENDWINDOW		0x02000
#define DISPC_IRQ_SYNCLOST		0x04000
#define DISPC_IRQ_SYNCLOSTDIGITAL	0x08000
#define DISPC_IRQ_WAKEUP		0x10000

#define DISPC_CONTROL_LCDENABLE			0x00000001
#define DISPC_CONTROL_DIGITALENABLE		0x00000002
#define DISPC_CONTROL_MONOCOLOR			0x00000004
#define DISPC_CONTROL_STNTFT			0x00000008
#define DISPC_CONTROL_M8B			0x00000010
#define DISPC_CONTROL_GOLCD			0x00000020
#define DISPC_CONTROL_GODIGITAL			0x00000040
#define DISPC_CONTROL_STDITHERENABLE		0x00000080
#define DISPC_CONTROL_TFTDATALINES_MASK		0x00000300
#define DISPC_CONTROL_TFTDATALINES_12BPP	0x00000000
#define DISPC_CONTROL_TFTDATALINES_16BPP	0x00000100
#define DISPC_CONTROL_TFTDATALINES_18BPP	0x00000200
#define DISPC_CONTROL_TFTDATALINES_24BPP	0x00000300
#define DISPC_CONTROL_SECURE			0x00000400
#define DISPC_CONTROL_STALLMODE			0x00000800
#define DISPC_CONTROL_OVERLAYOPTIMIZATION	0x00001000
#define DISPC_CONTROL_GPIN0			0x00002000
#define DISPC_CONTROL_GPIN1			0x00004000
#define DISPC_CONTROL_GPOUT0			0x00008000
#define DISPC_CONTROL_GPOUT1			0x00010000
#define DISPC_CONTROL_HT_MASK			0x000E0000
#define DISPC_CONTROL_HT_SHIFT			17
#define DISPC_CONTROL_TDMENABLE			0x00100000
#define DISPC_CONTROL_TDMPARALLELMODE_MASK	0x00600000
#define DISPC_CONTROL_TDMPARALLELMODE_8		0x00000000
#define DISPC_CONTROL_TDMPARALLELMODE_9		0x00200000
#define DISPC_CONTROL_TDMPARALLELMODE_12	0x00400000
#define DISPC_CONTROL_TDMPARALLELMODE_16	0x00600000
#define DISPC_CONTROL_TDMCYCLEFORMAT_MASK	0x01800000
#define DISPC_CONTROL_TDMCYCLEFORMAT_1_1	0x00000000
#define DISPC_CONTROL_TDMCYCLEFORMAT_2_1	0x00800000
#define DISPC_CONTROL_TDMCYCLEFORMAT_3_1	0x01000000
#define DISPC_CONTROL_TDMCYCLEFORMAT_3_2	0x01800000
#define DISPC_CONTROL_TDMUNUSEDBITS_MASK	0x06000000
#define DISPC_CONTROL_TDMUNUSEDBITS_LL		0x00000000
#define DISPC_CONTROL_TDMUNUSEDBITS_HL		0x02000000
#define DISPC_CONTROL_TDMUNUSEDBITS_UNCHANGED	0x04000000
#define DISPC_CONTROL_PCKFREEENABLE		0x08000000
#define DISPC_CONTROL_LCDENABLESIGNAL		0x10000000
#define DISPC_CONTROL_LCDENABLEPOL		0x20000000
#define DISPC_CONTROL_STDITHERINGFRAMES_MASK			0xC0000000
#define DISPC_CONTROL_STDITHERINGFRAMES_SPATIAL			0x00000000
#define DISPC_CONTROL_STDITHERINGFRAMES_SPATIAL_TEMPORAL_2	0x40000000
#define DISPC_CONTROL_STDITHERINGFRAMES_SPATIAL_TEMPORAL_4	0x80000000

#define DISPC_CONFIG_PIXELGATED			0x00001
#define DISPC_CONFIG_LOADMODE_MASK		0x00006
#define DISPC_CONFIG_LOADMODE_BOTH		0x00000
#define DISPC_CONFIG_LOADMODE_PALETTE		0x00002 /* and then what? */
#define DISPC_CONFIG_LOADMODE_FRAME		0x00004
#define DISPC_CONFIG_LOADMODE_BOTH_THEN_FRAME	0x00006
#define DISPC_CONFIG_PALETTEGAMMATABLE		0x00008
#define DISPC_CONFIG_PIXELDATAGATED		0x00010
#define DISPC_CONFIG_PIXELCLOCKGATED		0x00020
#define DISPC_CONFIG_HSYNCGATED			0x00040
#define DISPC_CONFIG_VSYNCGATED			0x00080
#define DISPC_CONFIG_ACBIASGATED		0x00100
#define DISPC_CONFIG_FUNCGATED			0x00200
#define DISPC_CONFIG_TCKLCDENABLE		0x00400
#define DISPC_CONFIG_TCKLCDSELECTION		0x00800
#define DISPC_CONFIG_TCKDIGENABLE		0x01000
#define DISPC_CONFIG_TCKDIGSELECTION		0x02000
#define DISPC_CONFIG_FIFOMERGE			0x04000
#define DISPC_CONFIG_CPR			0x08000
#define DISPC_CONFIG_FIFOHANDCHECK		0x10000
#define DISPC_CONFIG_FIFOFILLING		0x20000
#define DISPC_CONFIG_LCDALPHABLENDERENABLE	0x40000
#define DISPC_CONFIG_TVALPHABLENDERENABLE	0x80000

/* Max values defined by HAL (they vary by OMAP revision) */
#define DISPC_TIMING_H_HSW_SHIFT 0
#define DISPC_TIMING_H_HFP_SHIFT 8
#define DISPC_TIMING_H_HBP_SHIFT 20

#define DISPC_TIMING_V_VSW_SHIFT 0
#define DISPC_TIMING_V_VFP_SHIFT 8
#define DISPC_TIMING_V_VBP_SHIFT 20

#define DISPC_POL_FREQ_ACB_MASK		0x000FF
#define DISPC_POL_FREQ_ACB_SHIFT	0
#define DISPC_POL_FREQ_ACBI_MASK	0x00F00
#define DISPC_POL_FREQ_ACBI_SHIFT	8
#define DISPC_POL_FREQ_IVS		0x01000
#define DISPC_POL_FREQ_IHS		0x02000
#define DISPC_POL_FREQ_IPC		0x04000
#define DISPC_POL_FREQ_IEO		0x08000
#define DISPC_POL_FREQ_RF		0x10000
#define DISPC_POL_FREQ_ONOFF		0x20000

#define DISPC_DIVISOR_PCD_MASK	0x0000FF
#define DISPC_DIVISOR_PCD_SHIFT	0
#define DISPC_DIVISOR_LCD_MASK	0xFF0000
#define DISPC_DIVISOR_LCD_SHIFT	16

#define DISPC_GLOBAL_ALPHA_GFXGLOBALALPHA_MASK		0x0000FF
#define DISPC_GLOBAL_ALPHA_GFXGLOBALALPHA_SHIFT		0
#define DISPC_GLOBAL_ALPHA_VID2GLOBALALPHA_MASK		0xFF0000
#define DISPC_GLOBAL_ALPHA_VID2GLOBALALPHA_SHIFT	16

#define DISPC_SIZE_DIG_PPL_MASK		0x00007FF
#define DISPC_SIZE_DIG_PPL_SHIFT	0
#define DISPC_SIZE_DIG_LPP_MASK		0x7FF0000
#define DISPC_SIZE_DIG_LPP_SHIFT	16

#define DISPC_SIZE_LCD_PPL_MASK		0x00007FF
#define DISPC_SIZE_LCD_PPL_SHIFT	0
#define DISPC_SIZE_LCD_LPP_MASK		0x7FF0000
#define DISPC_SIZE_LCD_LPP_SHIFT	16

#define OVERLAY_POSITION_X_MASK		0x00007FF
#define OVERLAY_POSITION_X_SHIFT	0
#define OVERLAY_POSITION_Y_MASK		0x7FF0000
#define OVERLAY_POSITION_Y_SHIFT	16

#define OVERLAY_SIZE_X_MASK	0x00007FF
#define OVERLAY_SIZE_X_SHIFT	0
#define OVERLAY_SIZE_Y_MASK	0x7FF0000
#define OVERLAY_SIZE_Y_SHIFT	16

/* Common overlay attributes */
#define OVERLAY_ATTRIBUTES_ENABLE		0x0001
#define OVERLAY_ATTRIBUTES_FORMAT_MASK		0x001E
#define OVERLAY_ATTRIBUTES_FORMAT_SHIFT		1
#define OVERLAY_ATTRIBUTES_FORMAT_BMP1		0x0000 /* GFX           */
#define OVERLAY_ATTRIBUTES_FORMAT_BMP2		0x0002 /* GFX           */
#define OVERLAY_ATTRIBUTES_FORMAT_BMP4		0x0004 /* GFX           */
#define OVERLAY_ATTRIBUTES_FORMAT_BMP8		0x0006 /* GFX           */
#define OVERLAY_ATTRIBUTES_FORMAT_RGB12		0x0008 /* GFX VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_ARGB16	0x000A /* GFX      VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_RGB16		0x000C /* GFX VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_RGB24_32	0x0010 /* GFX VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_RGB24_24	0x0012 /* GFX VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_YUV2		0x0014 /*     VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_UYVY		0x0016 /*     VID1 VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_ARGB32	0x0018 /* GFX      VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_RGBA32	0x001A /* GFX      VID2 */
#define OVERLAY_ATTRIBUTES_FORMAT_RGBx32	0x001C /* GFX      VID2 */
#define OVERLAY_ATTRIBUTES_ROTATION_MASK	0x3000
#define OVERLAY_ATTRIBUTES_ROTATION_0		0x0000
#define OVERLAY_ATTRIBUTES_ROTATION_90		0x1000
#define OVERLAY_ATTRIBUTES_ROTATION_180		0x2000
#define OVERLAY_ATTRIBUTES_ROTATION_270		0x3000

/* Graphics overlay attributes */
#define OVERLAY_ATTRIBUTES_GFXREPLICATIONENABLE	0x0020
#define OVERLAY_ATTRIBUTES_GFXBURSTSIZE_MASK	0x00C0
#define OVERLAY_ATTRIBUTES_GFXBUSRTSIZE_4X32	0x0000
#define OVERLAY_ATTRIBUTES_GFXBURSTSIZE_8X32	0x0040
#define OVERLAY_ATTRIBUTES_GFXBURSTSIZE_16X32	0x0080
#define OVERLAY_ATTRIBUTES_GFXCHANNELOUT	0x0100
#define OVERLAY_ATTRIBUTES_GFXNIBBLEMODE	0x0200
#define OVERLAY_ATTRIBUTES_GFXENDIANNESS	0x0400
#define OVERLAY_ATTRIBUTES_GFXFIFOPRELOAD	0x0800
#define OVERLAY_ATTRIBUTES_GFXARBITRATION	0x4000
#define OVERLAY_ATTRIBUTES_GFXSELFREFRESH	0x8000

/* Video overlay attributes */
#define OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_MASK	0x0000060
#define OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_NONE	0x0000000
#define OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_H	0x0000020
#define OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_V	0x0000040
#define OVERLAY_ATTRIBUTES_VIDRESIZEENABLE_BOTH	0x0000060
#define OVERLAY_ATTRIBUTES_VIDHRESIZECONF	0x0000080
#define OVERLAY_ATTRIBUTES_VIDVRESIZECONF	0x0000100
#define OVERLAY_ATTRIBUTES_VIDCOLORCONVENABLE	0x0000200
#define OVERLAY_ATTRIBUTES_VIDREPLICATIONENABLE	0x0000400
#define OVERLAY_ATTRIBUTES_VIDFULLRANGE		0x0000800
#define OVERLAY_ATTRIBUTES_VIDBURSTSIZE_MASK	0x000C000
#define OVERLAY_ATTRIBUTES_VIDBURSTSIZE_4X32	0x0000000
#define OVERLAY_ATTRIBUTES_VIDBURSTSIZE_8X32	0x0004000
#define OVERLAY_ATTRIBUTES_VIDBURSTSIZE_16X32	0x0008000
#define OVERLAY_ATTRIBUTES_VIDCHANNELOUT	0x0010000
#define OVERLAY_ATTRIBUTES_VIDENDIANNESS	0x0020000
#define OVERLAY_ATTRIBUTES_VIDROWREPEATENABLE	0x0040000
#define OVERLAY_ATTRIBUTES_VIDFIFOPRELOAD	0x0080000
#define OVERLAY_ATTRIBUTES_VIDDMAOPTIMIZATION	0x0100000
#define OVERLAY_ATTRIBUTES_VIDVERTICALTAPS	0x0200000
#define OVERLAY_ATTRIBUTES_VIDLINEBUFFERSPLIT	0x0400000
#define OVERLAY_ATTRIBUTES_VIDARBITRATION	0x0800000
#define OVERLAY_ATTRIBUTES_VIDSELFREFRESH	0x1000000

#define OVERLAY_FIFOLOWTHRESHOLD_MASK	0x0000FFF
#define OVERLAY_FIFOLOWTHRESHOLD_SHIFT	0
#define OVERLAY_FIFOHIGHTHRESHOLD_MASK	0xFFF0000
#define OVERLAY_FIFOHIGHTHRESHOLD_SHIFT	16

#define OVERLAY_FIFO_SIZE_STATUS_MASK	0xFFF
#define OVERLAY_FIFO_SIZE_STATUS_SHIFT	0

#define OVERLAY_PIXEL_INC_MAX 0xFFFFF

#define VID_OVERLAY_FIR_HINC_MASK	0x00001FFF
#define VID_OVERLAY_FIR_HINC_SHIFT	0
#define VID_OVERLAY_FIR_VINC_MASK	0x1FFF0000
#define VID_OVERLAY_FIR_VINC_SHIFT	16

/* For each of the three registers */
#define DISPC_CPR_COEF_xB_MASK		0x000003FF
#define DISPC_CPR_COEF_xB_SHIFT		0
#define DISPC_CPR_COEF_xG_MASK		0x001FF800
#define DISPC_CPR_COEF_xG_SHIFT		11
#define DISPC_CPR_COEF_xR_MASK		0xFFC00000
#define DISPC_CPR_COEF_xR_SHIFT		22

#define DISPC_PRELOAD_MASK	0xFFF
#define DISPC_PRELOAD_SHIFT	0

/* RFBI registers */

typedef struct {
	uint32_t config;
	uint32_t onoff_time;
	uint32_t cycle_time;
	uint32_t data_cycle[3];
} rfbi_buffer_regs; //???

typedef struct {
	uint32_t _pad[4];
	uint32_t sysconfig;
	uint32_t sysstatus;
	uint32_t _pad2[(0x40-0x18)>>2];
	uint32_t control;
	uint32_t pixel_cnt;
	uint32_t line_number;
	uint32_t cmd;
	uint32_t param;
	uint32_t data;
	uint32_t read;
	uint32_t status;
	rfbi_buffer_regs buffers[2]; //???
	uint32_t vsync_width;
	uint32_t hsync_width;
} rfbi_regs;

/* VENC registers */

typedef struct {
	uint32_t _pad;
	uint32_t status;
	uint32_t f_control;
	uint32_t _pad2;
	uint32_t vidout_ctrl;
	uint32_t sync_ctrl;
	uint32_t _pad3;
	uint32_t llen;
	uint32_t flens;
	uint32_t hfltr_ctrl;
	uint32_t cc_carr_wss_carr;
	uint32_t c_phase;
	uint32_t gain_u;
	uint32_t gain_v;
	uint32_t gain_y;
	uint32_t black_level;
	uint32_t blank_level;
	uint32_t x_color;
	uint32_t m_control;
	uint32_t bstamp_wss_data;
	uint32_t s_carr;
	uint32_t line21;
	uint32_t ln_sel;
	uint32_t l21_wc_ctl;
	uint32_t htrigger_vtrigger;
	uint32_t savid_eavid;
	uint32_t flen_fal;
	uint32_t lal_phase_reset;
	uint32_t hs_int_start_stop_x;
	uint32_t hs_ext_start_stop_x;
	uint32_t vs_int_start_x;
	uint32_t vs_int_stop_x_vs_int_start_y;
	uint32_t vs_int_stop_y_vs_ext_start_x;
	uint32_t vs_ext_stop_x_vs_ext_start_y;
	uint32_t vs_ext_stop_y;
	uint32_t _pad4;
	uint32_t avid_start_stop_x;
	uint32_t avid_start_stop_y;
	uint32_t _pad5;
	uint32_t _pad6;
	uint32_t fid_int_start_x_fid_int_start_y;
	uint32_t fid_int_offset_y_fid_ext_start_x;
	uint32_t fid_ext_start_y_fid_ext_offset_y;
	uint32_t _pad7;
	uint32_t tvdetgp_int_start_stop_x;
	uint32_t tvdetgp_int_start_stop_y;
	uint32_t gen_ctrl;
	uint32_t _pad8;
	uint32_t _pad9;
	uint32_t output_control;
	uint32_t output_test;
} venc_regs;

#define VENC_STATUS_FSQ_MASK		0x07
#define VENC_STATUS_FSQ_SHIFT		0
#define VENC_STATUS_CCO			0x08
#define VENC_STATUS_CCE			0x10

#define VENC_F_CONTROL_FMT_MASK			0x003
#define VENC_F_CONTROL_FMT_24_444_RGB		0x000
#define VENC_F_CONTROL_FMT_24_444		0x001
#define VENC_F_CONTROL_FMT_16_422		0x002
#define VENC_F_CONTROL_FMT_8_ITUR_656_422	0x003
#define VENC_F_CONTROL_FMT_BCOLOR_MASK		0x01c
#define VENC_F_CONTROL_FMT_BCOLOR_BLACK		0x000
#define VENC_F_CONTROL_FMT_BCOLOR_BLUE		0x004
#define VENC_F_CONTROL_FMT_BCOLOR_RED		0x008
#define VENC_F_CONTROL_FMT_BCOLOR_MAGENTA	0x00c
#define VENC_F_CONTROL_FMT_BCOLOR_GREEN		0x010
#define VENC_F_CONTROL_FMT_BCOLOR_CYAN		0x014
#define VENC_F_CONTROL_FMT_BCOLOR_YELLOW	0x018
#define VENC_F_CONTROL_FMT_BCOLOR_WHITE		0x01c
#define VENC_F_CONTROL_RGBF			0x020
#define VENC_F_CONTROL_SVDS_MASK		0x0c0
#define VENC_F_CONTROL_SVDS_EXTERNAL		0x000
#define VENC_F_CONTROL_SVDS_TESTCARD		0x040
#define VENC_F_CONTROL_SVDS_BGCOL		0x080
#define VENC_F_CONTROL_RESET			0x100

#define VENC_VIDOUT_CTRL_27_54			0x1

#define VENC_SYNC_CTRL_FID_POL			0x0040
#define VENC_SYNC_CTRL_HBLKM_MASK		0x0300
#define VENC_SYNC_CTRL_HBLKM_INTERNAL_DEFAULT	0x0000
#define VENC_SYNC_CTRL_HBLKM_INTERNAL_PROGRAM	0x0100
#define VENC_SYNC_CTRL_HBLKM_EXTERNAL		0x0200
#define VENC_SYNC_CTRL_VBLKM_MASK		0x0c00
#define VENC_SYNC_CTRL_VBLKM_INTERNAL_DEFAULT	0x0000
#define VENC_SYNC_CTRL_VBLKM_INTERNAL_PROGRAM	0x0400
#define VENC_SYNC_CTRL_NBLNKS			0x1000
#define VENC_SYNC_CTRL_IGNP			0x2000
#define VENC_SYNC_CTRL_ESAV			0x4000
#define VENC_SYNC_CTRL_FREE			0x8000

#define VENC_LLEN_LLEN_MASK		0x3FF /* Should be 7FF, but writing to bit 10 is illegal! */
#define VENC_LLEN_LLEN_SHIFT		0

#define VENC_FLENS_FLENS_MASK		0x7FF
#define VENC_FLENS_FLENS_SHIFT		0

#define VENC_HFLTR_CTRL_YINTP			0x1
#define VENC_HFLTR_CTRL_CINTP_MASK		0x6
#define VENC_HFLTR_CTRL_CINTP_ENABLED		0x0
#define VENC_HFLTR_CTRL_CINTP_1BYPASSED		0x2
#define VENC_HFLTR_CTRL_CINTP_2BYPASSED		0x4
#define VENC_HFLTR_CTRL_CINTP_DISABLED		0x6

#define VENC_CC_CARR_WSS_CARR_FCC_MASK		0x0000FFFF
#define VENC_CC_CARR_WSS_CARR_FCC_SHIFT		0
#define VENC_CC_CARR_WSS_CARR_FWSS_MASK		0xFFFF0000
#define VENC_CC_CARR_WSS_CARR_FWSS_SHIFT	16

#define VENC_C_PHASE_CPHS_MASK		0xFF
#define VENC_C_PHASE_CPHS_SHIFT		0

#define VENC_GAIN_U_GU_MASK		0x1FF
#define VENC_GAIN_U_GU_SHIFT		0

#define VENC_GAIN_V_GV_MASK		0x1FF
#define VENC_GAIN_V_GU_SHIFT		0

#define VENC_GAIN_Y_GY_MASK		0x1FF
#define VENC_GAIN_Y_GY_SHIFT		0

#define VENC_BLACK_LEVEL_BLACK_MASK	0x7F
#define VENC_BLACK_LEVEL_BLACK_SHIFT	0

#define VENC_BLANK_LEVEL_BLANK_MASK	0x7F
#define VENC_BLANK_LEVEL_BLANK_SHIFT	0

#define VENC_X_COLOR_LCD_MASK		0x07
#define VENC_X_COLOR_LCD_SHIFT		0
#define VENC_X_COLOR_XCBW_MASK		0x18
#define VENC_X_COLOR_XCBW_32_8		0x00
#define VENC_X_COLOR_XCBW_26_5		0x08
#define VENC_X_COLOR_XCBW_30_0		0x10
#define VENC_X_COLOR_XCBW_29_2		0x18
#define VENC_X_COLOR_XCE		0x40

#define VENC_M_CONTROL_FFRQ		0x01
#define VENC_M_CONTROL_PAL		0x02
#define VENC_M_CONTROL_CBW_MASK		0x1c
#define VENC_M_CONTROL_CBW_21_8		0x00
#define VENC_M_CONTROL_CBW_19_8		0x04
#define VENC_M_CONTROL_CBW_18_0		0x08
#define VENC_M_CONTROL_CBW_23_7		0x14
#define VENC_M_CONTROL_CBW_26_8		0x18
#define VENC_M_CONTROL_CBW_BYPASS	0x1c
#define VENC_M_CONTROL_PALPHS		0x20
#define VENC_M_CONTROL_PALN		0x40
#define VENC_M_CONTROL_PALI		0x80

#define VENC_BSTAMP_WSS_DATA_BSTAP_MASK		0x000007F
#define VENC_BSTAMP_WSS_DATA_BSTAP_SHIFT	0
#define VENC_BSTAMP_WSS_DATA_SQP		0x0000080
#define VENC_BSTAMP_WSS_DATA_WSS_DATA_MASK	0xFFFFF00
#define VENC_BSTAMP_WSS_DATA_WSS_DATA_SHIFT	8

#define VENC_LINE21_L21O_MASK	0x0000FFFF
#define VENC_LINE21_L21O_SHIFT	0
#define VENC_LINE21_L21E_MASK	0xFFFF0000
#define VENC_LINE21_L21E_SHIFT	16

#define VENC_LN_SEL_SLINE_MASK		0x000001F
#define VENC_LN_SEL_SLINE_SHIFT		0
#define VENC_LN_SEL_LN21_RUNIN_MASK	0x3FF0000
#define VENC_LN_SEL_LN21_RUNIN_SHIFT	16

#define VENC_L21_WC_CTL_L21EN_MASK		0x0003
#define VENC_L21_WC_CTL_L21EN_OFF		0x0000
#define VENC_L21_WC_CTL_L21EN_ODD		0x0001
#define VENC_L21_WC_CTL_L21EN_EVEN		0x0002
#define VENC_L21_WC_CTL_L21EN_BOTH		0x0003
#define VENC_L21_WC_CTL_LINE_MASK		0x1F00
#define VENC_L21_WC_CTL_LINE_SHIFT		8
#define VENC_L21_WC_CTL_EVEN_ODD_EN_MASK	0x6000
#define VENC_L21_WC_CTL_EVEN_ODD_EN_OFF		0x0000
#define VENC_L21_WC_CTL_EVEN_ODD_EN_ODD		0x2000
#define VENC_L21_WC_CTL_EVEN_ODD_EN_EVEN	0x4000
#define VENC_L21_WC_CTL_EVEN_ODD_EN_BOTH	0x6000
#define VENC_L21_WC_CTL_INV			0x8000

#define VENC_HTRIGGER_VTRIGGER_HTRIG_MASK	0x00007FF
#define VENC_HTRIGGER_VTRIGGER_HTRIG_SHIFT	0
#define VENC_HTRIGGER_VTRIGGER_VTRIG_MASK	0x3FF0000
#define VENC_HTRIGGER_VTRIGGER_VTRIG_SHIFT	16

#define VENC_SAVID_EAVID_SAVID_MASK	0x00007FF
#define VENC_SAVID_EAVID_SAVID_SHIFT	0
#define VENC_SAVID_EAVID_EAVID_MASK	0x7FF0000
#define VENC_SAVID_EAVID_EAVID_SHIFT	16

#define VENC_FLEN_FAL_FLEN_MASK		0x00003FF
#define VENC_FLEN_FAL_FLEN_SHIFT	0
#define VENC_FLEN_FAL_FAL_MASK		0x1FF0000
#define VENC_FLEN_FAL_FAL_SHIFT		16

#define VENC_LAL_PHASE_RESET_LAL_MASK		0x001FF
#define VENC_LAL_PHASE_RESET_LAL_SHIFT		0
#define VENC_LAL_PHASE_RESET_SBLANK		0x10000
#define VENC_LAL_PHASE_RESET_PRES_MASK		0x60000
#define VENC_LAL_PHASE_RESET_PRES_NONE		0x00000
#define VENC_LAL_PHASE_RESET_PRES_2LINES	0x20000
#define VENC_LAL_PHASE_RESET_PRES_8FIELDS	0x40000
#define VENC_LAL_PHASE_RESET_PRES_4FIELDS	0x60000

/* blah blah blah start/stop registers */

#define VENC_AVID_START_STOP_X_AVID_START_X_MASK	0x00003FF
#define VENC_AVID_START_STOP_X_AVID_START_X_SHIFT	0
#define VENC_AVID_START_STOP_X_AVID_STOP_X_MASK		0x3FF0000
#define VENC_AVID_START_STOP_X_AVID_STOP_X_SHIFT	16

#define VENC_AVID_START_STOP_Y_AVID_START_Y_MASK	0x00003FF
#define VENC_AVID_START_STOP_Y_AVID_START_Y_SHIFT	0
#define VENC_AVID_START_STOP_Y_AVID_STOP_Y_MASK		0x3FF0000
#define VENC_AVID_START_STOP_Y_AVID_STOP_Y_SHIFT	16

/* blah blah blah */

#define VENC_GEN_CTRL_EN	0x0000001
#define VENC_GEN_CTRL_TVDP	0x0010000
#define VENC_GEN_CTRL_FEP	0x0020000
#define VENC_GEN_CTRL_FIP	0x0040000
#define VENC_GEN_CTRL_AVIDP	0x0080000
#define VENC_GEN_CTRL_VEP	0x0100000
#define VENC_GEN_CTRL_HEP	0x0200000
#define VENC_GEN_CTRL_VIP	0x0400000
#define VENC_GEN_CTRL_HIP	0x0800000
#define VENC_GEN_CTRL_CBAR	0x1000000
#define VENC_GEN_CTRL_656	0x2000000
#define VENC_GEN_CTRL_MS	0x4000000

#define VENC_OUTPUT_CONTROL_LUMA_ENABLE			0x0000001
#define VENC_OUTPUT_CONTROL_COMPOSITE_ENABLE		0x0000002
#define VENC_OUTPUT_CONTROL_CHROMA_ENABLE		0x0000004
#define VENC_OUTPUT_CONTROL_VIDEO_INVERT		0x0000008
#define VENC_OUTPUT_CONTROL_TEST_MODE			0x0000010
#define VENC_OUTPUT_CONTROL_LUMA_SOURCE			0x0000020
#define VENC_OUTPUT_CONTROL_COMPOSITE_SOURCE		0x0000040
#define VENC_OUTPUT_CONTROL_CHROMA_SOURCE		0x0000080
#define VENC_OUTPUT_CONTROL_LUMA_TEST_MASK		0x3FF0000
#define VENC_OUTPUT_CONTROL_LUMA_TEST_MASK_SHIFT	16

#define VENC_OUTPUT_TEST_COMPOSITE_TEST_MASK	0x00003FF
#define VENC_OUTPUT_TEST_COMPOSITE_TEST_SHIFT	0
#define VENC_OUTPUT_TEST_CHROMA_TEST_MASK	0x3FF0000
#define VENC_OUTPUT_TEST_CHROMA_TEST_SHIFT	16

/* DSI registers */

typedef struct {
	uint32_t ctrl;
	uint32_t te;
	uint32_t long_packet_header;
	uint32_t long_packet_payload;
	uint32_t short_packet_header;
	uint32_t _pad;
	uint32_t irqstatus;
	uint32_t irqenable;
} dsi_thing; //???

typedef struct {
	uint32_t _pad[4];
	uint32_t sysconfig;
	uint32_t sysstatus;
	uint32_t irqstatus;
	uint32_t irqenable;
	uint32_t _pad2[(0x40-0x20)>>2];
	uint32_t ctrl;
	uint32_t _pad3;
	uint32_t complexio_cfg1;
	uint32_t complexio_irqstatus;
	uint32_t complexio_irqenable;
	uint32_t clk_ctrl;
	uint32_t timing1;
	uint32_t timing2;
	uint32_t vm_timing1;
	uint32_t vm_timing2;
	uint32_t vm_timing3;
	uint32_t clk_timing;
	uint32_t tx_fifo_vc_size;
	uint32_t rx_fifo_vc_size;
	uint32_t complexio_cfg2;
	uint32_t rx_fifo_vc_fullness;
	uint32_t vm_timing4;
	uint32_t tx_fifo_vc_emptiness;
	uint32_t vm_timing5;
	uint32_t vm_timing6;
	uint32_t vm_timing7;
	uint32_t stopclk_timing;
	dsi_thing thing[2]; //???
} dsi_regs;

#define DSI_CLK_CTRL_LP_CLK_DIVISOR_MASK		0x00001FFF
#define DSI_CLK_CTRL_LP_CLK_DIVISOR_SHIFT		0
#define DSI_CLK_CTRL_DDR_CLK_ALWAYS_ON			0x00002000
#define DSI_CLK_CTRL_CIO_CLK_ICG			0x00004000
#define DSI_CLK_CTRL_LP_CLK_NULL_PACKET_ENABLE		0x00008000
#define DSI_CLK_CTRL_LP_CLK_NULL_PACKET_SIZE_MASK	0x00030000
#define DSI_CLK_CTRL_LP_CLK_NULL_PACKET_SIZE_SHIFT	16
#define DSI_CLK_CTRL_HS_AUTO_STOP_ENABLE		0x00040000
#define DSI_CLK_CTRL_HS_MANUAL_STOP_CTRL		0x00080000
#define DSI_CLK_CTRL_LP_CLK_ENABLE			0x00100000
#define DSI_CLK_CTRL_LP_RX_SYNCHRO_ENABLE		0x00200000
#define DSI_CLK_CTRL_PLL_PWR_STATUS_MASK		0x30000000
#define DSI_CLK_CTRL_PLL_PWR_STATUS_SHIFT		28
#define DSI_CLK_CTRL_PLL_PWR_CMD_MASK			0xC0000000
#define DSI_CLK_CTRL_PLL_PWR_CMD_SHIFT			30

#define DSI_PLL_PWR_CMD_OFF				0
#define DSI_PLL_PWR_CMD_DSI_PLL_ON_HSDIVIDER_OFF	1
#define DSI_PLL_PWR_CMD_BOTH_ON				2
#define DSI_PLL_PWR_CMD_BOTH_ON_DSI_COMPLEXIO_OFF	3


/* DSI PHY registers */

typedef struct {
	uint32_t cfg0;
	uint32_t cfg1;
	uint32_t cfg2;
	uint32_t _pad[2];
	uint32_t cfg5;
} dsi_phy_regs;

/* DSI PLL registers */

typedef struct {
	uint32_t control;
	uint32_t status;
	uint32_t go;
	uint32_t configuration1;
	uint32_t configuration2;
} dsi_pll_regs;

#define DSI_PLL_CONTROL_DSI_PLL_AUTOMODE	0x01
#define DSI_PLL_CONTROL_DSI_PLL_GATEMODE	0x02
#define DSI_PLL_CONTROL_DSI_PLL_HALTMODE	0x04
#define DSI_PLL_CONTROL_DSI_PLL_SYSRESET	0x08
#define DSI_PLL_CONTROL_DSI_HSDIV_SYSRESET	0x10

#define DSI_PLL_STATUS_DSI_PLLCTRL_RESET_DONE	0x001
#define DSI_PLL_STATUS_DSI_PLL_CLOCK		0x002
#define DSI_PLL_STATUS_DSI_PLL_RECAL		0x004
#define DSI_PLL_STATUS_DSI_PLL_LOSSREF		0x008
#define DSI_PLL_STATUS_DSI_PLL_LIMP		0x010
#define DSI_PLL_STATUS_DSI_PLL_HIGHJITTER	0x020
#define DSI_PLL_STATUS_DSI_PLL_BYPASS		0x040
#define DSI_PLL_STATUS_DSS_CLOCK_ACK		0x080
#define DSI_PLL_STATUS_DSIPROTO_CLOCK_ACK	0x100
#define DSI_PLL_STATUS_DSI_BYPASSACKZ		0x200

#define DSI_PLL_GO_DSI_PLL_GO	0x1

#define DSI_PLL_CONFIGURATION1_DSI_PLL_STOPMODE		0x0000001
#define DSI_PLL_CONFIGURATION1_DSI_PLL_REGN_MASK	0x00000FE
#define DSI_PLL_CONFIGURATION1_DSI_PLL_REGN_SHIFT	1
#define DSI_PLL_CONFIGURATION1_DSI_PLL_REGM_MASK	0x007FF00
#define DSI_PLL_CONFIGURATION1_DSI_PLL_REGM_SHIFT	8
#define DSI_PLL_CONFIGURATION1_DSS_CLOCK_DIV_MASK	0x0780000
#define DSI_PLL_CONFIGURATION1_DSS_CLOCK_DIV_SHIFT	19
#define DSI_PLL_CONFIGURATION1_DSIPROTO_CLOCK_DIV_MASK	0x7800000
#define DSI_PLL_CONFIGURATION1_DSIPROTO_CLOCK_DIV_SHIFT	23

#define DSI_PLL_CONFIGURATION2_DSI_PLL_IDLE		0x000001
#define DSI_PLL_CONFIGURATION2_DSI_PLL_FREQSEL_MASK	0x00001E
#define DSI_PLL_CONFIGURATION2_DSI_PLL_FREQSEL_SHIFT	1
#define DSI_PLL_CONFIGURATION2_DSI_PLL_PLLLPMODE	0x000020
#define DSI_PLL_CONFIGURATION2_DSI_PLL_LOWCURRSTBY	0x000040
#define DSI_PLL_CONFIGURATION2_DSI_PLL_TIGHTPHASELOCK	0x000080
#define DSI_PLL_CONFIGURATION2_DSI_PLL_DRIFTGUARDEN	0x000100
#define DSI_PLL_CONFIGURATION2_DSI_PLL_LOCKSEL_MASK	0x000600
#define DSI_PLL_CONFIGURATION2_DSI_PLL_LOCKSEL_TPL	0x000000 /* Use DSI_PLL_TIGHTPHASELOCK */
#define DSI_PLL_CONFIGURATION2_DSI_PLL_LOCKSEL_FREQ	0x000200
#define DSI_PLL_CONFIGURATION2_DSI_PLL_CLKSEL		0x000800
#define DSI_PLL_CONFIGURATION2_DSI_PLL_HIGHFREQ		0x001000
#define DSI_PLL_CONFIGURATION2_DSI_PLL_REFEN		0x002000
#define DSI_PLL_CONFIGURATION2_DSI_PHY_CLKINEN		0x004000
#define DSI_PLL_CONFIGURATION2_DSI_BYPASSEN		0x008000
#define DSI_PLL_CONFIGURATION2_DSS_CLOCK_EN		0x010000
#define DSI_PLL_CONFIGURATION2_DSS_CLOCK_PWDN		0x020000
#define DSI_PLL_CONFIGURATION2_DSI_PROTO_CLOCK_EN	0x040000
#define DSI_PLL_CONFIGURATION2_DSI_PROTO_CLOCK_PWDN	0x080000
#define DSI_PLL_CONFIGURATION2_DSI_HSDIVBYPASS		0x100000

/* SDMA registers */

typedef struct {
	uint32_t ccr;
	uint32_t clnk_ctrl;
	uint32_t cicr;
	uint32_t csr;
	uint32_t csdp;
	uint32_t cen;
	uint32_t cfn;
	uint32_t cssa;
	uint32_t cdsa;
	uint32_t csei;
	uint32_t csfi;
	uint32_t cdei;
	uint32_t cdfi;
	uint32_t csac;
	uint32_t cdac;
	uint32_t ccen;
	uint32_t ccfn;
	uint32_t color;
	uint32_t _pad[6];
} sdmachan_regs;

#define DMA4_CCR_SYNCHRO_CONTROL_MASK		0x000001F
#define DMA4_CCR_SYNCHRO_CONTROL_SHIFT		0
#define DMA4_CCR_FS				0x0000020
#define DMA4_CCR_READ_PRIORITY			0x0000040
#define DMA4_CCR_ENABLE				0x0000080
#define DMA4_CCR_SUSPEND_SENSITIVE		0x0000100
#define DMA4_CCR_RD_ACTIVE			0x0000200
#define DMA4_CCR_WR_ACTIVE			0x0000400
#define DMA4_CCR_SRC_AMODE_MASK			0x0003000
#define DMA4_CCR_SRC_AMODE_CONSTANT		0x0000000
#define DMA4_CCR_SRC_AMODE_POSTINCREMENT	0x0001000
#define DMA4_CCR_SRC_AMODE_SINGLEINDEX		0x0002000
#define DMA4_CCR_SRC_AMODE_DOUBLEINDEX		0x0003000
#define DMA4_CCR_DST_AMODE_MASK			0x000C000
#define DMA4_CCR_DST_AMODE_CONSTANT		0x0000000
#define DMA4_CCR_DST_AMODE_POSTINCREMENT	0x0004000
#define DMA4_CCR_DST_AMODE_SINGLEINDEX		0x0008000
#define DMA4_CCR_DST_AMODE_DOUBLEINDEX		0x000C000
#define DMA4_CCR_CONST_FILL_ENABLE		0x0010000
#define DMA4_CCR_TRANSPARENT_COPY_ENABLE	0x0020000
#define DMA4_CCR_BS				0x0040000
#define DMA4_CCR_SYNCHRO_CONTROL_UPPER_MASK	0x0180000
#define DMA4_CCR_SYNCHRO_CONTROL_UPPER_SHIFT	(19-5) /* Shifts to the correct position to combine with SYNCHRO_CONTROL */
#define DMA4_CCR_SECURE				0x0200000
#define DMA4_CCR_SUPERVISOR			0x0400000
#define DMA4_CCR_PREFETCH			0x0800000
#define DMA4_CCR_SEL_SRC_DST_SYNC		0x1000000
#define DMA4_CCR_BUFFERING_DISABLE		0x2000000
#define DMA4_CCR_WRITE_PRIORITY			0x4000000

#define DMA4_CLNK_CTRL_NEXTLCH_ID_MASK		0x001F
#define DMA4_CLNK_CTRL_NEXTLCH_ID_SHIFT		0
#define DMA4_CLNK_CTRL_ENABLE_LNK		0x8000

#define DMA4_CICR_DROP_IE		0x0002
#define DMA4_CICR_HALF_IE		0x0004
#define DMA4_CICR_FRAME_IE		0x0008
#define DMA4_CICR_LAST_IE		0x0010
#define DMA4_CICR_BLOCK_IE		0x0020
#define DMA4_CICR_PKT_IE		0x0080
#define DMA4_CICR_TRANS_ERR_IE		0x0100
#define DMA4_CICR_SECURE_ERR_IR		0x0200
#define DMA4_CICR_SUPERVISOR_ERR_IE	0x0400
#define DMA4_CICR_MISALIGNED_ERR_IE	0x0800
#define DMA4_CICR_DRAIN_IE		0x1000

#define DMA4_CSR_DROP			0x0002
#define DMA4_CSR_HALF			0x0004
#define DMA4_CSR_FRAME			0x0008
#define DMA4_CSR_LAST			0x0010
#define DMA4_CSR_BLOCK			0x0020
#define DMA4_CSR_SYNC			0x0040
#define DMA4_CSR_PKT			0x0080
#define DMA4_CSR_TRANS_ERR		0x0100
#define DMA4_CSR_SECURE_ERR		0x0200
#define DMA4_CSR_SUPERVISOR_ERR		0x0400
#define DMA4_CSR_MISALIGNED_ADRS_ERR	0x0800
#define DMA4_CSR_DRAIN_END		0x1000

#define DMA4_CSDP_DATA_TYPE_MASK		0x000003
#define DMA4_CSDP_DATA_TYPE_8			0x000000
#define DMA4_CSDP_DATA_TYPE_16			0x000001
#define DMA4_CSDP_DATA_TYPE_32			0x000002
#define DMA4_CSDP_SRC_PACKED			0x000040
#define DMA4_CSDP_SRC_BURST_EN_MASK		0x000180
#define DMA4_CSDP_SRC_BURST_EN_SINGLE		0x000000
#define DMA4_CSDP_SRC_BURST_EN_16BYTES		0x000080
#define DMA4_CSDP_SRC_BURST_EN_32BYTES		0x000100
#define DMA4_CSDP_SRC_BURST_EN_64BYTES		0x000180
#define DMA4_CSDP_DST_PACKED			0x002000
#define DMA4_CSDP_DST_BURST_EN_MASK		0x00C000
#define DMA4_CSDP_DST_BURST_EN_SINGLE		0x000000
#define DMA4_CSDP_DST_BURST_EN_16BYTES		0x004000
#define DMA4_CSDP_DST_BURST_EN_32BYTES		0x008000
#define DMA4_CSDP_DST_BURST_EN_64BYTES		0x00C000
#define DMA4_CSDP_WRITE_MODE_MASK		0x030000
#define DMA4_CSDP_WRITE_MODE_NONPOSTED		0x000000
#define DMA4_CSDP_WRITE_MODE_POSTED		0x010000
#define DMA4_CSDP_WRITE_MODE_LAST_NONPOSTED	0x020000
#define DMA4_CSDP_DST_ENDIAN_LOCK		0x040000
#define DMA4_CSDP_DST_ENDIAN			0x080000
#define DMA4_CSDP_SRC_ENDIAN_LOCK		0x100000
#define DMA4_CSDP_SRC_ENDIAN			0x200000

#define DMA4_CEN_CHANNEL_ELMNT_NBR_MASK		0xFFFFFF
#define DMA4_CEN_CHANNEL_ELMNT_NBR_SHIFT	0

#define DMA4_CFN_CHANNEL_FRAME_NBR_MASK		0xFFFF
#define DMA4_CFN_CHANNEL_FRAME_NBR_SHIFT	0

#define DMA4_CSEI_CHANNEL_SRC_ELMNT_INDEX_MASK	0xFFFF
#define DMA4_CSEI_CHANNEL_SRC_ELMNT_INDEX_SHIFT	0

#define DMA4_CSFI_CH_SRC_FRM_INDEX_MASK		0xFFFFFFFF
#define DMA4_CSFI_CH_SRC_FRM_INDEX_SHIFT	0
#define DMA4_CSFI_16BIT_PKT_ELNT_NBR_MASK	0xFFFF
#define DMA4_CSFI_16BIT_PKT_ELNT_NBR_SHIFT	0

#define DMA4_CDEI_CHANNEL_DST_ELMNT_INDEX_MASK	0xFFFF
#define DMA4_CDEI_CHANNEL_DST_ELMNT_INDEX_SHIFT	0

#define DMA4_CDFI_CH_DST_FRM_INDEX_MASK		0xFFFFFFFF
#define DMA4_CDFI_CH_DST_FRM_INDEX_SHIFT	0
#define DMA4_CDFI_16BIT_PKT_ELNT_NBR_MASK	0xFFFF
#define DMA4_CDFI_16BIT_PKT_ELNT_NBR_SHIFT	0

#define DMA4_CCEN_CURRENT_ELMNT_NBR_MASK	0xFFFFFF
#define DMA4_CCEN_CURRENT_ELMNT_NBR_SHIFT	0

#define DMA4_CCFN_CURRENT_FRAME_NBR_MASK	0xFFFF
#define DMA4_CCFN_CURRENT_FRAME_NBR_SHIFT	0

typedef struct {
	uint32_t _pad[2];
	uint32_t irqstatus[4];
	uint32_t irqenable[4];
	uint32_t sysstatus;  /* Ignore; handled by HAL/DMAManager */
	uint32_t ocp_sysconfig; /* Ignore; handled by HAL/DMAManager */
	uint32_t _pad2[(0x64-0x30)>>2];
	uint32_t caps[5];
	uint32_t gcr; /* Ignore; handled by HAL/DMAManager */
	uint32_t _pad3;
	sdmachan_regs chans[32];
} sdma_regs;

/* SMS registers */

#define SMS_REVISION_REV_MASK			0x000000FF
#define SMS_REVISION_REV_SHIFT			0

#define SMS_RG_RDPERM_CONNIDVECTOR_MASK		0x0000FFFF
#define SMS_RG_RDPERM_CONNIDVECTOR_SHIFT	0

#define SMS_RG_WRPERM_CONNIDVECTOR_MASK		0x0000FFFF
#define SMS_RG_WRPERM_CONNIDVECTOR_SHIFT	0

#define SMS_RG_START_STARTADDRESS_MASK		0x7FFF0000
#define SMS_RG_START_STARTADDRESS_SHIFT		0 /* Since we want 64K alignment */

#define SMS_RG_END_ENDADDRESS_MASK		0x7FFF0000
#define SMS_RG_END_ENDADDRESS_SHIFT		0 /* Since we want 64K alignment */

#define SMS_CLASS_ARBITER0_HIGHPRIOVECTOR_MASK	0x000000C0
#define SMS_CLASS_ARBITER0_HIGHPRIOVECTOR_SHIFT	6
#define SMS_CLASS_ARBITER0_EXTENDEDGRANT_MASK	0x00F00000
#define SMS_CLASS_ARBITER0_EXTENDEDGRANT_SHIFT	20
#define SMS_CLASS_ARBITER0_BURSTCOMPLETE_MASK	0xC0000000
#define SMS_CLASS_ARBITER0_BURSTCOMPLETE_SHIFT	30

#define SMS_CLASS_ARBITER1_HIGHPRIOVECTOR_MASK	0x00000003
#define SMS_CLASS_ARBITER1_HIGHPRIOVECTOR_SHIFT	0
#define SMS_CLASS_ARBITER1_EXTENDEDGRANT_MASK	0x00000F00
#define SMS_CLASS_ARBITER1_EXTENDEDGRANT_SHIFT	8
#define SMS_CLASS_ARBITER1_BURSTCOMPLETE_MASK	0x03000000
#define SMS_CLASS_ARBITER1_BURSTCOMPLETE_SHIFT	24

#define SMS_CLASS_ARBITER2_HIGHPRIOVECTOR_MASK	0x0000003C
#define SMS_CLASS_ARBITER2_HIGHPRIOVECTOR_SHIFT	2
#define SMS_CLASS_ARBITER2_EXTENDEDGRANT_MASK	0x000FF000
#define SMS_CLASS_ARBITER2_EXTENDEDGRANT_SHIFT	12
#define SMS_CLASS_ARBITER2_BURSTCOMPLETE_MASK	0x3C000000
#define SMS_CLASS_ARBITER2_BURSTCOMPLETE_SHIFT	26

#define SMS_INTERCLASS_ARBITER_CLASS1PRIO_MASK	0x000000FF
#define SMS_INTERCLASS_ARBITER_CLASS1PRIO_SHIFT	0
#define SMS_INTERCLASS_ARBITER_CLASS2PRIO_MASK	0x00FF0000
#define SMS_INTERCLASS_ARBITER_CLASS2PRIO_SHIFT	16

#define SMS_CLASS_ROTATION_NOFSERVICES_MASK	0x0000001F
#define SMS_CLASS_ROTATION_NOFSERVICES_SHIFT	0

#define SMS_ERR_TYPE_ERRORVALID			0x00000001
#define SMS_ERR_TYPE_ERRORSECOVERLAP		0x00000008
#define SMS_ERR_TYPE_ILLEGALCMD			0x00000100
#define SMS_ERR_TYPE_UNEXPECTEDREQ		0x00000200
#define SMS_ERR_TYPE_UNEXPECTEDADD		0x00000400
#define SMS_ERR_TYPE_ERRORCONNID_MASK		0x000F0000
#define SMS_ERR_TYPE_ERRORCONNID_SHIFT		16
#define SMS_ERR_TYPE_ERRORMCMD_MASK		0x00700000
#define SMS_ERR_TYPE_ERRORMCMD_SHIFT		20
#define SMS_ERR_TYPE_ERRORREGIONID_MASK		0x03000000
#define SMS_ERR_TYPE_ERRORREGIONID_SHIFT	24

#define SMS_POW_CTRL_IDLEDELAY_MASK		0x000000FF
#define SMS_POW_CTRL_IDLEDELAY_SHIFT		0

#define SMS_ROT_CONTROL_PS_MASK		0x00000003
#define SMS_ROT_CONTROL_PS_SHIFT	0
#define SMS_ROT_CONTROL_PW_MASK		0x00000070
#define SMS_ROT_CONTROL_PW_SHIFT	4
#define SMS_ROT_CONTROL_PH_MASK		0x00000700
#define SMS_ROT_CONTROL_PH_SHIFT	8

#define SMS_ROT_SIZE_IMAGEWIDTH_MASK	0x000007FF
#define SMS_ROT_SIZE_IMAGEWIDTH_SHIFT	0
#define SMS_ROT_SIZE_IMAGEHEIGHT_MASK	0x07FF0000
#define SMS_ROT_SIZE_IMAGEHEIGHT_SHIFT	16

#define SMS_ROT_PHYSICAL_BA_MASK	0x7FFFFFFF
#define SMS_ROT_PHYSICAL_BA_SHIFT	0

typedef struct {
	uint32_t att;
	uint32_t _pad;
	uint32_t rdperm;
	uint32_t _pad2;
	uint32_t wrperm;
	uint32_t _pad3;
	uint32_t start;
	uint32_t end;
} sms_rg_regs;

typedef struct {
	uint32_t control;
	uint32_t size;
	uint32_t physical_ba;
	uint32_t _pad;
} sms_rot;

typedef struct {
	uint32_t revision;
	uint32_t _pad[3];
	uint32_t sysconfig;
	uint32_t sysstatus;
	uint32_t _pad2[((0x48-0x18)>>2)];
	sms_rg_regs rg[8];
	uint32_t _pad3[2];
	uint32_t class_arbiter0;
	uint32_t class_arbiter1;
	uint32_t class_arbiter2;
	uint32_t _pad4;
	uint32_t interclass_arbiter;
	uint32_t class_rotation[3];
	uint32_t err_addr;
	uint32_t err_type;
	uint32_t pow_ctrl;
	uint32_t _pad5;
	sms_rot rot[12];
} sms_regs;

extern volatile dss_regs *dss;
extern volatile dispc_regs *dispc;
extern volatile rfbi_regs *rfbi;
extern volatile venc_regs *venc;
extern volatile dsi_regs *dsi;
extern volatile dsi_phy_regs *dsi_phy;
extern volatile dsi_pll_regs *dsi_pll;
extern volatile sdma_regs *sdma;
extern volatile sdmachan_regs *sdmachan; /* Current code only makes use of one DMA channel */
extern volatile sms_regs *sms;
d44 11
a56 1

a58 5
#define BHUB_OFF		0x1 /* Ban hardware update due to hardware being off */
#define BHUB_SYNCLOST		0x2 /* Ban hardware update due to SYNCLOST IRQ */
#define BHUB_SYNCLOSTDIGITAL	0x4 /* Ban hardware update due to SYNCLOSTDIGITAL IRQ */


a65 1

@


1.3
log
@OMAPVideo fixes & tweaks
Detail:
  Makefile - now rewritten to use CModule fragment instead of obsolete RAMCModule/ROMCModule fragments
  c/cmodule - Make *videoregs print out a couple more regs
  c/dsi - Fix debug output when DSI requests time out. Fix HSDIVIDER not working on AM/DM37x.
  c/graphicsv - When setting the mode from a VIDC list, add the border values to the porch values to take into account the hardware's inability to emulate VIDC's coloured border facility. Behaviour matches that of NVidia module.
  h/regs - Add definitions for SMS registers (for display rotation)
Admin:
  Tested on rev C2 beagleboard, rev A2 BB-xM (indirectly), rev C1 TouchBook


Version 0.07. Tagged as 'OMAPVideo-0_07'
@
text
@d32 1
a32 8

typedef unsigned char u8;
typedef signed char s8;
typedef unsigned short u16;
typedef signed short s16;
typedef unsigned int u32;
typedef signed int s32;
typedef unsigned long long u64;
d63 10
a72 10
	u32 _pad[4];
	u32 sysconfig;
	u32 sysstatus;
	u32 irqstatus;
	u32 _pad2[(0x40-0x1c)>>2];
	u32 control;
	u32 sdi_control;
	u32 pll_control;
	u32 _pad3[(0x5c-0x4c)>>2];
	u32 sdi_status;
d130 11
a140 11
	u32 ba[2];
	u32 position;
	u32 size;
	u32 pad[4];
	u32 attributes;
	u32 fifo_threshold;
	u32 fifo_size_status;
	u32 row_inc;
	u32 pixel_inc;
	u32 window_skip;
	u32 table_ba;
d144 11
a154 11
	u32 ba[2];
	u32 position;
	u32 size;
	u32 attributes;
	u32 fifo_threshold;
	u32 fifo_size_status;
	u32 row_inc;
	u32 pixel_inc;
	u32 fir;
	u32 picture_size;
	u32 accui[2];
d156 2
a157 2
		u32 h;
		u32 hv;
d159 1
a159 1
	u32 conv_coef[5];
d163 20
a182 20
	u32 _pad[4];
	u32 sysconfig;
	u32 sysstatus;
	u32 irqstatus;
	u32 irqenable;
	u32 _pad2[8];
	u32 control;
	u32 config;
	u32 _pad3;
	u32 default_color[2];
	u32 trans_color[2];
	u32 line_status;
	u32 line_number;
	u32 timing_h;
	u32 timing_v;
	u32 pol_freq;
	u32 divisor;
	u32 global_alpha;
	u32 size_dig;
	u32 size_lcd;
d185 1
a185 1
	u32 _pad4[2];
d187 7
a193 7
	u32 data_cycle[3];
	u32 vid_fir_coef_v[2][8];
	u32 cpr_coef_r;
	u32 cpr_coef_g;
	u32 cpr_coef_b;
	u32 gfx_preload;
	u32 vid_preload[2];
d425 4
a428 4
	u32 config;
	u32 onoff_time;
	u32 cycle_time;
	u32 data_cycle[3];
d432 12
a443 12
	u32 _pad[4];
	u32 sysconfig;
	u32 sysstatus;
	u32 _pad2[(0x40-0x18)>>2];
	u32 control;
	u32 pixel_cnt;
	u32 line_number;
	u32 cmd;
	u32 param;
	u32 data;
	u32 read;
	u32 status;
d445 2
a446 2
	u32 vsync_width;
	u32 hsync_width;
d452 51
a502 51
	u32 _pad;
	u32 status;
	u32 f_control;
	u32 _pad2;
	u32 vidout_ctrl;
	u32 sync_ctrl;
	u32 _pad3;
	u32 llen;
	u32 flens;
	u32 hfltr_ctrl;
	u32 cc_carr_wss_carr;
	u32 c_phase;
	u32 gain_u;
	u32 gain_v;
	u32 gain_y;
	u32 black_level;
	u32 blank_level;
	u32 x_color;
	u32 m_control;
	u32 bstamp_wss_data;
	u32 s_carr;
	u32 line21;
	u32 ln_sel;
	u32 l21_wc_ctl;
	u32 htrigger_vtrigger;
	u32 savid_eavid;
	u32 flen_fal;
	u32 lal_phase_reset;
	u32 hs_int_start_stop_x;
	u32 hs_ext_start_stop_x;
	u32 vs_int_start_x;
	u32 vs_int_stop_x_vs_int_start_y;
	u32 vs_int_stop_y_vs_ext_start_x;
	u32 vs_ext_stop_x_vs_ext_start_y;
	u32 vs_ext_stop_y;
	u32 _pad4;
	u32 avid_start_stop_x;
	u32 avid_start_stop_y;
	u32 _pad5;
	u32 _pad6;
	u32 fid_int_start_x_fid_int_start_y;
	u32 fid_int_offset_y_fid_ext_start_x;
	u32 fid_ext_start_y_fid_ext_offset_y;
	u32 _pad7;
	u32 tvdetgp_int_start_stop_x;
	u32 tvdetgp_int_start_stop_y;
	u32 gen_ctrl;
	u32 _pad8;
	u32 _pad9;
	u32 output_control;
	u32 output_test;
d704 8
a711 8
	u32 ctrl;
	u32 te;
	u32 long_packet_header;
	u32 long_packet_payload;
	u32 short_packet_header;
	u32 _pad;
	u32 irqstatus;
	u32 irqenable;
d715 28
a742 28
	u32 _pad[4];
	u32 sysconfig;
	u32 sysstatus;
	u32 irqstatus;
	u32 irqenable;
	u32 _pad2[(0x40-0x20)>>2];
	u32 ctrl;
	u32 _pad3;
	u32 complexio_cfg1;
	u32 complexio_irqstatus;
	u32 complexio_irqenable;
	u32 clk_ctrl;
	u32 timing1;
	u32 timing2;
	u32 vm_timing1;
	u32 vm_timing2;
	u32 vm_timing3;
	u32 clk_timing;
	u32 tx_fifo_vc_size;
	u32 rx_fifo_vc_size;
	u32 complexio_cfg2;
	u32 rx_fifo_vc_fullness;
	u32 vm_timing4;
	u32 tx_fifo_vc_emptiness;
	u32 vm_timing5;
	u32 vm_timing6;
	u32 vm_timing7;
	u32 stopclk_timing;
d771 5
a775 5
	u32 cfg0;
	u32 cfg1;
	u32 cfg2;
	u32 _pad[2];
	u32 cfg5;
d781 5
a785 5
	u32 control;
	u32 status;
	u32 go;
	u32 configuration1;
	u32 configuration2;
d841 19
a859 19
	u32 ccr;
	u32 clnk_ctrl;
	u32 cicr;
	u32 csr;
	u32 csdp;
	u32 cen;
	u32 cfn;
	u32 cssa;
	u32 cdsa;
	u32 csei;
	u32 csfi;
	u32 cdei;
	u32 cdfi;
	u32 csac;
	u32 cdac;
	u32 ccen;
	u32 ccfn;
	u32 color;
	u32 _pad[6];
d975 9
a983 9
	u32 _pad[2];
	u32 irqstatus[4];
	u32 irqenable[4];
	u32 sysstatus;  /* Ignore; handled by HAL/DMAManager */
	u32 ocp_sysconfig; /* Ignore; handled by HAL/DMAManager */
	u32 _pad2[(0x64-0x30)>>2];
	u32 caps[5];
	u32 gcr; /* Ignore; handled by HAL/DMAManager */
	u32 _pad3;
d1064 8
a1071 8
	u32 att;
	u32 _pad;
	u32 rdperm;
	u32 _pad2;
	u32 wrperm;
	u32 _pad3;
	u32 start;
	u32 end;
d1075 4
a1078 4
	u32 control;
	u32 size;
	u32 physical_ba;
	u32 _pad;
d1082 5
a1086 5
	u32 revision;
	u32 _pad[3];
	u32 sysconfig;
	u32 sysstatus;
	u32 _pad2[((0x48-0x18)>>2)];
d1088 11
a1098 11
	u32 _pad3[2];
	u32 class_arbiter0;
	u32 class_arbiter1;
	u32 class_arbiter2;
	u32 _pad4;
	u32 interclass_arbiter;
	u32 class_rotation[3];
	u32 err_addr;
	u32 err_type;
	u32 pow_ctrl;
	u32 _pad5;
d1116 1
a1116 1
extern u32 ban_hardware_update; /* Bitflags used to ban hardware updates (GOLCD/GODIGITAL, etc) */
d1123 2
a1124 2
extern void set_ban(u32 flags); /* Set ban flags */
extern void clear_ban(u32 flags); /* Clear ban flags */
@


1.2
log
@Assorted OMAPVideo tweaks and fixes
Detail:
  c/dispc - Added some WIP code for programming scaling coefficients
  c/dispc, c/graphicsv - Fixed code to not allow the graphics overlay to be enabled before its DMA address had been set (as was happening on boot)
  c/dispc - Enable reporting of FIFO underflow & OCPERROR interrupts in debug builds, to help track down bugs
  c/dispc - Check in some disabled code that was an attempt to fix the IGEP display problems. Code was to force FIFO preload values to 0x100, and to force DISPC_POL_FREQ to 0.
  c/dsi - Keep the DSI complex I/O clock off
  c/dsi, c/dss, h/dss, h/regs - rewrote calculate_dss_clock_divider to remove data lane frequency restriction, and to increase speed/accuracy when calculating rates for tricky values like 25.175MHz. Also in another attempt to fix the IGEP issues, it mimics the Linux driver by trying to generate a 48MHz DSI clock.
  c/dss, c/venc - Tweaked DSS reset & VENC code to make sure VENC clcoks are enabled & disabled at the appropriate times.
  c/graphicsv - Fix GraphicsV_SetDMAAddress so it works properly no matter what overlay the desktop is on
  c/venc - A fix to get the PAL test card working, and a fudge to get PAL output working.
Admin:
  Tested on rev C2 beagleboard & IGEP.
  IGEP reported as showing no concrete improvement in display stability :(


Version 0.03. Tagged as 'OMAPVideo-0_03'
@
text
@d48 2
a49 2
#define SYSCONFIG_AUTOIDLE		0x0001	/* DSS, DISPC */
#define SYSCONFIG_SOFTRESET		0x0002	/* DSS, DISPC */
d51 1
a51 1
#define SYSCONFIG_SIDLEMODE_MASK	0x0018	/* DISPC */
d65 1
a65 1
#define SYSSTATUS_RESETDONE		1	/* DSS */
d994 114
d1118 1
@


1.1
log
@Add initial version of OMAP video driver module
Detail:
  All-new OMAP video driver, written as a module in C.
  Functionality-wise it's basically the same as the original HAL-based driver, except it provides support for GraphicsV_Render via use of the OMAP SDMA controller, and there's currently no support for GraphicsV_IICOp.
  However under the hood the module is significantly different, to ensure it can be expanded to expose the full feature set of the video controller once the new GraphicsV API is ready.
Admin:
  Tested on rev C2 beagleboard.


Version 0.01. Tagged as 'OMAPVideo-0_01'
@
text
@d39 1
@


head	1.19;
access;
symbols
	EtherUSB-0_41:1.19
	EtherUSB-0_40:1.18
	EtherUSB-0_39:1.18
	EtherUSB-0_38:1.18
	EtherUSB-0_37:1.17
	EtherUSB-0_36:1.17
	EtherUSB-0_35:1.16
	EtherUSB-0_34:1.16
	EtherUSB-0_33:1.16
	EtherUSB-0_32:1.16
	EtherUSB-0_31:1.16
	EtherUSB-0_30:1.15
	EtherUSB-0_29:1.15
	EtherUSB-0_28:1.15
	EtherUSB-0_27:1.13
	EtherUSB-0_26:1.13
	EtherUSB-0_25:1.12
	EtherUSB-0_24:1.11
	EtherUSB-0_23:1.10
	EtherUSB-0_22:1.9
	EtherUSB-0_21:1.8
	EtherUSB-0_20:1.8
	EtherUSB-0_19:1.8
	EtherUSB-0_18:1.7
	EtherUSB-0_17:1.6
	EtherUSB-0_16:1.5
	EtherUSB-0_15:1.4
	EtherUSB-0_14:1.3
	jpeacock-0_13:1.1;
locks; strict;
comment	@# @;


1.19
date	2018.03.21.23.54.42;	author jlee;	state Exp;
branches;
next	1.18;
commitid	FAdt578EOH7cRnvA;

1.18
date	2017.10.21.16.35.36;	author rool;	state Exp;
branches;
next	1.17;
commitid	RL2w4GqnhnkuhWbA;

1.17
date	2016.02.29.10.37.07;	author bavison;	state Exp;
branches;
next	1.16;
commitid	oAHZMQOdmovfANWy;

1.16
date	2015.09.05.20.33.08;	author rool;	state Exp;
branches;
next	1.15;
commitid	hsW7lDmaNPcqz6Ay;

1.15
date	2014.08.24.08.11.29;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	YZmCKmQSYSPmAANx;

1.14
date	2014.08.24.08.09.29;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	waLmpCDiEYRjzANx;

1.13
date	2013.10.13.13.54.41;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	cLeOtNKk3nePB89x;

1.12
date	2013.10.04.07.41.13;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	KOKUvofUdP1GPW7x;

1.11
date	2013.04.07.17.47.10;	author jlee;	state Exp;
branches;
next	1.10;
commitid	7koGNmobBUDhYRKw;

1.10
date	2013.04.01.14.59.33;	author jlee;	state Exp;
branches;
next	1.9;
commitid	depDMAPvYqzJe5Kw;

1.9
date	2012.10.31.21.56.11;	author jlee;	state Exp;
branches;
next	1.8;
commitid	VatbpwobWsJAqAqw;

1.8
date	2012.06.24.20.59.40;	author jlee;	state Exp;
branches;
next	1.7;
commitid	Is6csYj0C3Vhg0aw;

1.7
date	2012.05.19.08.46.48;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	jnaodXkH29YBmj5w;

1.6
date	2012.05.19.08.44.28;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	6JuVMhjS8DSNlj5w;

1.5
date	2012.05.19.08.42.21;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	1BHJUY7zoQz3lj5w;

1.4
date	2012.05.19.08.39.06;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	sBdKYcdaXJwXjj5w;

1.3
date	2012.05.19.08.30.24;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	R1EOINZ5A36Ygj5w;

1.2
date	2012.05.19.08.22.12;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	SzPjH7uh6hKVdj5w;

1.1
date	2012.05.19.08.19.06;	author rsprowson;	state Exp;
branches;
next	;
commitid	q3rEKeu2RrS2cj5w;


desc
@@


1.19
log
@Add SMSC78xx support
Detail:
  c/smsc78xx, c/module, c/products, h/backends, Makefile - Add SMSC78xx driver, for the chip used in the Raspberry Pi 3B+
  c/config, c/mii, h/mii - Add support for gigabit MIIs & associated (auto) configuration
  c/net, h/net - Handle gigabit link types. Pass verbose flag through to backend info function.
  c/smsc95xx - Make configure_link const-correct
  Resources/UK/CmdHelp - Update *EJConfig syntaxt text to include 1000 option
  Resources/UK/Messages - Add 78xx backend name & device-specific info tokens
Admin:
  Tested on Raspberry Pi 3B & 3B+
  Manually configured gigabit links aren't supported yet
  Gigabit half-duplex isn't supported (78xx MAC limitation)
  For the 78xx, manually-configured full-duplex links appear to suffer terrible RX performance (as seen on 95xx). All supported auto modes appear to work correctly.


Version 0.41. Tagged as 'EtherUSB-0_41'
@
text
@//
// Copyright (c) 2006, James Peacock
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of RISC OS Open Ltd nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//

#include <stddef.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>

#include "swis.h"
#include "kernel.h"
#include "AsmUtils/irqs.h"
#include "Global/NewErrors.h"
#include "Global/Variables.h"
#include "Global/ModHand.h"
#undef   Module_Title
#include "SyncLib/SyncLib.h"

#include "module.h"
#include "utils.h"
#include "USB/USBDevFS.h"
#include "usb.h"
#include "net.h"
#include "mbuf.h"
#include "products.h"
#include "config.h"
#include "EtherUSBHdr.h"


#define DEBUG_DATA  0
#define DEBUG_PKTS  0
#define DEBUG_SCAN  0
#define DEBUG_QUEUE 0

typedef struct backend_t
{
  struct backend_t*    next;                          // Next list.
  struct backend_t*    prev;                          // Previous list.
  const net_backend_t* backend;                       // Implementation
} backend_t;

static backend_t*    s_backends = NULL;               // Owns data.
static net_device_t* s_devices = NULL;                // Owns data.
static net_device_t* s_units[MODULE_MAX_UNITS];       // Unit no -> device.

struct net_filter_t
{
  struct net_filter_t*   next;
  struct net_filter_t*   prev;
  uint32_t               frame_type;
  uint8_t                addr_level;
  uint8_t                err_level;
  uint32_t               r12;
  uint32_t               handler;
  uint32_t               flags;
};


//---------------------------------------------------------------------------
// Generation of default MAC address for devices which don't have one. The
// MAC address is generated from the machine's unique ID, or failing that
// a hard coded one.
//
// Most significant byte:
//   b0   : Flag: 0=>unicast, 1=>multicast.
//   b1   : Flag: 0=>globally unique, 1=>locally administered.
//   b2-b3: zero.
//   b4-b7: unit number.
// unit number
//---------------------------------------------------------------------------
void net_default_mac(unsigned unit, uint8_t* mac)
{
  mac[0] = 2 | (((uint8_t)unit) << 4);

  unsigned id_lo = 0;
  unsigned id_hi = 0;
  _kernel_oserror* e = _swix(OS_ReadSysInfo, _IN(0)|_OUTR(0,1),
                             5, &id_lo, &id_hi);

  if (!e && (id_lo!=0 || id_hi!=0))
  {
    // Crude hash to reduce 64 bit machine ID to 40 bits.
    mac[1] = ((id_lo >> 0 ) & 0xff) ^ ((id_hi >> 8 ) & 0xff);
    mac[2] = ((id_lo >> 8 ) & 0xff) ^ ((id_hi >> 16) & 0xff);
    mac[3] = ((id_lo >> 16) & 0xff) ^ ((id_hi >> 24) & 0xff);
    mac[4] = ((id_lo >> 24) & 0xff);
    mac[5] = ((id_hi >> 0 ) & 0xff);
  }
  else
  {
    // Machine has no ID, use a default one.
    mac[1] = 0x07;
    mac[2] = 0x21;
    mac[3] = 0x68;
    mac[4] = 0x16;
    mac[5] = 0x03;
  }
}

//---------------------------------------------------------------------------
// Look up the configured MAC address for the machine. Returns false if no
// MAC exists, or if it's already in use by another driver.
//---------------------------------------------------------------------------
bool net_machine_mac(uint8_t* mac)
{
  unsigned int mac2[2] = {0,0};
  _kernel_oserror* e = _swix(OS_ReadSysInfo, _IN(0)|_OUTR(0,1),
                             4, &mac2[0], &mac2[1]);

  if (e || ((mac2[0] == 0) && (mac2[1] == 0)))
  {
    return false;
  }

  // We have a MAC, now enumerate all the devices on the system to check it
  // isn't already in use (e.g. motherboard NIC on Iyonix)
  ChDib *drivers = NULL;
  e = _swix(OS_ServiceCall,_INR(0,1)|_OUT(0),0,Service_EnumerateNetworkDrivers,&drivers);
  if (e)
    return false;
  bool found = false;
  while(drivers)
  {
    if(drivers->chd_dib && drivers->chd_dib->dib_address &&
       (drivers->chd_dib->dib_address != mac) &&
       !memcmp(drivers->chd_dib->dib_address,mac2,ETHER_ADDR_LEN))
      found = true;
    ChDib *next = drivers->chd_next;
    _swix(OS_Module,_IN(0)|_IN(2),ModHandReason_Free,drivers);
    drivers = next;
  }

  if (!found)
    memcpy(mac,mac2,ETHER_ADDR_LEN);

  return !found;
}

//---------------------------------------------------------------------------
// Hack to aid device writes and help stop stalls due to not being able
// to tell when a USB read has finished.
//---------------------------------------------------------------------------
static callback_delay_t prod_writes(void* h)
{
  net_device_t* dev = h;
  net_attempt_transmit(dev);
  return 5;
}

//---------------------------------------------------------------------------
// Prod status. Save each backend from having to do this. Only called if
// the backend supports the status call.
//---------------------------------------------------------------------------
static callback_delay_t prod_status(void* h)
{
  net_device_t* dev = h;
  const net_backend_t* backend = dev->backend;
  _kernel_oserror* e = backend->status(dev);

  callback_delay_t delay = 100;
  if (e)
  {
    syslog("%s: status error: %s", dev->name, e->errmess);
    delay = 500;
  }

  return delay;
}

//---------------------------------------------------------------------------
// Set Inet$EtherType if not already set. This violates the DCI specification
// slightly, but is probably the least worst option. See !ReadMe for
// reasoning behind this.
//---------------------------------------------------------------------------
static callback_delay_t set_inet_variables(void* h)
{
  char value[20];

  size_t size = 0;
  _kernel_oserror *e = _swix(OS_ReadVarVal, _INR(0,4)|_OUT(2),
                             "Inet$EtherType",
                             value, sizeof(value)-1, 0, 3,
                             &size);
  if ((e && (e->errnum==ErrorNumber_VarCantFind)) || size==0)
  {
    e = NULL;
    for (unsigned unit=0; unit!=MODULE_MAX_UNITS; ++unit)
    {
      if (s_units[unit])
      {
        snprintf(value, sizeof(value), MODULE_DCI_NAME "%u", unit);
        e = _swix(OS_SetVarVal, _INR(0,4),
                  "Inet$EtherType", value, strlen(value), 0, VarType_String);
        break;
      }
    }
  }

  if (e) syslog("Can't set Inet$... variables: %s", e->errmess);

  UNUSED(h);

  return CALLBACK_REMOVE;
}

//---------------------------------------------------------------------------
// Deregisters device, informs backend of its demise and frees resources.
//---------------------------------------------------------------------------
static _kernel_oserror* device_destroy(net_device_t* dev)
{
  syslog("%s: removed",dev->name);

  _kernel_oserror* e = callback_cancel(&prod_writes, dev);
  if (!e && dev->backend->status) e = callback_cancel(&prod_status, dev);

  if (!e) e = _swix(OS_ServiceCall, _INR(0,3),
                    &(dev->dib),
                    Service_DCIDriverStatus,
                    DCIDRIVER_DYING,
                    DCIVERSION);

  if (e) return e;

  if (dev->backend->stop) dev->backend->stop(dev);
  if (dev->backend->close) dev->backend->close(&(dev->private));
  s_units[dev->dib.dib_unit] = NULL;
  LINKEDLIST_REMOVE(s_devices, dev);

  while (dev->specific_filters)
  {
    net_filter_t* r = dev->specific_filters;
    LINKEDLIST_REMOVE(dev->specific_filters, r);
    xfree(r);
  }

  xfree(dev->sink_filter);
  xfree(dev->monitor_filter);
  xfree(dev->ieee_filter);

  xfree(dev);
  return NULL;
}

//---------------------------------------------------------------------------
// TX packet buffer functions
//---------------------------------------------------------------------------
static inline void tx_push(int irqs_disabled, net_tx_t* volatile* list, net_tx_t* packet)
{
  if (!irqs_disabled) _kernel_irqs_off();
  
  packet->next = *list;
  *list = packet;
  
  if (!irqs_disabled) _kernel_irqs_on();
}

static inline net_tx_t* tx_pop(int irqs_disabled, net_tx_t* volatile* list)
{
  if (!irqs_disabled) _kernel_irqs_off();
  
  net_tx_t* packet = *list;
  if (packet != NULL) *list = packet->next;
  
  if (!irqs_disabled) _kernel_irqs_on();
  
  return packet;
}

//---------------------------------------------------------------------------
// Registers a device, binds it to a backend and asks the backend to
// initialise it.
//---------------------------------------------------------------------------
static _kernel_oserror* device_create(const USBServiceCall* dev,
                                      const net_backend_t*  backend,
                                      const char*           options,
                                      void*                 private)
{
  net_device_t* d = xalloc(sizeof(net_device_t));

  assert(sizeof(d->name)==sizeof(dev->devname));

  if (!d) return err_translate(ERR_NO_MEMORY);

  memcpy(d->name, dev->devname, sizeof(dev->devname));

  memset(&d->status, 0, sizeof(d->status));
  memset(&d->abilities, 0, sizeof(d->abilities));

  d->vendor = dev->ddesc.idVendor;
  d->product = dev->ddesc.idProduct;
  d->bus = dev->bus;
  d->address = dev->devaddr;
  d->speed = dev->speed;

  {
    _kernel_oserror *e = usb_location(d->name,d->usb_location);
    if(e)
    {
      xfree(d);
      return e;
    }
  }

  d->gone = false;
  d->tx_guard = 0;
  d->backend = backend;
  d->dib.dib_swibase = EtherUSB_00;
  d->dib.dib_name = (unsigned char *)MODULE_DCI_NAME;
  d->dib.dib_unit = MODULE_MAX_UNITS;
  d->dib.dib_address = d->status.mac;
  d->dib.dib_module = (unsigned char *)Module_Title;
  d->dib.dib_location = (unsigned char *)d->location;
  d->dib.dib_slot.sl_slotid = DIB_SLOT_USB_BUS(dev->bus);
  d->dib.dib_slot.sl_minor = dev->devaddr;
  d->dib.dib_slot.sl_pcmciaslot = 0;
  d->dib.dib_slot.sl_mbz = 0;
  d->dib.dib_inquire = 0;

  snprintf(d->location, sizeof(d->location),
           msg_translate("Loc"),
           d->bus, d->address, d->name);

  d->mtu = 1500;
  d->private = private;
  d->specific_filters = NULL;
  d->sink_filter = NULL;
  d->monitor_filter = NULL;
  d->ieee_filter = NULL;
   
  d->packet_tx_count = 0;
  d->packet_rx_count = 0;
  d->packet_unwanted = 0;
  d->packet_tx_errors = 0;
  d->packet_rx_errors = 0;
  d->packet_tx_bytes = 0;
  d->packet_rx_bytes = 0;
  d->queue_tx_overflows = 0;
  d->queue_tx_max_usage = 0;

  {
    bool reserved[MODULE_MAX_UNITS];
    _kernel_oserror *e = config_reserved_units(reserved,d);
    if(e)
    {
      xfree(d);
      return e;
    }
    if(d->dib.dib_unit == MODULE_MAX_UNITS)
    {
      for(unsigned i=0; i!=MODULE_MAX_UNITS; ++i)
      {
        if (!reserved[i] && !s_units[i])
        {
          d->dib.dib_unit = i;
          break;
        }
      }
    }
  }

  LINKEDLIST_INSERT(s_devices, d);

  if (backend->start)
  {
    _kernel_oserror* e = backend->start(d, options);
    if (e)
    {
      LINKEDLIST_REMOVE(s_devices, d);
      xfree(d);
      return e;
    }
  }

  syslog("%s: backend '%s', MAC %02X:%02X:%02X:%02X:%02X:%02X",
         dev->devname, backend->name,
         d->dib.dib_address[0], d->dib.dib_address[1], d->dib.dib_address[2],
         d->dib.dib_address[3], d->dib.dib_address[4], d->dib.dib_address[5]);

  {
    uint32_t inquire = ( INQ_HASSTATS |
                         INQ_HWADDRVALID |
                         INQ_RXERRORS );

    const net_abilities_t* a = &d->abilities;
    if (a->multicast        ) inquire |= INQ_MULTICAST;
    if (a->promiscuous      ) inquire |= INQ_PROMISCUOUS;
    if (a->tx_rx_loopback   ) inquire |= INQ_CANREFLECT;
    if (a->mutable_mac      ) inquire |= INQ_SOFTHWADDR;

    d->dib.dib_inquire = inquire;
  }

  net_config_t config;

  {
    _kernel_oserror* e = config_new_device(d, &config);

    if (!e && d->dib.dib_unit>=MODULE_MAX_UNITS) e = err_translate(ERR_TOO_MANY_UNITS);
    if (!e && s_units[d->dib.dib_unit]) e = err_translate(ERR_UNIT_IN_USE);
    if (!e && backend->status) e = callback(&prod_status, 100, d);
    if (!e) e = callback(&set_inet_variables, 1, NULL);
    if (e)
    {
      LINKEDLIST_REMOVE(s_devices, d);
      if (backend->stop) backend->stop(d);
      xfree(d);
      return e;
    }
  }

  d->dib.dib_slot.sl_minor = d->dib.dib_unit;
  s_units[d->dib.dib_unit] = d;

  _swix(OS_ServiceCall, _INR(0,3),
        &(d->dib),
        Service_DCIDriverStatus,
        DCIDRIVER_STARTING,
        DCIVERSION);

  syslog("%s: bound to interface %s%u",
         dev->devname, d->dib.dib_name, d->dib.dib_unit);

  if (backend->config)
  {
    // Consider failure to config here a soft error as it may be able
    // to correct it using *EJConfig.
    _kernel_oserror* e = backend->config(d, &config);
    if (e) syslog("%s: config: %s", dev->devname, e->errmess);
  }

  return NULL;
}

//---------------------------------------------------------------------------
// Checks a device to see if any backend can handle it.
// Takes no action if device is not supported.
//---------------------------------------------------------------------------
static inline bool backend_match(const char* s1, const char* s2)
{
  while (*s1 && *s2 && tolower(*s1)==tolower(*s2)) ++s1,++s2;
  return (*s1==*s2);
}

_kernel_oserror* net_check_device(const USBServiceCall* dev, void* handle)
{
  if (DEBUG_SCAN)
  {
    static const char *speed;

    switch (dev->speed)
    {
      case USB_SPEED_FULL: speed = "Full";      break;
      case USB_SPEED_LOW:  speed = "Low";       break;
      case USB_SPEED_HI:   speed = "Hi";        break;
      default:             speed = "<UNKNOWN>"; break;
    }
    syslog("Checking '%s' %02x:%02x:%02x [%s speed]",
                         dev->devname,
                         dev->ddesc.bDeviceClass,
                         dev->ddesc.bDeviceSubClass,
                         dev->ddesc.bDeviceProtocol,
                         speed);
  }

  const char* backend_name = NULL;
  const char* options = NULL;
  if (products_match(dev, &backend_name, &options))
  {
    if (!backend_name || backend_name[0]<=32)
    {
      syslog("Device '%s' 0x%04hX:0x%04hX intentionally ignored",
              dev->devname, dev->ddesc.idVendor, dev->ddesc.idProduct);
      return NULL;
    }
  }

  const backend_t* bbackend = s_backends;
  while (bbackend)
  {
    const net_backend_t* backend = bbackend->backend;
    bbackend = bbackend->next;

    if (backend_name && !backend_match(backend_name, backend->name))
      continue;

    if (backend && backend->open)
    {
      void* private = NULL;
      _kernel_oserror* e = backend->open(dev, options, &private);
      if (!e)
      {
        e = device_create(dev, backend, options, private);
        if (!e) return NULL;

        syslog("%s: Removed as unable to start device: %s",
                dev->devname, e->errmess);

        if (backend->close) backend->close(&private);
        return NULL;
      }
      if (e && e->errnum!=err_translate(ERR_UNSUPPORTED)->errnum) return e;
      if (e && DEBUG_SCAN) syslog("  Unsupported.");
      if (backend_name) return NULL;
    }
  }
  if (backend_name)
  {
    syslog("Unknown backend name specified in products list: '%s'",
            backend_name);
  }

  UNUSED(handle);

  return NULL;
}

//---------------------------------------------------------------------------
// Lookup a device from a unit number, returns NULL if unknown.
//---------------------------------------------------------------------------
static inline net_device_t* net_from_unit(unsigned unit)
{
  return (unit>=MODULE_MAX_UNITS) ? NULL : s_units[unit];
}

//---------------------------------------------------------------------------
// Notify of device removal. 'name' is DeviceFS name, e.g. 'USB1'
//---------------------------------------------------------------------------

_kernel_oserror* net_dead_device(const char* name)
{
  net_device_t* dev = s_devices;
  while (dev)
  {
    if (strcoll(name, dev->name)==0)
    {
      dev->gone = true;
      return device_destroy(dev);
    }
    dev = dev->next;
  }
  return NULL;
}

//---------------------------------------------------------------------------
// Called on module initialisation to register backends.
//---------------------------------------------------------------------------
_kernel_oserror* net_register_backend(const net_backend_t* backend)
{
  syslog("Adding backend: %s",backend->name);

  backend_t* b = xalloc(sizeof(backend_t));
  if (!b) return err_translate(ERR_NO_MEMORY);

  b->backend = backend;
  LINKEDLIST_INSERT(s_backends, b);
  return NULL;
}

//---------------------------------------------------------------------------
// Called on module death.
//---------------------------------------------------------------------------

_kernel_oserror* net_finalise(void)
{
  net_device_t* dev = s_devices;
  _kernel_oserror* e = NULL;
  while (dev)
  {
    net_device_t* tdev = dev;
    dev = dev->next;
    e = device_destroy(tdev);
    if (e) syslog("%s: error shutting down: %s", tdev->name, e->errmess);
  }

  if (e) return e;

  while (s_backends)
  {
    backend_t* b = s_backends;
    s_backends = s_backends->next;
    xfree(b);
  }

  return NULL;
}

//---------------------------------------------------------------------------
// Send a packet to wherever it is meant to go or discard it.
//---------------------------------------------------------------------------
_kernel_oserror* net_receive(net_device_t* dev,
                             const void* pk,
                             size_t size,
                             uint32_t error)
{
  if (size<sizeof(net_header_t))
  {
    syslog("Receive: packet too short: %zu/%u",size,sizeof(net_header_t));
    ++dev->packet_rx_errors;
    return NULL;
  }

  const net_header_t* hdr = pk;
  const uint32_t type = (hdr->type >> 8) | ((hdr->type & 0xff) << 8);
  const net_filter_t* handler = NULL;

  if (DEBUG_PKTS)
    syslog("Receive: type=&%04X size=%zu err=%u "
           "%02x:%02x:%02x:%02x:%02x:%02x -> "
           "%02x:%02x:%02x:%02x:%02x:%02x",
           type,
           size,
           error,
           hdr->src_addr[0], hdr->src_addr[1], hdr->src_addr[2],
           hdr->src_addr[3], hdr->src_addr[4], hdr->src_addr[5],
           hdr->dst_addr[0], hdr->dst_addr[1], hdr->dst_addr[2],
           hdr->dst_addr[3], hdr->dst_addr[4], hdr->dst_addr[5]);

  if (DEBUG_PKTS && DEBUG_DATA) syslog_data(pk, size);

  if (type>1500)
  {
    // Ethernet 2.0 frame
    handler = dev->monitor_filter;
    if (!handler)
    {
      handler = dev->specific_filters;
      while (handler)
      {
        if (handler->frame_type == type) break;
        handler = handler->next;
      }
      if (!handler) handler = dev->sink_filter;
    }
  }
  else
  {
    // IEEE 802.3
    handler = dev->ieee_filter;
  }

  ++dev->packet_rx_count;
  dev->packet_rx_bytes += size;
  if (error) ++dev->packet_rx_errors;

  if (!handler)
  {
     ++dev->packet_unwanted;
     return NULL;
  }

  if (error && handler->err_level==0)
  {
    ++dev->packet_unwanted;
    return NULL;
  }

  RxHdr rx;
  rx.rx_tag = 0;
  rx.rx_ptr = NULL;
  for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) rx.rx_src_addr[i] = hdr->src_addr[i];
  for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) rx.rx_dst_addr[i] = hdr->dst_addr[i];
  rx._spad[0] = 0;
  rx._spad[1] = 0;
  rx._dpad[0] = 0;
  rx._dpad[1] = 0;
  rx.rx_frame_type = type;
  rx.rx_error_level = error;

  mbuf_t* mbuf1 = g_mbuf->alloc_u(g_mbuf, sizeof(RxHdr), &rx);
  if (!mbuf1) return err_translate(ERR_NO_MEMORY);

  mbuf_t* mbuf2 = g_mbuf->alloc_u(g_mbuf,
                                  size - sizeof(net_header_t),
                                  (void*)(hdr+1));
  if (!mbuf2)
  {
    g_mbuf->freem(g_mbuf, mbuf1);
    return err_translate(ERR_NO_MEMORY);
  }

  mbuf1->type = MBUF_MT_HEADER;
  mbuf2->type = MBUF_MT_DATA;

  mbuf1->next = mbuf2;
  mbuf1->list = NULL;
  mbuf2->list = NULL;

  if (handler->flags & FILTER_NO_UNSAFE)
  {
    mbuf1 = g_mbuf->ensure_safe(g_mbuf, mbuf1);
  }

  __asm
  {
    mov r0,&dev->dib
    mov r1,mbuf1
    mov r12,handler->r12
    blx handler->handler,{r0,r1,r12},{},{LR,PSR}
  }

  return NULL;
}

//---------------------------------------------------------------------------
// _Inquire
//---------------------------------------------------------------------------
_kernel_oserror* net_inquire(_kernel_swi_regs* r)
{
  net_device_t* dev = net_from_unit(r->r[1]);
  if (!dev) return err_translate(ERR_BAD_UNIT);
  r->r[2] = dev->dib.dib_inquire;
  return NULL;
}

//---------------------------------------------------------------------------
// _GetNetworkMTU
//---------------------------------------------------------------------------
_kernel_oserror* net_get_network_mtu(_kernel_swi_regs* r)
{
  net_device_t* dev = net_from_unit(r->r[1]);
  if (!dev) return err_translate(ERR_BAD_UNIT);
  r->r[2] = dev->mtu;
  return NULL;
}

//---------------------------------------------------------------------------
// Send some data (DCI_Transmit).
//---------------------------------------------------------------------------
// Note there can be multiple mbuf chains representing multiple packets.



//---------------------------------------------------------------------------
// Attempts to send next queued packet by calling dev's backend.
//---------------------------------------------------------------------------


typedef struct 
{
  int                   flags;
  int                   if_unit;
  unsigned int          type;                   // Ethernet packet type
  mbuf_t*               mbuf_list;              // List of mbufs to send
  const uint8_t*        dst_addr;               // Destination ethernet address 
  const uint8_t*        src_addr;               // Source ethernet address if
                                                // TX_FAKESOURCE flag set
} dci4transmit_t;

static _kernel_oserror* tx_error(_kernel_oserror* e, dci4transmit_t* args)
{
  mbuf_t* next;
  mbuf_t* mbuf;

  if (args == NULL || (args->flags & TX_PROTOSDATA) != 0) return e;
  
  // Delete mbuf list if protocol doesn't own the data
  for (mbuf = args->mbuf_list; mbuf != NULL; mbuf = next)
  {
    next = mbuf->list;
    g_mbuf->freem(g_mbuf, mbuf);
  }
 
  return e;
}

_kernel_oserror* net_transmit(_kernel_swi_regs* r)
{
  _kernel_oserror* e = NULL;
  
  dci4transmit_t* args = (void*) r;
  
  if (args->mbuf_list == NULL) return e;
  
  net_device_t* dev = net_from_unit(args->if_unit);
   
  if (dev == NULL) 
  {
    return tx_error(err_translate(ERR_BAD_UNIT),args);
  }

  uint8_t guard = atomic_update_byte(1, &dev->tx_guard);
  
  if (guard != 0)
  {
      return tx_error(err_translate(ERR_TX_BLOCKED),args);
  }

  // free up any buffered packets that can be inserted into usb buffer now
  for (mbuf_t* mbuf = args->mbuf_list; mbuf; mbuf = mbuf->list)
  {
      // Skip an mbuf that is too big
      size_t size = g_mbuf->count_bytes(g_mbuf, mbuf);
      if (size>TX_MAX_DATA_SIZE) {e = err_translate(ERR_MESSAGE_TOO_BIG); continue;}
      
      
      dev->tx_packet.size = size + sizeof(net_header_t);
      dev->tx_packet.header.type = ((args->type >> 8) & 0x00ff) |
                              ((args->type << 8) & 0xff00) ;

      const uint8_t* src = (args->flags & TX_FAKESOURCE)
                         ? args->src_addr
                         : (dev->status.mac);

      const uint8_t* dst = args->dst_addr;

      for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) dev->tx_packet.header.src_addr[i] = src[i];
      for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) dev->tx_packet.header.dst_addr[i] = dst[i];

      g_mbuf->export(g_mbuf, mbuf, size, dev->tx_packet.data);
      
      e = dev->backend->transmit(dev, &dev->tx_packet); /* blocking in usb_write */
        
      if (e)
      {
        ++dev->packet_tx_errors;
        break;
      }
      
      ++dev->packet_tx_count;
      dev->packet_tx_bytes += size;
  }
  
  dev->tx_guard = 0;

  return tx_error(e,args);
}  

_kernel_oserror* net_attempt_transmit(net_device_t* dev) { dev = dev; return 0;}



//---------------------------------------------------------------------------
// Claim/release packet types (DCI_Filter).
//---------------------------------------------------------------------------

static _kernel_oserror* net_filter_impl(_kernel_swi_regs* r)
{
  net_device_t* dev = net_from_unit(r->r[1]);
  if (!dev) return err_translate(ERR_BAD_UNIT);

  const uint32_t flags = r->r[0];
  const uint32_t frame_type = (uint32_t)(r->r[2]) & 0xffff;
  const uint32_t frame_level = (uint32_t)(r->r[2]) >> 16;
  const uint32_t addr_level = r->r[3];
  const uint32_t err_level = r->r[4];
  const uint32_t r12 = r->r[5];
  const uint32_t handler = r->r[6];

  if (frame_level==0 || frame_level>FRMLVL_IEEE) return err_translate(ERR_BAD_VALUE);
  if (frame_level!=FRMLVL_E2SPECIFIC && frame_type!=0) return err_translate(ERR_BAD_VALUE);

  if (flags & FILTER_RELEASE)
  {
    // Release
    switch (frame_level)
    {
      case FRMLVL_E2SINK:
        if (!dev->sink_filter) return err_translate(ERR_BAD_FILTER_RELEASE);
        if (dev->sink_filter->r12!=r12 ||
            dev->sink_filter->handler!=handler)
          {
            return err_translate(ERR_OTHERS_FILTER_RELEASE);
          }
        xfree(dev->sink_filter);
        dev->sink_filter = NULL;
        _swix(OS_ServiceCall, _INR(0,4),
              (&dev->dib), Service_DCIFrameTypeFree,
              r->r[2], r->r[3], r->r[4]);
        return NULL;

      case FRMLVL_E2MONITOR:
        if (!dev->monitor_filter) return err_translate(ERR_BAD_FILTER_RELEASE);
        if (dev->monitor_filter->r12!=r12 ||
            dev->monitor_filter->handler!=handler)
          {
            return err_translate(ERR_OTHERS_FILTER_RELEASE);
          }
        xfree(dev->monitor_filter);
        dev->monitor_filter = NULL;
        _swix(OS_ServiceCall, _INR(0,4),
              (&dev->dib), Service_DCIFrameTypeFree,
              r->r[2], r->r[3], r->r[4]);
        return NULL;

      case FRMLVL_IEEE:
        if (!dev->ieee_filter) return err_translate(ERR_BAD_FILTER_RELEASE);
        if (dev->ieee_filter->r12!=r12 ||
            dev->ieee_filter->handler!=handler)
          {
            return err_translate(ERR_OTHERS_FILTER_RELEASE);
          }
        xfree(dev->ieee_filter);
        dev->ieee_filter = NULL;
        _swix(OS_ServiceCall, _INR(0,4),
              (&dev->dib), Service_DCIFrameTypeFree,
              r->r[2], r->r[3], r->r[4]);
        return NULL;

      case FRMLVL_E2SPECIFIC:
        for (net_filter_t* f = dev->specific_filters; f; f=f->next)
        {
          if (frame_type==f->frame_type)
          {
            if (f->r12!=r12 || f->handler!=handler)
              return err_translate(ERR_OTHERS_FILTER_RELEASE);

            LINKEDLIST_REMOVE(dev->specific_filters,f);
            xfree(f);
            _swix(OS_ServiceCall, _INR(0,4),
                  (&dev->dib), Service_DCIFrameTypeFree,
                  r->r[2], r->r[3], r->r[4]);
            return NULL;
          }
        } return err_translate(ERR_BAD_FILTER_RELEASE);
    }
    return err_translate(ERR_BAD_VALUE);
  }
  else
  {
    // Claim
    net_filter_t** f = NULL;
    switch (frame_level)
    {
      case FRMLVL_E2SINK:
        if (dev->sink_filter || dev->monitor_filter)
          return err_translate(ERR_BAD_FILTER_CLAIM);
        f = &(dev->sink_filter);
        break;

      case FRMLVL_E2MONITOR:
        if (dev->sink_filter || dev->monitor_filter || dev->specific_filters)
          return err_translate(ERR_BAD_FILTER_CLAIM);
        f = &(dev->monitor_filter);
        break;

      case FRMLVL_IEEE:
        if (dev->ieee_filter) return err_translate(ERR_BAD_FILTER_CLAIM);
        f = &(dev->ieee_filter);
        break;

      case FRMLVL_E2SPECIFIC:
        for (net_filter_t* f = dev->specific_filters; f; f=f->next)
        {
          if (frame_type==f->frame_type) return err_translate(ERR_BAD_FILTER_CLAIM);
        }
        f = &(dev->specific_filters);
        break;
    }
    if (!f) return err_translate(ERR_BAD_VALUE);

    net_filter_t* filter = xalloc(sizeof(net_filter_t));
    if (!filter) return err_translate(ERR_NO_MEMORY);

    filter->frame_type = frame_type;
    filter->addr_level = addr_level;
    filter->err_level = err_level;
    filter->r12 = r12;
    filter->handler = handler;
    filter->flags = flags;

    if (f==&(dev->specific_filters))
    {
      LINKEDLIST_INSERT(dev->specific_filters, filter);
    }
    else
    {
      filter->next = NULL;
      filter->prev = NULL;
      *f = filter;
    }
    return NULL;
  }
  return err_translate(ERR_BAD_OPERATION);
}

_kernel_oserror* net_filter(_kernel_swi_regs* r)
{
  // FIXME: Don't really want to disable IRQs for this long...
  int              irqs = ensure_irqs_off();
  _kernel_oserror* e = net_filter_impl(r);
  restore_irqs(irqs);
  return e;
}

//---------------------------------------------------------------------------
// Release all packets from a single protocol module
//---------------------------------------------------------------------------
static _kernel_oserror *net_protocol_dying_impl(_kernel_swi_regs* r)
{
  if (r->r[2]!=1) return NULL;
  const uint32_t r12 = r->r[0];
  for (net_device_t* dev=s_devices; dev; dev=dev->next)
  {
    if (dev->sink_filter && dev->sink_filter->r12==r12)
    {
      _swix(OS_ServiceCall, _INR(0,4),
            (&dev->dib), Service_DCIFrameTypeFree,
             FRMLVL_E2SINK,
             dev->sink_filter->addr_level,
             dev->sink_filter->err_level);

      xfree(dev->sink_filter);
      dev->sink_filter = NULL;
    }

    if (dev->monitor_filter && dev->monitor_filter->r12==r12)
    {
      _swix(OS_ServiceCall, _INR(0,4),
            (&dev->dib), Service_DCIFrameTypeFree,
             FRMLVL_E2MONITOR,
             dev->monitor_filter->addr_level,
             dev->monitor_filter->err_level);

      xfree(dev->monitor_filter);
      dev->monitor_filter = NULL;
    }

    if (dev->ieee_filter && dev->ieee_filter->r12==r12)
    {
      _swix(OS_ServiceCall, _INR(0,4),
            (&dev->dib), Service_DCIFrameTypeFree,
             FRMLVL_IEEE,
             dev->ieee_filter->addr_level,
             dev->ieee_filter->err_level);

      xfree(dev->ieee_filter);
      dev->ieee_filter = NULL;
    }

    net_filter_t* next = dev->specific_filters;
    while (next)
    {
      net_filter_t* f = next;
      next = next->next;
      if (f->r12==r12)
      {
        _swix(OS_ServiceCall, _INR(0,4),
              (&dev->dib), Service_DCIFrameTypeFree,
              f->frame_type | (FRMLVL_E2SPECIFIC<<16),
              f->addr_level,
              f->err_level);

        LINKEDLIST_REMOVE(dev->specific_filters, f);
        xfree(f);
      }
    }
  }
  return NULL;
}

_kernel_oserror *net_protocol_dying(_kernel_swi_regs* r)
{
  // FIXME: Don't really want to disable IRQs for this long...
  int              irqs = ensure_irqs_off();
  _kernel_oserror* e = net_protocol_dying_impl(r);
  restore_irqs(irqs);
  return e;
}

//---------------------------------------------------------------------------
// Statistics
//---------------------------------------------------------------------------
static uint8_t dci_interface_type(const net_status_t* status)
{
  switch (status->link)
  {
    case net_link_unknown:
      break;

    case net_link_10BaseT_Half:
    case net_link_10BaseT_Full:
      return ST_TYPE_10BASET;

    case net_link_100BaseTX_Half:
    case net_link_100BaseTX_Full:
      return ST_TYPE_100BASETX;

    case net_link_100BaseT4:
      return ST_TYPE_100BASET4;

    case net_link_1000BaseT_Half:
    case net_link_1000BaseT_Full:
      return ST_TYPE_1000BASET;
  }

  // Fallback to just picking one.
  switch(status->speed)
  {
    case net_speed_unknown: break;
    case net_speed_10Mb   : return ST_TYPE_10BASET;
    case net_speed_100Mb  : return ST_TYPE_100BASETX;
    case net_speed_1000Mb  : return ST_TYPE_1000BASET;
  }

  return ST_TYPE_100BASETX;
}

_kernel_oserror* net_stats(_kernel_swi_regs* r)
{
  net_device_t* dev = net_from_unit(r->r[1]);
  if (!dev) return err_translate(ERR_BAD_UNIT);

  struct stats* s = (void*)(r->r[2]);
  memset(s, 0, sizeof(struct stats));

  if ((r->r[0]) & 1)
  {
    // Return stats
    const net_status_t* status = &dev->status;
    s->st_interface_type = dci_interface_type(status);
    s->st_link_status = status->ok | (status->up<<1u);
    if (status->duplex==net_duplex_full)
    {
      s->st_link_status|=ST_STATUS_FULL_DUPLEX;
    }

    if      (status->promiscuous) s->st_link_status|=ST_STATUS_PROMISCUOUS;
    else if (status->multicast  ) s->st_link_status|=ST_STATUS_MULTICAST;
    else if (status->broadcast  ) s->st_link_status|=ST_STATUS_BROADCAST;

    s->st_link_polarity = status->polarity_incorrect ? ST_LINK_POLARITY_INCORRECT
                                                     : ST_LINK_POLARITY_CORRECT;
    s->st_tx_frames = dev->packet_tx_count;
    s->st_tx_bytes  = dev->packet_tx_bytes;
    s->st_tx_general_errors = dev->packet_tx_errors;
    s->st_rx_frames = dev->packet_rx_count;
    s->st_rx_bytes  = dev->packet_rx_bytes;
    s->st_rx_general_errors = dev->packet_rx_errors;
    s->st_unwanted_frames = dev->packet_unwanted;
    s->st_jabbers = status->jabbers;
  }
  else
  {
    // Return supported stats list.
    s->st_interface_type = 0xff;
    s->st_link_status = 0xff;
    s->st_link_polarity = 0xff;
    s->st_tx_frames = 0xffffffff;
    s->st_tx_bytes = 0xffffffff;
    s->st_tx_general_errors = 0xffffffff;
    s->st_rx_frames = 0xffffffff;
    s->st_rx_bytes = 0xffffffff;
    s->st_rx_general_errors = 0xffffffff;
    s->st_unwanted_frames = 0xffffffff;
  }
  return NULL;
}

//---------------------------------------------------------------------------
// Configure
//---------------------------------------------------------------------------
_kernel_oserror* net_configure(unsigned unit, const char* arg_string)
{
  net_device_t* dev = net_from_unit(unit);
  if (!dev) return err_translate(ERR_BAD_UNIT);

  const net_backend_t* backend = dev->backend;
  if (!backend->config) return err_translate(ERR_UNSUPPORTED);

  net_config_t cfg;
  bool doit = false;
  _kernel_oserror* e = config_parse_arguments(dev, arg_string, &cfg, &doit);
  if (!e && doit) e = backend->config(dev, &cfg);
  return e;
}

//---------------------------------------------------------------------------
// Info
//---------------------------------------------------------------------------
static void print_list(const char* name, ...)
{
  char fmt[16];

  va_list ap;
  va_start(ap, name);
  bool any = false;
  sprintf(fmt, "%%-%us : ", strlen(msg_translate("IfLen")));
  printf(fmt, msg_translate(name));
  while (true)
  {
    const char* name = va_arg(ap, const char*);
    if (!name) break;
    bool v = va_arg(ap, unsigned);
    if (v)
    {
      if (any) printf(", "); else any=true;
      printf("%s", msg_translate(name));
    }
  }
  va_end(ap);
  printf("%s\n", any ? "" : msg_translate("None"));
}

static void print_numeric(const char* fmt, const char* heading, unsigned long number)
{
  char text[16];

  sprintf(text, "%lu", number);
  printf(fmt, msg_translate(heading), text);
}

_kernel_oserror* net_info(unsigned unit_no, bool verbose)
{
  char fmt[16], text[100];

  if (unit_no<MODULE_MAX_UNITS && !s_units[unit_no]) return err_translate(ERR_BAD_UNIT);

  // Common information
  printf(msg_translate("AuthInf"), Module_Title, Module_VersionString, "James Peacock");
  putchar('\n');
  printf(msg_translate("DCI4Inf"), DCIVERSION / 100u, DCIVERSION % 100u,
                                   MODULE_DCI_NAME, MODULE_MAX_UNITS);
  printf("\n%s:\n", msg_translate("BackSup"));
  for (const backend_t* be=s_backends; be; be=be->next)
  {
    printf("  %-13s - %s\n",be->backend->name,
                            msg_translate(be->backend->description));
  }

  // Make a template for the left column headings
  sprintf(fmt, "%%-%us : %%s\n", strlen(msg_translate("IfLen")));

  for (size_t unit=0; unit!=MODULE_MAX_UNITS; ++unit)
  {
    if (unit_no<MODULE_MAX_UNITS && unit!=unit_no) continue;

    net_device_t* dev = s_units[unit];
    if (!dev) continue;

    if (dev->backend->status)
    {
      _kernel_oserror* e = dev->backend->status(dev);
      if (e) return e;
    }

    const net_status_t* status = &dev->status;

    // Heading line for this unit
    printf("\n%s%zu: %s, %s, %s\n\n",
           MODULE_DCI_NAME,
           unit,
           dev->backend->name,
           dev->location,
           !status->ok ? msg_translate("Bad")
                       : !status->up ? msg_translate("Down")
                                     : msg_translate("Up"));
    printf(fmt, msg_translate("IfDrv"), MODULE_DCI_NAME);
    print_numeric(fmt, "IfNum", unit);
    printf(fmt, msg_translate("IfLoc"), dev->location);
    sprintf(text, "%02X:%02X:%02X:%02X:%02X:%02X",
            status->mac[0], status->mac[1], status->mac[2],
            status->mac[3], status->mac[4], status->mac[5]);
    printf(fmt, msg_translate("IfEUI"), text);
    printf(fmt, msg_translate("IfBak"), dev->backend->name);
    
    if (status->up && status->ok)
    {
      // Speed and duplex
      sprintf(text, "Dit%u", dci_interface_type(status));
      strcpy(text, msg_translate(text));
      if (status->duplex!=net_duplex_unknown)
      {
        strcat(text, " ");
        strcat(text, msg_translate(status->duplex==net_duplex_half ? "DupH" : "DupF"));
      }
      printf(fmt, msg_translate("IfMed"), text);

      // Polarity
      if (status->autoneg==net_autoneg_none ||
          status->autoneg==net_autoneg_complete)
      {
        strcpy(text, msg_translate(status->polarity_incorrect ? "PolI" : "PolC"));
      }
      else
      {
        strcpy(text, msg_translate("PolU"));
      }
      printf(fmt, msg_translate("IfPol"), text);

      // Controller mode
      sprintf(text, "Mod%u%u%u", status->promiscuous ? 1 : 0,
                                 status->broadcast ? 1 : 0,
                                 status->multicast ? 1 : 0);
      strcpy(text, msg_translate(text));
      printf(fmt, msg_translate("CtMod"), text);

      // Statistics
      print_numeric(fmt, "Stat0", dev->packet_tx_count);
      print_numeric(fmt, "Stat1", dev->packet_rx_count);
      print_numeric(fmt, "Stat2", dev->packet_tx_bytes);
      print_numeric(fmt, "Stat3", dev->packet_rx_bytes);
      print_numeric(fmt, "Stat4", dev->packet_tx_errors);
      print_numeric(fmt, "Stat5", dev->packet_rx_errors);
      print_numeric(fmt, "Stat6", dev->packet_unwanted);
      print_numeric(fmt, "Stat7", dev->queue_tx_overflows);
    }

    if (verbose)
    {
      sprintf(text, "%04X_%04X", dev->vendor, dev->product);
      printf(fmt, msg_translate("VVend"), text);
      sprintf(text, "%02X_%02X_%02X_%02X_%02X_%02X",
              dev->usb_location[0], dev->usb_location[1], dev->usb_location[2],
              dev->usb_location[3], dev->usb_location[4], dev->usb_location[5]);
      printf(fmt, msg_translate("VUSBL"), text);

      const net_abilities_t* a = &dev->abilities;

      print_list("VDupe",
                 "DupH" , a->half_duplex,
                 "DupF" , a->full_duplex,
                 NULL);

      print_list("VSped",
                 "Sp10" , a->speed_10Mb,
                 "Sp100", a->speed_100Mb,
                 "Sp1000", a->speed_1000Mb,
                 NULL);

      print_list("VMode",
                 "Uni"  , 1u,
                 "BCast", 1u,
                 "Multi", a->multicast,
                 "Prom" , a->promiscuous,
                 "Loop" , a->loopback,
                 NULL);

      print_list("VOthr",
                 "ANeg" , a->autoneg,
                 "MutM" , a->mutable_mac,
                 "TxRxL", a->tx_rx_loopback,
                 "EJC"  , dev->backend->config!=NULL,
                 NULL);
    }

    // Active filters
    const net_filter_t* f;
    if (dev->specific_filters)
    {
      printf("\n%s:\n\n", msg_translate("CStd"));
      for (f = dev->specific_filters; f; f=f->next)
      {
        printf(msg_translate("Type"), f->frame_type, f->addr_level, f->err_level,
                                      f->handler, f->r12);
        putchar('\n');
      }
    }
    if (dev->ieee_filter)
    {
      printf("\n%s:\n\n", msg_translate("CIEEE"));
      f = dev->ieee_filter;
      printf(msg_translate("Type"), f->frame_type, f->addr_level, f->err_level,
                                    f->handler, f->r12);
      putchar('\n');
    }
    if (dev->monitor_filter)
    {
      printf("\n%s:\n\n", msg_translate("CMon"));
      f = dev->monitor_filter;
      printf(msg_translate("Type"), f->frame_type, f->addr_level, f->err_level,
                                    f->handler, f->r12);
      putchar('\n');
    }
    if (dev->sink_filter)
    {
      printf("\n%s:\n\n", msg_translate("CSink"));
      f = dev->sink_filter;
      printf(msg_translate("Type"), f->frame_type, f->addr_level, f->err_level,
                                    f->handler, f->r12);
      putchar('\n');
    }

    // Extra specific info
    if (DEBUG_QUEUE) printf("    TX queue usage     %-12zu\n",
                            dev->queue_tx_max_usage);

    if (dev->backend->info)
    {
      printf("\n%s:\n\n", msg_translate("BackInf"));
      dev->backend->info(dev,verbose);
    }
  }

  return NULL;
}


//---------------------------------------------------------------------------
// Someone is scanning for network interfaces.
//---------------------------------------------------------------------------

_kernel_oserror* net_enumerate_drivers(_kernel_swi_regs* r)
{
  for (const net_device_t* dev=s_devices; dev; dev=dev->next)
  {
    ChDib* dib = NULL;
    _kernel_oserror* e = _swix(OS_Module, _IN(0)|_IN(3)|_OUT(2),
                               ModHandReason_Claim, sizeof(ChDib), &dib);

    if (!e && dib)
    {
      dib->chd_next = (ChDib*)(r->r[0]);
      dib->chd_dib = (struct dib*)&dev->dib;
      r->r[0] = (uint32_t)dib;
    }
  }
  return NULL;
}

@


1.18
log
@Speed reporting and buffer sizing for SMSC75xx backend
Detail:
  net.c: added support for 1000Mb speed
  smsc75xx.c: reduced MAX_RX_FIFOSIZE to 16k (avoids problems with Kernel keyboard scanning);
              corrected determination of ethernet speed (read from SMC75XX_MAC_CR register)
  net.h: added net_speed_1000Mb (in net_speed_t) and speed_1000Mb (in struct net_abilities_t)
  Messages: added Sp1000 and Dit21 for supporting 1000Mb speed
Admin:
  Submission from Colin Granville.

Version 0.38. Tagged as 'EtherUSB-0_38'
@
text
@d1106 4
d1406 1
a1406 1
      dev->backend->info(dev);
@


1.17
log
@  Support ARMv8
Detail:
  This module previously used both SWP and SWPB instructions, which have
  been withdrawn in ARMv8. Now use SyncLib to provide the equivalent
  functionality, which will use LDREX/STREX or LDREXB/STREXB instead when
  appropriate.
Admin:
  Tested on Raspberry Pi 3.

Version 0.36. Tagged as 'EtherUSB-0_36'
@
text
@d1114 1
d1339 1
@


1.16
log
@Further throughput improvements
ax88772.c:
  Modified to work with changes made to net.c and usb.c.
  Increased buffer sizes, allow more than one packet receipt.
ax88172.c/mcs7830.c/pegasus.c:
  Modified to work with changes made to net.c and usb.c.
smsc95xx.c:
  Copyright header simplified by using pronoun form "the copyright holders" rather than repeating this list.
  Modified to work with changes made to net.c and usb.c.
  Reading of MAC address from EEPROM fixed.
products.c:
  Added SMSC9730 device id (uses smsc95xx backend).
net.c/net.h:
  tx_queue removed, all transmit buffering is now done in the USB code.
usb.c:
  Function usb_write() blocks until room is available, or times out.
  Use USBDriver header rather than defining local SWI numbers.
Messages:
  Renamed DescSMC token to DescSMC9.
  Removed redundant Stat7 statistic.

Submission from Colin Granville.
Tested on Pi B+ and OMAP3, not tested on OMAP4, but believed to markedly improve its performance over version 0.30.

Version 0.31. Tagged as 'EtherUSB-0_31'
@
text
@d43 1
d807 1
a807 5
  uint8_t guard = 1;
  __asm 
  {
    SWPB guard,guard,[&dev->tx_guard]
  }
d849 1
a849 4
  __asm 
  {
    SWPB guard,guard,[&dev->tx_guard]
  }
@


1.15
log
@Propagate ERR_TX_BLOCKED up the stack
Errors from net_attempt_transmit() are now passed back to the Internet module.
Fix from Colin Granville.

Version 0.28. Tagged as 'EtherUSB-0_28'
@
text
@a82 9
//---------------------------------------------------------------------------
// Get length of Tx queue
//---------------------------------------------------------------------------
static size_t net_tx_queue_length(const net_device_t* dev)
{
  size_t in = dev->tx_queue_in;
  size_t out = dev->tx_queue_out;
  return in>out ? in - out - 1 : TX_QUEUE_LENGTH - out + in - 1;
}
d171 1
a171 1
  if (net_tx_queue_length(dev)!=0) net_attempt_transmit(dev);
d270 25
d354 1
a354 3
  d->tx_queue_in = 1;
  d->tx_queue_out = 0;

a424 1
    if (!e) e = callback(&prod_writes, 150, d);
a755 3
_kernel_oserror* net_transmit(_kernel_swi_regs* r)
{
  _kernel_oserror* e = NULL;
a756 2
  net_device_t* dev = net_from_unit(r->r[1]);
  if (!dev) e = err_translate(ERR_BAD_UNIT);
d758 4
a761 1
  if (!e) e = net_attempt_transmit(dev);
d763 20
a782 2
  mbuf_t* next_mbuf_chain = (void*)(r->r[3]);
  while (next_mbuf_chain)
d784 2
a785 55
    mbuf_t* mbuf = next_mbuf_chain;
    next_mbuf_chain = next_mbuf_chain->list;

    if (!e)
    {
      size_t size = g_mbuf->count_bytes(g_mbuf, mbuf);
      if (size>TX_MAX_DATA_SIZE) e = err_translate(ERR_MESSAGE_TOO_BIG);

      if (!e)
      {
        int    irqs = ensure_irqs_off();
        size_t in = dev->tx_queue_in;
        size_t out = dev->tx_queue_out;
        if (in==out)
        {
          ++dev->queue_tx_overflows;
          e = err_translate(ERR_TX_BLOCKED);
        }
        else
        {
          dev->tx_queue_in = (in+1 == TX_QUEUE_LENGTH) ? 0u : in+1;

          if (DEBUG_QUEUE)
          {
            const size_t qlen = net_tx_queue_length(dev);
            if (qlen>dev->queue_tx_max_usage) dev->queue_tx_max_usage=qlen;
          }
        }
        restore_irqs(irqs);

        if (!e)
        {
          net_tx_t* item = &dev->tx_queue[in];

          item->size = size + sizeof(net_header_t);
          item->header.type = ((r->r[2] >> 8) & 0x00ff) |
                              ((r->r[2] << 8) & 0xff00) ;

          const uint8_t* src = ((r->r[0]) & TX_FAKESOURCE)
                             ? (void*)(r->r[5])
                             : (dev->status.mac);

          const uint8_t* dst = (void*)(r->r[4]);

          for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) item->header.src_addr[i] = src[i];
          for (size_t i=0; i!=ETHER_ADDR_LEN; ++i) item->header.dst_addr[i] = dst[i];

          g_mbuf->export(g_mbuf, mbuf, size, item->data);

          e = net_attempt_transmit(dev);
        }
      }
    }

    if (!((r->r[0]) & TX_PROTOSDATA)) g_mbuf->freem(g_mbuf, mbuf);
d787 1
a787 1

d791 1
a791 4
//---------------------------------------------------------------------------
// Attempts to send next queued packet by calling dev's backend.
//---------------------------------------------------------------------------
_kernel_oserror* net_attempt_transmit(net_device_t* dev)
d793 12
a804 2
  size_t out = dev->tx_queue_out;
  size_t in  = dev->tx_queue_in;
d807 2
a808 1
  __asm {
d811 5
a815 1
  if (guard!=0) return NULL;
d817 2
a818 2
  _kernel_oserror* e = NULL;
  while (true)
d820 28
a847 32
    if (++out==TX_QUEUE_LENGTH) out=0;
    if (out==in) break;

    const size_t size = dev->tx_queue[out].size;

    e = dev->backend->transmit(dev, &dev->tx_queue[out]);
    if (e && e->errnum==err_translate(ERR_TX_BLOCKED)->errnum)
    {
      e = NULL;
      break;
    }

#if DEBUG_PKTS
    const net_header_t* hdr = &dev->tx_queue[out].header;

    syslog("Transmit: type=&%04X size=%zu "
           "from %02x:%02x:%02x:%02x:%02x:%02x "
           "to %02x:%02x:%02x:%02x:%02x:%02x",
           ((hdr->type & 0xff) << 8) | ((hdr->type) >> 8),
           size,
           hdr->src_addr[0], hdr->src_addr[1], hdr->src_addr[2],
           hdr->src_addr[3], hdr->src_addr[4], hdr->src_addr[5],
           hdr->dst_addr[0], hdr->dst_addr[1], hdr->dst_addr[2],
           hdr->dst_addr[3], hdr->dst_addr[4], hdr->dst_addr[5]);

    if (DEBUG_DATA) syslog_data((void*)hdr, size);
#endif

    dev->tx_queue_out = out;

    if (!e)
    {
a849 5
    }
    else
    {
      ++dev->packet_tx_errors;
    }
d851 3
a853 2

  __asm {
d857 6
a862 2
  return e;
}
d1322 1
a1322 2
      print_numeric(fmt, "Stat7", net_tx_queue_length(dev));
      print_numeric(fmt, "Stat8", dev->queue_tx_overflows);
@


1.14
log
@Define ETHER_ADDR_LEN
There's an element of duplication between the definitions of net.h and those in TCPIPLibs:net/ethernet.h which would be better to resolve, but for now just mirror its definition locally.
Not tagged.
@
text
@d750 1
a750 1
  net_attempt_transmit(dev);
d804 1
a804 1
          net_attempt_transmit(dev);
@


1.13
log
@Internationalised
AutoSense script updated to be able to parse both the hardwired english output (0.08-0.25 inclusive) and internationalised text (0.26+).
Tested RAM loaded on a Raspberry Pi.

Version 0.26. Tagged as 'EtherUSB-0_26'
@
text
@d95 2
a96 2
// 'mac' pointer must point to a 6 byte buffer. The MAC address is
// generated from the machine's unique ID, or failing that a hard coded one.
d158 3
a160 1
    if(drivers->chd_dib && drivers->chd_dib->dib_address && (drivers->chd_dib->dib_address != mac) && !memcmp(drivers->chd_dib->dib_address,mac2,6))
d168 1
a168 1
    memcpy(mac,mac2,6);
d672 2
a673 2
  for (size_t i=0; i!=6; ++i) rx.rx_src_addr[i] = hdr->src_addr[i];
  for (size_t i=0; i!=6; ++i) rx.rx_dst_addr[i] = hdr->dst_addr[i];
d799 2
a800 2
          for (size_t i=0; i!=6; ++i) item->header.src_addr[i] = src[i];
          for (size_t i=0; i!=6; ++i) item->header.dst_addr[i] = dst[i];
@


1.12
log
@Fix to incorrect polarity report in DCI stats
The polarity information was being stuffed into the wrong stats byte.
Fixes problem reported
  http://www.riscosopen.org/forum/forums/4/topics/2121

Version 0.25. Tagged as 'EtherUSB-0_25'
@
text
@a37 1
#include "sys/dcistructs.h"
d39 1
d216 1
a216 1
  if ((e && (e->errnum==292)) || size==0)
d243 1
a243 1
  if (DEBUG) syslog("%s: removed",dev->name);
d252 1
a252 1
                    MODULE_DCI_VERSION);
d327 1
a327 1
           "USB bus %u, device %u, Devices:$.%s",
d428 1
a428 1
        MODULE_DCI_VERSION);
d456 12
a467 1
  if (DEBUG_SCAN) syslog("Checking '%s' %02x:%02x:%02x [%s speed]",
d472 2
a473 1
                         usb_speed_string(dev->speed));
d559 1
a559 1
  if (DEBUG) syslog("Adding backend: %s",backend->name);
a832 1
    const net_header_t* hdr = &dev->tx_queue[out].header;
d842 2
a843 10
    if (DEBUG_PKTS)
      syslog("Transmit: type=&%04X size=%zu "
             "from %02x:%02x:%02x:%02x:%02x:%02x "
             "to %02x:%02x:%02x:%02x:%02x:%02x",
             ((hdr->type & 0xff) << 8) | ((hdr->type) >> 8),
             size,
             hdr->src_addr[0], hdr->src_addr[1], hdr->src_addr[2],
             hdr->src_addr[3], hdr->src_addr[4], hdr->src_addr[5],
             hdr->dst_addr[0], hdr->dst_addr[1], hdr->dst_addr[2],
             hdr->dst_addr[3], hdr->dst_addr[4], hdr->dst_addr[5]);
d845 12
a856 1
    if (DEBUG_PKTS && DEBUG_DATA) syslog_data((void*)hdr, size);
d1213 2
d1218 2
a1219 1
  printf("    %-10s",name);
d1228 1
a1228 1
      printf("%s",name);
d1232 1
a1232 14
  printf("%s\n", any ? "" : "none");
}

const char* net_link_string(net_link_t link)
{
  switch (link)
  {
    case net_link_10BaseT_Half  : return "10BaseT (Half)";
    case net_link_10BaseT_Full  : return "10BaseT (Full)";
    case net_link_100BaseTX_Half: return "100BaseTX (Half)";
    case net_link_100BaseTX_Full: return "100BaseTX (Full)";
    case net_link_100BaseT4     : return "100BaseT4";
  }
  return "unknown";
d1235 1
a1235 1
const char* net_speed_string(net_speed_t speed)
d1237 1
a1237 7
  switch(speed)
  {
    case net_speed_10Mb : return "10Mb" ;
    case net_speed_100Mb: return "100Mb";
  }
  return "speed unknown";
}
d1239 2
a1240 8
const char* net_duplex_string(net_duplex_t duplex)
{
  switch(duplex)
  {
    case net_duplex_half: return "half duplex";
    case net_duplex_full: return "full duplex";
  }
  return "duplex unknown";
d1243 1
a1243 1
static const char* net_autoneg_string(net_autoneg_t autoneg)
d1245 1
a1245 10
  switch(autoneg)
  {
    case net_autoneg_none       : return "manual";
    case net_autoneg_started    : return "auto [in progress]";
    case net_autoneg_reconfigure: return "auto [configuring]";
    case net_autoneg_complete   : return "auto";
    case net_autoneg_failed     : return "auto [failed]";
  }
  return "auto [unknown]";
}
a1246 2
_kernel_oserror* net_info(unsigned unit_no, bool verbose)
{
d1249 6
a1254 8
  printf(Module_Title " driver for USB network adapters, version "
         Module_VersionString " (" Module_Date ") James Peacock\n"
         "DCI version: %u.%02u, prefix: " MODULE_DCI_NAME "\n",
         MODULE_DCI_VERSION / 100u,
         MODULE_DCI_VERSION & 100u);

  printf("Maximum units: %u\n\nSupported backends:\n",
         MODULE_MAX_UNITS);
d1257 2
a1258 1
    printf("  %-13s - %s\n",be->backend->name,be->backend->description);
d1261 3
d1279 3
a1281 5
    printf("\nUnit %zu (%s):\n"
           "  Backend:          %s\n"
           "  Ethernet address: %02X:%02X:%02X:%02X:%02X:%02X\n"
           "  Link type:        %s\n"
           "  Link status:      ",
d1283 1
d1285 23
a1307 10
           dev->backend->name,
           status->mac[0], status->mac[1], status->mac[2],
           status->mac[3], status->mac[4], status->mac[5],
           net_link_string(status->link));

    if      (!status->ok) printf("bad\n");
    else if (!status->up) printf("down\n");
    else
    {
      printf("up, %s", net_autoneg_string(status->autoneg));
d1309 1
d1313 1
a1313 10
        printf(", %s, %s, polarity %s",
               net_speed_string(status->speed),
               net_duplex_string(status->duplex),
               status->polarity_incorrect ? "incorrect" : "correct");
      }

      printf("\n  Controller mode:  ");
      if (status->promiscuous)
      {
        printf("promiscuous\n");
d1317 1
a1317 3
        printf("unicast%s%s\n",
                status->broadcast ? ", broadcast" : "",
                status->multicast ? ", multicast" : "");
d1319 19
d1342 6
a1347 6
      printf("\n  Vendor+Product:   %04X_%04X\n"
               "  USB location:     %02X_%02X_%02X_%02X_%02X_%02X\n",
             dev->vendor,
             dev->product,
             dev->usb_location[0], dev->usb_location[1], dev->usb_location[2],
             dev->usb_location[3], dev->usb_location[4], dev->usb_location[5]);
a1349 1
      printf("\n  Advertised capabilities:\n");
d1351 3
a1353 3
      print_list("Duplex:",
                 "half", a->half_duplex,
                 "full", a->full_duplex,
d1356 3
a1358 3
      print_list("Speed:",
                 "10Mb" , a->speed_10Mb,
                 "100Mb", a->speed_100Mb,
d1361 6
a1366 6
      print_list("Modes:",
                 "unicast"    , 1u,
                 "broadcast"  , 1u,
                 "multicast"  , a->multicast,
                 "promiscuous", a->promiscuous,
                 "loopback"   , a->loopback,
d1369 5
a1373 5
      print_list("Other:",
                 "auto negotiate", a->autoneg,
                 "mutable MAC"   , a->mutable_mac,
                 "Tx-Rx loopback", a->tx_rx_loopback,
                 "*EJConfig"     , dev->backend->config!=NULL,
d1377 12
a1388 2
    printf("\n  Frame types claimed:\n");

d1390 7
a1396 3
      printf("    IEEE 802.3                 handler=(%08X,%08X)\n",
             dev->ieee_filter->handler, dev->ieee_filter->r12);

d1398 7
a1404 3
      printf("    Ethernet monitor           handler=(%08X,%08X)\n",
             dev->monitor_filter->handler, dev->monitor_filter->r12);

a1405 4
      printf("    Ethernet sink              handler=(%08X,%08X)\n",
             dev->sink_filter->handler, dev->sink_filter->r12);

    for (const net_filter_t* f = dev->specific_filters; f; f=f->next)
d1407 5
a1411 10
      const char* level = "";
      switch (f->addr_level)
      {
        case ADDRLVL_SPECIFIC:    level = "(specific)"   ; break;
        case ADDRLVL_NORMAL:      level = "(normal)"     ; break;
        case ADDRLVL_MULTICAST:   level = "(multicast)"  ; break;
        case ADDRLVL_PROMISCUOUS: level = "(promiscuous)"; break;
      }
      printf("    Ethernet %04X %-12s handler=(%08X,%08X)\n",
             f->frame_type, level, f->handler, f->r12);
d1414 1
a1414 21
    if (!( dev->ieee_filter      ||
           dev->monitor_filter   ||
           dev->sink_filter      ||
           dev->specific_filters )) printf("    (none)\n");

    printf("\n  Statistics summary:\n");
    printf("    TX frames          %-12zu  RX frames   %-12zu\n"
           "    TX bytes           %-12zu  RX bytes    %-12zu\n"
           "    TX errors          %-12zu  RX errors   %-12zu\n"
           "    TX queue length    %-12zu  RX unwanted %-12zu\n"
           "    TX queue overflows %-12zu\n",
           dev->packet_tx_count,
           dev->packet_rx_count,
           dev->packet_tx_bytes,
           dev->packet_rx_bytes,
           dev->packet_tx_errors,
           dev->packet_rx_errors,
           net_tx_queue_length(dev),
           dev->packet_unwanted,
           dev->queue_tx_overflows);

d1420 1
a1420 1
      printf("\n  Backend information:\n");
@


1.11
log
@Add more ways of specifying device configuration. Adjust unit number allocation & SMSC MAC handling.
Detail:
  c/smsc95xx - Adjust MAC handling some more:
    - Unit number check removed from EtherUSB$MAC_Configured code in fill_arbitraryMAC(), to increase compatibility with previous version
    - EtherUSB$MAC_Configured check is now performed before the devices currently-programmed MAC is checked; this should ensure it always takes priority over the other methods (especially when reiniting EtherUSB after setting the variable)
    - OS_ReadSysInfo 4 & machine ID hash checks remain in their previous place, after the currently-programmed MAC check
  c/config, h/config:
    - Add support for using EtherUSB$VP_* and EtherUSB$Loc_* system variables to configure devices, by specifying USB vendor/product IDs or USB device tree locations, respectively.
    - Allow config_reserved_units() to select a devices unit number by looking for VP_ or Loc_ system variables.
  c/net, h/net:
    - Add USB device vendor & product ID, and device tree location, to net_device_t struct.
    - Display vendor/product ID & device tree location in verbose ejinfo output
    - Adjust unit number selection: Attempt to select a unit number before calling backend->start, so that the unit number can be used in MAC allocation if required (i.e. by net_default_mac()).
    - Change net_default_mac() to use OS_ReadSysInfo 5 instead of OS_ReadSysInfo 2; OS_ReadSysInfo 2 strips out the first and last byte of the ID, making the psuedo-unique MAC somewhat less unique.
  c/usb, h/usb - Add utility function for reading the location of a device within the USB device tree.
Admin:
  Tested on BB-xM, Raspberry Pi
  Overriding MAC via EtherUSB$MAC_Configured now works as expected (was previously failing due to unit number being MODULE_MAX_UNITS)
  Unit number reservation/selection & device configuration via all three variable types (MAC, VP, Loc) verified


Version 0.24. Tagged as 'EtherUSB-0_24'
@
text
@d1148 2
a1149 2
    if (!status->polarity_incorrect) s->st_link_status|=ST_LINK_POLARITY_CORRECT;

@


1.10
log
@Improve SMSC MAC selection
Detail:
  c/net, h/net - Make net_default_mac() non-static. Add net_machine_mac() function for looking up MAC by OS_ReadSysInfo 4.
  c/smsc95xx - Change MAC selection logic. Old order was OS_ReadSysInfo 4 -> EtherUSB$MAC_Configured -> 100% hardcoded default. New order is EtherUSB$MAC_Configured -> OS_ReadSysInfo 4 -> hashed machine ID + unit number -> hardcoded default (with unit number). This new logic means BB-xM's should now have unique MACs instead of all sharing the same MAC.
Admin:
  Tested on BB-xM, Raspberry Pi. Raspberry Pi retains the MAC that's specified by the firmware, while the BB-xM now uses the hashed machine ID instead of the hardcoded default.
  Based on changes supplied by Willi Theiss.


Version 0.23. Tagged as 'EtherUSB-0_23'
@
text
@d111 2
a112 2
  _kernel_oserror* e = _swix(OS_ReadSysInfo, _IN(0)|_OUTR(3,4),
                             2, &id_lo, &id_hi);
d296 2
d301 10
d349 21
a405 16
    if (!e && d->dib.dib_unit>=MODULE_MAX_UNITS)
    {
      bool reserved[MODULE_MAX_UNITS-1];
      e = config_reserved_units(reserved);
      if (!e)
      {
        for (unsigned i=0; i!=MODULE_MAX_UNITS; ++i)
        {
          if (!reserved[i] && !s_units[i])
          {
            d->dib.dib_unit = i;
            break;
          }
        }
      }
    }
d1338 7
@


1.9
log
@Tidy up some debugging code
Detail:
  c/net, c/usb - Tidy up some debugging code so it's only active in debug builds.
Admin:
  Changes supplied by Willi Theiss, to fix hangs on restart (on OMAP4) when the SysLog module is active.
  Tested locally on BB-xM


Version 0.22. Tagged as 'EtherUSB-0_22'
@
text
@d105 1
a105 1
static void net_default_mac(unsigned unit, uint8_t* mac)
d135 37
@


1.8
log
@Fix null pointer dereference
Detail:
  c/net - In set_inet_variables(), no check was being made for whether OS_ReadVarVal returned an error or not, resulting in a null pointer dereference if <Inet$EtherType> does exist
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.19. Tagged as 'EtherUSB-0_19'
@
text
@d4 1
a4 1
// 
d6 1
a6 1
// modification, are permitted provided that the following conditions are met: 
d15 1
a15 1
// 
d206 1
a206 1
  syslog("%s: removed",dev->name);
d457 1
a457 1
  
@


1.7
log
@Dib slot number set per DCI 4.06.
Changed *EJINFO output to refer to bus/device to match *USBDEVICES nomenclature.

Version 0.18. Tagged as 'EtherUSB-0_18'
@
text
@d179 1
a179 1
  if (e->errnum==292 || size==0)
@


1.6
log
@Save 4.5kB by making the table of errors with objasm (so they're not all padded to 252 bytes by the compiler to fit into _kernel_oserror structs).
The 'moduleerr.s' source should be made redundant by internationalising the module.

Version 0.17. Tagged as 'EtherUSB-0_17'
@
text
@d214 1
a214 1
                    1,
d271 2
a272 2
  d->dib.dib_slot.sl_slotid = MODULE_DCI_USB_SLOT;
  d->dib.dib_slot.sl_minor = 0;
d278 1
a278 1
           "USB bus %u, address %u, Devices:$.%s",
d373 1
a373 1
        0,
@


1.5
log
@Added autosense, and autosense install rule to makefile.
Now uses AsmUtils for irqs_on/irqs_off
Squash a few unused variable warnings, not in the backends though as porting updates would be more complex for those that come from (for example) NetBSD.
Changed to use structure definitions from sys/dcistructs.h (mostly an exercise in prefixing member names).

Version 0.16. Tagged as 'EtherUSB-0_16'
@
text
@d252 1
a252 1
  if (!d) return &err_no_memory;
d353 2
a354 2
    if (!e && d->dib.dib_unit>=MODULE_MAX_UNITS) e = &err_too_many_units;
    if (!e && s_units[d->dib.dib_unit]) e = &err_unit_in_use;
d445 1
a445 1
      if (e && e->errnum!=err_unsupported.errnum) return e;
d496 1
a496 1
  if (!b) return &err_no_memory;
d614 1
a614 1
  if (!mbuf1) return &err_no_memory;
d622 1
a622 1
    return &err_no_memory;
d654 1
a654 1
  if (!dev) return &err_bad_unit;
d665 1
a665 1
  if (!dev) return &err_bad_unit;
d680 1
a680 1
  if (!dev) e = &err_bad_unit;
d693 1
a693 1
      if (size>TX_MAX_DATA_SIZE) e = &err_message_too_big;
d703 1
a703 1
          e = &err_tx_blocked;
d771 1
a771 1
    if (e && e->errnum==err_tx_blocked.errnum)
d817 1
a817 1
  if (!dev) return &err_bad_unit;
d827 2
a828 2
  if (frame_level==0 || frame_level>FRMLVL_IEEE) return &err_bad_value;
  if (frame_level!=FRMLVL_E2SPECIFIC && frame_type!=0) return &err_bad_value;
d836 1
a836 1
        if (!dev->sink_filter) return &err_bad_filter_release;
d840 1
a840 1
            return &err_others_filter_release;
d850 1
a850 1
        if (!dev->monitor_filter) return &err_bad_filter_release;
d854 1
a854 1
            return &err_others_filter_release;
d864 1
a864 1
        if (!dev->ieee_filter) return &err_bad_filter_release;
d868 1
a868 1
            return &err_others_filter_release;
d883 1
a883 1
              return &err_others_filter_release;
d892 1
a892 1
        } return &err_bad_filter_release;
d894 1
a894 1
    return &err_bad_value;
d904 1
a904 1
          return &err_bad_filter_claim;
d910 1
a910 1
          return &err_bad_filter_claim;
d915 1
a915 1
        if (dev->ieee_filter) return &err_bad_filter_claim;
d922 1
a922 1
          if (frame_type==f->frame_type) return &err_bad_filter_claim;
d927 1
a927 1
    if (!f) return &err_bad_value;
d930 1
a930 1
    if (!filter) return &err_no_memory;
d951 1
a951 1
  return &err_bad_operation;
d1074 1
a1074 1
  if (!dev) return &err_bad_unit;
d1128 1
a1128 1
  if (!dev) return &err_bad_unit;
d1131 1
a1131 1
  if (!backend->config) return &err_unsupported;
d1212 1
a1212 1
  if (unit_no<MODULE_MAX_UNITS && !s_units[unit_no]) return &err_bad_unit;
@


1.4
log
@Uses common USB header files exported by the USB stack.
Use ModHand/Variables/RISCOS/OsByte headers.
Note, this has meant some header files needed reordering to prevent circular dependencies.

Version 0.15. Tagged as 'EtherUSB-0_15'
@
text
@d39 1
d195 3
d221 1
a221 1
  s_units[dev->dib.unit] = NULL;
d265 11
a275 11
  d->dib.swibase = EtherUSB_00;
  d->dib.name = MODULE_DCI_NAME;
  d->dib.unit = MODULE_MAX_UNITS;
  d->dib.address = d->status.mac;
  d->dib.module = Module_Title;
  d->dib.location = d->location;
  d->dib.slot.id = DCI_SLOT_USB;
  d->dib.slot.minor = 0;
  d->dib.slot.pcmia = 0;
  d->dib.slot.mbz = 0;
  d->dib.inquire = 0;
d315 2
a316 2
         d->dib.address[0], d->dib.address[1], d->dib.address[2],
         d->dib.address[3], d->dib.address[4], d->dib.address[5]);
d319 3
a321 3
    uint32_t inquire = ( DCI_INQUIRE_STD_STATS      |
                         DCI_INQUIRE_HW_ADDRESS     |
                         DCI_INQUIRE_RX_BAD_PACKETS );
d324 4
a327 4
    if (a->multicast        ) inquire |= DCI_INQUIRE_MULTICAST;
    if (a->promiscuous      ) inquire |= DCI_INQUIRE_PROMISCUOUS;
    if (a->tx_rx_loopback   ) inquire |= DCI_INQUIRE_LOOPBACK;
    if (a->mutable_mac      ) inquire |= DCI_INQUIRE_HW_ADDRESS_MUTABLE;
d329 1
a329 1
    d->dib.inquire = inquire;
d336 1
a336 1
    if (!e && d->dib.unit>=MODULE_MAX_UNITS)
d346 1
a346 1
            d->dib.unit = i;
d353 2
a354 2
    if (!e && d->dib.unit>=MODULE_MAX_UNITS) e = &err_too_many_units;
    if (!e && s_units[d->dib.unit]) e = &err_unit_in_use;
d367 2
a368 2
  d->dib.slot.minor = d->dib.unit;
  s_units[d->dib.unit] = d;
d377 1
a377 1
         dev->devname, d->dib.name, d->dib.unit);
d456 2
d601 11
a611 11
  dci_rx_header_t rx;
  rx.tag = 0;
  rx.ptr = NULL;
  for (size_t i=0; i!=6; ++i) rx.src_addr[i] = hdr->src_addr[i];
  for (size_t i=0; i!=6; ++i) rx.dst_addr[i] = hdr->dst_addr[i];
  rx.src_pad[0] = 0;
  rx.src_pad[1] = 0;
  rx.dst_pad[0] = 0;
  rx.dst_pad[1] = 0;
  rx.frame_type = type;
  rx.error_level = error;
d613 1
a613 1
  mbuf_t* mbuf1 = g_mbuf->alloc_u(g_mbuf, sizeof(dci_rx_header_t), &rx);
d632 1
a632 1
  if (handler->flags & DCI_FILTER_SAFE)
d655 1
a655 1
  r->r[2] = dev->dib.inquire;
d697 1
a697 1
        irq_state_t irqs = disable_irqs();
d725 1
a725 1
          const uint8_t* src = ((r->r[0]) & DCI_TX_HW_ADDRESS)
d741 1
a741 1
    if (!((r->r[0]) & DCI_TX_DONT_OWN)) g_mbuf->freem(g_mbuf, mbuf);
d827 2
a828 2
  if (frame_level==0 || frame_level>DCI_FL_IEEE) return &err_bad_value;
  if (frame_level!=DCI_FL_E2SPECIFIC && frame_type!=0) return &err_bad_value;
d830 1
a830 1
  if (flags & DCI_FILTER_RELEASE)
d835 1
a835 1
      case DCI_FL_E2SINK:
d849 1
a849 1
      case DCI_FL_E2MONITOR:
d863 1
a863 1
      case DCI_FL_IEEE:
d877 1
a877 1
      case DCI_FL_E2SPECIFIC:
d902 1
a902 1
      case DCI_FL_E2SINK:
d908 1
a908 1
      case DCI_FL_E2MONITOR:
d914 1
a914 1
      case DCI_FL_IEEE:
d919 1
a919 1
      case DCI_FL_E2SPECIFIC:
d957 1
a957 1
  irq_state_t irqs = disable_irqs();
d976 1
a976 1
             DCI_FL_E2SINK,
d988 1
a988 1
             DCI_FL_E2MONITOR,
d1000 1
a1000 1
             DCI_FL_IEEE,
d1017 1
a1017 1
              f->frame_type | (DCI_FL_E2SPECIFIC<<16),
d1032 1
a1032 1
  irq_state_t irqs = disable_irqs();
d1050 1
a1050 1
      return DCI_ST_10BASE_T;
d1054 1
a1054 1
      return DCI_ST_100BASE_TX;
d1057 1
a1057 1
      return DCI_ST_100BASE_T4;
d1064 2
a1065 2
    case net_speed_10Mb   : return DCI_ST_10BASE_T;
    case net_speed_100Mb  : return DCI_ST_100BASE_TX;
d1068 1
a1068 1
  return DCI_ST_100BASE_TX;
d1076 2
a1077 2
  dci_stats_t* s = (void*)(r->r[2]);
  memset(s, 0, sizeof(dci_stats_t));
d1083 2
a1084 2
    s->interface_type = dci_interface_type(status);
    s->link_status = status->ok | (status->up<<1u);
d1087 1
a1087 1
      s->link_status|=DCI_ST_INTERFACE_FULL_DUPLEX;
d1090 14
a1103 14
    if      (status->promiscuous) s->link_status|=DCI_ST_INTERFACE_ALL;
    else if (status->multicast  ) s->link_status|=DCI_ST_INTERFACE_MULTICAST;
    else if (status->broadcast  ) s->link_status|=DCI_ST_INTERFACE_BROADCAST;

    if (!status->polarity_incorrect) s->link_status|=DCI_ST_POLARITY_CORRECT;

    s->tx_frames = dev->packet_tx_count;
    s->tx_bytes  = dev->packet_tx_bytes;
    s->tx_general_errors = dev->packet_tx_errors;
    s->rx_frames = dev->packet_rx_count;
    s->rx_bytes  = dev->packet_rx_bytes;
    s->rx_general_errors = dev->packet_rx_errors;
    s->unwanted_frames = dev->packet_unwanted;
    s->jabbers = status->jabbers;
d1108 10
a1117 10
    s->interface_type = 0xff;
    s->link_status = 0xff;
    s->link_polarity = 0xff;
    s->tx_frames = 0xffffffff;
    s->tx_bytes = 0xffffffff;
    s->tx_general_errors = 0xffffffff;
    s->rx_frames = 0xffffffff;
    s->rx_bytes = 0xffffffff;
    s->rx_general_errors = 0xffffffff;
    s->unwanted_frames = 0xffffffff;
d1197 1
a1197 1
const char* net_autoneg_string(net_autoneg_t autoneg)
d1332 4
a1335 4
        case DCI_AL_SPECIFIC:    level = "(specific)"   ; break;
        case DCI_AL_NORMAL:      level = "(normal)"     ; break;
        case DCI_AL_MULTICAST:   level = "(multicast)"  ; break;
        case DCI_AL_PROMISCUOUS: level = "(promiscuous)"; break;
d1384 1
a1384 1
    dci_chain_dib_t* dib = NULL;
d1386 1
a1386 1
                               ModHandReason_Claim, sizeof(dci_chain_dib_t), &dib);
d1390 2
a1391 2
      dib->next = (dci_chain_dib_t*)(r->r[0]);
      dib->dib = &(dev->dib);
@


1.3
log
@Brought under srccommit control for update of version numbers.
Makefile recreated from fragments
CMHG file renamed to avoid needing special rule to tell where it is.

Version 0.14. Tagged as 'EtherUSB-0_14'
@
text
@d29 14
a43 1
#include "net.h"
d45 1
d47 1
a52 10
#include "swis.h"
#include "kernel.h"
#include "sys/dcistructs.h"

#include <stddef.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
d187 1
a187 1
                  "Inet$EtherType", value, strlen(value), 0, 0);
d239 4
a242 4
static _kernel_oserror* device_create(const usb_service_t* dev,
                                      const net_backend_t* backend,
                                      const char*          options,
                                      void*                private)
d246 1
a246 1
  assert(sizeof(d->name)==sizeof(dev->name));
d250 1
a250 1
  memcpy(d->name, dev->name, sizeof(dev->name));
d256 1
a256 1
  d->address = dev->address;
d310 1
a310 1
         dev->name, backend->name,
d373 1
a373 1
         dev->name, d->dib.name, d->dib.unit);
d380 1
a380 1
    if (e) syslog("%s: config: %s", dev->name, e->errmess);
d396 1
a396 1
_kernel_oserror* net_check_device(const usb_service_t* dev, void* handle)
d399 4
a402 4
                         dev->name,
                         dev->device.bDeviceClass,
                         dev->device.bDeviceSubClass,
                         dev->device.bDeviceProtocol,
d412 1
a412 1
              dev->name, dev->device.idVendor, dev->device.idProduct);
d436 1
a436 1
                dev->name, e->errmess);
d1380 1
a1380 1
                               6, sizeof(dci_chain_dib_t), &dib);
@


1.2
log
@Explicit BSD licence heading blocks added to those source files that did not have them.
No code changes, not tagged.
@
text
@d29 1
a32 2
#include "module.h"
#include "version.h"
d36 1
a36 1
#include "autogen/header"
d40 1
d239 2
a242 1
  net_device_t* d = xalloc(sizeof(net_device_t));
d256 1
a256 1
  d->dib.swibase = MODULE_SWI_BASE;
d260 1
a260 1
  d->dib.module = MODULE_NAME;
d1203 2
a1204 2
  printf(MODULE_NAME " driver for USB network adapters, version "
         Module_VersionString " (" Module_Date ") " MODULE_EXTRA "\n"
@


1.1
log
@Import of sources to EtherUSB.
Special thanks to James Peacock for allowing ROOL to host these sources.
This import represents version 0.13 by James and the backend contributors, the only change being that the makefile wipes the directories it creates on cleaning so there's no need to import those to CVS.
Tagged as jpeacock-0_13.
@
text
@d1 28
a28 3
/* EtherUSB
 * (C) James Peacock, 2006.
 */
@


head	1.14;
access;
symbols
	EtherUSB-0_41:1.14
	EtherUSB-0_40:1.13
	EtherUSB-0_39:1.13
	EtherUSB-0_38:1.13
	EtherUSB-0_37:1.13
	EtherUSB-0_36:1.12
	EtherUSB-0_35:1.11
	EtherUSB-0_34:1.11
	EtherUSB-0_33:1.10
	EtherUSB-0_32:1.10
	EtherUSB-0_31:1.9
	EtherUSB-0_30:1.9
	EtherUSB-0_29:1.9
	EtherUSB-0_28:1.9
	EtherUSB-0_27:1.9
	EtherUSB-0_26:1.9
	EtherUSB-0_25:1.8
	EtherUSB-0_24:1.8
	EtherUSB-0_23:1.8
	EtherUSB-0_22:1.8
	EtherUSB-0_21:1.8
	EtherUSB-0_20:1.7
	EtherUSB-0_19:1.7
	EtherUSB-0_18:1.7
	EtherUSB-0_17:1.6
	EtherUSB-0_16:1.5
	EtherUSB-0_15:1.4
	EtherUSB-0_14:1.3
	jpeacock-0_13:1.1;
locks; strict;
comment	@# @;


1.14
date	2018.03.21.23.54.42;	author jlee;	state Exp;
branches;
next	1.13;
commitid	FAdt578EOH7cRnvA;

1.13
date	2016.04.14.20.15.42;	author jlee;	state Exp;
branches;
next	1.12;
commitid	LjJsPfWNhED4lD2z;

1.12
date	2016.02.29.10.37.06;	author bavison;	state Exp;
branches;
next	1.11;
commitid	oAHZMQOdmovfANWy;

1.11
date	2015.12.12.09.36.54;	author rool;	state Exp;
branches;
next	1.10;
commitid	Mp6dAex7toR1NDMy;

1.10
date	2015.10.17.08.48.08;	author rool;	state Exp;
branches;
next	1.9;
commitid	rRqBp5gfBn0SjrFy;

1.9
date	2013.10.13.13.54.41;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	cLeOtNKk3nePB89x;

1.8
date	2012.09.09.15.37.14;	author jlee;	state Exp;
branches;
next	1.7;
commitid	PX4F0vbh4EFd0Sjw;

1.7
date	2012.05.19.08.46.48;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	jnaodXkH29YBmj5w;

1.6
date	2012.05.19.08.44.28;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	6JuVMhjS8DSNlj5w;

1.5
date	2012.05.19.08.42.20;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	1BHJUY7zoQz3lj5w;

1.4
date	2012.05.19.08.39.06;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	sBdKYcdaXJwXjj5w;

1.3
date	2012.05.19.08.30.24;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	R1EOINZ5A36Ygj5w;

1.2
date	2012.05.19.08.22.12;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	SzPjH7uh6hKVdj5w;

1.1
date	2012.05.19.08.19.06;	author rsprowson;	state Exp;
branches;
next	;
commitid	q3rEKeu2RrS2cj5w;


desc
@@


1.14
log
@Add SMSC78xx support
Detail:
  c/smsc78xx, c/module, c/products, h/backends, Makefile - Add SMSC78xx driver, for the chip used in the Raspberry Pi 3B+
  c/config, c/mii, h/mii - Add support for gigabit MIIs & associated (auto) configuration
  c/net, h/net - Handle gigabit link types. Pass verbose flag through to backend info function.
  c/smsc95xx - Make configure_link const-correct
  Resources/UK/CmdHelp - Update *EJConfig syntaxt text to include 1000 option
  Resources/UK/Messages - Add 78xx backend name & device-specific info tokens
Admin:
  Tested on Raspberry Pi 3B & 3B+
  Manually configured gigabit links aren't supported yet
  Gigabit half-duplex isn't supported (78xx MAC limitation)
  For the 78xx, manually-configured full-duplex links appear to suffer terrible RX performance (as seen on 95xx). All supported auto modes appear to work correctly.


Version 0.41. Tagged as 'EtherUSB-0_41'
@
text
@//
// Copyright (c) 2006, James Peacock
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met: 
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of RISC OS Open Ltd nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "Global/Services.h"
#include "SyncLib/SyncLib.h"

#include "module.h"
#include "utils.h"
#include "USB/USBDevFS.h"
#include "usb.h"
#include "net.h"
#include "mbuf.h"
#include "products.h"
#include "backends.h"
#include "config.h"

// This is generated by CMHG
#include "EtherUSBHdr.h"

// Module state.
static enum { st_inactive, st_active, st_dead } s_module_state = st_inactive;
static int s_msg_block[4];
static _kernel_oserror s_msg_buffer;
void* g_module_pw = NULL;

//-------------------------------------------------------------------------
// Attempt to start driver
//-------------------------------------------------------------------------
static _kernel_oserror* start_driver(void)
{
  if (s_module_state==st_dead) return NULL;
  _kernel_oserror* e = mbuf_initialise(MODULE_MBUF_MIN_UBS,
                                       MODULE_MBUF_MAX_UBS,
                                       MODULE_MBUF_MIN_CONTIG);
  if (e)
  {
    syslog("Unable to start driver at the moment: %s",e->errmess);
  }
  else
  {
    s_module_state = st_active;
    syslog("Driver started");
    usb_scan_devices(&net_check_device, NULL);
  }
  return e;
}

static callback_delay_t start_callback(void* h)
{
  // Need to have our SWIs available to other modules.
  start_driver();

  UNUSED(h);
  
  return CALLBACK_REMOVE;
}

//-------------------------------------------------------------------------
// Module message code
//-------------------------------------------------------------------------

_kernel_oserror *err_translate(int which)
{
  struct {
    int errnum;
    char errmess[8];
  } token;

  if (which < ERR_MAX)
  {
      // One from this module
      token.errnum = MODULE_ERROR_BASE + which;
  }
  else
  {
      // Literal (shared) error number
      token.errnum = which;
  }
  sprintf(token.errmess, "E%02x", which);
  return _swix(MessageTrans_ErrorLookup, _INR(0,3),
            &token, s_msg_block, &s_msg_buffer, sizeof(s_msg_buffer));
}

const char *msg_translate(const char *token)
{
  if (_swix(MessageTrans_Lookup, _INR(0,7),
            s_msg_block, token,  &s_msg_buffer, sizeof(s_msg_buffer),
            0, 0, 0, 0) != NULL)
  {
    return "";
  }

  return (const char *)&s_msg_buffer;
}

//-------------------------------------------------------------------------
// Module initialisation code
//-------------------------------------------------------------------------

_kernel_oserror *module_init(const char *cmd_tail,
                             int         podule_base,
                             void       *pw)
{
  _kernel_oserror *e;

#ifndef ROM
  // Register the messages for RAM based modules
  e = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (e) return e;
#endif
  // Try open, report fail
  e = _swix(MessageTrans_OpenFile, _INR(0,2), s_msg_block, Module_MessagesFile, 0);
  if (e)
  {
#ifndef ROM
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
    return e;
  }

  if (podule_base==1) e = err_translate(ERR_REINSTANTIATE);

  syslog(" ");
  syslog(Module_Title " " Module_VersionString " starting");

  g_module_pw = pw;
  s_module_state = st_dead;

  // Module initialisation
  synclib_init();
  if (!e) e = callback_initialise(pw);
  if (!e) e = usb_initialise();

  // Register backends
  if (!e) e = cdc_register();
  if (!e) e = ax88172_register();
  if (!e) e = ax88772_register();
  if (!e) e = pegasus_register();
  if (!e) e = mcs7830_register();
  if (!e) e = smsc95xx_register();
  if (!e) e = smsc78xx_register();
  if (!e) e = smsc75xx_register();

  // Start interfaces on callback so our SWIs are available for protocol
  // modules to call when they notice Service_DCIDriverStatus.
  if (!e) e = callback(&start_callback, CALLBACK_ASAP, NULL);

  if (e)
  {
    syslog("Error during initialisation: '%s'", e->errmess);
    if (module_final(1,0,pw))
    {
      // Unsafe to return a error in this case.
      syslog("Unable to clean up after initialisation error");
      return NULL;
    }
    return e;
  }

  s_module_state = st_inactive;

  UNUSED(cmd_tail);
  UNUSED(pw);

  return NULL;
}

//-------------------------------------------------------------------------
// Module finalisation code
//-------------------------------------------------------------------------

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
  s_module_state = st_dead;
  _kernel_oserror* e = net_finalise();
  if (!e) e = usb_finalise();
  if (!e) e = callback_finalise();
  if (!e) e = mbuf_finalise();

  _swix(MessageTrans_CloseFile, _IN(0), s_msg_block);
#ifndef ROM
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif

  if (e)
  {
    syslog("Unexpected error during finalisation: '%s'", e->errmess);
    return e;
  }
  syslog(Module_Title " stopped");

  UNUSED(fatal);
  UNUSED(pw);
  UNUSED(podule);
  
  return NULL;
}


//-------------------------------------------------------------------------
// Module service call handler
//-------------------------------------------------------------------------

void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  switch (service_number)
  {
    case Service_USB:
      switch (r->r[0])
      {
        case Service_USB_Attach:
          if (s_module_state==st_active)
            net_check_device((const USBServiceCall*)(r->r[2]), NULL);
          break;
        // Service_USB_USBDriverStarting not required as devices are attached via Service_USB_Attach
      }
      break;

    case Service_DeviceDead:
      if (r->r[3]!=0 && s_module_state==st_active)
        net_dead_device((const char*)(r->r[3]));
      break;

    case Service_MbufManagerStatus:
      if (s_module_state==st_inactive &&
          r->r[0]==Service_MbufManagerStatus_Started) start_driver();

    case Service_EnumerateNetworkDrivers:
      if (s_module_state==st_active) net_enumerate_drivers(r);
      break;

    case Service_DCIProtocolStatus:
      if (r->r[2]==DCIPROTOCOL_DYING && s_module_state==st_active) net_protocol_dying(r);
      break;

    case Service_DeviceFSStarting:
      usb_scan_devices(&net_check_device, NULL);
      // Service_DeviceFSDying not required as devices are removed in Service_DeviceDead
      break;

    case Service_Reset:
      usb_service_reset();
      break;

#ifndef ROM
    case Service_ResourceFSStarting:
      (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
      break;
#endif
  }
  UNUSED(pw);
}

//---------------------------------------------------------------------------
// Module SWI dispatcher
//---------------------------------------------------------------------------

#define MODULE_SWI(name) (name - EtherUSB_00)

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  // All this lot need to be reentrant.
  switch(swi_offset)
  {
    case MODULE_SWI(EtherUSB_DCIVersion):
      r->r[1] = DCIVERSION;
      return NULL;

    case MODULE_SWI(EtherUSB_Inquire):
      return net_inquire(r);

    case MODULE_SWI(EtherUSB_GetNetworkMTU):
      return net_get_network_mtu(r);

    case MODULE_SWI(EtherUSB_SetNetworkMTU):
      return err_translate(ERR_BAD_OPERATION);

    case MODULE_SWI(EtherUSB_Transmit):
      return net_transmit(r);

    case MODULE_SWI(EtherUSB_Filter):
      return net_filter(r);

    case MODULE_SWI(EtherUSB_Stats):
      return net_stats(r);

    case MODULE_SWI(EtherUSB_MulticastRequest):
      return err_translate(ERR_BAD_OPERATION);
  }
  UNUSED(pw);
  
  return error_BAD_SWI;
}

//---------------------------------------------------------------------------
// *EJConfig
//---------------------------------------------------------------------------
static _kernel_oserror* ejconfig(const char* arg_string)
{
  unsigned unit;
  _kernel_oserror* e = config_parse_unit(&arg_string, &unit);
  if (!e) e = net_configure(unit, arg_string);
  return e;
}

//---------------------------------------------------------------------------
// *EJInfo
//---------------------------------------------------------------------------
static _kernel_oserror* ejtest(const char* arg_string)
{
  UNUSED(arg_string);
  
  return NULL;
}

//---------------------------------------------------------------------------
// *EJInfo
//---------------------------------------------------------------------------
static _kernel_oserror* ejinfo(const char* arg_string)
{
  unsigned unit = MODULE_MAX_UNITS;
  bool verbose = false;

  char blk[20];
  while(true)
  {
    _kernel_oserror* e = config_parse_token(&arg_string, blk, sizeof(blk));
    if (e) return e;
    if (blk[0]==0) break;

    if      (strcmp(blk, "-v"      )==0) verbose = true;
    else if (strcmp(blk, "-verbose")==0) verbose = true;
    else
    {
      const char* b = blk;
      e = config_parse_unit(&b, &unit);
      if (e) return e;
    }
  }
  return net_info(unit, verbose);
}

//---------------------------------------------------------------------------
// Module *Command dispatcher
//---------------------------------------------------------------------------
_kernel_oserror *module_command(const char *arg_string,
                                int argc,
                                int cmd_no,
                                void *pw)
{
  switch (cmd_no)
  {
    case CMD_EJInfo:
      return ejinfo(arg_string);

    case CMD_EJTest:
      return ejtest(arg_string);

    case CMD_EJProducts:
      return products_list();

    case CMD_EJConfig:
      return ejconfig(arg_string);
  }
  UNUSED(pw);
  UNUSED(argc);

  return NULL;
}
@


1.13
log
@Don't pass silly error numbers to MsgTrans
Detail:
  c/module - Don't pass silly error numbers to MessageTrans_ErrorLookup - the kernel will now fault them.
Admin:
  Tested on Raspberry Pi 3


Version 0.37. Tagged as 'EtherUSB-0_37'
@
text
@d170 1
@


1.12
log
@  Support ARMv8
Detail:
  This module previously used both SWP and SWPB instructions, which have
  been withdrawn in ARMv8. Now use SyncLib to provide the equivalent
  functionality, which will use LDREX/STREX or LDREXB/STREXB instead when
  appropriate.
Admin:
  Tested on Raspberry Pi 3.

Version 0.36. Tagged as 'EtherUSB-0_36'
@
text
@d93 4
a96 2
  char token[12];
  _kernel_oserror *e;
d98 6
a103 4
  sprintf(token, "@@@@@@@@E%02x", which);
  e = _swix(MessageTrans_ErrorLookup, _INR(0,3),
            token, s_msg_block, &s_msg_buffer, sizeof(s_msg_buffer));
  if (e->errnum == 0x40404040)
d105 2
a106 11
    // Same error number out as went in, looked up OK
    if (which < ERR_MAX)
    {
        // One from this module
        s_msg_buffer.errnum = MODULE_ERROR_BASE + which;
    }
    else
    {
        // Literal (shared) error number
        s_msg_buffer.errnum = which;
    }
d108 3
a110 2

  return e;
@


1.11
log
@Improve resilience to USB stack hot swapping
Detail:
  Listen out for different service calls so EtherUSB keeps connected even if DeviceFS/USBDriver/HC backends get restarted.
Admin:
  Submission from Colin Granville.

Version 0.34. Tagged as 'EtherUSB-0_34'
@
text
@d34 1
d163 1
@


1.10
log
@Addition of SMSC 75xx backend
Support for USB product ids 0x7500 and 0x7505.
Submission from Colin Granville.

Version 0.32. Tagged as 'EtherUSB-0_32'
@
text
@d245 1
a245 4

        case Service_USB_USBDriverStarting:
          callback(&start_callback, CALLBACK_ASAP, NULL);
          break;
d266 5
@


1.9
log
@Internationalised
AutoSense script updated to be able to parse both the hardwired english output (0.08-0.25 inclusive) and internationalised text (0.26+).
Tested RAM loaded on a Raspberry Pi.

Version 0.26. Tagged as 'EtherUSB-0_26'
@
text
@d172 1
@


1.8
log
@Protect against memory corruption caused by devicefs streams being unexepectedly closed
Detail:
  c/cmodule, c/usb, cmhg/EtherUSBHdr, h/usb - Sit on FSControlV & FindV so we can watch for file closures and catch any attempt to close our devicefs streams. Also need to sit on Service_Reset to make sure FileSwitch doesn't get the vector calls before us.
  If the device streams get closed without our notice, then the next attempt to write to a buffer (or potentially read from one?) via the direct buffer manager calls will result in RMA corruption.
Admin:
  Tested on Raspberry Pi with high processor vectors
  Fixes occasional data aborts while sat on "shutdown complete" screen (since *shutdown will close the devicefs streams)


Version 0.21. Tagged as 'EtherUSB-0_21'
@
text
@a33 3
#include "Global/NewErrors.h"
#include "sys/dcistructs.h"
#include "sys/errno.h"
d50 3
a52 1
extern void* g_module_pw = NULL;
d87 42
d136 18
a153 2
  if (podule_base==1) return err_translate(ERR_REINSTANTIATE);
  g_module_pw = pw;
d156 1
a156 2
  syslog(Module_Title " " Module_VersionString
         " (" Module_Date ") starting");
d158 1
d162 1
a162 1
  _kernel_oserror* e = callback_initialise(pw);
d193 1
a193 2
  UNUSED(podule_base);
  
d209 5
a218 1

d248 2
a249 1
      } break;
d271 6
d293 1
a293 1
      r->r[1] = MODULE_DCI_VERSION;
d336 10
d383 3
@


1.7
log
@Dib slot number set per DCI 4.06.
Changed *EJINFO output to refer to bus/device to match *USBDEVICES nomenclature.

Version 0.18. Tagged as 'EtherUSB-0_18'
@
text
@d206 4
@


1.6
log
@Save 4.5kB by making the table of errors with objasm (so they're not all padded to 252 bytes by the compiler to fit into _kernel_oserror structs).
The 'moduleerr.s' source should be made redundant by internationalising the module.

Version 0.17. Tagged as 'EtherUSB-0_17'
@
text
@d204 1
a204 1
      if (r->r[2]==1 && s_module_state==st_active) net_protocol_dying(r);
@


1.5
log
@Added autosense, and autosense install rule to makefile.
Now uses AsmUtils for irqs_on/irqs_off
Squash a few unused variable warnings, not in the backends though as porting updates would be more complex for those that come from (for example) NetBSD.
Changed to use structure definitions from sys/dcistructs.h (mostly an exercise in prefixing member names).

Version 0.16. Tagged as 'EtherUSB-0_16'
@
text
@a55 120
// Error codes
//-------------------------------------------------------------------------

extern _kernel_oserror err_reinstantiate = {
  MODULE_ERROR_BASE + 0,
  "Module cannot be multiple instantiated"
};

extern _kernel_oserror err_no_memory = {
  MODULE_ERROR_BASE + 1,
  "Unable to allocate memory"
};

extern _kernel_oserror err_unsupported = {
  MODULE_ERROR_BASE + 2,
  "Not supported"
};

extern _kernel_oserror err_bad_device = {
  MODULE_ERROR_BASE + 3,
  "Device broken or misbehaving"
};

extern _kernel_oserror err_too_many_units = {
  MODULE_ERROR_BASE + 4,
  "Too many units"
};

extern _kernel_oserror err_config_failed = {
  MODULE_ERROR_BASE + 5,
  "Configuration failed"
};

extern _kernel_oserror err_bad_config = {
  MODULE_ERROR_BASE + 6,
  "Configuration not supported by device"
};

extern _kernel_oserror err_bad_phy = {
  MODULE_ERROR_BASE + 7,
  "No PHY or bad PHY address"
};

extern _kernel_oserror err_unit_in_use = {
  MODULE_ERROR_BASE + 8,
  "Unit in use"
};

extern _kernel_oserror err_usb_too_old = {
  MODULE_ERROR_BASE + 9,
  "Require USBDriver 0.49 or later"
};

extern _kernel_oserror err_timeout= {
  MODULE_ERROR_BASE + 10,
  "Operation timeout."
};

extern _kernel_oserror err_eeprom_range = {
  MODULE_ERROR_BASE + 11,
  "Data out of EEPROM address range."
};

extern _kernel_oserror err_mii_in_use = {
  MODULE_ERROR_BASE + 12,
  "MII in use."
};

//-------------------------------------------------------------------------
// DCI Error codes
//-------------------------------------------------------------------------
extern _kernel_oserror err_bad_unit = {
  DCI4ERRORBLOCK + EINVAL,
  MODULE_DCI_NAME ": bad unit"
};

extern _kernel_oserror err_bad_operation = {
  DCI4ERRORBLOCK + ENOTTY,
  MODULE_DCI_NAME ": unsupported operation"
};

extern _kernel_oserror err_bad_filter_claim = {
  INETERR_FILTERGONE,
  MODULE_DCI_NAME ": frame type already claimed"
};

extern _kernel_oserror err_bad_filter_release = {
  DCI4ERRORBLOCK + EINVAL,
  MODULE_DCI_NAME ": frame type not claimed"
};

extern _kernel_oserror err_others_filter_release = {
  DCI4ERRORBLOCK + EPERM,
  MODULE_DCI_NAME ": attempt to release anothers frame claim"
};

extern _kernel_oserror err_bad_value = {
  DCI4ERRORBLOCK + EINVAL,
  MODULE_DCI_NAME ": bad parameters"
};

extern _kernel_oserror err_tx_blocked = {
  INETERR_TXBLOCKED,
  MODULE_DCI_NAME ": transmission blocked"
};

extern _kernel_oserror err_message_too_big = {
  DCI4ERRORBLOCK + EMSGSIZE,
  MODULE_DCI_NAME ": packet too big"
};

//-------------------------------------------------------------------------
// OS error codes
//-------------------------------------------------------------------------
extern _kernel_oserror err_bad_syntax = {
  ErrorNumber_Syntax,
  "Syntax"
};

//-------------------------------------------------------------------------
d95 1
a95 1
  if (podule_base==1) return &err_reinstantiate;
d232 1
a232 1
      return &err_bad_operation;
d244 1
a244 1
      return &err_bad_operation;
@


1.4
log
@Uses common USB header files exported by the USB stack.
Use ModHand/Variables/RISCOS/OsByte headers.
Note, this has meant some header files needed reordering to prevent circular dependencies.

Version 0.15. Tagged as 'EtherUSB-0_15'
@
text
@d34 2
d128 1
a128 1
  DCI_ERR_BAD_UNIT,
d133 1
a133 1
  DCI_ERR_BAD_OPERATION,
d138 1
a138 1
  DCI_ERR_ALREADY_CLAIMED,
d143 1
a143 1
  DCI_ERR_BAD_VALUE,
d148 1
a148 1
  DCI_ERR_PERMISSIONS,
d153 1
a153 1
  DCI_ERR_BAD_VALUE,
d158 1
a158 1
  DCI_ERR_BLOCKED,
d163 1
a163 1
  DCI_ERR_MESSAGE_SIZE,
d171 2
a172 2
  220,
  "Incorrect syntax"
d201 3
d253 5
d280 5
d327 1
d366 2
d428 3
@


1.3
log
@Brought under srccommit control for update of version numbers.
Makefile recreated from fragments
CMHG file renamed to avoid needing special rule to tell where it is.

Version 0.14. Tagged as 'EtherUSB-0_14'
@
text
@d34 1
d38 1
d285 1
a285 1
        case Service_USBDriver_Attach:
d287 1
a287 1
            net_check_device((const usb_service_t*)(r->r[2]), NULL);
d290 1
a290 1
        case Service_USBDriver_Starting:
@


1.2
log
@Explicit BSD licence heading blocks added to those source files that did not have them.
No code changes, not tagged.
@
text
@d33 1
d35 1
a35 1
#include "version.h"
d45 1
a45 1
#include "autogen/header"
d57 1
a57 1
  MODULE_NAME ": module cannot be multiple instantiated"
d62 1
a62 1
  MODULE_NAME ": unable to allocate memory"
d67 1
a67 1
  MODULE_NAME ": not supported"
d72 1
a72 1
  MODULE_NAME ": device broken or misbehaving"
d77 1
a77 1
  MODULE_NAME ": too many units"
d82 1
a82 1
  MODULE_NAME ": configuration failed"
d87 1
a87 1
  MODULE_NAME ": configuration not supported by device"
d92 1
a92 1
  MODULE_NAME ": no PHY or bad PHY address"
d97 1
a97 1
  MODULE_NAME ": unit in use"
d102 1
a102 1
  MODULE_NAME ": require USBDriver 0.49 or later"
d107 1
a107 1
   MODULE_NAME ": Operation timeout."
d112 1
a112 1
  MODULE_NAME ": Data out of EEPROM address range."
d117 1
a117 1
  MODULE_NAME ": MII in usage."
d125 1
a125 1
  MODULE_NAME ": bad unit"
d130 1
a130 1
  MODULE_NAME ": unsupported operation"
d135 1
a135 1
  MODULE_NAME ": frame type already claimed"
d140 1
a140 1
  MODULE_NAME ": frame type not claimed"
d145 1
a145 1
  MODULE_NAME ": attempt to release anothers frame claim"
d150 1
a150 1
  MODULE_NAME ": bad parameters"
d155 1
a155 1
  MODULE_NAME ": transmission blocked"
d160 1
a160 1
  MODULE_NAME ": packet too big"
d168 1
a168 1
  MODULE_NAME ": incorrect syntax"
d280 1
a280 1
    case Service_USBDriver:
d316 1
a316 1
#define MODULE_SWI(name) (name - MODULE_SWI_BASE)
@


1.1
log
@Import of sources to EtherUSB.
Special thanks to James Peacock for allowing ROOL to host these sources.
This import represents version 0.13 by James and the backend contributors, the only change being that the makefile wipes the directories it creates on cleaning so there's no need to import those to CVS.
Tagged as jpeacock-0_13.
@
text
@d1 27
a27 3
/* EtherUSB
 * (C) James Peacock, 2006.
 */
@


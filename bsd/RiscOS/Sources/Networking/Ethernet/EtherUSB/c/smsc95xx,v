head	1.14;
access;
symbols
	EtherUSB-0_41:1.14
	EtherUSB-0_40:1.13
	EtherUSB-0_39:1.13
	EtherUSB-0_38:1.12
	EtherUSB-0_37:1.12
	EtherUSB-0_36:1.12
	EtherUSB-0_35:1.12
	EtherUSB-0_34:1.12
	EtherUSB-0_33:1.12
	EtherUSB-0_32:1.12
	EtherUSB-0_31:1.12
	EtherUSB-0_30:1.11
	EtherUSB-0_29:1.11
	EtherUSB-0_28:1.10
	EtherUSB-0_27:1.9
	EtherUSB-0_26:1.9
	EtherUSB-0_25:1.8
	EtherUSB-0_24:1.8
	EtherUSB-0_23:1.7
	EtherUSB-0_22:1.5
	EtherUSB-0_21:1.5
	EtherUSB-0_20:1.5
	EtherUSB-0_19:1.4
	EtherUSB-0_18:1.4
	EtherUSB-0_17:1.4
	EtherUSB-0_16:1.3
	EtherUSB-0_15:1.3
	EtherUSB-0_14:1.2
	jpeacock-0_13:1.1;
locks; strict;
comment	@# @;


1.14
date	2018.03.21.23.54.42;	author jlee;	state Exp;
branches;
next	1.13;
commitid	FAdt578EOH7cRnvA;

1.13
date	2018.01.18.23.12.29;	author jlee;	state Exp;
branches;
next	1.12;
commitid	lRremJsVERKgCpnA;

1.12
date	2015.09.05.20.33.08;	author rool;	state Exp;
branches;
next	1.11;
commitid	hsW7lDmaNPcqz6Ay;

1.11
date	2014.08.30.16.02.23;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	ZDJswl20osIWZoOx;

1.10
date	2014.08.24.08.09.29;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	waLmpCDiEYRjzANx;

1.9
date	2013.10.13.13.54.42;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	cLeOtNKk3nePB89x;

1.8
date	2013.04.07.17.47.10;	author jlee;	state Exp;
branches;
next	1.7;
commitid	7koGNmobBUDhYRKw;

1.7
date	2013.04.02.21.43.50;	author jlee;	state Exp;
branches;
next	1.6;
commitid	8kUc80b6XQXrrfKw;

1.6
date	2013.04.01.14.59.33;	author jlee;	state Exp;
branches;
next	1.5;
commitid	depDMAPvYqzJe5Kw;

1.5
date	2012.08.26.15.36.07;	author jballance;	state Exp;
branches;
next	1.4;
commitid	PI9rjb9rdECJr4iw;

1.4
date	2012.05.19.08.44.28;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	6JuVMhjS8DSNlj5w;

1.3
date	2012.05.19.08.39.06;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	sBdKYcdaXJwXjj5w;

1.2
date	2012.05.19.08.30.24;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	R1EOINZ5A36Ygj5w;

1.1
date	2012.05.19.08.19.07;	author rsprowson;	state Exp;
branches;
next	;
commitid	q3rEKeu2RrS2cj5w;


desc
@@


1.14
log
@Add SMSC78xx support
Detail:
  c/smsc78xx, c/module, c/products, h/backends, Makefile - Add SMSC78xx driver, for the chip used in the Raspberry Pi 3B+
  c/config, c/mii, h/mii - Add support for gigabit MIIs & associated (auto) configuration
  c/net, h/net - Handle gigabit link types. Pass verbose flag through to backend info function.
  c/smsc95xx - Make configure_link const-correct
  Resources/UK/CmdHelp - Update *EJConfig syntaxt text to include 1000 option
  Resources/UK/Messages - Add 78xx backend name & device-specific info tokens
Admin:
  Tested on Raspberry Pi 3B & 3B+
  Manually configured gigabit links aren't supported yet
  Gigabit half-duplex isn't supported (78xx MAC limitation)
  For the 78xx, manually-configured full-duplex links appear to suffer terrible RX performance (as seen on 95xx). All supported auto modes appear to work correctly.


Version 0.41. Tagged as 'EtherUSB-0_41'
@
text
@/*
 * Copyright (c) 2011 by Thomas Milius Stade, Germany
 *                       Raik Fischer Neuenhagen, Germany
 *                       Rainer Schubert Ammersbek, Germany
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Thomas Milius Stade, Germany, Rainer Schubert Ammersbek, Germany,
 *       nor Rainer Schubert Ammersbek, Germany nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
   Thanks to SMSC for providing the required information and support for queries.
   Note that SMSC documentation is now available from Microchip's website:
     http://www.microchip.com/wwwproducts/en/LAN9500A
     http://www.microchip.com/wwwproducts/en/LAN9512
*/
/* Created 07.12.2010 T. Milius   Based on the other drivers written by
                      with the    J. Peacock. Information taken from
                      help of     various sources like SMSC LAN9100 documentation
                      R. Schubert and SMSC developer information
                      R. Fischer
   Changed 14.01.2011 R. Schubert MAC by variable
   Changed 15.01.2011 T. Milius   General clean up of the first test version to a
                                  proper code.
   Changed 18.01.2011 T. Milius   moved link configuration into a separate function
   Changed 25.01.2011 T. Milius   moved pause depend setting into link configuration */

/* !!!!!!!!!! Libraries !!!!!!!!!! */
/* ---------- ANSI-C ---------- */
#include <stdio.h>

/* ---------- RISC OS ---------- */
#include "swis.h"

/* ---------- own ---------- */
#include "backends.h"
#include "module.h"
#include "utils.h"
#include "USB/USBDevFS.h"
#include "usb.h"
#include "net.h"
#include "products.h"
#include "mii.h"

#define CHIP_ID_9500     0x9500 /* LAN9500/LAN9500i */
#define CHIP_ID_9500A    0x9E00 /* LAN9500A/LAN9500Ai */
#define CHIP_ID_951x     0xEC00 /* LAN9512/LAN9513/LAN9514 plus 'i' variants */

/* Receive buffer registered with DeviceFS */
#define RX_BUF_SIZE      16384

//---------------------------------------------------------------------------
// Workspace
//---------------------------------------------------------------------------
typedef struct
{
  usb_pipe_t      pipe_rx;
  usb_pipe_t      pipe_tx;
  net_device_t*   dev;
  mii_t           mii;
  unsigned long   phy_address;
  unsigned long   chip_id;
  unsigned long   eeprom_size;
  uint32_t        rx_buf[RX_BUF_SIZE/sizeof(uint32_t)];
} ws_t;

//---------------------------------------------------------------------------
// Put arbitrary MAC address in an array so that we may have a chance to re-
// configure it. Reason: BeagleBoard(xM) comes without a default one.
// Idea is to set <EtherUSB$MAC_Configured> to a "recyled" MAC address to
// avoid clashes between all the BBxMs with the same MAC. R.S.
//
// (Above reasoning is obsolete now that we'll use the machine ID, but let's
//  keep this logic around for compatibility - JL)
//---------------------------------------------------------------------------

static void fill_arbitraryMAC(net_device_t* dev)
{
  char *p;
  unsigned long var_mac[ETHER_ADDR_LEN];
  int i;

  if ((p=getenv("EtherUSB$MAC_Configured")) != (char *) NULL) {
    if(sscanf(p,"%lx:%lx:%lx:%lx:%lx:%lx",
              &var_mac[0],
              &var_mac[1],
              &var_mac[2],
              &var_mac[3],
              &var_mac[4],
              &var_mac[5]) == ETHER_ADDR_LEN) {
      for(i=0;i<ETHER_ADDR_LEN;i++) {
         dev->status.mac[i] = (uint8_t)var_mac[i];
      }
      return;
    } else {
      syslog("MAC address %s is invalid\n",p);
    }
  }
}

//---------------------------------------------------------------------------
// Read/write device registers
//---------------------------------------------------------------------------
/* Little Endian 32 Bit on ARM and device so leave data unchanged */
static _kernel_oserror* reg_read(const ws_t*          ws,
                                 uint16_t             reg,
                                 unsigned long* data)
{
  _kernel_oserror* e;

  if ((e=usb_control(ws->dev->name,
                     USB_REQ_VENDOR_READ,
                     /* Read register */
                     0xA1,
                     0x0000,
                     reg,
                     4,
                     (void *) data)) != NULL) {
    syslog("smsc95xx reg read %s %x: %x %s", ws->dev->name, reg, e->errnum, e->errmess);
    return e;
    }
  syslog("smsc95xx reg read %s %x: %lx", ws->dev->name, reg, *data);
  return NULL;
}

static _kernel_oserror* reg_write(const ws_t*   ws,
                                  uint16_t      reg,
                                  unsigned long data)
{
  _kernel_oserror* e;

  if ((e=usb_control(ws->dev->name,
                     USB_REQ_VENDOR_WRITE,
                     /* Write register */
                     0xA0,
                     0x0000,
                     reg,
                     4,
                     &data)) != NULL) {
    syslog("smsc95xx reg write %s %x %lx: %x %s", ws->dev->name, reg, data, e->errnum, e->errmess);
    return e;
    }
  syslog("smsc95xx reg write %s %x %lx", ws->dev->name, reg, data);
  return NULL;
}

static _kernel_oserror* reg_modify(const ws_t*  ws,
                                  uint16_t      reg,
                                  unsigned long bic,
                                  unsigned long eor)
{
  unsigned long data;
  
  _kernel_oserror* e=reg_read(ws,reg,&data);
  
  if (e == NULL) e=reg_write(ws,reg,((data & ~bic) ^ eor));
  
  return e;
}

#define SMSC95XX_MII_ACCESS_READ        0u
#define SMSC95XX_MII_ACCESS_BUSY        1u
static _kernel_oserror* phy_read(void*     handle,
                                 unsigned  reg,
                                 uint16_t* data)
{
  const ws_t* ws = (const ws_t *) handle;
  unsigned long reg_data;
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
  _kernel_oserror* e;

  syslog("smsc95xx phy read %s %d", ws->dev->name, reg);
  /* Access to PHY indirects through MII registers. */
  /* Check that MII is not busy (MII_ADDR) */
  if((e=reg_read(ws,
                 0x0114,
                 &reg_data)) != NULL) {
    return e;
    }
  if ((reg_data & SMSC95XX_MII_ACCESS_BUSY) != 0) {
    return err_translate(ERR_MII_IN_USE);
    }

  /* Set the address, index & direction (read from PHY) by writing
     to MII_ADDR. */
  reg_data= ((ws->phy_address & 0x0000001FL)<<11) | ((reg & 0x001FL)<<6) | SMSC95XX_MII_ACCESS_READ | SMSC95XX_MII_ACCESS_BUSY;
  if((e=reg_write(ws,
                  0x0114,
                  reg_data)) != NULL) {
    return e;
    }
  /* Wait for completing by checking BUSY state */
  start_time=(unsigned long) regs.r[0];
  do {
    /* Get Busy info from MII (MII_ADRR). */
    if((e=reg_read(ws,
                   0x0114,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((reg_data & 0x00000001) == 0) {
      /* Now obtain value from MII_DATA */
      if((e=reg_read(ws,
                     0x0118,
                     &reg_data)) != NULL) {
        return e;
        }
      *data=reg_data;
      syslog("smsc95xx phy read value %x", *data);
      return NULL;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(actual_time < (start_time + 10));
  return err_translate(ERR_TIMEOUT);
}

static _kernel_oserror* phy_write(void*    handle,
                                  unsigned reg,
                                  uint16_t data)
{
  const ws_t* ws = (const ws_t *) handle;
  unsigned long reg_data;
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
  _kernel_oserror* e;

  syslog("smsc95xx phy write %s %d %lx",
                    ws->dev->name,
                    reg,
                    data);
  /* Check that MII is not busy */
  /* Get Busy info from MII (MII_ADRR). */
  if((e=reg_read(ws,
                 0x0114,
                 &reg_data)) != NULL) {
    return e;
    }
  if ((reg_data & 0x00000001) != 0) {
    return err_translate(ERR_MII_IN_USE);
    }

  /* Prepare data (MII_DATA)*/
  if((e=reg_write(ws,
                  0x0118,
                  data)) != NULL) {
    return e;
    }

  /* Set the address, index & direction (write to PHY) */
  reg_data= ((ws->phy_address & 0x0000001F)<<11) | ((reg & 0x001FL)<<6) | 2u | 1u;
  if((e=reg_write(ws,
                  0x0114,
                  reg_data)) != NULL) {
    return e;
    }
  /* Wait for completing by checking BUSY state */
  start_time=(unsigned long) regs.r[0];
  do {
    /* Get Busy info from MII (MII_ADRR). */
    if((e=reg_read(ws,
                   0x0114,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((reg_data & 0x00000001) == 0) {
      return NULL;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(actual_time < (start_time + 10));
  return err_translate(ERR_TIMEOUT);
}

#define SMSC95XX_E2P_CMD                0x30
#define SMSC95XX_E2P_DATA               0x34
#define SMSC95XX_E2P_CMD_EPC_BSY        (1ul << 31)
#define SMSC95XX_E2P_CMD_EPC_DL         (1ul << 9)
#define SMSC95XX_E2P_CMD_READ           0ul
#define SMSC95XX_E2P_DATA_MASK          0xfful

static _kernel_oserror* read_eeprom_byte(const ws_t* ws, unsigned long offset, uint8_t* byteout)
{
  unsigned long reg_data;
  _kernel_oserror* e;
 
  if (byteout == NULL) return NULL;
  if (e = reg_read(ws, SMSC95XX_E2P_CMD, &reg_data), e) return e;
  if (reg_data & SMSC95XX_E2P_CMD_EPC_BSY) return err_translate(ERR_TIMEOUT);
  
  if (e = reg_write(ws, SMSC95XX_E2P_CMD, (SMSC95XX_E2P_CMD_EPC_BSY | SMSC95XX_E2P_CMD_READ | offset)), e) return e;
  do
  {
     if (e = reg_read(ws, SMSC95XX_E2P_CMD, &reg_data), e) return e;
  } while (reg_data & SMSC95XX_E2P_CMD_EPC_BSY);
  
  if ((reg_data & SMSC95XX_E2P_CMD_EPC_DL) == 0) return err_translate(ERR_TIMEOUT);
  
  if (reg_read(ws, SMSC95XX_E2P_DATA, &reg_data), e) return e;
  *byteout = (uint8_t)(reg_data & SMSC95XX_E2P_DATA_MASK);
  return NULL;
}

static _kernel_oserror* read_eeprom(const ws_t* ws, unsigned long offset, unsigned long length, uint8_t *data)
{
  uint8_t reg_data;
  _kernel_oserror* e;

  if (offset + length > ws->eeprom_size)  return err_translate(ERR_EEPROM_RANGE);
  
  /* If eeprom byte 0 isn't 0xA5 then the eeprom is invalid */
  if (e = read_eeprom_byte(ws, 0, &reg_data), e) return e;
  if (reg_data != 0xA5) return err_translate(ERR_TIMEOUT);
  
  for (unsigned long i = 0; i < length; i++)
  {
    if (e = read_eeprom_byte(ws, offset + i, data + i), e) return e;
  }
  
  return NULL;
}

static bool check_mac(uint8_t *mac)
{
  int i;
  bool match;
  
  match=true;
  /* 00 00 00 00 00 00 */
  i=0;
  while(i<ETHER_ADDR_LEN) {
    if (mac[i] != 0x00) {
      match=false;
      break;
      }
    i++;
  }
  if (match) return false;
  match=true;
  /* FF FF FF FF FF FF */
  i=0;
  while(i<ETHER_ADDR_LEN) {
    if (mac[i] != 0xFF) {
      match=false;
      break;
      }
    i++;
  }
  if (match) return false;
  return true;
}

static _kernel_oserror* update_medium(net_device_t *dev)
{
  ws_t* ws = dev->private;
  _kernel_oserror *e;
  unsigned long reg_data;

  /* Adapt MAC to PHY duplex settings (MAC_CR) */
  if((e=reg_read(ws,
                 0x0100,
                 &reg_data)) != NULL) {
    return e;
    }
  /* Clear duplex information */
  reg_data&=~(0x00100000);
  /* Set new duplex information */
  if(dev->status.duplex == net_duplex_full) {
    /* MAC_CR_FDPX_ */
    reg_data|=0x00100000;
    }
  if((e=reg_write(ws,
                  0x0100,
                  reg_data)) != NULL) {
    return e;
    }

  /* Cope with pause handling */
  /* Set flow (FLOW) */
  const unsigned long AFC_LO = 0x30; /* 3KB low threshold (in units of 64 bytes) */
  const unsigned long AFC_HI = 0xF8; /* 15.5KB high threshold */
  const unsigned long PAUSE_TIME = AFC_HI-AFC_LO; /* Pause time in units of 512 bits */
  /* Note that we're setting the pause time to how long it takes the FIFO to
     transition from the low threshold to the high threshold (at network RX
     speed), even though we should technically be able to empty the FIFO much
     quicker (480Mbps USB vs. 100Mbps network)
     This is a compromise because:
     (a) The chip only sends a pause frame when the RX FIFO level transitions
         from below AFC_LO to above AFC_HI. So if the timer expires before we
         empty the FIFO, the remote link will resume transmitting, potentially
         overflowing the FIFO and causing packets to be lost. 
     (b) Setting a time which is too high may hurt performance, because although
         the chip will send a zero-time pause frame once AFC_LO is reached,
         there's no guarantee the remote link will receive the frame.
     */
  reg_data=(PAUSE_TIME<<16) & 0xFFFF0000;
  if(dev->status.rx_pause || (dev->status.duplex == net_duplex_half)) {
    reg_data|=0x2; /* Enable PAUSE RX, or enable back pressure */
  }
  if((e=reg_write(ws,
                  0x011C,
                  reg_data)) != NULL) {
    return e;
    }
  /* Set Automatic flow control configuration (AFC_CFG) */
  reg_data=(AFC_HI<<16) | (AFC_LO<<8); /* Upper/lower RX FIFO bounds for PAUSE / backpressure */
  if(dev->status.tx_pause || (dev->status.duplex == net_duplex_half)) {
    reg_data|=0x1; /* Configure which frames trigger PAUSE TX / backpressure (all frames) */
  }
  if(dev->status.speed == net_speed_10Mb) {
    reg_data|=0xD0; /* 500uS backpressure duration */
  } else {
    reg_data|=0x40; /* 50uS backpressure duration */
  }
  if((e=reg_write(ws,
                  0x002C,
                  reg_data)) != NULL) {
    return e;
  }

  return NULL;
}

static _kernel_oserror* configure_link(net_device_t* dev,
                                       const net_config_t* cfg)
{
  ws_t* ws = dev->private;
  _kernel_oserror* e = mii_configure(&ws->mii, &dev->status, cfg);
  if (e)
  {
    return e;
  }

  /* PHY internal only */
  if (ws->phy_address == 1) {
    uint16_t reg_data;
    if (ws->chip_id != CHIP_ID_9500A) {
      /* Auto-MDIX only works reliably if link autonegotiation is enabled (a known limitation of the protocol).
         So make sure we force it off if link autonegotiation is disabled. */
      if((e=phy_read(ws,27,&reg_data)) != NULL) {
        return e;
      }
      reg_data &= ~0xE000;
      if (dev->status.autoneg == net_autoneg_none) {
        reg_data |= 0x8000;
      }
      if((e=phy_write(ws,27,reg_data)) != NULL) {
        return e;
      }
    } else {
      /* For the 9500A, instead of disabling Auto-MDIX we can extend the crossover time so that it will still operate correctly with manual link configuration */
      if((e=phy_read(ws,16,&reg_data)) != NULL) {
        return e;
      }
      if (dev->status.autoneg == net_autoneg_none) {
        reg_data|=0x0001;
      } else {
        reg_data&=~0x0001;
      }
      if((e=phy_write(ws,16,reg_data)) != NULL) {
        return e;
      }
    }
  }

  /* Update medium now if autonegotiation disabled. Else, wait for the status callback. */
  if (dev->status.autoneg == net_autoneg_none)
  {
    e = update_medium(dev);
  }
  return e;
}

//---------------------------------------------------------------------------
// USB pipe handlers
//---------------------------------------------------------------------------
static void read_packet(usb_pipe_t pipe, void* dev_pw)
{
  ws_t* ws = dev_pw;
  uint32_t* buf = ws->rx_buf;

  pipe = pipe;
    
  for (;;)
  {
    size_t size = sizeof(ws->rx_buf);
  
    _kernel_oserror* e = usb_read(ws->pipe_rx, buf, &size);

    if (e || size == 0) break;
    usb_start_read(ws->pipe_rx);
    
    if (size>4)
    {
      
      int off = 0;
      size = (size+3)/4;
      size_t packet_size;
      size_t next;
      for  (off = 0; off < size-1; off = next)
      {
          packet_size = (buf[off] >> 16) & 0x3fff;
          next = off + ((packet_size+7)/4);
          if (packet_size > 0 && packet_size <= ETHER_MAX_LEN && next <= size) 
                net_receive(ws->dev, &buf[off+1], packet_size, 0);
      }
    }
  }
  
  usb_start_read(ws->pipe_rx);
}

static void write_packet(usb_pipe_t pipe, void* dev_pw)
{
  ws_t* ws = dev_pw;
  net_attempt_transmit(ws->dev);
  UNUSED(pipe);
}

//---------------------------------------------------------------------------
// Backend functions.
//---------------------------------------------------------------------------
static _kernel_oserror* device_status(net_device_t* dev)
{
  ws_t* ws = dev->private;
  _kernel_oserror *e = mii_link_status(&ws->mii, &dev->status);

  if (!e && dev->status.autoneg == net_autoneg_reconfigure)
  {
    e = update_medium(dev);
    if (!e) dev->status.autoneg = net_autoneg_complete;
  }
  return e;
}

static _kernel_oserror* device_configure(net_device_t* dev,
                                         const net_config_t* cfg)
{
  _kernel_oserror *e = configure_link(dev,
                        (net_config_t*) cfg);
  return e;
}

static _kernel_oserror* device_transmit(net_device_t*   dev,
                                        const net_tx_t* pkt)
{
  ws_t* ws = dev->private;
  unsigned long *prefix;
  /* Requires two Words at beginning TX_CMD_A and TX_CMD_B
     (see SMSC AN1212.pdf for details) */
  size_t to_write = 2*4 + pkt->size;
  unsigned long alignment;

  /* If using more than one paket at a time pakets must be word aligned
     so a round to a multiple of 4 is necassary. */
  alignment=(pkt->size % 4lu);
  if (alignment != 0) {
    to_write+=(size_t)(4 - alignment);
    }

  prefix=(unsigned long *) &pkt->header;
  prefix-=2;
  /* Is first and last segment of a packet */
  prefix[0]=0x00002000L | 0x00001000L | pkt->size;
  /* May also contain an ID but we don't use this */
  prefix[1]=pkt->size;
  usb_write(ws->pipe_tx, (void*)prefix, &to_write);
  return (to_write==0) ? err_translate(ERR_TX_BLOCKED) : NULL;
}

static _kernel_oserror* device_open(const USBServiceCall* dev,
                                    const char*           options,
                                    void**                private)
{
  syslog("smsc95xx open");
  if (!options) return err_translate(ERR_UNSUPPORTED);

  ws_t* ws = xalloc(sizeof(ws_t));
  if (!ws) return err_translate(ERR_NO_MEMORY);

  ws->pipe_rx    = 0;
  ws->pipe_tx    = 0;
  ws->dev        = NULL;
  /* other values initialized during device_start */

  mii_initialise(&ws->mii, phy_read, phy_write, ws);

  *private = ws;
  UNUSED(dev);
  return NULL;
}

static _kernel_oserror* device_start(net_device_t* dev, const char* options)
{
  ws_t* ws = dev->private;
  unsigned long reg_data;
  int i;
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
  _kernel_oserror* e;

  ws->dev  = dev;
  syslog("smsc95xx start");

  /* Reset */
  /* Set according Bit inside HW_CFG */
  if((e=reg_read(ws,
                 0x0014,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data|=0x00000008;
  if((e=reg_write(ws,
                  0x0014,
                  reg_data)) != NULL) {
    return e;
    }
  /* Wait for reset finished. */
  if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
    return e;
    }
  start_time=(unsigned long) regs.r[0];
  do {
    /* Check whether Reset Bit still set */
    if((e=reg_read(ws,
                   0x0014,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(((reg_data & 0x00000008) != 0) &&
        (actual_time < (start_time + 100)));
  if ((reg_data & 0x00000008) != 0) {
    return err_translate(ERR_TIMEOUT);
    }
  /* Determine chip type (ID_REV) to cope with certain special properties */
  syslog("Chip type");
  if((e=reg_read(ws,
                 0x0000,
                 &reg_data)) != NULL) {
    return e;
    }
  ws->chip_id=reg_data>>16;
  /* ??? EEPROM existence check still missing */
  ws->eeprom_size=512;

  dev->status.broadcast   = 1;
  dev->status.multicast   = 1;
  dev->status.promiscuous = 0;

  /* Reset the PHY */
  syslog("reset PHY");
  /* Set according Bit inside PM_CTRL */
  if((e=reg_read(ws,
                 0x0020,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data|=0x00000010;
  if((e=reg_write(ws,
                  0x0020,
                  reg_data)) != NULL) {
    return e;
    }
  /* Wait for reset finished. */
  if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
    return e;
    }
  start_time=(unsigned long) regs.r[0];
  do {
    /* Check whether Reset Bit still set */
    if((e=reg_read(ws,
                   0x0020,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(((reg_data & 0x00000010) != 0) &&
        (actual_time < (start_time + 100)));
  if ((reg_data & 0x00000010) != 0) {
    return err_translate(ERR_TIMEOUT);
    }
  /* Flush log */
  syslog_flush();

  /* MAC handling */
  syslog("mac handling");

  /* Obtain EUI48 from EEPROM - Starts at Position 1 */
  e = read_eeprom(ws, 1, ETHER_ADDR_LEN, dev->status.mac);
  
  if (e || !check_mac(dev->status.mac))
  {
    /* Default */
    for (i = 0; i < ETHER_ADDR_LEN; i++) dev->status.mac[i] = 0xFF;
    /* If MAC has been set by system variable, prefer that over the last-used
       MAC. This allows machines with EtherUSB in ROM to use a custom MAC by
       setting the variable and then reiniting the module. */
    fill_arbitraryMAC(dev);
  }
  if(!check_mac(dev->status.mac)) {
    /* If not given try to keep last MAC set
       Only valid if there was no reset. */
    /* Low (ADRRL) 4 Bytes */
    if((e=reg_read(ws,
                   0x0108,
                   &reg_data)) != NULL) {
      return e;
      }
    dev->status.mac[0]=(uint8_t)(reg_data >> 0);
    dev->status.mac[1]=(uint8_t)(reg_data >> 8);
    dev->status.mac[2]=(uint8_t)(reg_data >> 16);
    dev->status.mac[3]=(uint8_t)(reg_data >> 24);
    /* High (ADRRH) 2 Bytes */
    if((e=reg_read(ws,
                   0x0104,
                   &reg_data)) != NULL) {
      return e;
      }
    dev->status.mac[4]=(uint8_t)(reg_data >> 0);
    dev->status.mac[5]=(uint8_t)(reg_data >> 8);
    }
  if(!check_mac(dev->status.mac)) {
    /* Try the machines configured MAC (e.g. for builtin SMSC on Raspberry Pi) */
    net_machine_mac(dev->status.mac);
  }
  if(!check_mac(dev->status.mac)) {
    /* Try to construct a MAC from machine ID, or failing that, a hardcoded
       default */
    net_default_mac(dev->dib.dib_unit, dev->status.mac);
  }
  /* Set MAC */
  /* Low (ADRRL) 4 Bytes */
  reg_data = ((unsigned long)(dev->status.mac[3])<<24) |
             ((unsigned long)(dev->status.mac[2])<<16) |
             ((unsigned long)(dev->status.mac[1])<<8 ) |
             ((unsigned long)(dev->status.mac[0])<<0 ) ;

  if((e=reg_write(ws,
                  0x0108,
                  reg_data)) != NULL) {
    return e;
    }
  /* High (ADRRH) 2 Bytes */
  reg_data=((unsigned long)(dev->status.mac[5])<<8) |
           ((unsigned long)(dev->status.mac[4])   ) ;

  if((e=reg_write(ws,
                  0x0104,
                  reg_data)) != NULL) {
    return e;
    }
  /* Flush log */
  syslog_flush();

  /* Various setups */
  syslog("set up");
  /* Set to operational mode.
     Activate according Bit inside HW_CFG */
  if((e=reg_read(ws,
                 0x0014,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data|=0x00001000;
  if((e=reg_write(ws,
                  0x0014,
                  reg_data)) != NULL) {
     return e;
     }
  /* Flush log */
  syslog_flush();
  syslog("burst");
    
  /* Set multiple packets per frame, NAK empty input buffer, Burst cap enable */
  #define HW_CFG_BCE (1 << 1)
  #define HW_CFG_MEF (1 << 5)
  #define HW_CFG_BIR (1 << 12)
  #define HW_CFG_BITS (HW_CFG_BIR | HW_CFG_MEF | HW_CFG_BCE)
  if (e = reg_modify(ws, 0x14, HW_CFG_BITS, HW_CFG_BITS), e != NULL) return e;

  /* Set Burst cap (BURST_CAP) */
  if (dev->speed == USB_SPEED_HI) 
  {
    if (e = reg_write(ws, 0x38, (RX_BUF_SIZE -4096)/512), e != NULL) return e;
  }
  else 
  {
    if (e = reg_write(ws, 0x38, (RX_BUF_SIZE -4096)/64), e != NULL) return e;
  }
  
  /* burst delay */
  if (e = reg_write(ws,0x6C,0x800), e != NULL)  return e;

  syslog("set up 2");
  /* Clear all Information inside Interrupt Status (INT_STS) */
  if((e=reg_write(ws,
                  0x0008,
                  0xFFFFFFFF)) != NULL) {
    return e;
    }
  /* We don´t use the Interrupt Endpoint inside EtherUSB.
     So no need to set Interrupt Endpoint Control */
  /* Flush log */
  syslog_flush();

  /* Enable TX */
  syslog("enable TX");
  /* Now enable TX (MAC_CR). */
  if((e=reg_read(ws,
                 0x0100,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data|=0x00000008;
  if((e=reg_write(ws,
                  0x0100,
                  reg_data)) != NULL) {
    return e;
    }
  /* Also requires activation of transmission configuration (TX_CFG) */
  if((e=reg_write(ws,
                  0x0010,
                  0x00000004)) != NULL) {
    return e;
    }
  /* Flush log */
  syslog_flush();

  /* Enable RX */
  syslog("enable RX");
  /* Set up VLAN support (VLAN1). */
  if((e=reg_write(ws,
                  0x0120,
                  /* Which value is useful ???
                  0 ist default
                  1 could be useful according to MS documentation.
                  SMSC Softwaremanual tells about a special parameter.
                  VLANs are unusual under RISC OS. */
                  0)) != NULL) {
    return e;
    }
  /* Now enable RX (MAC_CR). */
  if((e=reg_read(ws,
                 0x0100,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data|=0x00000004;
  if((e=reg_write(ws,
                  0x0100,
                  reg_data)) != NULL) {
    return e;
    }
  /* Flush log */
  syslog_flush();

  /* Enable LEDs */
  syslog("LEDs");
  /* Clear according Bits inside LED configuration (LED_GPIO_CFG) and set them
     in such a way that they are indicating speed and activity. */
  if((e=reg_read(ws,
                 0x0024,
                 &reg_data)) != NULL) {
    return e;
    }
  reg_data&= ~0x03330000;
  reg_data|= 0x01110000;
  if((e=reg_write(ws,
                  0x0024,
                  reg_data)) != NULL) {
    return e;
    }
  if(ws->chip_id == CHIP_ID_9500A) {
    /* LAN9500A */
    /* Read from EEPROM configuration flags ??? */
    }
  /* Set filtering of incoming packages */
  syslog("filter RX");
  /* ??? Only ”all multicast” supported in the moment. */
    /* All multicast */
    /* Clear HASH (HASHH). */
    if((e=reg_write(ws,
                    0x010C,
                    0)) != NULL) {
      return e;
      }
    /* Clear HASH (HASHL). */
    if((e=reg_write(ws,
                    0x0110,
                    0)) != NULL) {
      return e;
      }
    /* Configure mode (MAC_CR) */
    if((e=reg_read(ws,
                   0x0100,
                   &reg_data)) != NULL) {
      return e;
      }
    /* Mulicast pass */
    reg_data|=0x00080000;
    /* No promiscuous and no hash pass filters */
    reg_data&=~(0x00040000 | 0x00002000);
    if((e=reg_write(ws,
                    0x0100,
                    reg_data)) != NULL) {
      return e;
      }
  /* Flush log */
  syslog_flush();

  /* Initialize PHY (HW_CFG) */
  syslog("set up PHY");
  if((e=reg_read(ws,
                 0x0014,
                 &reg_data)) != NULL) {
    return e;
    }

  if((reg_data & 0x00000004) != 0) {
    /* external PHY (HW_CFG_PSEL_) */
    /* ??? Auto detect as default */
    ws->phy_address = 32;
    if (ws->phy_address <= 31) {
      /* Given address (??? no point to be set yet) */
      unsigned long   phy_id;

      phy_id=ws->phy_address;
      /* Deactivate all PHYs available (PHY_BCR) */
      for (i=0; i<=31; i++) {
        ws->phy_address = i;
        if((e=phy_write(ws,
                        0,
                        /* Deactivation (PHY_BCR_ISOLATE) */
                        0x0400)) != NULL) {
          return e;
          }
        }
      /* Reactivate exactly the given one (PHY_BCR). */
      ws->phy_address=phy_id;
      if((e=phy_write(ws,
                      0,
                      0)) != NULL) {
        return e;
        }
      }
    else {
      /* Auto detect */
      ws->phy_address = 0;
      while(ws->phy_address <= 31) {
        uint16_t reg_data16;
        /* try to read PHY ID (PHY_ID_1) */
        if((e=phy_read(ws,
                       2,
                       &reg_data16)) != NULL) {
          return e;
          }
        /* Check whether a valid value has been found */
        if ((reg_data16 != 0x7FFF)&&
            (reg_data16 != 0xFFFF)&&
            (reg_data16 != 0x0000)) break;
        ws->phy_address++;
        }
      if (ws->phy_address > 31) {
        return err_translate(ERR_BAD_PHY);
        }
      }
    }
  else {
    /* internal PHY */
    ws->phy_address = 1;
    }

  /* Link setup and Status determined by EtherUSB after this procedure */

  /* Flush log */
  syslog_flush();

  /* RISC OS USB part */
  syslog("RISC OS USB");
  
  if (!e) e = usb_open(dev->name,
                       &ws->pipe_rx,
                       USBRead,
                       &read_packet,
                       ws,
                       "Devices#bulk;size" STR(RX_BUF_SIZE) ":$.%s",
                       dev->name);

  if (!e) e = usb_open(dev->name,
                       &ws->pipe_tx,
                       USBWrite,
                       &write_packet,
                       ws,
                       "Devices#bulk;size16384:$.%s",
                       dev->name);

  /* Reset PHY and update abilities structure */
  if (!e) e = mii_reset(&ws->mii);
  if (!e) e = mii_abilities(&ws->mii, &dev->abilities);
  if (dev->speed != USB_SPEED_HI) {
    /* Only at USB high speed */
    dev->abilities.speed_100Mb = 0;
    }
  dev->abilities.multicast   = 1;
  dev->abilities.promiscuous = 0; /* ??? still to be implemented */
  dev->abilities.tx_rx_loopback = 0; /* ??? SMSC chips can. But where to configure. */
  dev->abilities.rx_pause = dev->abilities.tx_pause = dev->abilities.symmetric_pause = 1;

  if (e) {
    usb_close(&ws->pipe_tx);
    usb_close(&ws->pipe_rx);
    return e;
  }

  // Request initial packet.
  read_packet(ws->pipe_rx,ws);

  dev->status.ok = true;
  UNUSED(options);
  return NULL;
}

static _kernel_oserror* device_stop(net_device_t* dev)
{
  ws_t* ws = dev->private;
  unsigned long reg_data;
  _kernel_oserror* e;

  syslog("smsc95xx stop");

  if (!dev->gone) {
    /* Stop TX (TX_CFG) */
    if((e=reg_read(ws,
                   0x0010,
                   &reg_data)) != NULL) {
      return e;
      }
    reg_data|=0x00000002;
    if((e=reg_write(ws,
                    0x0010,
                    reg_data)) != NULL) {
      return e;
      }
    /* Stop RX (MAC_CR) */
    if((e=reg_read(ws,
                   0x0100,
                   &reg_data)) != NULL) {
      return e;
      }
    reg_data&=~0x00000004;
    if((e=reg_write(ws,
                    0x0100,
                    reg_data)) != NULL) {
      return e;
      }
    }
  /* RISC OS USB part */
  usb_close(&ws->pipe_tx);
  usb_close(&ws->pipe_rx);
  return NULL;
}

static _kernel_oserror* device_close(void** private)
{
  syslog("smsc95xx close");
  xfree(*private);
  return NULL;
}

/* Provides the driver functions for this kind of device.
   Must be declared here because all functions are known at here. */
static const net_backend_t s_backend = {
  .name        = N_SMSC95XX,
  .description = "DescSMC9",
  .open        = device_open,
  .start       = device_start,
  .stop        = device_stop,
  .close       = device_close,
  .transmit    = device_transmit,
  .info        = NULL,
  .config      = device_configure,
  .status      = device_status,
};

/* Registers device driver to general driver */
_kernel_oserror* smsc95xx_register(void)
{
  syslog("smsc95xx register");
  return net_register_backend(&s_backend);
}
@


1.13
log
@Improvements to SMSC 95xx backend and common MII handling
Detail:
  c/smsc95xx - Convert code to use the common MII backend. Reduce verbosity of debug output. Fix two sets of status callbacks running (callback_status_adapter + device_status). Tweak/refactor a couple of other bits as necessary in order to get 10M links working reliably.
  c/mii, h/mii, h/net - Allow backends to indicate their level of support for PAUSE functionality, so that we can advertise it correctly when performing auto-negotiation (previously no pause ability would have been advertised)
  c/config - Ensure config_parse_arguments passes through the PAUSE capabilities to the output net_config_t. Use the (currently unused) ERR_BAD_CONFIG for if autonegotiation is disabled but either speed or duplex setting not specified (avoids MII code or backends getting confused as to what options they should use)
  Resources/UK/Messages - Tweak wording of ERR_BAD_CONFIG so that it's more sensible for the new usage
  doc/!ReadMe - Remove the note about 10M links not being supported by the SMSC 95xx backend. Update the changelog to point people towards CVS for recent changes.
Admin:
  Tested on PandaBoard + Raspberry Pi 3, using SMSC 95xx and AX88772 devices
  SMSC testing results:
  * Previously, 10M links were non-functional
  * Previously, manually-configured 100M full duplex links would suffer terrible performance
  * Previously, any attempt to reconfigure a link on Pi 3 would result in a "Device broken or misbehaving" error? (or at least, that's how 0.38 is behaving for me now)
  * Now, all combinations of configuration (speed + link + auto/noauto) appear to work correctly, except for manually-configured full-duplex links, which still suffer from terrible performance
  AX88772 was used to verify MII changes haven't broken anything for other backends; testing showed no significant differences to previous version (all speed + link + auto/noauto modes working)
  Resolves ticket #342:
  https://www.riscosopen.org/tracker/tickets/342
  Note that currently the SMSC 95xx backend is the only backend to advertise PAUSE functionality via the common MII code; a future improvement would be to set up the other backends appropriately (set correct flags in net_abilities_t)


Version 0.39. Tagged as 'EtherUSB-0_39'
@
text
@d452 1
a452 1
                                       net_config_t* cfg)
@


1.12
log
@Further throughput improvements
ax88772.c:
  Modified to work with changes made to net.c and usb.c.
  Increased buffer sizes, allow more than one packet receipt.
ax88172.c/mcs7830.c/pegasus.c:
  Modified to work with changes made to net.c and usb.c.
smsc95xx.c:
  Copyright header simplified by using pronoun form "the copyright holders" rather than repeating this list.
  Modified to work with changes made to net.c and usb.c.
  Reading of MAC address from EEPROM fixed.
products.c:
  Added SMSC9730 device id (uses smsc95xx backend).
net.c/net.h:
  tx_queue removed, all transmit buffering is now done in the USB code.
usb.c:
  Function usb_write() blocks until room is available, or times out.
  Use USBDriver header rather than defining local SWI numbers.
Messages:
  Renamed DescSMC token to DescSMC9.
  Removed redundant Stat7 statistic.

Submission from Colin Granville.
Tested on Pi B+ and OMAP3, not tested on OMAP4, but believed to markedly improve its performance over version 0.30.

Version 0.31. Tagged as 'EtherUSB-0_31'
@
text
@d33 3
d63 1
d65 3
a67 9
/* Cable handling definitions */
#define AUTO_MDIX_DISABLE_STRAIGHT   0
#define AUTO_MDIX_DISABLE_CROSSOVER  1
#define AUTO_MDIX_ENABLE             2

#define PAUSE_MODE_NO        0
#define PAUSE_MODE_IN        1
#define PAUSE_MODE_IN_OUT    2
#define PAUSE_MODE_BACKPRESS 3
d80 1
a81 1
  unsigned long   phy_id;
a83 3
  unsigned long   auto_mdix;
  bool            mdix_mode_supported;
  unsigned long   pause_mode;
a130 1
  syslog("smsc95xx register read %s %d", ws->dev->name, reg);
d139 1
d142 1
a142 1
  syslog("smsc95xx register read value %lx", *data);
d150 3
a152 5
  syslog("smsc95xx register write %s %d %lx",
                    ws->dev->name,
                    reg,
                    data);
  return usb_control(ws->dev->name,
d159 6
a164 1
                     &data);
d183 3
a185 4
static _kernel_oserror* phy_read(const ws_t*    ws,
                                 uint16_t       reg,
                                 unsigned long* data)

d187 1
d230 1
a230 1
      syslog("smsc95xx phy read value %lx", *data);
d242 3
a244 3
static _kernel_oserror* phy_write(const ws_t*   ws,
                                  uint16_t      reg,
                                  unsigned long data)
d246 1
d380 1
a380 68
static _kernel_oserror* obtain_autoneg_status(net_device_t* dev)
{
  ws_t* ws = dev->private;
  unsigned long reg_data, partner_abilities;
  _kernel_oserror* e;

  /* In to accordance to LAN9100 description.
     Fetch link abilities (PHY_ANEG_ADV) and that of the
     bus (PHY_ANEG_LPA) */
  if((e=phy_read(ws,
                 4,
                 &reg_data)) != NULL) {
    return e;
    }
  if((e=phy_read(ws,
                 5,
                 &partner_abilities)) != NULL) {
    return e;
    }
  /* only that which is supported by both sides is valid */
  reg_data&=partner_abilities;
  /* Find out the remaing abilities by priority:
     1. PHY_ANEG_ADV_100F_
     2. PHY_ANEG_ADV_100H_
     3. PHY_ANEG_ADV_10F_
     4. PHY_ANEG_ADV_10H_ */
  if ((reg_data & 0x00000100) != 0) {
    dev->status.speed=net_speed_100Mb;
    dev->status.duplex=net_duplex_full;
    }
  else if ((reg_data & 0x00000080) != 0) {
    dev->status.speed=net_speed_100Mb;
    dev->status.duplex=net_duplex_half;
    }
  else if ((reg_data & 0x00000040) != 0) {
    dev->status.duplex=net_duplex_full;
    dev->status.speed=net_speed_10Mb;
    }
  else if ((reg_data & 0x00000020) != 0) {
    dev->status.duplex=net_duplex_half;
    dev->status.speed=net_speed_10Mb;
    }
  else {
    dev->status.duplex=net_duplex_unknown;
    dev->status.speed=net_speed_unknown;
    }
  /* Check for pause handling */
  if (dev->status.duplex == net_duplex_full) {
    if ((reg_data & 0x00000400) != 0) {
      /* Symmetric */
      ws->pause_mode=PAUSE_MODE_IN_OUT;
      }
    else if ((reg_data & 0x00000800) != 0) {
      /* Asymmetric */
      ws->pause_mode=PAUSE_MODE_IN;
      }
    else {
      ws->pause_mode=PAUSE_MODE_NO;
      }
    }
  else {
    ws->pause_mode=PAUSE_MODE_BACKPRESS;
    }
  return NULL;
}

static _kernel_oserror* configure_link(net_device_t* dev,
                                       net_config_t* cfg)
d383 1
a384 228
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
  _kernel_oserror* e;
  
  dev->status.up = false;
  
  
  /* Reset PHY in another way (PHY_BCR) by writing the according Bit */
  if((e=phy_write(ws,
                  0,
                  0x8000)) != NULL) {
    return e;
    }
  start_time=(unsigned long) regs.r[0];
  do {
    /* Check whether Reset Bit still set */
    if((e=phy_read(ws,
                   0,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(((reg_data & 0x00008000) != 0) &&
        (actual_time - start_time < 100));
  if ((reg_data & 0x00008000) != 0) {
    return err_translate(ERR_BAD_DEVICE);
    }

  /* Give the device some time to recover */
  if ((e=cs_wait(50)) != NULL) {
    return e;
    }

  /* Flush log */
  syslog_flush();

  /* Set up cable polarity handling */
  syslog("set up mdix");
  if(ws->auto_mdix <= AUTO_MDIX_ENABLE) {
    /* Fetch actual PHY special control status (PHY_SPECIAL_CTRL_STS) to modify */
    if((e=phy_read(ws,
                   17,
                   &reg_data)) != NULL) {
      return e;
      }
    switch(ws->auto_mdix) {
      case AUTO_MDIX_DISABLE_STRAIGHT: {
        /* Override (SPECIAL_CTRL_STS_OVRRD_AMDIX_) */
        reg_data |= 0x00008000;
        /* Auto MDIX off (SPECIAL_CTRL_STS_AMDIX_ENABLE_) Crossover off (SPECIAL_CTRL_STS_AMDIX_STATE_) */
        reg_data &= ~(0x00004000 | 0x00002000);
        }
      break;
      case AUTO_MDIX_DISABLE_CROSSOVER: {
        /* Override (SPECIAL_CTRL_STS_OVRRD_AMDIX_) Crossover on (SPECIAL_CTRL_STS_AMDIX_STATE_) */
        reg_data|= (0x00008000 | 0x00002000);
        /* Auto MDIX off (SPECIAL_CTRL_STS_AMDIX_ENABLE_) */
        reg_data&= ~0x00004000;
        }
      break;
      default: {
        /* Override (SPECIAL_CTRL_STS_OVRRD_AMDIX_) Auto MDIX on (SPECIAL_CTRL_STS_AMDIX_ENABLE_) */
        reg_data|=( 0x00008000 | 0x00004000);
        }
      }
    /* Modify PHY special control status (PHY_SPECIAL_CTRL_STS) */
    if((e=phy_write(ws,
                    17,
                    reg_data)) != NULL) {
      return e;
      }
    }
  /* Flush log */
  syslog_flush();

  /* Configure link */
  syslog("configure link");
  if(cfg->autoneg) {
    /* Autonegotiation */
    syslog("autonegotiation");
    dev->status.autoneg=net_autoneg_complete;
    /* Read actual autonegotiation settings (PHY_ANEG_ADV) for modification */
    if((e=phy_read(ws,
                   4,
                   &reg_data)) != NULL) {
      return e;
      }
    reg_data&=0x0000FFFF;
    /* Pause not supported by EtherUSB but should be set for PHY support this */
    /* Clear pause info (not necassary but yes perhaps if enhanced later) */
    reg_data&=~0x00000C00;
    /* Enable pause */
    reg_data|=0x0800;
    reg_data|=0x0400;
    /* Clear speed info */
    reg_data&=~0x000001E0;
    if((dev->abilities.speed_10Mb == 1) && (dev->abilities.half_duplex == 1)) {
      /* 10MB half duplex possible (PHY_ANEG_ADV_10H_) */
      reg_data|=0x0020;
      }
    if((dev->abilities.speed_10Mb == 1) && (dev->abilities.full_duplex == 1)) {
      /* 10MB full duplex possible (PHY_ANEG_ADV_10F_) */
      reg_data|=0x0040;
      }
    if((dev->abilities.speed_100Mb == 1) && (dev->abilities.half_duplex == 1)) {
      /* 100MB half duplex possible (PHY_ANEG_ADV_100H_) */
      reg_data|=0x0080;
      }
    if((dev->abilities.speed_100Mb == 1) && (dev->abilities.full_duplex == 1)) {
      /* 100MB full duplex possible (PHY_ANEG_ADV_100F_) */
      reg_data|=0x0100;
      }
    reg_data&=0x0000FFFF;
    /* Modify autonegotiation settings(PHY_ANEG_ADV) */
    if((e=phy_write(ws,
                    4,
                    reg_data)) != NULL) {
      return e;
      }
    /* Start negotiation (PHY_BCR)
       Enable and Restart */
    reg_data=0x00001000|0x00000200;
    reg_data&=0x0000FFFF;
    if((e=phy_write(ws,
                    0,
                    reg_data)) != NULL) {
      return e;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    start_time=(unsigned long) regs.r[0];
    do {
      /* Check for negotiation completed (PHY_BSR) */
      if((e=phy_read(ws,
                     1,
                     &reg_data)) != NULL) {
        return e;
        }
      if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
        return e;
        }
      actual_time=(unsigned long) regs.r[0];
      }
    while(((reg_data & 0x00000020) == 0) &&
          (actual_time - start_time < 1000));
    if((reg_data & 0x00000020) == 0) {
      return err_translate(ERR_BAD_DEVICE);
      }
    if((e=obtain_autoneg_status(dev)) != NULL) {
      return e;
      }
    }
  else {
    /* Manual configuration */
    syslog("manual setup");
    dev->status.autoneg=net_autoneg_none;
    ws->pause_mode=PAUSE_MODE_NO;
    /* PHY internal only */
    if (ws->phy_address == 1) {
      if((ws->auto_mdix >= AUTO_MDIX_ENABLE) && (ws->mdix_mode_supported)) {
        /* Activate (PHY_SILICON_REV) by modification */
        if((e=phy_read(ws,
                       16,
                       &reg_data)) != NULL) {
          return e;
          }
        /* Extension (PHY_SILICON_REV_AMDIX_XTD_) */
        reg_data|=0x00000001;
        if((e=phy_write(ws,
                        16,
                        reg_data)) != NULL) {
          return e;
          }
       }
      else {
        /* Activate (PHY_SPECIAL_CTRL_STS) by modification */
        if((e=phy_read(ws,
                       27,
                       &reg_data)) != NULL) {
          return e;
          }
        reg_data&=0x00001FFF;
        /* Override (SPECIAL_CTRL_STS_OVRRD_AMDIX_) */
        reg_data|=0x00008000;
        if((e=phy_write(ws,
                        27,
                        reg_data)) != NULL) {
          return e;
          }
        }
      }
    reg_data=0;
    if(cfg->duplex == net_duplex_full) {
      dev->status.duplex=net_duplex_full;
      /* Duplex (PHY_BCR_DUPLEX_MODE_) */
      reg_data|=0x00000100;
      }
    else {
      dev->status.duplex=net_duplex_half;
      ws->pause_mode=PAUSE_MODE_BACKPRESS;
      }
    if(cfg->speed == net_speed_100Mb) {
      dev->status.speed=net_speed_100Mb;
      /* 100Mb (PHY_BCR_SPEED_SELECT_) */
      reg_data|=0x00002000;
      }
    else {
      dev->status.speed=net_speed_10Mb;
      }
    /* Setup PHY accordingly (PHY_BCR) */
    if((e=phy_write(ws,
                    0,
                    reg_data)) != NULL) {
      return e;
      }
    }
  /* Flush log */
  syslog_flush();

  /* Give the device some time to recover */
  if ((e=cs_wait(50)) != NULL) {
    return e;
    }
d407 20
a426 11
  switch(ws->pause_mode) {
    case PAUSE_MODE_IN:
    case PAUSE_MODE_IN_OUT: {
      reg_data=0xFFFF0002;
      }
    break;
    default: {
      reg_data=0;
      }
    break;
    }
d433 9
a441 15
  /* Uppper Bound 15,5 KB        (Bits 16 - 23) Faktor 96
     Lower Bound   3   KB        (Bits  8 - 15) Faktor 96
     Backpressure duration 50us  (Bits  4 -  7) (50us ~ 0x4 = Factor 12.5) recommend for 100Mb
     ANY/ADD/MULT/BRD            (Bits  0 -  3) Type of frames for which backpressure shall be applied */
  switch(ws->pause_mode) {
    case PAUSE_MODE_IN_OUT:
    case PAUSE_MODE_BACKPRESS: {
      reg_data=0x00F83041;
      }
    break;
    default: {
      reg_data=0x00F83040;
      }
    break;
    }
d446 4
a449 1
    }
d451 9
a459 2
  /* Flush log */
  syslog_flush();
d461 31
a491 2
  // cfg->valid=true;
  dev->status.up = 1;
d493 6
a498 1
  return NULL;
a549 7
static _kernel_oserror* device_configure(net_device_t* dev,
                                         const net_config_t* cfg)
{
  return configure_link(dev,
                        (net_config_t*) cfg);
}

d553 1
a553 2
  unsigned long reg_data;
  _kernel_oserror* e;
d555 6
a560 48
  /* Fetch link status (PHY_BSR) */
  if((e=phy_read(ws,
                 1,
                 &reg_data)) != NULL) {
    return e;
    }
  if ((reg_data & 0x00000004) != 0) {
    dev->status.up=true;
    }
  else {
    dev->status.up=false;
    }
  /* Fetch autonegotiation status (PHY_BCR) */
  if((e=phy_read(ws,
                 0,
                 &reg_data)) != NULL) {
    return e;
    }
  if ((reg_data & 0x00001000) != 0) {
    /* Autonegotiation */
    dev->status.autoneg=net_autoneg_complete;
    if((e=obtain_autoneg_status(dev)) != NULL) {
      return e;
      }
    }
  else {
    /* Configured */
    dev->status.autoneg=net_autoneg_none;
    /* Values are determined by settings inside PHY_BCR */
    if((e=phy_read(ws,
                   0,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((reg_data & 0x00000100) != 0) {
      dev->status.duplex=net_duplex_full;
      }
    else {
      dev->status.duplex=net_duplex_half;
      }
    if ((reg_data & 0x00002000) != 0) {
      dev->status.speed=net_speed_100Mb;
      }
    else {
      dev->status.speed=net_speed_10Mb;
      }
    }
  return NULL;
d563 2
a564 1
static callback_delay_t callback_status_adapter(void* w)
d566 3
a568 4
  ws_t* ws = w;

  device_status(ws->dev);
  return 200;
d613 2
a627 1
  net_config_t first_config;
a676 34
  /* ??? PHY determination still missing */
  ws->auto_mdix=AUTO_MDIX_ENABLE;
  /* Special cable handling for LAN9500A */
  if (ws->chip_id == 0x9E00) {
    if (ws->auto_mdix < AUTO_MDIX_ENABLE) {
      ws->mdix_mode_supported=true;
      }
    else {
      ws->mdix_mode_supported=false;
      }
    }
  else {
    ws->mdix_mode_supported=false;
    }
  dev->abilities.speed_10Mb = 1;
  if (dev->speed == USB_SPEED_HI) {
    /* Only at USB high speed */
    dev->abilities.speed_100Mb = 1;
    }
  else {
    dev->abilities.speed_100Mb = 0;
    }
  dev->abilities.half_duplex = 1;
  dev->abilities.full_duplex = 1;
  /* ??? exact determination still required but BB xM definitely can */
  dev->abilities.autoneg     = 1;

  dev->abilities.multicast   = 1;
  /* ??? still to be implemented */
  dev->abilities.promiscuous = 0;

  dev->abilities.loopback    = 1;
  /* ??? SMSC chips can. But where to configure. */
  dev->abilities.tx_rx_loopback = 0;
a680 10
  ws->pause_mode = PAUSE_MODE_NO;

  if (dev->abilities.autoneg == 1) {
    dev->status.autoneg  = net_autoneg_complete;
    first_config.autoneg = net_autoneg_complete;
    }
  else {
    dev->status.autoneg  = net_autoneg_none;
    first_config.autoneg = net_autoneg_none;
    }
d909 1
a909 1
  if(ws->chip_id == 0x9E00) {
d986 1
d990 1
a990 1
                       &reg_data)) != NULL) {
d994 3
a996 3
        if ((reg_data != 0x00007FFF)&&
            (reg_data != 0x0000FFFF)&&
            (reg_data != 0x00000000)) break;
a1008 15
  /* Obtain PHY id information (PHY_ID_2 PHY_ID_1) */
  if((e=phy_read(ws,
                 3,
                 &reg_data)) != NULL) {
    return e;
    }
  ws->phy_id = ((reg_data & 0x0000FC00)<<8);
  if((e=phy_read(ws,
                 2,
                 &reg_data)) != NULL) {
    return e;
    }
  ws->phy_id |= ((reg_data & 0x0000FFFF)<<2);
  syslog("phy_id %lx", ws->phy_id);

d1033 12
a1050 3
  // Install callback to check state periodically.
  callback(&callback_status_adapter, 50, ws);

a1066 3
  /* Stop polling for status. */
  callback_cancel(&callback_status_adapter, ws);

d1118 1
a1118 1
  .status      = device_status
@


1.11
log
@Step change improvement in transmit speed
'usb_upcall_hook_handler' removed filling of tx pipe. This fixes problems of the tx pipe being very slow. It was never needed anyway.
When transmitting, the tx pipe is driven by inserts from the socket driver and transfering that data to USB kicks USB writes into action.
Underflow isn't a problem USB will send as data arrives in the buffer.
Submission from Colin Granville.

Testing with a Raspberry Pi connected via LanManFS to a WinXP server *COPYing a 10MB file from SDFS to Windows, and *COPYing it back to null:
  EtherUSB 0.26  uplink   0.07 MB/s
                 downlink 2.96 MB/s
  This version   uplink   1.31 MB/s
                 downlink 3.05 MB/s
inspection in Wireshark shows no dropped TCP segments or ACKs during the test, previously duplicated ACKs and missing segments would cause most of the uplink slowness while the TCP/IP stack backed off for ~1.5s.
Note: other filing systems and use cases may vary.
In the case of the SMSC91xx backend, ticket #342 remains - sending to a 10Mbps server (even if through a 100Mbps switch) causes dropped segments/duplicated ACKs as before.

usb.c: upcall handler change as above.
smsc91xx.c: typos in comments and debug ammended.


Version 0.29. Tagged as 'EtherUSB-0_29'
@
text
@d1 30
a30 30
/* Copyright (c) 2011 by Thomas Milius Stade, Germany
*                        Raik Fischer Neuenhagen, Germany
*                        Rainer Schubert Ammersbek, Germany
*
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Thomas Milius Stade, Germany, Rainer Schubert Ammersbek, Germany,
*       or Rainer Schubert Ammersbek, Germany nor the names of its contributors
*       may be used to endorse or promote products derived from this software
*       without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Thomas Milius Stade, Germany, Raik Fischer Neuenhagen, Germany
* and Rainer Schubert Ammersbek, Germany ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Thomas Milius Stade, Germany, Raik Fischer Neuenhagen, Germany,
* and Rainer Schubert Ammersbek, Germany BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
d71 3
d89 1
d132 1
a132 1
                                 const unsigned long* data)
a154 1

d169 16
d203 1
a203 1
  if ((reg_data & 0x00000001) != 0) {
d209 1
a209 1
  reg_data= ((ws->phy_address & 0x0000001FL)<<11) | ((reg & 0x001FL)<<6) | 0u;
d276 1
a276 1
  reg_data= ((ws->phy_address & 0x0000001F)<<11) | ((reg & 0x001FL)<<6) | 2;
d303 8
a310 1
static _kernel_oserror* eeprom_is_busy(const ws_t* ws)
a312 2
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
d314 16
a329 27

  /* Check whether EEPROM is busy (in E2P_CMD) */
  if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
    return e;
    }
  start_time=(unsigned long) regs.r[0];
  do {
    if((e=reg_read(ws,
                   0x0030,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((reg_data & 0x80000000) == 0){
      return NULL;
      }
    /* Check for timeout */
    if ((reg_data & 0x00000400) != 0){
      return err_translate(ERR_TIMEOUT);
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(actual_time < (start_time + 100));
  /* Timeout problem */
  return err_translate(ERR_TIMEOUT);
d332 1
a332 4
static _kernel_oserror* read_eeprom(const ws_t* ws,
                                    unsigned long offset,
                                    unsigned long length,
                                    uint8_t *data)
d334 1
a334 4
  int i;
  unsigned long reg_data;
  unsigned long start_time, actual_time;
  _kernel_swi_regs regs;
d337 11
a347 49
  if((offset + length) > ws->eeprom_size) {
    return err_translate(ERR_EEPROM_RANGE);
    }
  /* Check for EEPROM in usage (in E2P_CMD). */
  if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
    return e;
    }
  start_time=(unsigned long) regs.r[0];
  do {
    if((e=reg_read(ws,
                   0x0030,
                   &reg_data)) != NULL) {
      return e;
      }
    if ((e=_kernel_swi(OS_ReadMonotonicTime, &regs, &regs)) != NULL) {
      return e;
      }
    actual_time=(unsigned long) regs.r[0];
    }
  while(((reg_data & 0x80000000) != 0) &&
        ((reg_data & 0x00000200) != 0) &&
        (actual_time < (start_time + 100)));
  if (reg_data & 0x00000200) {
    /* More practical for us to return no error. */
    return NULL;
    }
  if (reg_data & 0x80000000) {
    return err_translate(ERR_TIMEOUT);
    }
  for(i=0; i<length; i++){
    /* Read EEPROM content.
       Requires setting of busy information, read direction and EEPROM position */
    reg_data = 0x80000000 | 0 | ((offset + i) & 0x000001FF);
    if((e=reg_write(ws,
                    0x0030,
                    reg_data)) != NULL) {
      return e;
      }
    if((e=eeprom_is_busy(ws)) != NULL) {
      return e;
      }
    /* Read result of operation (E2P_DATA). */
    if((e=reg_read(ws,
                   0x0034,
                   &reg_data)) != NULL) {
      return e;
      }
    data[i] =(uint8_t)(reg_data & 0xFF);
    }
d455 1
a455 2

  /* No activities in the moment please. */
d457 2
a458 1

d479 1
a479 1
        (actual_time < (start_time + 100)));
d601 1
a601 1
          (actual_time < (start_time + 250)));
d755 5
a759 5
  /* Alloc from stack too big for modules ??? */
  char blk[2048];
  size_t size = sizeof(blk);
  _kernel_oserror* e = usb_read(ws->pipe_rx, blk, &size);
  if (!e && size>4)
d761 22
a782 3
    /* Preceeded by a 4 Byte Status word
       (see SMSC AN1212.pdf for details) */
    net_receive(ws->dev, blk + 4, size - 4, 0);
d784 1
a784 1
  UNUSED(pipe);
d885 1
a885 1
  if (to_write>(usb_buffer_free(ws->pipe_tx))) return err_translate(ERR_TX_BLOCKED);
d1064 8
a1071 16
  /* Default */
  for (i=0; i<ETHER_ADDR_LEN; i++) {
    dev->status.mac[i]=0xFF;
    }
  /* Obtain address from EEPROM */
  if((e=read_eeprom(ws,
                    /* Starts at Position 1 (base 0) */
                    1,
                    /* 6 Bytes */
                    ETHER_ADDR_LEN,
                    dev->status.mac)) != NULL) {
    return e;
    }
  /* Flush log */
  syslog_flush();
  if(!check_mac(dev->status.mac)) {
d1150 21
a1170 22
  /* Setup Burst handling. */
  /* Set Burst capacity (BURST_CAP) */
  if (dev->speed == USB_SPEED_HI) {
    if((e=reg_write(ws,
                    0x0038,
                    37)) != NULL) {
      return e;
      }
    }
  else {
    if((e=reg_write(ws,
                    0x0038,
                    128)) != NULL) {
      return e;
      }
    }
  /* Set Bulk delay (BULK_IN_DLY) */
  if((e=reg_write(ws,
                  0x006C,
                  0x00002000)) != NULL) {
    return e;
    }
d1371 1
d1377 1
a1377 1
                       "Devices#bulk;size16385:$.%s",
d1385 1
a1385 1
                       "Devices#bulk;size16385:$.%s",
d1459 1
a1459 1
  .description = "DescSMC",
@


1.10
log
@Define ETHER_ADDR_LEN
There's an element of duplication between the definitions of net.h and those in TCPIPLibs:net/ethernet.h which would be better to resolve, but for now just mirror its definition locally.
Not tagged.
@
text
@d196 1
a196 1
  /* Wait for completing buy checking BUSY state */
d263 1
a263 1
  /* Wait for completing buy checking BUSY state */
d642 1
a642 1
    syslog("fix setup");
d900 1
a900 1
  /* Is first and last segment of a paket */
d1085 1
a1085 1
                    6,
@


1.9
log
@Internationalised
AutoSense script updated to be able to parse both the hardwired english output (0.08-0.25 inclusive) and internationalised text (0.26+).
Tested RAM loaded on a Raspberry Pi.

Version 0.26. Tagged as 'EtherUSB-0_26'
@
text
@d101 1
a101 1
  unsigned long var_mac[6];
d111 2
a112 2
              &var_mac[5]) == 6) {
      for(i=0;i<6;i++) {
d384 12
a395 12
int i;
bool match;

match=true;
/* 00 00 00 00 00 00 */
i=0;
while(i<6) {
  if (mac[i] != 0x00) {
    match=false;
    break;
    }
  i++;
d397 10
a406 10
if (match) return false;
match=true;
/* FF FF FF FF FF FF */
i=0;
while(i<6) {
  if (mac[i] != 0xFF) {
    match=false;
    break;
    }
  i++;
d408 2
a409 2
if (match) return false;
return true;
d1077 1
a1077 1
  for (i=0; i<6; i++) {
@


1.8
log
@Add more ways of specifying device configuration. Adjust unit number allocation & SMSC MAC handling.
Detail:
  c/smsc95xx - Adjust MAC handling some more:
    - Unit number check removed from EtherUSB$MAC_Configured code in fill_arbitraryMAC(), to increase compatibility with previous version
    - EtherUSB$MAC_Configured check is now performed before the devices currently-programmed MAC is checked; this should ensure it always takes priority over the other methods (especially when reiniting EtherUSB after setting the variable)
    - OS_ReadSysInfo 4 & machine ID hash checks remain in their previous place, after the currently-programmed MAC check
  c/config, h/config:
    - Add support for using EtherUSB$VP_* and EtherUSB$Loc_* system variables to configure devices, by specifying USB vendor/product IDs or USB device tree locations, respectively.
    - Allow config_reserved_units() to select a devices unit number by looking for VP_ or Loc_ system variables.
  c/net, h/net:
    - Add USB device vendor & product ID, and device tree location, to net_device_t struct.
    - Display vendor/product ID & device tree location in verbose ejinfo output
    - Adjust unit number selection: Attempt to select a unit number before calling backend->start, so that the unit number can be used in MAC allocation if required (i.e. by net_default_mac()).
    - Change net_default_mac() to use OS_ReadSysInfo 5 instead of OS_ReadSysInfo 2; OS_ReadSysInfo 2 strips out the first and last byte of the ID, making the psuedo-unique MAC somewhat less unique.
  c/usb, h/usb - Add utility function for reading the location of a device within the USB device tree.
Admin:
  Tested on BB-xM, Raspberry Pi
  Overriding MAC via EtherUSB$MAC_Configured now works as expected (was previously failing due to unit number being MODULE_MAX_UNITS)
  Unit number reservation/selection & device configuration via all three variable types (MAC, VP, Loc) verified


Version 0.24. Tagged as 'EtherUSB-0_24'
@
text
@d113 1
a113 1
         dev->status.mac[i] = (uint8_t)(var_mac[i] & 0xFF);
d132 1
a132 1
  if (DEBUG) syslog("smsc95xx register read %s %d", ws->dev->name, reg);
d143 1
a143 1
  if (DEBUG) syslog("smsc95xx register read value %lx", *data);
d152 1
a152 1
  if (DEBUG) syslog("smsc95xx register write %s %d %lx",
d176 1
a176 1
  if (DEBUG) syslog("smsc95xx phy read %s %d", ws->dev->name, reg);
d213 1
a213 1
      if (DEBUG) syslog("smsc95xx phy read value %lx", *data);
d234 1
a234 1
  if (DEBUG) syslog("smsc95xx phy write %s %d %lx",
d524 1
a524 1
  if (DEBUG) syslog("set up mdix");
d563 1
a563 1
  if (DEBUG) syslog("configure link");
d566 1
a566 1
    if (DEBUG) syslog("autonegotiation");
d642 1
a642 1
    if (DEBUG) syslog("fix setup");
d912 1
a912 1
  if (DEBUG) syslog("smsc95xx open");
d939 1
a939 1
  if (DEBUG) syslog("smsc95xx start");
d977 1
a977 1
  if (DEBUG) syslog("Chip type");
d1036 1
a1036 1
  if (DEBUG) syslog("reset PHY");
d1075 1
a1075 1
  if (DEBUG) syslog("mac handling");
d1106 4
a1109 4
    dev->status.mac[0]=(uint8_t)(reg_data & 0xFF);
    dev->status.mac[1]=(uint8_t)((reg_data >> 8) & 0xFF);
    dev->status.mac[2]=(uint8_t)((reg_data >> 16) & 0xFF);
    dev->status.mac[3]=(uint8_t)((reg_data >> 24) & 0xFF);
d1116 2
a1117 2
    dev->status.mac[4]=(uint8_t)(reg_data & 0xFF);
    dev->status.mac[5]=(uint8_t)((reg_data >> 8) & 0xFF);
d1153 1
a1153 1
  if (DEBUG) syslog("set up");
d1169 1
a1169 1
  if (DEBUG) syslog("burst");
d1192 1
a1192 1
  if (DEBUG) syslog("set up 2");
d1205 1
a1205 1
  if (DEBUG) syslog("enable TX");
d1228 1
a1228 1
  if (DEBUG) syslog("enable RX");
d1256 1
a1256 1
  if (DEBUG) syslog("LEDs");
d1276 1
a1276 1
  if (DEBUG) syslog("filter RX");
d1310 1
a1310 1
  if (DEBUG) syslog("set up PHY");
d1383 1
a1383 1
  if (DEBUG) syslog("phy_id %lx", ws->phy_id);
d1391 1
a1391 1
  if (DEBUG) syslog("RISC OS USB");
d1431 1
a1431 1
  if (DEBUG) syslog("smsc95xx stop");
d1470 1
a1470 1
  if (DEBUG) syslog("smsc95xx close");
d1479 1
a1479 1
  .description = "SMSC 95xx",
d1493 1
a1493 1
  if (DEBUG) syslog("smsc95xx register");
@


1.7
log
@Remove redundant code
Detail:
  c/smsc95xx - Removed old code that was setting the MAC address via OS_ReadSysInfo 4. Code now correctly uses the logic described previously.
Admin:
  Tested on Raspberry Pi


Version 0.23. Retagged as 'EtherUSB-0_23'
@
text
@a97 2
// routine to fill MAC with default or with variable, if <EtherUSB$MAC_Configured> exists

a102 1
  unsigned int unit = dev->dib.dib_unit; 
d104 1
a104 1
  if (!unit && ((p=getenv("EtherUSB$MAC_Configured")) != (char *) NULL)) {
a119 7

  // try the machines configured MAC (e.g. for builtin SMSC on Raspberry Pi)
  if (net_machine_mac(dev->status.mac))
    return;

  // try to construct a MAC from machine ID
  net_default_mac(unit, dev->status.mac);
d1092 6
d1120 8
a1127 2
    fill_arbitraryMAC(dev);
    }
@


1.6
log
@Improve SMSC MAC selection
Detail:
  c/net, h/net - Make net_default_mac() non-static. Add net_machine_mac() function for looking up MAC by OS_ReadSysInfo 4.
  c/smsc95xx - Change MAC selection logic. Old order was OS_ReadSysInfo 4 -> EtherUSB$MAC_Configured -> 100% hardcoded default. New order is EtherUSB$MAC_Configured -> OS_ReadSysInfo 4 -> hashed machine ID + unit number -> hardcoded default (with unit number). This new logic means BB-xM's should now have unique MACs instead of all sharing the same MAC.
Admin:
  Tested on BB-xM, Raspberry Pi. Raspberry Pi retains the MAC that's specified by the firmware, while the BB-xM now uses the hashed machine ID instead of the hardcoded default.
  Based on changes supplied by Willi Theiss.


Version 0.23. Tagged as 'EtherUSB-0_23'
@
text
@a1123 5
    _kernel_oserror *e = _swix(OS_ReadSysInfo, _IN(0)|_OUTR(0,1),
                               4,
                               ((char*)(&dev->status.mac[0])), ((char*)(&dev->status.mac[4])));
    }
  if(!check_mac(dev->status.mac)) {
@


1.5
log
@Detail:
	Added call to read MAC address from kernel (machineID) if nothing
	available in eeprom.
Admin:
	tested in RPi build


Version 0.20. Tagged as 'EtherUSB-0_20'
@
text
@d93 3
d100 1
a100 1
void fill_arbitraryMAC(net_device_t* dev)
a103 1
  bool set_by_var;
d105 1
d107 1
a107 2
  set_by_var=false;
  if ((p=getenv("EtherUSB$MAC_Configured")) != (char *) NULL) {
a114 1
      set_by_var=true;
d118 1
d123 7
a129 14
  if (!set_by_var) {
    /* Ultima ratio: using arbitrary local MAC (LAA)
       02 07 21 68 16 03
       LAA
          RISC OS territory
             Postal code
                   Birthday */
    dev->status.mac[0]=0x02;
    dev->status.mac[1]=0x07;
    dev->status.mac[2]=0x21;
    dev->status.mac[3]=0x68;
    dev->status.mac[4]=0x16;
    dev->status.mac[5]=0x03;
    }
d392 1
a392 1
bool check_mac(uint8_t *mac)
d806 1
d814 1
d934 1
d1424 1
@


1.4
log
@Save 4.5kB by making the table of errors with objasm (so they're not all padded to 252 bytes by the compiler to fit into _kernel_oserror structs).
The 'moduleerr.s' source should be made redundant by internationalising the module.

Version 0.17. Tagged as 'EtherUSB-0_17'
@
text
@d1126 5
@


1.3
log
@Uses common USB header files exported by the USB stack.
Use ModHand/Variables/RISCOS/OsByte headers.
Note, this has meant some header files needed reordering to prevent circular dependencies.

Version 0.15. Tagged as 'EtherUSB-0_15'
@
text
@d200 1
a200 1
    return &err_mii_in_use;
d237 1
a237 1
  return &err_timeout;
d261 1
a261 1
    return &err_mii_in_use;
d296 1
a296 1
  return &err_timeout;
d322 1
a322 1
      return &err_timeout;
d331 1
a331 1
  return &err_timeout;
d346 1
a346 1
    return &err_eeprom_range;
d372 1
a372 1
    return &err_timeout;
d527 1
a527 1
    return &err_bad_device;
d649 1
a649 1
      return &err_bad_device;
d910 1
a910 1
  if (to_write>(usb_buffer_free(ws->pipe_tx))) return &err_tx_blocked;
d918 1
a918 1
  return (to_write==0) ? &err_tx_blocked : NULL;
d926 1
a926 1
  if (!options) return &err_unsupported;
d929 1
a929 1
  if (!ws) return &err_no_memory;
d986 1
a986 1
    return &err_timeout;
d1081 1
a1081 1
    return &err_timeout;
d1361 1
a1361 1
        return &err_bad_phy;
@


1.2
log
@Brought under srccommit control for update of version numbers.
Makefile recreated from fragments
CMHG file renamed to avoid needing special rule to tell where it is.

Version 0.14. Tagged as 'EtherUSB-0_14'
@
text
@d47 1
a47 1
#include "stdio.h"
a54 1
#include "net.h"
d56 1
d58 1
d921 3
a923 3
static _kernel_oserror* device_open(const usb_service_t* dev,
                                    const char*          options,
                                    void**               private)
@


1.1
log
@Import of sources to EtherUSB.
Special thanks to James Peacock for allowing ROOL to host these sources.
This import represents version 0.13 by James and the backend contributors, the only change being that the makefile wipes the directories it creates on cleaning so there's no need to import those to CVS.
Tagged as jpeacock-0_13.
@
text
@d54 1
a57 1
#include "module.h"
a58 1
#include "version.h"
d535 1
a535 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d574 1
a574 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d719 1
a719 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d786 1
a786 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1083 1
a1083 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1101 1
a1101 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1149 1
a1149 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1167 1
a1167 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1201 1
a1201 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1224 1
a1224 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1252 1
a1252 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1306 1
a1306 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
d1387 1
a1387 1
  _swix(0x4c882, _IN(0), MODULE_NAME);
@


head	1.7;
access;
symbols
	EtherUSB-0_41:1.7
	EtherUSB-0_40:1.7
	EtherUSB-0_39:1.7
	EtherUSB-0_38:1.7
	EtherUSB-0_37:1.7
	EtherUSB-0_36:1.7
	EtherUSB-0_35:1.6
	EtherUSB-0_34:1.6
	EtherUSB-0_33:1.6
	EtherUSB-0_32:1.6
	EtherUSB-0_31:1.6
	EtherUSB-0_30:1.6
	EtherUSB-0_29:1.6
	EtherUSB-0_28:1.6
	EtherUSB-0_27:1.6
	EtherUSB-0_26:1.6
	EtherUSB-0_25:1.5
	EtherUSB-0_24:1.5
	EtherUSB-0_23:1.5
	EtherUSB-0_22:1.5
	EtherUSB-0_21:1.5
	EtherUSB-0_20:1.5
	EtherUSB-0_19:1.5
	EtherUSB-0_18:1.5
	EtherUSB-0_17:1.5
	EtherUSB-0_16:1.4
	EtherUSB-0_15:1.3
	EtherUSB-0_14:1.3
	jpeacock-0_13:1.1;
locks; strict;
comment	@# @;


1.7
date	2016.02.29.10.37.07;	author bavison;	state Exp;
branches;
next	1.6;
commitid	oAHZMQOdmovfANWy;

1.6
date	2013.10.13.13.54.42;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	cLeOtNKk3nePB89x;

1.5
date	2012.05.19.08.44.28;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	6JuVMhjS8DSNlj5w;

1.4
date	2012.05.19.08.42.21;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	1BHJUY7zoQz3lj5w;

1.3
date	2012.05.19.08.30.24;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	R1EOINZ5A36Ygj5w;

1.2
date	2012.05.19.08.22.13;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	SzPjH7uh6hKVdj5w;

1.1
date	2012.05.19.08.19.07;	author rsprowson;	state Exp;
branches;
next	;
commitid	q3rEKeu2RrS2cj5w;


desc
@@


1.7
log
@  Support ARMv8
Detail:
  This module previously used both SWP and SWPB instructions, which have
  been withdrawn in ARMv8. Now use SyncLib to provide the equivalent
  functionality, which will use LDREX/STREX or LDREXB/STREXB instead when
  appropriate.
Admin:
  Tested on Raspberry Pi 3.

Version 0.36. Tagged as 'EtherUSB-0_36'
@
text
@//
// Copyright (c) 2006, James Peacock
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met: 
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of RISC OS Open Ltd nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//

#include <stdarg.h>
#include <stdio.h>
#include <stdbool.h>
#include "swis.h"
#include "SyncLib/SyncLib.h"

#include "module.h"
#include "utils.h"

// This is generated by CMHG
#include "EtherUSBHdr.h"

#define DADEBUG 0
#define SYSLOG 1
#define TIMERMOD 0

#if DEBUG
static unsigned s_sec  = 0;
static unsigned s_msec = 0;

void syslog(const char* fmt, ...)
{
  char blk[256];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(blk, sizeof(blk), fmt, ap);
  va_end(ap);

  void (*write_fn)(char) = NULL;
  if (DADEBUG && !_swix(0x531c0, _OUT(0), &write_fn))
  {
    unsigned sec  = 0;
    unsigned msec = 0;
    if (TIMERMOD && !_swix(0x490c2, _OUTR(0,1), &sec, &msec))
    {
      char blk2[20];
      snprintf(blk2, sizeof(blk2),
               "%10u.%06u: ",
               sec-s_sec,
               msec>s_msec ? msec-s_msec : s_msec-msec);

      s_sec  = sec;
      s_msec = msec;
      const char* ch = blk2;
      while (*ch) write_fn(*ch++);
    }

    const char* ch = blk;
    while (*ch) write_fn(*ch++);
    write_fn('\r');
    write_fn('\n');
  }
  if (SYSLOG && !_swix(0x4c88e, _IN(0), 1))
  {
    _swix(0x4c880, _INR(0,2), Module_Title, blk, 64);
    _swix(0x4c88e, _IN(0), 0);
  }
}

void syslog_data(const void* data, size_t size)
{
  if (SYSLOG && !_swix(0x4c88e, _IN(0), 1))
  {
    _swix(0x4c88a, _INR(0,4), Module_Title, 64, data, size, 0);
    _swix(0x4c88e, _IN(0), 0);
  }
}

void syslog_flush(void)
{
  _swix(0x4c882, _IN(0), Module_Title);
}
#endif

_kernel_oserror* cs_wait(uint32_t centiseconds)
{
  uint32_t start;
  _kernel_oserror* e = _swix(OS_ReadMonotonicTime, _OUT(0), &start);
  if (e) return e;

  while(true)
  {
    uint32_t now;
    e = _swix(OS_ReadMonotonicTime, _OUT(0), &now);
    if (e || ((now-start)>centiseconds)) break;
  }
  return e;
}


// Defined in asm.s
extern void asm_ticker_handler(void*);

// Must match asm.s
#define CALLBACK_STATE_UNREQUIRED 0u
#define CALLBACK_STATE_REQUIRED   1u
#define CALLBACK_STATE_PENDING    2u

// The first three words of this structure are accessed from a ticker event
struct callback
{
  void (*handler)(void);     // Address to call.
  void*             r12;     // Value of r12 to call with.
  volatile uint32_t state;   // State, changed by asm ticker handler, 1->2
};

// Holds data for pending calls.
typedef struct callback_t
{
  struct callback_t* prev;
  struct callback_t* next;
  callback_fn*       fn;
  void*              handle;
  uint32_t           time;
} callback_t;

static struct callback s_callback;
static bool            s_ticker        = false;
static callback_t*     s_callback_list = NULL;


static _kernel_oserror* callback_request_now(void)
{
  // Need to stop ticker getting in the way here, otherwise we might
  // schedule two callbacks.
  uint32_t current_state = atomic_update(CALLBACK_STATE_PENDING, &s_callback.state);
  _kernel_oserror* e = NULL;
  __asm
  {
    TEQ        current_state,#CALLBACK_STATE_PENDING
    BEQ        asm_exit
    MOV        R0,s_callback.handler
    MOV        R1,s_callback.r12
    SWI        OS_AddCallBack | XOS_Bit, {R0-R1}, {R0, PSR}, {LR}
    MOVVS      e,R0
    MOVVS      s_callback.state, current_state
  asm_exit:
  }
  return e;
}

_kernel_oserror* callback_initialise(void* private_word)
{
  if (s_ticker) return NULL;
  s_callback.handler = &callback_hook;
  s_callback.r12 = private_word;
  s_callback.state = CALLBACK_STATE_UNREQUIRED;

  _kernel_oserror* e = _swix(OS_CallEvery, _INR(0,2),
                             CALLBACK_TICKER_FREQ,
                             &asm_ticker_handler,
                             &s_callback);
  if (e) return e;

  s_ticker = true;
  return NULL;
}

_kernel_oserror* callback_finalise(void)
{
  if (s_ticker)
  {
    _kernel_oserror* e = _swix(OS_RemoveTickerEvent, _INR(0,1),
                               &asm_ticker_handler, &s_callback);
    if (e) return e;
    s_ticker = false;
  }

  if (s_callback.state == CALLBACK_STATE_PENDING)
  {
    _kernel_oserror* e = _swix(OS_RemoveCallBack, _INR(0,1),
                               s_callback.handler, s_callback.r12);
    if (e) return e;
    s_callback.state = CALLBACK_STATE_UNREQUIRED;
  }

  while (s_callback_list)
  {
    callback_t* c = s_callback_list;
    LINKEDLIST_REMOVE(s_callback_list, c);
    xfree(c);
  }

  return NULL;
}

_kernel_oserror* callback(callback_fn* fn, uint32_t cs_delay, void* handle)
{
  uint32_t now;
  _kernel_oserror* e = _swix(OS_ReadMonotonicTime, _OUT(0), &now);
  if (e) return e;

  callback_t* cb = xalloc(sizeof(callback_t));
  if (!cb) return err_translate(ERR_NO_MEMORY);

  cb->fn = fn;
  cb->handle = handle;
  cb->time = now + cs_delay;

  LINKEDLIST_INSERT(s_callback_list, cb);

  if (cs_delay==CALLBACK_ASAP)
  {
    return callback_request_now();
  }
  else
  {
    if (s_callback.state==CALLBACK_STATE_UNREQUIRED)
      s_callback.state = CALLBACK_STATE_REQUIRED;
  }
  return NULL;
}



_kernel_oserror* callback_cancel(callback_fn*     fn,
                                 void*            handle)
{
  callback_t* next = s_callback_list;
  while (next)
  {
    callback_t* c = next;
    next = next->next;
    if (c->fn==fn && c->handle==handle)
    {
      LINKEDLIST_REMOVE(s_callback_list, c);
      xfree(c);
      break;
    }
  }
  return NULL;
}


_kernel_oserror *callback_hook_handler(_kernel_swi_regs *r, void *pw)
{
  // In transient callback, no where to send errors... The callback state
  // should be pending - so the ticker handler won't touch the state.
  uint32_t now;
  _kernel_oserror* e = _swix(OS_ReadMonotonicTime, _OUT(0), &now);
  if (e) return NULL;

  bool asap = false;

  callback_t* next = s_callback_list;
  while (next)
  {
    callback_t* c = next;
    next = next->next;
    if (now>=c->time && (now - c->time) < 0x80000000)
    {
      uint32_t cs_delay = c->fn(c->handle);
      if (cs_delay==CALLBACK_REMOVE)
      {
        LINKEDLIST_REMOVE(s_callback_list, c);
        xfree(c);
      }
      else
      {
        c->time = now + cs_delay;
        if (cs_delay==CALLBACK_ASAP) asap = true;
      }
    }
  }

  s_callback.state = s_callback_list
    ? CALLBACK_STATE_REQUIRED
    : CALLBACK_STATE_UNREQUIRED;

  if (asap) callback_request_now();

  UNUSED(r);
  UNUSED(pw);

  return NULL;
}
@


1.6
log
@Internationalised
AutoSense script updated to be able to parse both the hardwired english output (0.08-0.25 inclusive) and internationalised text (0.26+).
Tested RAM loaded on a Raspberry Pi.

Version 0.26. Tagged as 'EtherUSB-0_26'
@
text
@d33 1
d154 1
a154 1
  uint32_t current_state;
a157 1
    SWP        current_state,CALLBACK_STATE_PENDING,[&s_callback.state]
@


1.5
log
@Save 4.5kB by making the table of errors with objasm (so they're not all padded to 252 bytes by the compiler to fit into _kernel_oserror structs).
The 'moduleerr.s' source should be made redundant by internationalising the module.

Version 0.17. Tagged as 'EtherUSB-0_17'
@
text
@a28 3
#include "utils.h"
#include "module.h"

d32 1
d34 2
a35 1
#include "swis.h"
d44 1
a47 1

d100 1
@


1.4
log
@Added autosense, and autosense install rule to makefile.
Now uses AsmUtils for irqs_on/irqs_off
Squash a few unused variable warnings, not in the backends though as porting updates would be more complex for those that come from (for example) NetBSD.
Changed to use structure definitions from sys/dcistructs.h (mostly an exercise in prefixing member names).

Version 0.16. Tagged as 'EtherUSB-0_16'
@
text
@d222 1
a222 1
  if (!cb) return &err_no_memory;
@


1.3
log
@Brought under srccommit control for update of version numbers.
Makefile recreated from fragments
CMHG file renamed to avoid needing special rule to tell where it is.

Version 0.14. Tagged as 'EtherUSB-0_14'
@
text
@d299 4
@


1.2
log
@Explicit BSD licence heading blocks added to those source files that did not have them.
No code changes, not tagged.
@
text
@a28 3
/*
 * Assorted utility functions.
 */
a29 1
#include "version.h"
d39 1
a39 1
#include "autogen/header"
d83 1
a83 1
    _swix(0x4c880, _INR(0,2), MODULE_NAME, blk, 64);
d92 1
a92 1
    _swix(0x4c88a, _INR(0,4), MODULE_NAME, 64, data, size, 0);
d97 5
@


1.1
log
@Import of sources to EtherUSB.
Special thanks to James Peacock for allowing ROOL to host these sources.
This import represents version 0.13 by James and the backend contributors, the only change being that the makefile wipes the directories it creates on cleaning so there's no need to import those to CVS.
Tagged as jpeacock-0_13.
@
text
@d1 30
a30 3
/* Assorted utility functions.
 *
 * (C) James Peacock, 2006.
@


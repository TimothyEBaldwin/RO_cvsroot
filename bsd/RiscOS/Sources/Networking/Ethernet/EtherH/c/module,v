head	1.8;
access;
symbols
	EtherH-4_59:1.8
	EtherH-4_58:1.8
	EtherH-4_57:1.7
	EtherH-4_56:1.6
	EtherH-4_55:1.5
	EtherH-4_54:1.4
	EtherH-4_53:1.3
	EtherH-4_52:1.1.1.1
	designit-4_52:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2012.10.13.21.06.46;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	gRDzXRcm019sJgow;

1.7
date	2012.10.13.21.01.18;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	x8Jt9KAXLv3CHgow;

1.6
date	2012.10.13.20.58.34;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	622MTy7PdZDGGgow;

1.5
date	2012.10.13.20.55.23;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	iWEN5VZZYRYzFgow;

1.4
date	2012.10.13.20.49.25;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	wW7NhIHyp8SxDgow;

1.3
date	2012.10.13.20.45.41;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	1E7Khr6vvCWfCgow;

1.2
date	2012.10.13.20.41.18;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	wjgMh8kSS5QCAgow;

1.1
date	2012.10.13.20.36.27;	author rsprowson;	state Exp;
branches
	1.1.1.1;
next	;
commitid	K58crg30YaBxygow;

1.1.1.1
date	2012.10.13.20.36.27;	author rsprowson;	state Exp;
branches;
next	;
commitid	K58crg30YaBxygow;


desc
@@


1.8
log
@Internationalised
Enabled podule speed setting code to ensure speed A.
In tx_done(), don't assume anything about the opaque value from ensure_irqs_off().
Fixed looping in eh_init() to not turn off interrupts repeatedly for non present podules, also removed the call to Podule_ReadID since Podule_ReadHeader will error if there is no podule fitted anyway.
Tested on RISC OS 3.70 and RISC OS 5.19, 10000+ pings, and doing some file transfer loops via LanManFS.

Version 4.58. Tagged as 'EtherH-4_58'
@
text
@/*
 * Copyright (c) 2002, Design IT
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**************************************************************************
 * Title:       RISC OS Ethernet Driver Source
 * Author:      Douglas J. Berry, Gary Stephenson
 * File:        module.c
 *
 * Copyright © 1992 PSI Systems Innovations
 * Copyright © 1994 i-cubed Limited
 * Copyright © 1994 Network Solutions
 * Copyright © 2000 Design IT
 *
 ************************************************************************/

/*
 * Initial code supplied by Acorn Computers Ltd
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <kernel.h>
#include <swis.h>
#include "Global/Services.h"
#include "AsmUtils/irqs.h"

#include <sys/types.h>
#include <sys/dcistructs.h>
#include <sys/errno.h>
#include <sys/mbuf.h>

#include "if_eh.h"
#include "Init.h"
#include "EtherHHdr.h"
#include "module.h"

/* #define DEBUG */

struct swient {
        int (*swi_call)(_kernel_swi_regs *);      /* swi handler */
};

static struct swient eh_ent[] = {
    eh_dciversion,
    eh_inquire,
    eh_getnetworkmtu,
    eh_setnetworkmtu,
    eh_transmit,
    eh_filter,
    eh_stats,
    eh_multicastrequest,
    NULL
};

/*
 * Public data.
 */
extern void *eh_messages(void); /* Generated by 'resgen' */
volatile int mbuf_present = FALSE;
void *module_wsp = NULL;
struct mbctl MBCTL =
{
        0,                              /* opaque */
        sizeof(struct mbctl),           /* mbcsize */
        MBUF_MANAGER_VERSION,           /* mbcvers */
        0ul,                            /* flags */
        MINCONTIG,                      /* advminubs */
        ETHERMTU,                       /* advmaxubs */
        MINCONTIG,                      /* mincontig */
        0ul,                            /* spare1 */
        /*
         * Rest of the structure gets initialised
         * to zeroes due to the trailing comma
         */
};


/*
 * mb_present - check whether the mbuf manager is present or not,
 * using the Mbuf_Control SWI to do so.  returns 1 if manager
 * present, else 0.
 */
static int mb_present(void)
{
    _kernel_swi_regs r;

    /*
     * the control SWI with reason code 0 should *always*
     * succeed if the mbuf manager is loaded.
     */
    r.r[0] = 0;
    return((_kernel_swi(XOS_Bit | Mbuf_Control, &r, &r) == NULL) ? 1 : 0);
}


/*
 * mbuf memory manager session initialisation
 */
_kernel_oserror *mb_entryinit(void)
{
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_OpenSession, &r, &r);
}


/*
 * mbuf memory manager session termination
 */
_kernel_oserror *mb_closesession(void)
{
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_CloseSession, &r, &r);
}


/*
 * mbuf memory manager module initialisation
 */
static _kernel_oserror *init_mmanager(void)
{
    _kernel_oserror *e = NULL;

    /*
     * first see if mbuf manager module is present
     */
    if (mbuf_present == FALSE)
    {
        if (mb_present())
        {
            /* then try to open a session with it */
            e = mb_entryinit();
            if (e == NULL)
            {
              mbuf_present = TRUE;
#ifdef DEBUG
              printf("debug: mbuf session opened &MBCTL:%x\n",(int)&MBCTL);
#endif
            }
        }
    }
    return(e);
}


/*
 * Convert EUI48 to printable representation.
 */
const char *eh_sprint_mac(const u_char *ap)
{
        int i;
        static char etherbuf[18];
        char *cp = etherbuf;
        static const char digits[] = "0123456789abcdef";

        for (i = 0; i < 6; i++) {
                *cp++ = digits[*ap >> 4];
                *cp++ = digits[*ap++ & 0xf];
                *cp++ = ':';
        }
        *--cp = 0;
        return (etherbuf);
}


/*
 * Module Finalization code
 * OSS 4.52 20 Nov 2002 Made into a real module finalisation with new
 * cmhg keyword, not an at_exit() handler.
 */
_kernel_oserror * eh_finalise(int fatal, int podule, void *pw)
{
    _kernel_swi_regs r;

    eh_final(pw);

#ifndef ROM
    /* Deregister the messages for RAM based modules */
    r.r[0] = (int)eh_messages();
    _kernel_swi(XOS_Bit | ResourceFS_DeregisterFiles, &r, &r);
#endif

    UNUSED(fatal);
    UNUSED(podule);
    
    return NULL;
}


/*
 * Module Initialization code.
 */
_kernel_oserror *eh_initialise(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e = NULL;
    _kernel_swi_regs r;
    module_wsp = pw;
    /*
     * If module has been loaded from ROM then pbase != 0,
     * so rely on postinit service call to tidy things up later, e.g. setting
     * DCR register on 600 card into proper state
     * unless we have been reinited from a podule in which case there isn't a postinit!
     */
    if (pbase == 0)
       pre_init = FALSE;

#ifndef ROM
    /* Register the messages for RAM based modules */
    r.r[0] = (int)eh_messages();
    e = _kernel_swi(XOS_Bit | ResourceFS_RegisterFiles, &r, &r);
    if (e != NULL) return e;
#endif

    eh_init();
    if (ehcnt == 0)
    {
        e = eh_error(INETERR_IFBAD);
    }

    if (e == NULL)
    {
        e = init_mmanager();
#ifdef DEBUG
        printf("debug: mbuf manager init %s\n", (e == NULL) ? "OK" : "fail");
#endif
    }

#ifndef ROM
    if (e != NULL)
    {
        r.r[0] = (int)eh_messages();
        _kernel_swi(XOS_Bit | ResourceFS_DeregisterFiles, &r, &r);
    }
#endif

    UNUSED(cmd_tail);
    
    return(e);
}


/*
 * Module Service Call handler
 */
void eh_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    struct eh_softc *eh;
    struct chaindib *chdib, *oldhead;
    u_char *private;
    int i, status;

    switch(sn) {
        case Service_EnumerateNetworkDrivers:
            /* only respond to this if pre_init is FALSE because we haven't actually
             * completed the initialisiation yet
             */

            if (pre_init == FALSE)
            {
                oldhead = (ChDibRef) r->r[0];
#ifdef DEBUG
                printf("debug: Service_EnumerateNetworkDrivers pre_init %d oldhead:%x\n", pre_init, (int) oldhead);
#endif

                /* for (i = 0; i < ehcnt; i++) */
                for (i = ehcnt-1; i > -1; i--)
                {
                    eh = eh_softc[i];
                    chdib = (ChDibRef) malloc(sizeof(ChDib));
                    if (chdib != NULL)
                    {
                       chdib->chd_next = oldhead;
                       chdib->chd_dib = eh->eh_dib;
                       oldhead = chdib;
                    }
                }

                r->r[0] = (int)oldhead;
#ifdef DEBUG
                printf("debug: Service_EnumerateNetworkDrivers oldhead:%x\n", (int)oldhead);
#endif
            }
            break;

        case Service_DCIProtocolStatus:
            private = (u_char *) r->r[0];
            status = r->r[2];
#ifdef DEBUG
            printf("debug: Service_DCIProtocolStatus private ptr:%x status:%x\n",(int)private, status);
#endif
            if (status == DCIPROTOCOL_DYING)
            {
                /* protocol module is terminating */
                for (i = 0; i < ehcnt; i++)
                {
#ifdef DEBUG
                    printf("debug: private:%x i:%d\n",(int) private, i);
#endif
                    free_filter(eh_softc[i], -1, private);
                }
            }
            break;

        case Service_MbufManagerStatus:
#ifdef DEBUG
            printf("debug: mbuf manager service call:%x\n",r->r[0]);
#endif
            switch (r->r[0]) {
                case MbufManagerStatus_Started:
                    init_mmanager();
                    break;

                case MbufManagerStatus_Stopping:
                    mb_closesession();
                    mbuf_present = FALSE;
                    break;

                default:
                    break;
            }
            break;

        case Service_PreReset:
            pre_reset = TRUE;
            eh_softreset();
            break;

        case Service_PostInit:
            eh_postinit();
            break;

        default:
            break;
    }
    
    UNUSED(pw);
}


/*
 * Module SWI handler
 */
_kernel_oserror *eh_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int    error, oldstate;

    if (swinum >= (sizeof(eh_ent) / sizeof(struct swient)))
        return error_BAD_SWI;

    if (ehcnt == 0)
    {
        SETDCI4ERRNO(error, ENXIO);
    }
    else
    {
        callp = &eh_ent[swinum];
        oldstate = ensure_irqs_on();
        error = (*(callp->swi_call))(r);
        restore_irqs(oldstate);
    }

    UNUSED(pw);

    return eh_error(error);
}


/*
 * Module CLI handler
 */
_kernel_oserror *eh_cli_handler(const char *arg_string, int arg_count, int cmd_no, void *pw)
{
   if (ehcnt == 0)
       return eh_error(INETERR_IFBAD);
   else
   {
       switch(cmd_no) {
           case CMD_EHInfo:
               eh_statshow();
               break;

           case CMD_EHTest:
               eh_ehtest();
               break;

#ifdef DRIVER16BIT
           case CMD_EHVirtual:
               return eh_cmos_virtual(arg_string, arg_count);

           case CMD_EHConnection:
               /* OSS 16 June 2001 *Configure EHConnection for E600 cards */
               return eh_cmos_connection(arg_string, arg_count);
#endif
           default:
               break;
       }
   }

   UNUSED(pw);
#ifdef DRIVER8BIT
   UNUSED(arg_count);
   UNUSED(arg_string);
#endif
   
   return NULL;
}


/*
 * Module error handler
 */
_kernel_oserror *eh_error(int error)
{
    static _kernel_oserror _eh_errblk = { 0, "" };
    _kernel_swi_regs r;
    int msgtrans_control[4];
    char token[5], number[9];

    if (error)
    {
        /* An error occurred */
        r.r[0] = (int)msgtrans_control;
        r.r[1] = (int)Module_MessagesFile;
        r.r[2] = 0;
        if (_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r) == NULL)
        {
            /* Lookup the error */
            sprintf(token, "E%d", error & 0xFF);
            sprintf(number, "%X", error);
            r.r[0] = (int)msgtrans_control;
            r.r[1] = (int)token;
            r.r[2] = (int)_eh_errblk.errmess;
            r.r[3] = sizeof(_eh_errblk.errmess);
            r.r[4] = (int)number; /* Catchall internal error */ 
            _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r);

            r.r[0] = (int)msgtrans_control;
            _kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
        }
        else
        {
            /* Can't open the messages, use english */
            sprintf(_eh_errblk.errmess, "EtherH module error &%X", error);
        }
        _eh_errblk.errnum = error;
        return &_eh_errblk;
    }
    return NULL;
}


/*
 * Module message lookup
 */
const char *eh_message(int id, const char *arg0, const char *arg1, const char *arg2)
{
    static char string[128];
    _kernel_swi_regs r;
    int msgtrans_control[4];
    char token[5];

    /* An error occurred */
    r.r[0] = (int)msgtrans_control;
    r.r[1] = (int)Module_MessagesFile;
    r.r[2] = 0;
    if (_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r) == NULL)
    {
        /* Lookup the error */
        sprintf(token, "M%d", id);
        r.r[0] = (int)msgtrans_control;
        r.r[1] = (int)token;
        r.r[2] = (int)string;
        r.r[3] = sizeof(string);
        r.r[4] = (int)arg0;
        r.r[5] = (int)arg1;
        r.r[6] = (int)arg2;
        _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r);

        r.r[0] = (int)msgtrans_control;
        _kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
    }
    else
    {
        /* Can't open the messages, return something */
        sprintf(string, "EtherH module message &%X", id);
    }
    return string;
}


/* EOF module.c */
@


1.7
log
@Recoded MICRODELAY to be processor speed/cache agnostic
Checked on a scope doing groups of 250/125/62us delays with interrupts disabled, wiggling an IO line.
Get podule/MEMC logical addresses from Podule_ReadInfo (falls back to table for pre RISC OS 3.50).

Version 4.57. Tagged as 'EtherH-4_57'
@
text
@d84 1
d202 2
d206 6
d225 1
d236 7
d245 3
a247 1
        return (_kernel_oserror *)"\0\0\0\0No EtherH supported hardware found";
d249 3
d253 1
a253 1
    printf("debug: now init mbuf manager\n");
d255 8
a262 3
    e = init_mmanager();
#ifdef DEBUG
    printf("debug: mbuf manager inited\n");
d291 1
a291 1
            printf("debug: Service_EnumerateNetworkDrivers pre_init %d oldhead:%x\n", pre_init, (int) oldhead);
d309 1
a309 1
            printf("debug: Service_EnumerateNetworkDrivers oldhead:%x\n", (int)oldhead);
d375 1
a375 1
    int error, oldstate;
d379 1
a382 1
        return (eh_error(error));
d384 7
a390 4
    callp = &eh_ent[swinum];
    oldstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(oldstate);
d394 1
a394 1
    return(eh_error(error));
d404 1
a404 1
       printf("No EtherH expansion cards installed\n");
d409 1
a409 1
               prenstats();
d445 3
d449 26
a474 1
    if (error) {
a475 1
        sprintf(_eh_errblk.errmess, "EtherH module error (0x%x)", error);//@@@@
d482 39
@


1.6
log
@32 bitted the assembler
Only a couple of places make OS interface calls, everything else is called from APCS-32 C, so doesn't need to flag preserve.
Fixed *CONFIGURE output to not show a "Syntax:" error prefix.
Now uses device number queried from podule manager (or falls back to hardwired assignments if Podule_ReadInfo missing).

Version 4.56. Tagged as 'EtherH-4_56'
@
text
@d418 1
a418 1
        sprintf(_eh_errblk.errmess, "EtherH module error (0x%x)", error);
@


1.5
log
@Replaced htons and friends with ${INETLIB} ones
Functions max() and min() changed for macros.
Made supporting assembler functions common -> support.s, so the IO sources just manipulate IO.
Unused header file 'int_hndlr.h' removed.
Resolved all the remaining compiler warnings.
File 'dma.c' compiles now, but is unused.
Substituted magic numbers for defines from exported header files where available.
Text for NIC slot 8 is now "Network slot" rather than "Expansion slot 8".
Builds but not tested. 26 bit only.

Version 4.55. Tagged as 'EtherH-4_55'
@
text
@d388 1
a388 2
               eh_cmosram(arg_string, arg_count);
               break;
d392 1
a392 2
               eh_cmos_connection(arg_string, arg_count);
               break;
@


1.4
log
@Makefile recreated from fragments
CMHG file inserts version from VersionNum.
Use ensure_irqs_on/irqs_restore from AsmUtils.
Trimmed revision history now the code is in CVS.
Debug switch SHOW_INFO removed - there was no supporting code.
Dozens of minor warning fixups as the shared makefiles have stricter checking enabled by default.
Builds, tested on RISC OS 3.70. 26 bit only.

Version 4.54. Tagged as 'EtherH-4_54'
@
text
@a62 2
extern int mb_present(void);

a68 7
/*
 * External data.
 */
extern int ehcnt;
extern volatile int pre_init, pre_reset;
extern struct eh_softc *eh_softc[];

d81 3
d85 58
a142 1
void *module_wsp = 0;
a143 4
struct {
    int  e_num;
    char e_mess[80];
} _eh_errblk = { 0 };
d150 1
a150 1
    _kernel_oserror *e = 0;
d161 1
a161 1
            if (e == 0)
d175 20
d201 1
a201 1
    eh_final();
a204 1
    UNUSED(pw);
d215 1
a215 1
    _kernel_oserror *e = 0;
d293 1
a293 1
            if (status & 1)
d402 4
d416 1
a416 1
    char tmp[80];
d419 3
a421 4
        _eh_errblk.e_num = error;
        sprintf(tmp, "Eh module error (0x%x)", error);
        strcpy(_eh_errblk.e_mess, tmp);
        return ((_kernel_oserror *)&_eh_errblk);
@


1.3
log
@Substitute 'mbuf', 'dcistructs', 'types', 'errors' from TCPIPLibs:
Insert version number from VersionNum.
Changed error numbers to use SETDCI4ERRNO(), a few were previously using the wrong offset from 0x20E00.
CMHG now generates a header file.
Textual SWI prefix is now "EtherH" for both EtherH8 and EtherH16 versions, since they use the same SWI base they can't coexist, and to match the prefix declared in the DIB block (slightly irrelevant for an ethernet driver since the DCI interface doesn't use SWI names).
Macro FREEM() replaced with m_freem(), also no longer checks for freeing NULL, since MbufManager does that.
Builds but not tested. 26 bit only.

Version 4.53. Tagged as 'EtherH-4_53'
@
text
@a37 44
 *
 * Initial Revision 4.00        2nd December 1994
 *
 * History
 *      v.4.00   2nd December 1994      GS
 *      Modified to support new DCI 4 specification
 *
 *      v.4.01   4th January 1995       GS
 *      More changes for DCI 4
 *      Service_DCIProtocolDying changed and extended to Service_DCIProtocolStatus
 *
 *      v.4.01   7th February 1995      GS
 *      SWI Stats added
 *      *EHTest for running diagnostics added
 *      outputs DCIVERSION major and minor revision
 *
 *      v.4.02   20th March 1995        GS
 *      now opens an mbuf manager session only once instead of during init and
 *      on receipt of mbuf manager service calls
 *
 *      v.4.06   14th July 1995        GS
 *      Service_EnumerateNetworkDrivers fixed to return info on multiple interfaces
 *      Made eh_error() print error number.
 *
 *      v4.07    16th August 1995               GS
 *      added cmos ram configuration of number of frame buffers
 *
 *      v4.08    20th September 1995            GS
 *      Service_EnumerateNetworkDrivers changed to only report info about first
 *      interface found
 *      increased size of error message buffer
 *
 *      v4.14    28th March 1996                GS
 *      Now issues Service_EnumerateNetworkDrivers info in reverse order
 *      which stop Claims going to Unit 1 when FreeWay/Internet starts
 *      from the rom when EHVirtual is ON
 *
 *      v4.38   2nd October 1998 GS
 *      Added MulticastRequest SWI
 *
 *      v4.43   16th June 2001 OSS
 *      Added *Configure EHConnection for E600 cards since they don't
 *      have a hardware link to select between 10BaseT and 10Base2
 *
d45 2
d51 1
d59 1
d61 3
d68 1
a68 1
        int (*swi_call)();      /* swi handler */
d71 3
a73 10
#define MAXENSWI 8

extern int eh_dciversion(), eh_inquire(), eh_getnetworkmtu();
extern int eh_setnetworkmtu(), eh_transmit(), eh_stats(), eh_multicastrequest();
extern eh_filter(), free_filter(struct eh_softc *, int, u_char *);
extern void eh_final(), eh_ehtest(), eh_softreset(), eh_postinit();

extern int mb_present(void);
extern _kernel_oserror *mb_entryinit(void);

d78 1
a78 1
struct swient eh_ent[MAXENSWI + 1] = {
d87 1
a87 1
    0,
a89 2
_kernel_oserror *eh_error(), *init_mmanager();

d98 28
d136 4
d162 1
a162 1
        return ((_kernel_oserror *)0);
d171 3
d205 2
a206 1
                    if (chdib = (ChDibRef) malloc (sizeof (ChDib)))
d271 2
d284 1
a284 1
    if (swinum >= MAXENSWI)
d295 3
d312 1
a312 1
           case 0:
d316 1
a316 1
           case 1:
d319 3
a321 1
           case 2:
d325 1
a325 2
#ifdef DRIVER16BIT
           case 3:
a329 1

d334 4
a337 1
   return ((_kernel_oserror *)0);
d354 1
a354 29
    return ((_kernel_oserror *)0);
}

/*
 * mbuf memory manager module initialisation
 */
_kernel_oserror *init_mmanager(void)
{
    _kernel_oserror *e = 0;

    /*
     * first see if mbuf manager module is present
     */
    if (mbuf_present == FALSE)
    {
        if (mb_present())
        {
            /* then try to open a session with it */
            e = mb_entryinit();
            if (e == 0)
            {
              mbuf_present = TRUE;
#ifdef DEBUG
              printf("debug: mbuf session opened &MBCTL:%x\n",(int)&MBCTL);
#endif
            }
        }
    }
    return(e);
@


1.2
log
@Add explicit copyright header to all files
Builds but not tested. 26 bit only.
@
text
@d92 6
a98 3
#include "types.h"
#include "mbuf.h"
#include "dcistructs.h"
d100 1
a100 1
#include "module.h"
d161 1
a161 1
_kernel_oserror *eh_initialise(char *cmd_tail, int pbase, void *pw)
d192 1
a192 1
void eh_sc_handler(int sn, _kernel_swi_regs *r)
d293 1
a293 1
        return (eh_error(EBADSWI));
d295 4
a298 1
        return (eh_error(ENOUNIT));
d310 1
a310 1
_kernel_oserror *eh_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
@


1.1
log
@Initial revision
@
text
@d1 27
@


1.1.1.1
log
@Import of EtherH driver for i-cubed/Acorn/DesignIT NIC
Special thanks to Rob Cowell of Design IT for taking the time to locate the sources, and agreeing to them being published. 
This is EtherH 4.52, the last public release. 
Only changes
 - makefile now creates empty dirs (to avoid importing empty dirs into CVS)
 - local copies of Hdr: removed, assembler files point to exported central copies
Builds but not tested. 26 bit only.
@
text
@@

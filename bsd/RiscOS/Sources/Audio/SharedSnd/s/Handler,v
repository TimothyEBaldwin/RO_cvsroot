head	1.12;
access;
symbols
	SharedSnd-1_20:1.12
	SharedSnd-1_19:1.11
	SharedSnd-1_18:1.10
	SharedSnd-1_17:1.8
	SharedSnd-1_16:1.8
	SharedSnd-1_15:1.8
	SharedSnd-1_14:1.8
	SharedSnd-1_13:1.7
	SharedSnd-1_12:1.6
	SharedSnd-1_11:1.6
	SharedSnd-1_10:1.5
	SharedSnd-1_09:1.5
	SharedSnd-1_08:1.5
	SharedSnd-1_07:1.5
	ESP_SharedSnd-1_06_merge:1.3.2.1
	SharedSnd-1_06:1.4
	ESP_SharedSnd-1_06:1.3.0.2
	ESP_SharedSnd-1_06_bp:1.3
	SharedSnd-1_05:1.3
	SharedSnd-1_04:1.3
	SharedSnd-1_03:1.3
	SharedSnd-1_02:1.3
	SharedSnd-1_01:1.2
	SharedSnd-1_00:1.1;
locks; strict;
comment	@# @;


1.12
date	2016.06.18.16.52.49;	author jlee;	state Exp;
branches;
next	1.11;
commitid	UtNAyjiaNTWV7Yaz;

1.11
date	2016.06.18.16.46.47;	author jlee;	state Exp;
branches;
next	1.10;
commitid	GZPyEQx8oxuR5Yaz;

1.10
date	2016.06.18.16.39.01;	author jlee;	state Exp;
branches;
next	1.9;
commitid	ODW0ixlFy50c3Yaz;

1.9
date	2016.06.18.16.19.19;	author jlee;	state Exp;
branches;
next	1.8;
commitid	L0sIVnG3vL4sWXaz;

1.8
date	2013.09.07.09.48.59;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	xd8cpTeM2vojpu4x;

1.7
date	2013.09.04.07.14.41;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	2RDI391I6q1nE54x;

1.6
date	2012.05.13.12.13.47;	author bavison;	state Exp;
branches;
next	1.5;
commitid	ikRUfBzwYcXxHy4w;

1.5
date	2011.12.06.00.13.40;	author jlee;	state Exp;
branches;
next	1.4;
commitid	JycXv4ushgqpP3Kv;

1.4
date	2011.08.15.23.10.48;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.05.12.38.04;	author bavison;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.06.28.20.21.55;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.28.18.11.57;	author bavison;	state Exp;
branches;
next	;

1.3.2.1
date	2011.08.15.14.11.19;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.12
log
@ARMv5E, ARMv6 optimisations
Detail:
  s/FillCode - Buffer fill & mix fragments optimised to use SMULWB/T, PKH, QADD16 and QDADD where possible, resulting in new variants optimised for ARMv5E and ARMv6
  s/Handler - Remove old, unoptimised callback buffer mixing code. Add new optimisated code for ARMv6 (SHADD16)
Admin:
  Tested on Raspberry Pi, Iyonix


Version 1.20. Tagged as 'SharedSnd-1_20'
@
text
@; Copyright (c) 1995, Expressive Software Projects
; All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of Expressive Software Projects nor the names of its
;       contributors may be used to endorse or promote products derived from
;       this software without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; 
        GBLL    CBAIDisableInt

; these are defined in global headers
; XOS_SWINumberFromString       *       &20039

; The process involves receiving a 'fill this buffer' instruction
; from a driver.
; The fill code then fills and mixes any available data from
; any immediate handlers whith each handler doing it's own mixing.
; Then any call back streams are called to give any available data
; with the fill code mixing it.
; Finally, call back streams are called to make sure that the call
; back buffer is full.
; At the end of each call back call process handlers can be called.
; The same handler code for each stage can be used with flags to
; indicate which type of handler is being processed ans with the
; data pointers set appropriately.

CBAIDisableInt  SETL {TRUE}

 ;-------------------------- Sound Handler Code ------------------------

stopSound       ROUT
        ; Make sure nothing is happening

        Entry   "r0"

        MOV     r0,#1
        STR     r0,[ws,#work_SoundPause]    ; Pause flag for handler routine

        ; Now wait until no sound is happening

stopSoundLoop


        LDR     r0,[ws,#work_SoundActive]   ; This will be set to 0 at then end of a fill
        CMP     r0,#0
        BNE     stopSoundLoop

        EXIT

 ; -----------

startSound      ROUT
        ; Set handler going again

        Entry   "r0"

        MOV     r0,#0
        STR     r0,[ws,#work_SoundPause]  ; Clear the pause flag

        ; Should check that there is a current driver and that it is active...

        EXIT
 ; -------------------------------

fill    ROUT
        ; Main fill call for output driver
        ; Can be called by a 16 or 8 bit driver
        ; It needs to collect and mix data into the final buffer
        ; converting the data if necessary.
        ; On entry:
        ;    r0 = parameter, this should be the SharedSound ws value
        ;    r1 = base of buffer
        ;    r2 = end of buffer
        ;    r3 = flags
        ;    r4 = sample frequency or period
        ; Added:
        ;    r5 = sample period

        Entry   "r0-r11,ws"

        LDR     ws,[r0]

        LDR     r0,[ws,#work_SoundPause]     ; Are we in pause state
        CMP     r0,#1
        BEQ     fillExit

        MOV     r0,#1
        STR     r0,[ws,#work_SoundActive]    ; Flag active

        ; If there is data in the buffer then this is shown in r3
        MOV     r5,r4
        LDR     r4,[ws,#work_SampleFrequency]         ; Put current rate into r4
        CMP     r4,r5

        BLNE    rateChange                             ; Set a call back to change values

        LDR     r5,[ws,#work_SamplePeriod]            ; Use old values for now

        ; First call any immediate handlers

        LDR     r6,[ws,#work_ImmediateHandlers]
        CMP     r6,#0
        MOVNE   r6,#handlerType_Immediate
        BLNE    handler

        ; Now get any callBack buffers and mix in
        LDR     r6,[ws,#work_CallBackHandlers]
        CMP     r6,#0
        BEQ     fillExit

        BL      addCallBackBuffer

        ; Finally initiate any callbacks required

        BL      callBackHandlerProcess


fillExit
        ; Do we need to pass the buffer on to SoundDriver for record?
        LDR     r0,[ws,#work_RecordOn]
        CMP     r0,#0
        BEQ     fillQuit

        ; Send to record

        ; r0 = Parameter
        ; r1 = Base
        ; r2 = End
        ; r3 = Handler number
        ; r4 = Sample frequency
        LDR     r0,[ws,#work_RecordHandlerParameter]
        LDR     r3,[ws,#work_RecordHandle]

        LDR     r9,[ws,#work_RecordHandlerAddress]
        CMP     r9,#0
        BEQ     fillQuit

        MOV     lr,pc   ; Return address
        MOV     pc,r9    ; Call handler

fillQuit
        MOV     r0,#0
        STR     r0,[ws,#work_SoundActive]    ; Flag finished

        EXIT

 ; ------------------

rateChange      ROUT
        ; Issue a call back to change the rate values
        Entry   "r0,r1"

 [ doCallBack
        ADR     r0,rateChangeCallBack
        LDR     r1,[ws,#work_privateWord]

        ; Change here from RJW; we may well be in IRQ mode here, so
        ; can't call SWIs directly. Instead jump to SVC mode and
        ; protect SVC_R14 first.
        Push    "R8,R9"

        SetMode SVC32_mode, R8, R9

        Push    "R14"

        SWI     XOS_AddCallBack

        Pull    "R14"
        RestPSR R9,,cf
        Pull    "R8,R9"


        EXIT
 |
        MOV     r0,r5   ; New frequency
        BL      newRate

        EXIT
 ]


 ; ---------


 [ doCallBack


rateChangeCallBack ROUT
        Entry   "r0-r11,ws"

        LDR     ws,[ws]         ; Get workspace pointer

        ; First get current sample frequency and sample period
        ; This is provided by the SampleRate routine
        MOV     r0,#0          ; Function code read
        BL      newSampleRate

        EXIT

 ]


 ; ---------------- Handler stuff ---------------

handler ROUT
        ; Dummy fill code
        ; Used to pass on control to chain of handlers
        ; The flags indicate which handlers to call
        ; There are three types - immediate, callback and process
        ; On entry:
        ;    r0 = parameter, this should be the SharedSound ws value
        ;    r1 = base of buffer
        ;    r2 = end of buffer
        ;    r3 = flags
        ;    r4 = sample frequency
        ;    r5 = sample period
        ;    r6 = Handler type

        ; Added by SharedSound before calling handlers

        ;    r6 = fraction step
        ;    r7 = LR Volume

        Entry   "r0-r2,r4-r11,ws"

        ; Now call each handler in turn, if they match the flag type

        MOV     r11,r6 ; Handler type

        ADD     r8,ws,#work_handlerTable       ; Address of table
        MOV     r9,#handlerMax                  ; Handler count

handlerLoop
        LDR     r10,[r8,#handler_Type]
        CMP     r10,r11
        BNE     handlerNext

        LDR     r10,[r8,#handler_Address]        ; Does this slot contain a handler?
        CMP     r10,#0
        BEQ     handlerNext

        Push    "r1,r2,r4,r5,r8,r9,r11,ws"      ; Will need these preserved

        LDR     r0,[r8,#handler_Parameter]
        LDR     r6,[r8,#handler_Fraction]
        LDR     r7,[r8,#handler_VolumeScaled]
        ADD     r8,ws,#work_FillcodeTable

        ; Set those extra flags
        CMN     r7,#1           ; If volume != 0xFFFFFFFF
        ORRNE   r3,r3,#1<<30    ; then set bit 30
        CMP     r7,#0           ; If volume == 0x00000000
        ORREQ   r3,r3,#1<<31    ; then set bit 31

        MOV     lr,pc
        MOV     pc,r10                            ; Jump to address
handlerReturn
        BIC     r3,r3,#3<<30    ; Clear the volume indicator bits
        Pull    "r1,r2,r4,r5,r8,r9,r11,ws"      ; Will need these preserved

handlerNext
        ADD     r8,r8,#handlerTableLen
        SUBS    r9,r9,#1
        BNE     handlerLoop

handlerExit
        EXIT

 ; ------------------- Call Back Handler routines

work_CallBack_BufferVal
        DCD     work_CallBack_Buffer

 ; ----

addCallBackBuffer ROUT
        ; Get pointer to call back buffer if it exists
        ; On entry:
        ;    r1 = base of buffer
        ;    r2 = end of buffer
        ;    r3 = flags
        ;    r4 = sample frequency
        ;    r5 = sample period
        ; On exit:
        ;    call back data mixed in if there is some

        Entry   "r0-r11,ws"

        SUB     r6,r2,r1
        LDR     r7,[ws,#work_CallBack_BufferSize]

        CMP     r6,r7

        ; If the buffer size has changed then need to make changes...
        STR     r6,[ws,#work_CallBack_BufferSize]

        LDR     r5,[ws,#work_CallBack_BufferFullCount]  ; Are there any full buffers?
        CMP     r5,#0
        BGT     addCallBackBuffer_OK

        ; Need to flag an overrun
        LDR     r5,[ws,#work_callBack_Active]  ; Is the old call back active?
        CMP     r5,#1

        ; If there are no full buffers and the call back is active then we have overrun
        LDREQ   r7,[ws,#work_callBack_Count]   ; If so then increment count and return
        ADDEQ   r7,r7,#1
        STREQ   r7,[ws,#work_callBack_Count]

        ; Need to do a volume shift on the buffer to effectivly mix an empty buffer
        ; into the existing data
        ; This avoids volume fluctuations

        ; r1 = Start of SoundDMA buffer
        ; r2 = End of SoundDMA buffer
        ; r6 = Length

  [ NoARMv6
addCallBackBuffer_VolumeShiftLoop
        LDMIA   r1,{r3-r6}

        MACRO
        acbb_vsl        $work1,$work2,$getReg
        ; Shift volumes
        MOV     $getReg,$getReg,ASR#1
        ; Now getReg is perfect except possibly for bit 15 that should be the same as
        ; bit 14. Form a word of differences between bits.
        EOR     $work1,$getReg,$getReg,LSL#1
        AND     $work1,$work1,#1<<15
        EOR     $getReg,$getReg,$work1
        MEND

        acbb_vsl        R11,R12,R3
        acbb_vsl        R11,R12,R4
        acbb_vsl        R11,R12,R5
        acbb_vsl        R11,R12,R6

        STMIA   r1!,{r3-r6}

        CMP     r1,r2
        BLT     addCallBackBuffer_VolumeShiftLoop
  |
        MOV     r11, #0
addCallBackBuffer_VolumeShiftLoop
        LDMIA   r1,{r3-r6}
        SHADD16 r3, r3, r11
        SHADD16 r4, r4, r11
        SHADD16 r5, r5, r11
        SHADD16 r6, r6, r11
        STMIA   r1!,{r3-r6}
        CMP     r1,r2
        BLT     addCallBackBuffer_VolumeShiftLoop
  ]

        B     addCallBackBuffer_Exit   ; No data available

addCallBackBuffer_OK
        ; There are buffers available so use one of these

        ; r1 = Start of SoundDMA buffer
        ; r2 = End of SoundDMA buffer
        ; r6 = Length

        LDR     r5,work_CallBack_BufferVal
        ADD     r5,r5,ws
        ;       Align
        ADD     r5,r5,#63
        BIC     r5,r5,#63
        LDR     r7,[ws,#work_CallBack_CurrentSoundBuffer]
        MLA     r0,r6,r7,r5                                    ; Buffer position

        ; r0 = Source buffer
        ; r1 = DMA buffer
        ; r2 = DMA buffer end
        ; r3 = Fill flags

        ; Copy across (mixing??)

        TST     r3,#1
        BNE     addCallBackBuffer_Mix

        ; No mixing

addCallBackBuffer_Loop
        LDMIA   r0!,{r3-r6}
        STMIA   r1!,{r3-r6}

        CMP     r1,r2
        BLT     addCallBackBuffer_Loop

        B       addCallBackBuffer_Final

addCallBackBuffer_Mix
  [ NoARMv6
        Push    "ws"

        MVN     r12,#0
        MOV     r12,r12,LSL#16

addCallBackBufferMix_Loop
        LDMIA   r0!,{r3-r6}
        LDMIA   r1,{r7-r10}

        MACRO
        acbbm_l $work1,$work2,$getReg,$mixReg
        ; getReg = abcdefgh
        ; mixReg = ijklmnop
        ; target = qrstuvwx
        ; work2 = 0xFFFF0000
        AND     $work1,$work2,$getReg,ASR#1             ; work1 = (abcD0000)>>>1
        MOV     $getReg,$getReg,LSL#16                  ; getReg=  efgh00000
        MOV     $getReg,$getReg,ASR#1                   ; getReg= (efgh00000)>>>1

        ADD     $work1,$work1,$mixReg,ASR#1             ; work1 = qrstXXXX
        MOV     $mixReg,$mixReg,LSL#16                  ; work2 = mnop0000
        ADD     $getReg,$getReg,$mixReg,ASR#1           ; getReg= uvwxXXXX
        AND     $work1,$work1,$work2                    ; work1 = qrst0000
        ORR     $getReg,$work1,$getReg,LSR#16           ; work1 = qrstuvwx
        MEND

        acbbm_l R11,R12,R3,R7
        acbbm_l R11,R12,R4,R8
        acbbm_l R11,R12,R5,R9
        acbbm_l R11,R12,R6,R10

        STMIA   r1!,{r3-r6}

        CMP     r1,r2
        BLT     addCallBackBufferMix_Loop

        Pull    "ws"
  |
addCallBackBufferMix_Loop
        LDMIA   r0!,{r3-r6}
        LDMIA   r1,{r7-r10}
        SHADD16 r3, r3, r7
        SHADD16 r4, r4, r8
        SHADD16 r5, r5, r9
        SHADD16 r6, r6, r10
        STMIA   r1!,{r3-r6}
        CMP     r1,r2
        BLT     addCallBackBufferMix_Loop
  ]

addCallBackBuffer_Final
        ; Increment current SoundDMA buffer

        LDR     r7,[ws,#work_CallBack_CurrentSoundBuffer]
        LDR     r8,[ws,#work_CallBack_numCallBackBuffers]
        ADD     r7,r7,#1
        CMP     r7,r8
        MOVGE   r7,#0
        STR     r7,[ws,#work_CallBack_CurrentSoundBuffer]

        ; Decrement full count
        LDR     r8,[ws,#work_CallBack_BufferFullCount]
        SUBS    r8,r8,#1
        MOVLT   r8,#0
        STR     r8,[ws,#work_CallBack_BufferFullCount]

addCallBackBuffer_Exit
        EXIT

 ; -------------------------------

callBackHandlerProcess ROUT

        ; On entry:
        ;    r1 = base of buffer
        ;    r2 = end of buffer
        ;    r3 = flags
        ;    r4 = sample frequency
        ;    r5 = sample period

        Entry   "r0-r11,ws"

        SUB     r6,r2,r1
        STR     r6,[ws,#work_CallBack_BufferSize]
        STR     r3,[ws,#work_CallBack_Flags]
        STR     r4,[ws,#work_CallBack_SampleFrequency]
        STR     r5,[ws,#work_CallBack_SamplePeriod]

        LDR     r5,[ws,#work_callBack_Active]  ; Set the call back active flag
        CMP     r5,#1
        BEQ     callBackHandlerProcess_Exit

        MOV     r5,#1
        STR     r5,[ws,#work_callBack_Active]  ; Set the call back active flag

        ; Set up new call back

 [ doCBAI

        ; Either by CBAI

        LDR     r0,[ws,#work_CBAIActive]
        CMP     r0,#1

        ADREQ   r0,CBAIRoutine
        STREQ   r0,[ws,#work_PollWord]
        BEQ     callBackHandlerProcess_Exit

        ; Or by old style Call backs

 ]

        ADR     r0,doHandlerCallBack
        LDR     r1,[ws,#work_privateWord]

        SetMode SVC32_mode, R8, R9
        Push    "lr"

        SWI     XOS_AddCallBack

        Pull    "lr"
        RestPSR R9,,cf

callBackHandlerProcess_Exit
        EXIT

 ; -------



 ; ---------------

doHandlerCallBack ROUT
        ; Called by call back system
        ; Needs to call the handler with the right parameters
        Entry   "r0-r11,ws"

        LDR     ws,[ws]

        ; From the start and end get the length and offset into the buffer
        ; by the current OutBuffer value

        LDR     r10,[ws,#work_CallBack_BufferSize]
        LDR     r0,[ws,#work_privateWord]
        LDR     r3,[ws,#work_CallBack_Flags]
        LDR     r4,[ws,#work_CallBack_SampleFrequency]
        LDR     r5,[ws,#work_CallBack_SamplePeriod]

doHandlerCallBack_Loop
        ;       r10 = Buffer length

        LDR     r2,work_CallBack_BufferVal
        ADD     r2,r2,ws
        ;       Align
        ADD     r2,r2,#63
        BIC     r2,r2,#63

        LDR     r7,[ws,#work_CallBack_CurrentOutBuffer]
        MLA     r1,r10,r7,r2                              ; Buffer address

        ADD     r2,r1,r10

        MOV     r3,#0                           ; Buffer invalid

        LDR     r8,[ws,#work_CallBackHandlers]
        CMP     r8,#0
        MOVNE   r6,#handlerType_CallBack
        BLNE    handler

        LDR     r8,[ws,#work_ProcessHandlers]
        CMP     r8,#0
        MOVNE   r6,#handlerType_Process
        BLNE    handler

 [  :LNOT:  CBAIDisableInt
        PHPSEI  r8,r9                  ; interrupts -> disabled
 ]
        ; increment full count
        ; Increment out buffer
        LDR     r7,[ws,#work_CallBack_CurrentOutBuffer]
        LDR     r9,[ws,#work_CallBack_numCallBackBuffers]
        ADD     r7,r7,#1
        CMP     r7,r9
        MOVGE   r7,#0
        STR     r7,[ws,#work_CallBack_CurrentOutBuffer]

        LDR     r7,[ws,#work_CallBack_BufferFullCount]
        ADD     r7,r7,#1
        CMP     r7,r9
        MOVGT   r7,r9
        STR     r7,[ws,#work_CallBack_BufferFullCount]

 [  :LNOT:  CBAIDisableInt
        PLP     r8                     ; Interrupts reenabled
 ]

        ; Check for full count = max
        ; Loop round if not

        CMP     r7,r9
        BLT     doHandlerCallBack_Loop

        ; Otherwise we have filled all the buffers and can return

        MOV     r5,#0
        STR     r5,[ws,#work_callBack_Active]  ; Call back completed

        EXIT

 ; ---------------

clearCallBackBuffer ROUT
        ; Initialise the call back buffer to 0
        Entry   "r0-r11,ws"

        MOV     r0,#0
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#0

        LDR     r4,work_CallBack_BufferVal
        ADD     r4,r4,ws

        ADD   r4,r4,#63
        BIC     r4,r4,#63

        ADD   r5,r4,#callBackBufferLen

clearCallBackBuffer_Loop
        STMIA   r4!,{r0-r3}
        CMP     r4,r5
        BLT     clearCallBackBuffer_Loop

        EXIT


 ; ---------------

setHandlerType  ROUT
        ; Set the corresponding bit for this handler's number & type
        ; On entry:
        ;    r0 = Handler number
        ;    r4 = Type
        Entry   "r0-r4"

        MOV     r1,#1
        MOV     r0,r1,LSL r0          ; As a bit

        CMP     r4,#handlerType_Immediate
        LDREQ   r1,[ws,#work_ImmediateHandlers]
        ORREQ   r1,r1,r0
        STREQ   r1,[ws,#work_ImmediateHandlers]

        CMP     r4,#handlerType_CallBack
        LDREQ   r1,[ws,#work_CallBackHandlers]
        ORREQ   r1,r1,r0
        STREQ   r1,[ws,#work_CallBackHandlers]

        CMP     r4,#handlerType_Process
        LDREQ   r1,[ws,#work_ProcessHandlers]
        ORREQ   r1,r1,r0
        STREQ   r1,[ws,#work_ProcessHandlers]

        EXIT

 ; ---------

clearHandlerType ROUT
        ; Clear the corresponding bit for this handler's number & type
        ; On entry:
        ;    r0 = Handler number
        ;    r4 = Type
        Entry   "r0-r4"

        MOV     r1,#1
        MOV     r0,r1,LSL r0          ; As a bit

        CMP     r4,#handlerType_Immediate
        LDREQ   r1,[ws,#work_ImmediateHandlers]
        BICEQ   r1,r1,r0
        STREQ   r1,[ws,#work_ImmediateHandlers]

        CMP     r4,#handlerType_CallBack
        LDREQ   r1,[ws,#work_CallBackHandlers]
        BICEQ   r1,r1,r0
        STREQ   r1,[ws,#work_CallBackHandlers]

        CMP     r4,#handlerType_Process
        LDREQ   r1,[ws,#work_ProcessHandlers]
        BICEQ   r1,r1,r0
        STREQ   r1,[ws,#work_ProcessHandlers]

        EXIT


 ; -------------------- CBAI -----------------

 [ doCBAI

InstallCBAI     ROUT
        ; Install the CBAI stuff if module exists

        Entry   "r0-r11,ws"

        MOV     r0,#0
        STR     r0,[ws,#work_PollWord]

        MOV     r0,#0
        ADR     r1,CBAIString
        SWI     XOS_SWINumberFromString

        MOVVC   r0,#1
        MOVVS   r0,#0
        STR     r0,[ws,#work_CBAIActive]

        ADDVC   r0,ws,#work_PollWord
        MOVVC   r1,#&100000       ; Scheduling class
        LDRVC   r2,[ws,#work_privateWord]
        SWIVC   XCBAI_RegisterPollWord

        EXIT

 ; -----------------

CBAIString
        =       "CBAI_RegisterPollWord"
        DCB     0
        ALIGN

 ; -----------------

RemoveCBAI      ROUT
        ; De-register the CBAI pollword
        Entry   "r0-r11,ws"

        LDR     r0,[ws,#work_CBAIActive]
        CMP     r0,#1

        ADDEQ   r0,ws,#work_PollWord
        SWIEQ   XCBAI_DeregisterPollWord

        MOV     r0,#0
        STR     r0,[ws,#work_CBAIActive]

        EXIT

 ; -----------------

CBAIRoutine     ROUT
        ; Call back routine to call call back addresses

        Push    "r0-r11,ws"

 [ CBAIDisableInt
        PHPSEI  r8,r9                  ; interrupts -> disabled
 ]

        BL      doHandlerCallBack

 [ CBAIDisableInt
        PLP     r8                     ; Interrupts reenabled
 ]

        Pull    "r0-r11,ws,pc"

 ; -----------------
 ]

;;

        END
@


1.11
log
@Use PSR manipulation macros. Macroise driver calling. Simplify error checks.
Detail:
  s/Drivers - Macroise driver calling to reduce amount of duplicate code. Also avoid NOP if storing PC stores PC+8 and not PC+12.
  s/Handler - Use PSR manipulation macros for switching modes and controlling IRQs. Remove redundant IRQ disabling around atomic store of one word in doHandlerCallBack.
  s/Module - Use PSR manipulation macros for switching modes
  s/SWIS - Simplify range checking on handler and driver numbers; treat as unsigned numbers instead of signed.
  s/Vars - Remove local definitions of IRQ flags & SVC mode
Admin:
  Tested on Raspberry Pi


Version 1.19. Tagged as 'SharedSnd-1_19'
@
text
@d335 1
a341 16
 [ 0 = 1
        ; Old dumb way.
        MOV     $work1,$getReg,LSL #16          ; Put right into work1
        EOR     $getReg,$getReg,$work1,LSR #16  ; and left in getReg

        MOV     $work1,$work1,ASR #1     ; DIV 2

        MOV     $getReg,$getReg,ASR #1   ; DIV 2

        ;TST    $getReg,#1<<15           ; Remove any low bit
        ;EORNE  $getReg,$getReg,#1<<15
        BIC     $getReg,$getReg,#1<<15

        ADD     $getReg,$getReg,$work1,LSR #16
 |
        ; New shiny way
a347 2
 ]

d359 12
d411 1
a422 32

 [ 0 = 1
        ; Old dumb way
        MOV     $work1,$getReg,LSL #16          ; Put right into work1
        EOR     $getReg,$getReg,$work1,LSR #16  ; and left in getReg

        MOV     $work1,$work1,ASR #1     ; DIV 2

        MOV     $getReg,$getReg,ASR #1   ; DIV 2

        ;TST    $getReg,#1<<15           ; Remove any low bit
        ;EORNE  $getReg,$getReg,#1<<15
        BIC     $getReg,$getReg,#1<<15

        MOV     $work2,$mixReg,LSL #16          ; Put right into work2
        EOR     $mixReg,$mixReg,$work2,LSR #16  ; and left in mixReg

        MOV     $work2,$work2,ASR #1     ; DIV 2

        MOV     $mixReg,$mixReg,ASR #1   ; DIV 2

        ;TST    $mixReg,#1<<15           ; Remove any low bit
        ;EORNE  $mixReg,$mixReg,#1<<15
        BIC     $mixReg,$mixReg,#1<<15

        ; Now mix
        ADD     $getReg,$getReg,$mixReg
        ADD     $work1,$work1,$work2

        ADD     $getReg,$getReg,$work1,LSR #16
 |
        ; New shiny way
a435 2
 ]

d449 12
@


1.10
log
@Use Entry/EXIT, Push/Pull macros
Detail:
  s/* - Code updated to use Entry/EXIT and Push/Pull macros where possible instead of manual STM/LDM. Also add ROUTs for safety (although most routines use named local labels rather than numbered ones). A few obvious cases also fixed to reduce number of regs pushed onto stack.
  A few other changes and fixes of note:
  s/Log - Trim empty, unused installLogDriver routine when doLog is {FALSE}
  s/Module - Add a veneer to swiHandler to deal with 26bit and 26/32bit neutral cases; avoids the need for individual SWI handlers to preserve NZC
  s/SWIs:
  - Remove 26/32bit neutral SWI exit code, now handled by veneers. CLRV on most SWI exits to replace the implicit CLRV from CMP pc,pc.
  - swiHandlerVolume and swiDriverMixer were popping the wrong regs from the stack for most error cases; now fixed via the switch to Entry/EXIT
Admin:
  Tested on Raspberry Pi


Version 1.18. Tagged as 'SharedSnd-1_18'
@
text
@d179 2
a180 14
      [ NoARMG
        TEQ     PC,PC
        MRSEQ   R9,CPSR         ; If in 32-bit mode, R9 = CPSR
        MOVNE   R9,PC           ; If in 26-bit mode, R9 = PC+PSR
        ORR     R8,R9,#3        ; Preserves 32-bitness
        MSREQ   CPSR_c,R8
        TEQNEP  R8,#0
        MOV     R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MRS     R9,CPSR
        ORR     R8,R9,#3        ; to SVC32 mode
        MSR     CPSR_c,R8
      ]
d186 1
a186 9
      [ NoARMG
        TEQ     PC,PC
        MSREQ   CPSR_c,R9
        TEQNEP  R9,#0
        MOV     R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MSR     CPSR_c,R9       ; back to original mode
      ]
d553 1
a553 14
      [ NoARMG
        TEQ     PC,PC
        MRSEQ   R9,CPSR         ; If we are in 32-bit mode. R9 = CPSR
        MOVNE   R9,PC           ; If we are in 26-bit mode, R9 = PC+PSR
        ORR     r8,r9,#SVC_Mode ; Preserved 32-bitness
        MSREQ   CPSR_c,R8
        TEQNEP  r8,#0
        MOV     r0,r0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MRS     R9,CPSR
        ORR     R8,R9,#3        ; to SVC32 mode
        MSR     CPSR_c,R8
      ]
d559 1
a559 9
      [ NoARMG
        TEQ     PC,PC
        MSREQ   CPSR_c,R9
        TEQNEP  R9,#0
        MOV     r0,r0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MSR     CPSR_c,R9       ; back to original mode
      ]
d613 1
a613 8

        TEQ     PC,PC
        MRSEQ   R8,CPSR
        MOVNE   R8,PC
        ORREQ   r9,r8,#I32flag
        ORRNE   r9,r8,#Iflag
        MSREQ   CPSR_c,R9
        TEQNEP  r9,#0                  ; interrupts -> disabled
d631 1
a631 3
        TEQ     PC,PC
        MSREQ   CPSR_c,R8
        TEQNEP  r8,#0                  ; Interrupts reenabled
a641 10
 [  :LNOT:  CBAIDisableInt
        TEQ     PC,PC
        MRSEQ   R8,CPSR
        MOVNE   R8,PC
        ORREQ   r9,r8,#I32flag
        ORRNE   r9,r8,#Iflag
        MSREQ   CPSR_c,R9
        TEQNEP  r9,#0                 ; interrupts -> disabled
 ]

a644 7
 [  :LNOT:  CBAIDisableInt

        TEQ     PC,PC
        MSREQ   CPSR_c,R8
        TEQNEP  r8,#0                  ; Interrupts reenabled
 ]

a790 9
        ;TEQ    PC,PC
        ;MRSEQ  R9,CPSR
        ;MOVNE  R9,PC
        ;ORR    r8,r9,#SVC_Mode
        ;MSREQ  CPSR_c,R8
        ;TEQNEP r8,#0
        ;MOV    r0,r0
        ;STMFD  sp!,{R9,lr}

d792 1
a792 8

        TEQ     PC,PC
        MRSEQ   R8,CPSR
        MOVNE   r8,pc
        ORREQ   r9,r8,#I32flag
        ORRNE   r9,r8,#Iflag
        MSREQ   CPSR_c,R9
        TEQNEP  r9,#0                  ; interrupts -> disabled
d798 1
a798 4

        TEQ     PC,PC
        MSREQ   CPSR_c,R8
        TEQNEP  r8,#0                  ; Interrupts reenabled
a800 6
        ;LDMFD  sp!,{R9,lr}
        ;TEQ    PC,PC
        ;MSREQ  CPSR_c,R9
        ;TEQNEP r9,#0
        ;MOV    r0,r0

@


1.9
log
@Expand tabs
Detail:
  s/* - Expand all tabs, to avoid space/tab use inconsistencies within some files and to match general ROOL code formatting
Admin:
  Binary unchanged


Version 1.17. Not tagged
@
text
@d48 1
a48 1
stopSound
d51 1
a51 1
        STMDB   sp!,{r0,lr}
d65 1
a65 1
        LDMIA   sp!,{r0,pc}
d69 1
a69 1
startSound
d72 1
a72 1
        STMDB   sp!,{r0,lr}
d79 1
a79 1
        LDMIA   sp!,{r0,pc}
d82 1
a82 1
fill
d96 1
a96 1
        STMDB   sp!,{r0-r11,ws,lr}
d162 1
a162 1
        LDMIA   sp!,{r0-r11,ws,pc}
d166 1
a166 1
rateChange
d168 1
a168 1
        STMDB   sp!,{r0,r1,lr}
d177 1
a177 1
        STMFD   R13!,{R8,R9}
d207 1
a207 1
        LDMFD   R13!,{R8,R9}
d210 1
a210 1
        LDMIA   sp!,{r0,r1,pc}
d215 1
a215 1
        LDMIA   sp!,{r0,r1,pc}
d225 2
a226 4
rateChangeCallBack


        STMDB   sp!,{r0-r11,ws,lr}
d235 1
a235 1
        LDMIA   sp!,{r0-r11,ws,pc}
d242 1
a242 1
handler
d261 1
a261 1
        STMDB   sp!,{r0-r2,r4-r11,ws,lr}
d279 1
a279 1
        STMDB   sp!,{r1,r2,r4,r5,r8,r9,r11,ws}      ; Will need these preserved
d296 1
a296 1
        LDMIA   sp!,{r1,r2,r4,r5,r8,r9,r11,ws}      ; Will need these preserved
d304 1
a304 2

        LDMIA   sp!,{r0-r2,r4-r11,ws,pc}
d313 1
a313 1
addCallBackBuffer
d324 1
a324 1
        STMDB   sp!,{r0-r11,ws,lr}
d525 1
a525 1
        LDMIA   sp!,{r0-r11,ws,pc}
d529 1
a529 1
callBackHandlerProcess
d538 1
a538 1
        STMDB   sp!,{r0-r11,ws,lr}
d603 1
a603 1
        LDMIA   sp!,{r0-r11,ws,pc}
d611 1
a611 1
doHandlerCallBack
d614 1
a614 1
        STMDB   sp!,{r0-r11,ws,lr}
d712 1
a712 1
        LDMIA   sp!,{r0-r11,ws,pc}
d716 1
a716 1
clearCallBackBuffer
d718 1
a718 3


        STMDB   sp!,{r0-r11,ws,lr}
a727 1
        ;EVALAlign
d738 1
a738 1
        LDMIA   sp!,{r0-r11,ws,pc}
d743 1
a743 1
setHandlerType
d748 1
a748 1
        STMDB   sp!,{r0-r4,lr}
d768 1
a768 1
        LDMIA   sp!,{r0-r4,pc}
d772 1
a772 1
clearHandlerType
d777 1
a777 1
        STMDB   sp!,{r0-r4,lr}
d797 1
a797 1
        LDMIA   sp!,{r0-r4,pc}
d804 1
a804 1
InstallCBAI
d807 1
a807 1
        STMDB sp!,{r0-r11,ws,lr}
d825 1
a825 1
        LDMIA   sp!,{r0-r11,ws,pc}
d836 1
a836 1
RemoveCBAI
d838 1
a838 1
        STMDB sp!,{r0-r11,ws,lr}
d849 1
a849 1
        LDMIA   sp!,{r0-r11,ws,pc}
d853 1
a853 1
CBAIRoutine
d856 1
a856 1
        STMDB sp!,{r0-r11,ws}
d893 1
a893 1
        LDMIA   R13!,{r0-r12,PC}
@


1.8
log
@Signed pointer comparison fix
In SWI InstallDriver reason codes > 2 are interpreted to mean a pointer to an install driver block, but this used a signed comparison so registering blocks in the top half of memory would fail.
SWIS.s:
 Comparison changed to process 0/1/2 and > 2 correctly
SoundDrv.s & Handler.s:
 Eliminated ADR range function by just using ADRL
Module.s:
 Zero length command table replaced by a 0 in the command entry of the module header
Memory.s:
 Signed loop exit changed for unsigned one (not relevant since the workspace is < 2G)
Drivers.s:
 SWI name moved inside doDMI switch

Version 1.14. Tagged as 'SharedSnd-1_14'
@
text
@d26 1
a26 1
	GBLL	CBAIDisableInt
d29 1
a29 1
; XOS_SWINumberFromString	*	&20039
d44 1
a44 1
CBAIDisableInt	SETL {TRUE}
d49 1
a49 1
	; Make sure nothing is happening
d51 1
a51 1
	STMDB	sp!,{r0,lr}
d53 2
a54 2
	MOV	r0,#1
	STR	r0,[ws,#work_SoundPause]    ; Pause flag for handler routine
d56 1
a56 1
	; Now wait until no sound is happening
d61 3
a63 3
	LDR	r0,[ws,#work_SoundActive]   ; This will be set to 0 at then end of a fill
	CMP	r0,#0
	BNE	stopSoundLoop
d65 1
a65 1
	LDMIA	sp!,{r0,pc}
d70 1
a70 1
	; Set handler going again
d72 1
a72 1
	STMDB	sp!,{r0,lr}
d74 2
a75 2
	MOV	r0,#0
	STR	r0,[ws,#work_SoundPause]  ; Clear the pause flag
d77 1
a77 1
	; Should check that there is a current driver and that it is active...
d79 1
a79 1
	LDMIA	sp!,{r0,pc}
d83 12
a94 12
	; Main fill call for output driver
	; Can be called by a 16 or 8 bit driver
	; It needs to collect and mix data into the final buffer
	; converting the data if necessary.
	; On entry:
	;    r0 = parameter, this should be the SharedSound ws value
	;    r1 = base of buffer
	;    r2 = end of buffer
	;    r3 = flags
	;    r4 = sample frequency or period
	; Added:
	;    r5 = sample period
d96 1
a96 1
	STMDB	sp!,{r0-r11,ws,lr}
d98 1
a98 1
	LDR	ws,[r0]
d100 3
a102 3
	LDR	r0,[ws,#work_SoundPause]     ; Are we in pause state
	CMP	r0,#1
	BEQ	fillExit
d104 2
a105 2
	MOV	r0,#1
	STR	r0,[ws,#work_SoundActive]    ; Flag active
d107 4
a110 4
	; If there is data in the buffer then this is shown in r3
	MOV	r5,r4
	LDR	r4,[ws,#work_SampleFrequency]         ; Put current rate into r4
	CMP	r4,r5
d112 1
a112 1
	BLNE	rateChange                             ; Set a call back to change values
d114 1
a114 1
	LDR	r5,[ws,#work_SamplePeriod]            ; Use old values for now
d116 1
a116 1
	; First call any immediate handlers
d118 4
a121 4
	LDR	r6,[ws,#work_ImmediateHandlers]
	CMP	r6,#0
	MOVNE	r6,#handlerType_Immediate
	BLNE	handler
d123 4
a126 4
	; Now get any callBack buffers and mix in
	LDR	r6,[ws,#work_CallBackHandlers]
	CMP	r6,#0
	BEQ	fillExit
d128 1
a128 1
	BL	addCallBackBuffer
d130 1
a130 1
	; Finally initiate any callbacks required
d132 1
a132 1
	BL	callBackHandlerProcess
d136 18
a153 18
	; Do we need to pass the buffer on to SoundDriver for record?
	LDR	r0,[ws,#work_RecordOn]
	CMP	r0,#0
	BEQ	fillQuit

	; Send to record

	; r0 = Parameter
	; r1 = Base
	; r2 = End
	; r3 = Handler number
	; r4 = Sample frequency
	LDR	r0,[ws,#work_RecordHandlerParameter]
	LDR	r3,[ws,#work_RecordHandle]

	LDR	r9,[ws,#work_RecordHandlerAddress]
	CMP	r9,#0
	BEQ	fillQuit
d155 2
a156 2
	MOV	lr,pc   ; Return address
	MOV	pc,r9    ; Call handler
d159 2
a160 2
	MOV	r0,#0
	STR	r0,[ws,#work_SoundActive]    ; Flag finished
d162 1
a162 1
	LDMIA	sp!,{r0-r11,ws,pc}
d167 2
a168 2
	; Issue a call back to change the rate values
	STMDB	sp!,{r0,r1,lr}
d171 2
a172 2
	ADR	r0,rateChangeCallBack
	LDR	r1,[ws,#work_privateWord]
d174 4
a177 4
	; Change here from RJW; we may well be in IRQ mode here, so
	; can't call SWIs directly. Instead jump to SVC mode and
	; protect SVC_R14 first.
	STMFD	R13!,{R8,R9}
d180 7
a186 7
	TEQ	PC,PC
	MRSEQ	R9,CPSR		; If in 32-bit mode, R9 = CPSR
	MOVNE	R9,PC		; If in 26-bit mode, R9 = PC+PSR
	ORR	R8,R9,#3	; Preserves 32-bitness
	MSREQ	CPSR_c,R8
	TEQNEP	R8,#0
	MOV	R0,R0
d193 1
a193 1
	Push    "R14"
d195 1
a195 1
	SWI	XOS_AddCallBack
d199 4
a202 4
	TEQ	PC,PC
	MSREQ	CPSR_c,R9
	TEQNEP	R9,#0
	MOV	R0,R0
d207 1
a207 1
	LDMFD	R13!,{R8,R9}
d210 1
a210 1
	LDMIA	sp!,{r0,r1,pc}
d212 2
a213 2
	MOV	r0,r5   ; New frequency
	BL	newRate
d215 1
a215 1
	LDMIA	sp!,{r0,r1,pc}
d228 1
a228 1
	STMDB	sp!,{r0-r11,ws,lr}
d230 1
a230 1
	LDR	ws,[ws]         ; Get workspace pointer
d232 4
a235 4
	; First get current sample frequency and sample period
	; This is provided by the SampleRate routine
	MOV	r0,#0          ; Function code read
	BL	newSampleRate
d237 1
a237 1
	LDMIA	sp!,{r0-r11,ws,pc}
d245 17
a261 17
	; Dummy fill code
	; Used to pass on control to chain of handlers
	; The flags indicate which handlers to call
	; There are three types - immediate, callback and process
	; On entry:
	;    r0 = parameter, this should be the SharedSound ws value
	;    r1 = base of buffer
	;    r2 = end of buffer
	;    r3 = flags
	;    r4 = sample frequency
	;    r5 = sample period
	;    r6 = Handler type

	; Added by SharedSound before calling handlers

	;    r6 = fraction step
	;    r7 = LR Volume
d263 1
a263 1
	STMDB	sp!,{r0-r2,r4-r11,ws,lr}
d265 1
a265 1
	; Now call each handler in turn, if they match the flag type
d267 1
a267 1
	MOV	r11,r6 ; Handler type
d269 2
a270 2
	ADD	r8,ws,#work_handlerTable       ; Address of table
	MOV	r9,#handlerMax                  ; Handler count
d273 20
a292 20
	LDR	r10,[r8,#handler_Type]
	CMP	r10,r11
	BNE	handlerNext

	LDR	r10,[r8,#handler_Address]        ; Does this slot contain a handler?
	CMP	r10,#0
	BEQ	handlerNext

	STMDB	sp!,{r1,r2,r4,r5,r8,r9,r11,ws}      ; Will need these preserved

	LDR	r0,[r8,#handler_Parameter]
	LDR	r6,[r8,#handler_Fraction]
	LDR	r7,[r8,#handler_VolumeScaled]
	ADD	r8,ws,#work_FillcodeTable

	; Set those extra flags
	CMN	r7,#1		; If volume != 0xFFFFFFFF
	ORRNE	r3,r3,#1<<30	; then set bit 30
	CMP	r7,#0		; If volume == 0x00000000
	ORREQ	r3,r3,#1<<31	; then set bit 31
d294 2
a295 2
	MOV	lr,pc
	MOV	pc,r10                            ; Jump to address
d297 2
a298 2
	BIC	r3,r3,#3<<30	; Clear the volume indicator bits
	LDMIA	sp!,{r1,r2,r4,r5,r8,r9,r11,ws}      ; Will need these preserved
d301 3
a303 3
	ADD	r8,r8,#handlerTableLen
	SUBS	r9,r9,#1
	BNE	handlerLoop
d307 1
a307 1
	LDMIA	sp!,{r0-r2,r4-r11,ws,pc}
d312 1
a312 1
	DCD	work_CallBack_Buffer
d317 40
a356 40
	; Get pointer to call back buffer if it exists
	; On entry:
 	;    r1 = base of buffer
	;    r2 = end of buffer
	;    r3 = flags
	;    r4 = sample frequency
	;    r5 = sample period
	; On exit:
	;    call back data mixed in if there is some

	STMDB	sp!,{r0-r11,ws,lr}

	SUB	r6,r2,r1
	LDR	r7,[ws,#work_CallBack_BufferSize]

	CMP	r6,r7

	; If the buffer size has changed then need to make changes...
	STR	r6,[ws,#work_CallBack_BufferSize]

	LDR	r5,[ws,#work_CallBack_BufferFullCount]  ; Are there any full buffers?
	CMP	r5,#0
	BGT	addCallBackBuffer_OK

	; Need to flag an overrun
	LDR	r5,[ws,#work_callBack_Active]  ; Is the old call back active?
	CMP	r5,#1

	; If there are no full buffers and the call back is active then we have overrun
	LDREQ	r7,[ws,#work_callBack_Count]   ; If so then increment count and return
	ADDEQ	r7,r7,#1
	STREQ	r7,[ws,#work_callBack_Count]

	; Need to do a volume shift on the buffer to effectivly mix an empty buffer
	; into the existing data
	; This avoids volume fluctuations

	; r1 = Start of SoundDMA buffer
	; r2 = End of SoundDMA buffer
	; r6 = Length
d359 1
a359 1
	LDMIA	r1,{r3-r6}
d361 3
a363 3
	MACRO
	acbb_vsl	$work1,$work2,$getReg
	; Shift volumes
d365 3
a367 3
	; Old dumb way.
	MOV	$work1,$getReg,LSL #16          ; Put right into work1
	EOR	$getReg,$getReg,$work1,LSR #16  ; and left in getReg
d369 1
a369 1
	MOV	$work1,$work1,ASR #1     ; DIV 2
d371 1
a371 1
	MOV	$getReg,$getReg,ASR #1   ; DIV 2
d373 3
a375 3
	;TST	$getReg,#1<<15           ; Remove any low bit
	;EORNE	$getReg,$getReg,#1<<15
	BIC	$getReg,$getReg,#1<<15
d377 1
a377 1
	ADD	$getReg,$getReg,$work1,LSR #16
d379 7
a385 7
	; New shiny way
	MOV	$getReg,$getReg,ASR#1
	; Now getReg is perfect except possibly for bit 15 that should be the same as
	; bit 14. Form a word of differences between bits.
	EOR	$work1,$getReg,$getReg,LSL#1
	AND	$work1,$work1,#1<<15
	EOR	$getReg,$getReg,$work1
d388 1
a388 1
	MEND
d390 4
a393 4
	acbb_vsl	R11,R12,R3
	acbb_vsl	R11,R12,R4
	acbb_vsl	R11,R12,R5
	acbb_vsl	R11,R12,R6
d395 1
a395 1
	STMIA	r1!,{r3-r6}
d397 2
a398 2
	CMP	r1,r2
	BLT	addCallBackBuffer_VolumeShiftLoop
d400 1
a400 1
	B     addCallBackBuffer_Exit   ; No data available
d403 1
a403 1
	; There are buffers available so use one of these
d405 16
a420 16
	; r1 = Start of SoundDMA buffer
	; r2 = End of SoundDMA buffer
	; r6 = Length

	LDR	r5,work_CallBack_BufferVal
	ADD	r5,r5,ws
	;	Align
	ADD	r5,r5,#63
	BIC	r5,r5,#63
	LDR	r7,[ws,#work_CallBack_CurrentSoundBuffer]
	MLA	r0,r6,r7,r5                                    ; Buffer position

	; r0 = Source buffer
	; r1 = DMA buffer
	; r2 = DMA buffer end
	; r3 = Fill flags
d422 1
a422 1
	; Copy across (mixing??)
d424 2
a425 2
	TST	r3,#1
	BNE	addCallBackBuffer_Mix
d427 1
a427 1
	; No mixing
d430 2
a431 2
	LDMIA	r0!,{r3-r6}
	STMIA	r1!,{r3-r6}
d433 2
a434 2
	CMP	r1,r2
	BLT	addCallBackBuffer_Loop
d436 1
a436 1
	B	addCallBackBuffer_Final
d441 2
a442 2
	MVN	r12,#0
	MOV	r12,r12,LSL#16
d445 2
a446 2
	LDMIA	r0!,{r3-r6}
	LDMIA	r1,{r7-r10}
d448 2
a449 2
	MACRO
	acbbm_l	$work1,$work2,$getReg,$mixReg
d452 3
a454 3
	; Old dumb way
	MOV	$work1,$getReg,LSL #16          ; Put right into work1
	EOR	$getReg,$getReg,$work1,LSR #16  ; and left in getReg
d456 1
a456 1
	MOV	$work1,$work1,ASR #1     ; DIV 2
d458 1
a458 1
	MOV	$getReg,$getReg,ASR #1   ; DIV 2
d460 3
a462 3
	;TST	$getReg,#1<<15           ; Remove any low bit
	;EORNE	$getReg,$getReg,#1<<15
	BIC	$getReg,$getReg,#1<<15
d464 2
a465 2
	MOV	$work2,$mixReg,LSL #16          ; Put right into work2
	EOR	$mixReg,$mixReg,$work2,LSR #16  ; and left in mixReg
d467 1
a467 1
	MOV	$work2,$work2,ASR #1     ; DIV 2
d469 1
a469 1
	MOV	$mixReg,$mixReg,ASR #1   ; DIV 2
d471 3
a473 3
	;TST	$mixReg,#1<<15           ; Remove any low bit
	;EORNE	$mixReg,$mixReg,#1<<15
	BIC	$mixReg,$mixReg,#1<<15
d475 3
a477 3
	; Now mix
	ADD	$getReg,$getReg,$mixReg
	ADD	$work1,$work1,$work2
d479 1
a479 1
	ADD	$getReg,$getReg,$work1,LSR #16
d481 22
a502 22
	; New shiny way
	; getReg = abcdefgh
	; mixReg = ijklmnop
	; target = qrstuvwx
	; work2 = 0xFFFF0000
	AND	$work1,$work2,$getReg,ASR#1		; work1 = (abcD0000)>>>1
	MOV	$getReg,$getReg,LSL#16			; getReg=  efgh00000
	MOV	$getReg,$getReg,ASR#1			; getReg= (efgh00000)>>>1

	ADD	$work1,$work1,$mixReg,ASR#1		; work1 = qrstXXXX
	MOV	$mixReg,$mixReg,LSL#16			; work2 = mnop0000
	ADD	$getReg,$getReg,$mixReg,ASR#1		; getReg= uvwxXXXX
	AND	$work1,$work1,$work2			; work1 = qrst0000
	ORR	$getReg,$work1,$getReg,LSR#16		; work1 = qrstuvwx
 ]

	MEND

	acbbm_l	R11,R12,R3,R7
	acbbm_l	R11,R12,R4,R8
	acbbm_l	R11,R12,R5,R9
	acbbm_l	R11,R12,R6,R10
d504 1
a504 1
	STMIA	r1!,{r3-r6}
d506 2
a507 2
	CMP	r1,r2
	BLT	addCallBackBufferMix_Loop
d512 1
a512 1
	; Increment current SoundDMA buffer
d514 12
a525 12
	LDR	r7,[ws,#work_CallBack_CurrentSoundBuffer]
	LDR	r8,[ws,#work_CallBack_numCallBackBuffers]
	ADD	r7,r7,#1
	CMP	r7,r8
	MOVGE	r7,#0
	STR	r7,[ws,#work_CallBack_CurrentSoundBuffer]

	; Decrement full count
	LDR	r8,[ws,#work_CallBack_BufferFullCount]
	SUBS	r8,r8,#1
	MOVLT	r8,#0
	STR	r8,[ws,#work_CallBack_BufferFullCount]
d528 1
a528 1
	LDMIA	sp!,{r0-r11,ws,pc}
d534 18
a551 18
	; On entry:
	;    r1 = base of buffer
	;    r2 = end of buffer
	;    r3 = flags
	;    r4 = sample frequency
	;    r5 = sample period

	STMDB	sp!,{r0-r11,ws,lr}

	SUB	r6,r2,r1
	STR	r6,[ws,#work_CallBack_BufferSize]
	STR	r3,[ws,#work_CallBack_Flags]
	STR	r4,[ws,#work_CallBack_SampleFrequency]
	STR	r5,[ws,#work_CallBack_SamplePeriod]

	LDR	r5,[ws,#work_callBack_Active]  ; Set the call back active flag
	CMP	r5,#1
	BEQ	callBackHandlerProcess_Exit
d553 2
a554 2
	MOV	r5,#1
	STR	r5,[ws,#work_callBack_Active]  ; Set the call back active flag
d556 1
a556 1
	; Set up new call back
d560 1
a560 1
	; Either by CBAI
d562 2
a563 2
	LDR	r0,[ws,#work_CBAIActive]
	CMP	r0,#1
d565 3
a567 3
	ADREQ	r0,CBAIRoutine
	STREQ	r0,[ws,#work_PollWord]
	BEQ	callBackHandlerProcess_Exit
d569 1
a569 1
	; Or by old style Call backs
d573 2
a574 2
	ADR	r0,doHandlerCallBack
	LDR	r1,[ws,#work_privateWord]
d577 7
a583 7
	TEQ	PC,PC
	MRSEQ	R9,CPSR		; If we are in 32-bit mode. R9 = CPSR
	MOVNE	R9,PC		; If we are in 26-bit mode, R9 = PC+PSR
	ORR	r8,r9,#SVC_Mode	; Preserved 32-bitness
	MSREQ	CPSR_c,R8
	TEQNEP	r8,#0
	MOV	r0,r0
d590 1
a590 1
	Push    "lr"
d592 1
a592 1
	SWI	XOS_AddCallBack
d596 4
a599 4
	TEQ	PC,PC
	MSREQ	CPSR_c,R9
	TEQNEP	R9,#0
	MOV	r0,r0
d606 1
a606 1
	LDMIA	sp!,{r0-r11,ws,pc}
d615 14
a628 14
	; Called by call back system
	; Needs to call the handler with the right parameters
	STMDB	sp!,{r0-r11,ws,lr}

	LDR	ws,[ws]

	; From the start and end get the length and offset into the buffer
	; by the current OutBuffer value

	LDR	r10,[ws,#work_CallBack_BufferSize]
	LDR	r0,[ws,#work_privateWord]
	LDR	r3,[ws,#work_CallBack_Flags]
	LDR	r4,[ws,#work_CallBack_SampleFrequency]
	LDR	r5,[ws,#work_CallBack_SamplePeriod]
d631 1
a631 1
	;	r10 = Buffer length
d633 22
a654 22
	LDR	r2,work_CallBack_BufferVal
	ADD	r2,r2,ws
	;	Align
	ADD	r2,r2,#63
	BIC	r2,r2,#63

	LDR	r7,[ws,#work_CallBack_CurrentOutBuffer]
	MLA	r1,r10,r7,r2                              ; Buffer address

	ADD	r2,r1,r10

	MOV	r3,#0                           ; Buffer invalid

	LDR	r8,[ws,#work_CallBackHandlers]
	CMP	r8,#0
	MOVNE	r6,#handlerType_CallBack
	BLNE	handler

	LDR	r8,[ws,#work_ProcessHandlers]
	CMP	r8,#0
	MOVNE	r6,#handlerType_Process
	BLNE	handler
d658 22
a679 22
	TEQ	PC,PC
	MRSEQ	R8,CPSR
	MOVNE	R8,PC
	ORREQ	r9,r8,#I32flag
	ORRNE	r9,r8,#Iflag
	MSREQ	CPSR_c,R9
	TEQNEP	r9,#0                  ; interrupts -> disabled
 ]
	; increment full count
	; Increment out buffer
	LDR	r7,[ws,#work_CallBack_CurrentOutBuffer]
	LDR	r9,[ws,#work_CallBack_numCallBackBuffers]
	ADD	r7,r7,#1
	CMP	r7,r9
	MOVGE	r7,#0
	STR	r7,[ws,#work_CallBack_CurrentOutBuffer]

	LDR	r7,[ws,#work_CallBack_BufferFullCount]
	ADD	r7,r7,#1
	CMP	r7,r9
	MOVGT	r7,r9
	STR	r7,[ws,#work_CallBack_BufferFullCount]
d682 3
a684 3
	TEQ	PC,PC
	MSREQ	CPSR_c,R8
	TEQNEP	r8,#0                  ; Interrupts reenabled
d687 2
a688 2
	; Check for full count = max
	; Loop round if not
d690 2
a691 2
	CMP	r7,r9
	BLT	doHandlerCallBack_Loop
d693 1
a693 1
	; Otherwise we have filled all the buffers and can return
d696 7
a702 7
	TEQ	PC,PC
	MRSEQ	R8,CPSR
	MOVNE	R8,PC
	ORREQ	r9,r8,#I32flag
	ORRNE	r9,r8,#Iflag
	MSREQ	CPSR_c,R9
	TEQNEP	r9,#0                 ; interrupts -> disabled
d705 2
a706 2
	MOV	r5,#0
	STR	r5,[ws,#work_callBack_Active]  ; Call back completed
d710 3
a712 3
	TEQ	PC,PC
	MSREQ	CPSR_c,R8
	TEQNEP	r8,#0                  ; Interrupts reenabled
d715 1
a715 1
	LDMIA	sp!,{r0-r11,ws,pc}
d720 1
a720 1
	; Initialise the call back buffer to 0
d723 1
a723 1
	STMDB	sp!,{r0-r11,ws,lr}
d725 4
a728 4
	MOV	r0,#0
	MOV	r1,#0
	MOV	r2,#0
	MOV	r3,#0
d730 2
a731 2
	LDR	r4,work_CallBack_BufferVal
	ADD	r4,r4,ws
d733 3
a735 3
	;EVALAlign
	ADD   r4,r4,#63
	BIC	r4,r4,#63
d737 1
a737 1
	ADD   r5,r4,#callBackBufferLen
d740 3
a742 3
	STMIA	r4!,{r0-r3}
	CMP	r4,r5
	BLT	clearCallBackBuffer_Loop
d744 1
a744 1
	LDMIA	sp!,{r0-r11,ws,pc}
d750 23
a772 23
	; Set the corresponding bit for this handler's number & type
	; On entry:
	;    r0 = Handler number
	;    r4 = Type
	STMDB	sp!,{r0-r4,lr}

	MOV	r1,#1
	MOV	r0,r1,LSL r0          ; As a bit

	CMP	r4,#handlerType_Immediate
	LDREQ	r1,[ws,#work_ImmediateHandlers]
	ORREQ	r1,r1,r0
	STREQ	r1,[ws,#work_ImmediateHandlers]

	CMP	r4,#handlerType_CallBack
	LDREQ	r1,[ws,#work_CallBackHandlers]
	ORREQ	r1,r1,r0
	STREQ	r1,[ws,#work_CallBackHandlers]

	CMP	r4,#handlerType_Process
	LDREQ	r1,[ws,#work_ProcessHandlers]
	ORREQ	r1,r1,r0
	STREQ	r1,[ws,#work_ProcessHandlers]
d774 1
a774 1
	LDMIA	sp!,{r0-r4,pc}
d779 23
a801 23
	; Clear the corresponding bit for this handler's number & type
	; On entry:
	;    r0 = Handler number
	;    r4 = Type
	STMDB	sp!,{r0-r4,lr}

	MOV	r1,#1
	MOV	r0,r1,LSL r0          ; As a bit

	CMP	r4,#handlerType_Immediate
	LDREQ	r1,[ws,#work_ImmediateHandlers]
	BICEQ	r1,r1,r0
	STREQ	r1,[ws,#work_ImmediateHandlers]

	CMP	r4,#handlerType_CallBack
	LDREQ	r1,[ws,#work_CallBackHandlers]
	BICEQ	r1,r1,r0
	STREQ	r1,[ws,#work_CallBackHandlers]

	CMP	r4,#handlerType_Process
	LDREQ	r1,[ws,#work_ProcessHandlers]
	BICEQ	r1,r1,r0
	STREQ	r1,[ws,#work_ProcessHandlers]
d803 1
a803 1
	LDMIA	sp!,{r0-r4,pc}
d811 1
a811 1
	; Install the CBAI stuff if module exists
d813 1
a813 1
	STMDB sp!,{r0-r11,ws,lr}
d815 2
a816 2
	MOV	r0,#0
	STR	r0,[ws,#work_PollWord]
d818 3
a820 3
	MOV	r0,#0
	ADR	r1,CBAIString
	SWI	XOS_SWINumberFromString
d822 3
a824 3
	MOVVC	r0,#1
	MOVVS	r0,#0
	STR	r0,[ws,#work_CBAIActive]
d826 4
a829 4
	ADDVC	r0,ws,#work_PollWord
	MOVVC	r1,#&100000       ; Scheduling class
	LDRVC	r2,[ws,#work_privateWord]
	SWIVC	XCBAI_RegisterPollWord
d831 1
a831 1
	LDMIA	sp!,{r0-r11,ws,pc}
d836 3
a838 3
	=	"CBAI_RegisterPollWord"
	DCB	0
	ALIGN
d843 2
a844 2
	; De-register the CBAI pollword
	STMDB sp!,{r0-r11,ws,lr}
d846 2
a847 2
	LDR	r0,[ws,#work_CBAIActive]
	CMP	r0,#1
d849 2
a850 2
	ADDEQ	r0,ws,#work_PollWord
	SWIEQ	XCBAI_DeregisterPollWord
d852 2
a853 2
	MOV	r0,#0
	STR	r0,[ws,#work_CBAIActive]
d855 1
a855 1
	LDMIA	sp!,{r0-r11,ws,pc}
d860 1
a860 1
	; Call back routine to call call back addresses
d862 1
a862 1
	STMDB sp!,{r0-r11,ws}
d864 8
a871 8
	;TEQ	PC,PC
	;MRSEQ	R9,CPSR
	;MOVNE	R9,PC
	;ORR	r8,r9,#SVC_Mode
	;MSREQ	CPSR_c,R8
	;TEQNEP	r8,#0
	;MOV 	r0,r0
	;STMFD	sp!,{R9,lr}
d875 7
a881 7
	TEQ	PC,PC
	MRSEQ	R8,CPSR
	MOVNE	r8,pc
	ORREQ	r9,r8,#I32flag
	ORRNE	r9,r8,#Iflag
	MSREQ	CPSR_c,R9
	TEQNEP	r9,#0                  ; interrupts -> disabled
d884 1
a884 1
	BL	doHandlerCallBack
d888 3
a890 3
	TEQ	PC,PC
	MSREQ	CPSR_c,R8
	TEQNEP	r8,#0                  ; Interrupts reenabled
d893 5
a897 5
	;LDMFD	sp!,{R9,lr}
	;TEQ	PC,PC
	;MSREQ	CPSR_c,R9
	;TEQNEP	r9,#0
	;MOV	r0,r0
d899 1
a899 1
	LDMIA	R13!,{r0-r12,PC}
d906 1
a906 1
	END
@


1.7
log
@Changed to use NdrDebug instead of local debug functions
Changed GET of filenames to use <name>.<extension> form.
Built, but not tested.

Version 1.13. Tagged as 'SharedSnd-1_13'
@
text
@a81 6
getFillR0
	ADR	r0,fill
	MOV	pc,lr

 ; ----

@


1.6
log
@  No longer uses non-X SWIs in module code
Detail:
  A few of these were careless typos, others were already X SWIs but the
  symbol names didn't reflect the fact, and in other cases there was no code
  path to deal with error cases. All now fixed. Also fixed all the assembly
  time warnings (at least for 32-bit ROM builds).
Admin:
  No longer prevents the Raspberry Pi ROM init from completing.

Version 1.11. Tagged as 'SharedSnd-1_11'
@
text
@a626 7
 [ debug
; If you uncomment this, uncomment the switch to SVC mode in CBAIRoutine% too
;       SWI     XOS_WriteS
;	=	"Handler call back",0:ALIGN
;	SWI	XOS_NewLine
 ]

@


1.5
log
@Fix to work properly when built into ROM images
Detail:
  Makefile - Rewritten to use assembler makefile fragments instead of C ones. The component is listed as assembler in ModuleDB, so using the C fragments was causing an object file to be linked into the ROM instead of a module.
  MkRam,fd7 - Made to work with new makefile
  s/FillCode, s/Handler, s/Memory, s/Module, s/Vars - Removed dependency on relocation code. It looks like it was only the pointers in FILLCODE_table_start that were being relocated. The fillcode table is now stored in the workspace instead of within the module.
Admin:
  Tested in OMAP3 & Tungsten ROMs.
  Some of the disabled switches may still rely on the removed relocation code.


Version 1.07. Tagged as 'SharedSnd-1_07'
@
text
@d185 1
d193 7
a199 1
	STMFD	R13!,{R14}
d203 2
a204 1
	LDMFD	R13!,{R14}
d209 4
d445 1
a445 1
	STMDB	sp!,{ws}
d515 1
a515 1
	LDMIA	sp!,{ws}
d582 1
d590 7
a596 1
	STMFD	sp!,{lr}
d600 2
a601 1
	LDMFD	sp!,{lr}
d606 4
@


1.4
log
@  Selective merge of ESP's version 1.06 (14 May 2002) of SharedSound.
Detail:
  Changelog not provided by ESP. I have made an additional change to use
  the value of SoundSystemNIL from Hdr:Sound to test if SoundChannels is not
  installed - this constant changed in RISC OS 5 for 32-bitting reasons.
Admin:
  Builds, and briefly tested. Coincidentally, this is also our version 1.06.

Version 1.06. Tagged as 'SharedSnd-1_06'
@
text
@d280 1
a280 1
	ADR	r8,FILLCODE_table_start
@


1.3
log
@  Bugfix from Robin Watts.
Detail:
  1-instruction error broke sound mixing.
Admin:
  Fix for associated fault in AMPlayer on its way.

Version 1.02. Tagged as 'SharedSnd-1_02'
@
text
@a0 26
; Copyright (c) 1995, Expressive Software Projects
; All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of Expressive Software Projects nor the names of its
;       contributors may be used to endorse or promote products derived from
;       this software without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; 
	GBLL	debug
d28 2
a29 1
XOS_SWINumberFromString	*	&20039
a43 1
debug		SETL {FALSE}
@


1.3.2.1
log
@Import of latest sources from ESP.
This represents ESP's version 1.06 (14 May 2002). The files are exactly as
received, but they are not expected to build as they are against the public
headers.
@
text
@d26 1
d29 1
a29 2
; these are defined in global headers
; XOS_SWINumberFromString	*	&20039
d44 1
d190 1
a190 1
	MSREQ	CPSR_ctl,R8
d199 1
a199 1
	MSREQ	CPSR_ctl,R9
d575 1
a575 1
	MSREQ	CPSR_ctl,R8
d584 1
a584 1
	MSREQ	CPSR_ctl,R9
@


1.2
log
@  Module scrutinised for problems, and many found and fixed.
Detail:
  * Module flags word and header entry reinstated.
  * Many exits from SWIs had lost their 32-bit compatibility.
  * Unconditional TEQP made conditional, and an MSR replaced with an MRS.
  * A few unnecessary mode checks and alternate returns simplified because
    transient callbacks and 8-bit fill code have never needed to preserve
    processor flags.
  * Driver mixer calling bug fixed again.
  * Spelling and grammatical errors in comments and error messages re-fixed.
  * Other insignificant stuff.
Admin:
  Still untested, but worth trying in a 32-bit build now.

Version 1.01. Tagged as 'SharedSnd-1_01'
@
text
@d284 1
a284 1
	CMN	r7,#0		; If volume != 0xFFFFFFFF
@


1.1
log
@  Import of version 1.00 of SharedSound from WSS - this is a merge of
  RISC OS Ltd, ESP and Pace sources. I've added the Makefile, Mk* and
  VersionNum files.

Detail (courtesy of WSS):
  * Incorporates fixes made to 0.58c to fix the callbacks on sound
    rate changes.

  * Incorporates RISC OS Ltd changes to response to
    TaskManager_Acknowledgements service.

  * Includes 8 bit Log and PowerWave drivers.

  * Now built with Objasm, not BASIC assembler.

  * SharedSound_HandlerInfo SWI fixed to conform to spec. Also
    extended to accept r0 = 0 on entry, in which case r0 = number of
    first registered handler (or 0 for none) on exit; R1-R5 corrupted.

    Therefore the following code enumerates handlers:

    REM Get first handler number.
    SYS "SharedSound_HandlerInfo",0 TO next% ; flags%
    REM While no errors, and not finished
    WHILE (next% <> 0) AND ((flags% AND 1) = 0)
     SYS"SharedSound_HandlerInfo",next% TO next%,a%,b%,c%,d%,e%
    ENDWHILE

  * Sends Service_Sound (&54) with reason code 6 (SharedSound Starting)
    on (callback after) initialisation.

  * Sends Service_Sound (&54) with reason code 7 (SharedSound Dying)
    on finalisation.

  * Some small optimisations

  * Version bumped to 1.00 (to allow RISC OS Ltd space to make changes
    to their versions).

  * Table of helpful fill code routines now passed to handlers in R8.

  * SharedSound reinitialises correctly on lower layers reinitialising.

  * More care taken to remove outstanding callbacks on finalise.

  * Dual 26/32 bit version.

Admin:
  * Not tested by us.

  * 8-bit sound system code is known not to be ROM safe. However, it is
    currently switched out (see the doLog option in s.Gets).

  * This version *will not work* on a 32-bit system. There are at least two
    issues with it that I've spotted with a quick glance through the code -
    the lack of the module flags word, and an unconditional TEQP instruction.
    This version has been checked in nevertheless as a record of what WSS
    delivered to us.

Version 1.00. Tagged as 'SharedSnd-1_00'
@
text
@d606 1
d866 1
a866 1
	MSREQ	R8,CPSR
d871 1
a871 1
	TEQP	r9,#0                  ; interrupts -> disabled
a880 1
	MOV	r0,r0
@


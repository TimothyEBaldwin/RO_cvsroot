head	1.14;
access;
symbols
	SharedSnd-1_20:1.14
	SharedSnd-1_19:1.14
	SharedSnd-1_18:1.13
	SharedSnd-1_17:1.10
	SharedSnd-1_16:1.9
	SharedSnd-1_15:1.9
	SharedSnd-1_14:1.8
	SharedSnd-1_13:1.7
	SharedSnd-1_12:1.6
	SharedSnd-1_11:1.5
	SharedSnd-1_10:1.4
	SharedSnd-1_09:1.4
	SharedSnd-1_08:1.4
	SharedSnd-1_07:1.4
	ESP_SharedSnd-1_06_merge:1.2.2.1
	SharedSnd-1_06:1.3
	ESP_SharedSnd-1_06:1.2.0.2
	ESP_SharedSnd-1_06_bp:1.2
	SharedSnd-1_05:1.2
	SharedSnd-1_04:1.2
	SharedSnd-1_03:1.2
	SharedSnd-1_02:1.2
	SharedSnd-1_01:1.2
	SharedSnd-1_00:1.1;
locks; strict;
comment	@# @;


1.14
date	2016.06.18.16.46.47;	author jlee;	state Exp;
branches;
next	1.13;
commitid	GZPyEQx8oxuR5Yaz;

1.13
date	2016.06.18.16.39.01;	author jlee;	state Exp;
branches;
next	1.12;
commitid	ODW0ixlFy50c3Yaz;

1.12
date	2016.06.18.16.25.15;	author jlee;	state Exp;
branches;
next	1.11;
commitid	VrYNipUTcuQuYXaz;

1.11
date	2016.06.18.16.19.19;	author jlee;	state Exp;
branches;
next	1.10;
commitid	L0sIVnG3vL4sWXaz;

1.10
date	2016.05.28.18.45.14;	author jlee;	state Exp;
branches;
next	1.9;
commitid	fNNi6vbOIgLlqh8z;

1.9
date	2013.09.07.09.58.38;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	DDb7J4xWmm0Dsu4x;

1.8
date	2013.09.07.09.48.59;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	xd8cpTeM2vojpu4x;

1.7
date	2013.09.04.07.14.41;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	2RDI391I6q1nE54x;

1.6
date	2013.04.14.16.33.37;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	spAQXyBBW956lLLw;

1.5
date	2012.05.13.12.13.48;	author bavison;	state Exp;
branches;
next	1.4;
commitid	ikRUfBzwYcXxHy4w;

1.4
date	2011.12.06.00.13.41;	author jlee;	state Exp;
branches;
next	1.3;
commitid	JycXv4ushgqpP3Kv;

1.3
date	2011.08.15.23.10.49;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.28.20.21.55;	author bavison;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.06.28.18.11.57;	author bavison;	state Exp;
branches;
next	;

1.2.2.1
date	2011.08.15.14.11.19;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Use PSR manipulation macros. Macroise driver calling. Simplify error checks.
Detail:
  s/Drivers - Macroise driver calling to reduce amount of duplicate code. Also avoid NOP if storing PC stores PC+8 and not PC+12.
  s/Handler - Use PSR manipulation macros for switching modes and controlling IRQs. Remove redundant IRQ disabling around atomic store of one word in doHandlerCallBack.
  s/Module - Use PSR manipulation macros for switching modes
  s/SWIS - Simplify range checking on handler and driver numbers; treat as unsigned numbers instead of signed.
  s/Vars - Remove local definitions of IRQ flags & SVC mode
Admin:
  Tested on Raspberry Pi


Version 1.19. Tagged as 'SharedSnd-1_19'
@
text
@; Copyright (c) 1995, Expressive Software Projects
; All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of Expressive Software Projects nor the names of its
;       contributors may be used to endorse or promote products derived from
;       this software without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; 

module
        ; Module header
        DCD     0                               ; Not an application
        DCD     initCode        - MODULE_START
        DCD     finalCode       - MODULE_START
        DCD     serviceCode     - MODULE_START
        DCD     title           - MODULE_START
        DCD     help            - MODULE_START
        DCD     0                               ; No commands
swiBaseNum
        DCD     SharedSoundSWI_Base             ; SWI Base number
        DCD     swiHandler      - MODULE_START
        DCD     swiTable        - MODULE_START  ; SWI Decode table
        DCD     0                               ; SWI Decode code
        DCD     0                               ; No messages file
        DCD     flagsWord       - MODULE_START

copyr
        = copyRightS
title
        = titleS,0
        ALIGN
help
        = "Shared Sound",9,Module_HelpVersion,variantS,0
        ALIGN

flagsWord
      [ No32bitCode
        DCD     0
      |
        DCD     ModuleFlag_32bit
      ]

        MakeInternatErrorBlock SSound_InitMem,,"NoMem"

initCode        ROUT
        Entry   "r7-r11,ws"

        BL      startMem                ; Get memory
        ADRVS   r0,ErrorBlock_SSound_InitMem
        BLVS    msgLookupErrorGlobal
        BVS     initError               ; Turns out there wasn't any

        ; r10 = private word
        ; ws = memory pointer [r10]

        BL      initWorkspace           ; Initialise workspace

      [ standalone
        ADR     r0,msgResArea
        SWI     XResourceFS_RegisterFiles
        BVS     initError
      ]
        ADD     r0,ws,#work_msgStruct
        ADR     r1,msgFileName
        MOV     r2,#0                   ; Buffer in RMA
        SWI     XMessageTrans_OpenFile
        BVS     initDeReg

 [ doCBAI
        BL      InstallCBAI
 ]

        BL      installDefaultDriver   ; Preferably Sound_LinearHandler or ChannelHandler

        ; notify TaskManager that the acknowledgements have changed
        LDR     r1,Service_TaskManagerAcknowledgementsVal
        MOV     r2,#0           ; MUST be zero to notify of change
        SWI     XOS_ServiceCall ; ignore if it failed

        ADR     R0,send_service_sound_start
        MOV     R1,#0
        SWI     XOS_AddCallBack

        CLRV                            ; Clear V
        EXIT

initDeReg
      [ standalone
        MOV     r7,r0
        ADR     r0,msgResArea
        SWI     XResourceFS_DeregisterFiles
        MOV     r0,r7
        SETV
      ]
initError
        EXIT

send_service_sound_start ROUT
        Entry   "r0-r8"
        MOV     r1,#Service_Sound                       ; Service_Sound
        MOV     r0,#Service_SharedSoundAlive            ; SharedSound starting
        SWI     XOS_ServiceCall                         ; Ignore any errors
        EXIT

 ; -------------------------------------------------

      [ standalone
msgResArea
        ResourceFile $MergedMsgs, Resources.SSound.Messages
        DCD     0
      ]
msgFileName
        DCB     "Resources:$.Resources.SSound.Messages", 0
        ALIGN
              
msgLookupErrorGlobal ROUT
        Entry   "r1-r7"
        MOV     r1, #0                  ; For errors before the messages are open
        B       %FT10
msgLookupError
        ; _kernel_oserror *msgLookupError(_kernel_oserror *err)
        ALTENTRY
        ADD     r1,ws,#work_msgStruct
10
        MOV     r2,#0
        ADRL    r4,title
        MOV     r5,#0
        MOV     r6,#0
        MOV     r7,#0
        SWI     XMessageTrans_ErrorLookup
        EXIT                            ; 26 bit case preserves flags (except V!)
                                        ; since nothing prior to the SWI corrupted them

msgLookupToken  ROUT
        ; void msgLookupToken(size_t buffersize, const char *token, char *buffer)
        Entry   "r0-r7"
        MOV     r3,r0
        ADD     r0,ws,#work_msgStruct
        MOV     r4,#0
        MOV     r5,#0
        MOV     r6,#0
        MOV     r7,#0
        SWI     XMessageTrans_Lookup
        MOVVS   r0,#0
        STRVSB  r0,[r2,#0]
        EXIT

 ; -------------------------------------------------

finalCode       ROUT
        Entry   "r0-r11,ws"

        LDR     ws,[ws]          ; Get work area

        MOV     r1,#Service_Sound                       ; Service_Sound
        MOV     r0,#Service_SharedSoundDying            ; SharedSound dying
        SWI     XOS_ServiceCall                         ; Ignore any errors

        ADR     r0,send_service_sound_start
        MOV     r1,#0
        SWI     XOS_RemoveCallBack


 [ doCBAI
        BL      RemoveCBAI
 ]
        BL      releaseDriver

        ; notify TaskManager that the acknowledgements have changed
        LDR     r1,Service_TaskManagerAcknowledgementsVal
        MOV     r2,#0 ; MUST be zero to notify of change
        SWI     XOS_ServiceCall ; ignore if it failed

        ADR     r0,serviceCode_Sound_DelayedCallback
        MOV     r1,r12
        SWI     XOS_RemoveTickerEvent

        ADR     r0,serviceCode_Sound_Callback
        MOV     r1,r12
        SWI     XOS_RemoveCallBack

 [ doCallBack
        ADRL    r0,rateChangeCallBack
        LDR     r1,[ws,#work_privateWord]
        SWI     XOS_RemoveCallBack
 ]

        ADRL    r0,doHandlerCallBack
        LDR     r1,[ws,#work_privateWord]
        SWI     XOS_RemoveCallBack

        ADD     r0,ws,#work_msgStruct
        SWI     XMessageTrans_CloseFile
      [ standalone
        ADRL    r0,msgResArea
        SWI     XResourceFS_DeregisterFiles
      ]
        CLRV                            ; Clear V
        EXIT
 ;
 ; -------------------------------------------------

        ; Service numbers, incorporating Ursula service numbers
        ASSERT  Service_Sound < Service_ResourceFSStarting
        ASSERT  Service_ResourceFSStarting < Service_TaskManagerAcknowledgements
        ASSERT  Service_TaskManagerAcknowledgements < Service_SoundDriver
UrsulaService
        DCD     0 ; flags
        DCD     serviceCode_UrsulaEntry - MODULE_START  ; the entry point

        DCD     Service_Sound
      [ standalone
        DCD     Service_ResourceFSStarting
      ]
Service_TaskManagerAcknowledgementsVal
        DCD     Service_TaskManagerAcknowledgements
Service_SoundDriverVal
        DCD     Service_SoundDriver
        DCD     0 ; table terminator
        DCD     UrsulaService           - MODULE_START  ; the table anchor

serviceCode
        MOV     r0, r0
serviceCode_UrsulaEntry
        Push    "lr"

        TEQ     R1,#Service_Sound
        BEQ     serviceCode_Sound

      [ standalone
        TEQ     R1,#Service_ResourceFSStarting
        BEQ     serviceCode_ResourceFSStarting
      ]
        LDR     lr,Service_SoundDriverVal
        TEQ     r1,lr
        BEQ     serviceCode_SoundDriver

        LDR     lr,Service_TaskManagerAcknowledgementsVal
        TEQ     r1,lr
        BEQ     serviceCode_TaskManagerAcknowledgements

        Pull    "pc"

      [ standalone
; ResourceFS started, reregister the messages
serviceCode_ResourceFSStarting
        Push    "R0"                 ; lr already stacked
        ADRL    R0, msgResArea
        MOV     lr,pc
        MOV     pc,R2
        Pull    "R0,PC"
      ]

; SoundDMA has reinitialised, so we need to stick our
; LinearHandler in place
serviceCode_Sound
        Push    "R0-R3"              ; lr already stacked
        LDR     ws,[ws]
        LDR     R14,[ws,# work_currentDriver]

; linear handler goes through level 0
; if it dies, we shutdown the current handler (for lin or log handlers)
; it it starts up, we start the current handler (for lin or log handlers)
        TEQ     R14,#2 ; linear handler
        TEQNE   R14,#1 ; log handler
        TEQEQ   R0,#Service_SoundLevel0Dying
        BEQ     serviceCode_Sound_Shutdown

        TEQ     R14,#2 ; linear handler
        TEQNE   R14,#1 ; log handler
        TEQ     R0,#Service_SoundLevel0Alive
        BEQ     serviceCode_Sound_Reinit

; log handler goes through level 1, but only after SoundChannels has
; registered itself
        TEQ     R0,#Service_SoundLevel1Dying
        TEQEQ   R14,#1 ; log handler
        BEQ     serviceCode_Sound_Shutdown

        TEQ     R0,#Service_SoundLevel1Alive
        TEQEQ   R14,#1 ; log handler

        Pull    "R0-R3,PC", NE

serviceCode_Sound_Reinit
        TEQ     r14,#1 ; log handler
        BNE     %FT10  ; linear handler can go

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
        ADR     r1,serviceCode_Sound_DelayedCallback
        MOV     r2,ws
        SWI     XOS_CallAfter

        Pull    "R0-R3,PC"

10
        ADR     r0,serviceCode_Sound_Callback
        MOV     r1,ws
        SWI     XOS_AddCallBack

        Pull    "R0-R3,PC"

serviceCode_Sound_Shutdown
        Debug   gn, "shutdown: releaseDriver"
        BL      releaseDriver
        Debug   gn, "shutdown: returning",0
        Pull    "R0-R3,PC"

serviceCode_Sound_Callback ROUT
        Entry   "R0-R3"
        Debug   gn, "callback: installDefaultDriver"
        BL      installDefaultDriver
        Debug   gn, "callback: done",0

; check the install type
        LDR     R14,[ws,# work_currentDriver]
        TEQ     R14,#1 ; log driver ?
        BNE     %FT90
   [ doLog
        LDR     R14,[ws,# work_Log_InitedFully]
        TEQ     R14,#1
        BEQ     %FT90
   ]

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
        ADR     r1,serviceCode_Sound_DelayedCallback
        MOV     r2,ws
        SWI     XOS_CallAfter

90
        EXIT

serviceCode_Sound_DelayedCallback ROUT
        Entry   "R0-R3"

        Debug   gn,"delayedcallback: set callback"

        ADR     r0,serviceCode_Sound_Callback
        MOV     r1,ws
        SWI     XOS_AddCallBack

        EXIT

 ; Ensure that we place messages in the acknowledgements window
serviceCode_TaskManagerAcknowledgements ROUT

        Push    "r0-r3"              ; lr already stacked
        TEQ     r2,#0
        Pull    "r0-r3,pc", EQ
        MOV     r3,r2
        MOV     r0,#&1000;TaskManager_AckGroup_System ; &1000

        ADRL    r1,title

        ADR     r2,acknowledgement
        MOV     lr,pc
        MOV     pc,r3
        Pull    "r0-r3,pc"

; the message to appear in the window
acknowledgement

        = ackS,0
        ALIGN

serviceCode_SoundDriver ROUT
        Push    "r0-r11,ws"      ; lr already stacked

        LDR     ws,[ws]          ; Get work area

        CMP     r0,#Service_SoundDriver_Start
        BEQ     serviceCode_SoundDriverStart

        CMP     r0,#Service_SoundDriver_End
        BEQ     serviceCode_SoundDriverEnd

        Pull    "r0-r11,ws,pc"

serviceCode_SoundDriverStart
        ; install into Sound Driver

        ADRL    r0,SoundDriverStart
        MOV     r1,ws

        ; Change here from RJW; we may well be in IRQ mode here, so
        ; can't call SWIs directly. Instead jump to SVC mode and
        ; protect SVC_R14 first.
        Push    "R8,R9"

        SetMode SVC32_mode, R8, R9
        Push    "R14"

        SWI     XOS_AddCallBack

        Pull    "R14"
        RestPSR R9,,cf
        Pull    "R8,R9"

        Pull    "r0-r11,ws,pc"

 ; ----

serviceCode_SoundDriverEnd
        ;  Remove from Sound Driver

        BL      SoundDriverRemove

        Pull    "r0-r11,ws,pc"

 ; -----------------  SWI'S

swiTable

        = swiNameS,0
        = "InstallHandler",0
        = "RemoveHandler",0
        = "HandlerInfo",0
        = "HandlerVolume",0
        = "HandlerSampleType",0
        = "HandlerPause",0
        = "SampleRate",0
        = "InstallDriver",0
        = "RemoveDriver",0
        = "DriverInfo",0
        = "DriverVolume",0
        = "DriverMixer",0
        = "CheckDriver",0
        = "ControlWord",0
        = "HandlerType",0
 [ debugxc
        = "Test",0
        = "Info",0
 ]
        DCB 0
        ALIGN

swiHandler
    [ :LNOT: No26bitCode
      [ :LNOT: No32bitCode
        TEQ     pc,pc
        BEQ     swiHandler32
      ]
        ; Veneer for 26bit OS's, preserve NZC
        Push    "lr"
        BL      swiHandler32
        Pull    "lr"
        MOVVCS  pc, lr
        ORRVSS  pc, lr, #V_bit
swiHandler32
    ]
        MOV     r10,ws
        LDR     ws,[ws]    ; ws = pointer to RMA data block
        CMP     r11,#(EndOfJumpTable - jumpTable)/4
        ADDCC   pc,pc,r11,LSL #2
        B       UnknownSWIerror
jumpTable
        B       swiInstallHandler          ;  OK
        B       swiRemoveHandler           ;  OK
        B       swiHandlerInfo             ;  OK
        B       swiHandlerVolume           ;  OK
        B       swiHandlerSampleType       ;  not in this version
        B       swiHandlerPause            ;  not in this version
        B       swiSampleRate              ;  OK
        B       swiInstallDriver           ;  OK
        B       swiRemoveDriver            ;  OK
        B       swiDriverInfo              ;  OK
        B       swiDriverVolume            ;  OK
        B       swiDriverMixer             ;  OK
        B       driverCheck                ;
        B       swiControlWord             ;
        B       swiHandlerType             ;
 [ debugxc
        B       swiTest                    ;  For debugging only
        B       swiInfo                    ;  For debugging only
 ]

EndOfJumpTable

UnknownSWIerror
        ADR     r0,ErrorBlock_ModuleBadSWI
        B       msgLookupError

        MakeInternatErrorBlock ModuleBadSWI,,"BadSWI"

        END
@


1.13
log
@Use Entry/EXIT, Push/Pull macros
Detail:
  s/* - Code updated to use Entry/EXIT and Push/Pull macros where possible instead of manual STM/LDM. Also add ROUTs for safety (although most routines use named local labels rather than numbered ones). A few obvious cases also fixed to reduce number of regs pushed onto stack.
  A few other changes and fixes of note:
  s/Log - Trim empty, unused installLogDriver routine when doLog is {FALSE}
  s/Module - Add a veneer to swiHandler to deal with 26bit and 26/32bit neutral cases; avoids the need for individual SWI handlers to preserve NZC
  s/SWIs:
  - Remove 26/32bit neutral SWI exit code, now handled by veneers. CLRV on most SWI exits to replace the implicit CLRV from CMP pc,pc.
  - swiHandlerVolume and swiDriverMixer were popping the wrong regs from the stack for most error cases; now fixed via the switch to Entry/EXIT
Admin:
  Tested on Raspberry Pi


Version 1.18. Tagged as 'SharedSnd-1_18'
@
text
@d415 1
a415 14
      [ NoARMG
        TEQ     PC,PC
        MRSEQ   R9,CPSR         ; If in 32-bit mode, R9 = CPSR
        MOVNE   R9,PC           ; If in 26-bit mode, R9 = PC+PSR
        ORR     R8,R9,#3        ; Preserves 32-bitness
        MSREQ   CPSR_c,R8
        TEQNEP  R8,#0
        MOV     R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MRS     R9,CPSR
        ORR     R8,R9,#3        ; to SVC32 mode
        MSR     CPSR_c,R8
      ]
d421 1
a421 9
      [ NoARMG
        TEQ     PC,PC
        MSREQ   CPSR_c,R9
        TEQNEP  R9,#0
        MOV     R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MSR     CPSR_c,R9       ; back to original mode
      ]
@


1.12
log
@Use constants from build system
Detail:
  s/Gets - GET Hdr:Services
  s/Vars - Remove some locally defined constants which we can get from Hdr: instead
  s/Module - SWI base and Service_Sound subreason tokens renamed to match those used in Hdr:
Admin:
  Binary unchanged


Version 1.17. Not tagged
@
text
@d61 3
a63 2
initCode
        STMDB   sp!,{r7-r11,ws,lr}
d102 1
a102 1
        LDMIA   sp!,{r7-r11,ws,pc}
d113 1
a113 1
        LDMIA   sp!,{r7-r11,ws,pc}
d115 2
a116 2
send_service_sound_start
        STMFD   r13!,{r0-r8,r14}
d120 1
a120 1
        LDMFD   r13!,{r0-r8,PC}
d134 1
a134 1
        STMDB   sp!,{r1-r7,lr}
d139 1
a139 1
        STMDB   sp!,{r1-r7,lr}
d148 1
a148 1
        LDMIA   sp!,{r1-r7,pc}          ; 26 bit case preserves flags (except V!)
d151 1
a151 1
msgLookupToken
d153 1
a153 1
        STMDB   sp!,{r0-r7,lr}
d163 1
a163 1
        LDMIA   sp!,{r0-r7,pc}
d167 2
a168 2
finalCode
        STMDB   sp!,{r0-r11,ws,lr}
d216 1
a216 1
        LDMIA   sp!,{r0-r11,ws,pc}
d264 1
a264 1
        STMFD   R13!,{R0,LR}
d268 1
a268 1
        LDMFD   R13!,{R0,PC}
d274 1
a274 1
        STMFD   R13!,{R0-R3}
d300 1
a300 1
        LDMNEFD R13!,{R0-R3,PC}
d315 1
a315 1
        LDMFD   R13!,{R0-R3,PC}
d322 1
a322 1
        LDMFD   R13!,{R0-R3,PC}
d328 1
a328 1
        LDMFD   R13!,{R0-R3,PC}
d331 1
a331 1
        STMFD   R13!,{R0-R3,R14}
d356 1
a356 1
        LDMFD   R13!,{R0-R3,PC}
d358 2
a359 2
serviceCode_Sound_DelayedCallback
        STMFD   R13!,{R0-R3,R14}
d367 1
a367 1
        LDMFD   R13!,{R0-R3,PC}
d370 1
a370 1
serviceCode_TaskManagerAcknowledgements
d372 1
a372 1
        STMDB   sp!,{r0-r3}
d374 1
a374 1
        LDMEQIA sp!,{r0-r3,pc}
d383 1
a383 1
        LDMIA sp!,{r0-r3,pc}
d391 2
a392 2
serviceCode_SoundDriver
        STMDB   sp!,{r0-r11,ws}      ; lr already stacked
d402 1
a402 1
        LDMIA   sp!,{r0-r11,ws,pc}
d413 1
a413 1
        STMFD   R13!,{R8,R9}
d443 1
a443 1
        LDMFD   R13!,{R8,R9}
d445 1
a445 1
        LDMIA   sp!,{r0-r11,ws,pc}
d454 1
a454 1
        LDMIA sp!,{r0-r11,ws,pc}
d484 13
@


1.11
log
@Expand tabs
Detail:
  s/* - Expand all tabs, to avoid space/tab use inconsistencies within some files and to match general ROOL code formatting
Admin:
  Binary unchanged


Version 1.17. Not tagged
@
text
@d37 1
a37 1
        DCD     swiBase                         ; SWI Base number
d117 1
a117 1
        MOV     r0,#Service_Sound_SharedSoundAlive      ; SharedSound starting
d172 1
a172 1
        MOV     r0,#Service_Sound_SharedSoundDying      ; SharedSound dying
d282 1
a282 1
        TEQEQ   R0,#Service_Sound_Level0Dying
d287 1
a287 1
        TEQ     R0,#Service_Sound_Level0Alive
d292 1
a292 1
        TEQ     R0,#Service_Sound_Level1Dying
d296 1
a296 1
        TEQ     R0,#Service_Sound_Level1Alive
@


1.10
log
@Don't flag 26bit builds as being 32bit compatible
Detail:
  s/Module - Make sure module flags word is 0 when No32bitCode
Admin:
  Builds, untested


Version 1.17. Tagged as 'SharedSnd-1_17'
@
text
@d28 8
a35 8
	; Module header
	DCD	0				; Not an application
	DCD	initCode	- MODULE_START
	DCD	finalCode	- MODULE_START
	DCD	serviceCode	- MODULE_START
	DCD	title		- MODULE_START
	DCD	help		- MODULE_START
	DCD	0				; No commands
d37 4
a40 4
	DCD	swiBase				; SWI Base number
	DCD	swiHandler	- MODULE_START
	DCD	swiTable	- MODULE_START	; SWI Decode table
	DCD	0				; SWI Decode code
d45 1
a45 1
	= copyRightS
d47 2
a48 2
	= titleS,0
	ALIGN
d50 2
a51 2
	= "Shared Sound",9,Module_HelpVersion,variantS,0
	ALIGN
d60 1
a60 1
	MakeInternatErrorBlock SSound_InitMem,,"NoMem"
d62 1
a62 1
	STMDB	sp!,{r7-r11,ws,lr}
d64 4
a67 4
	BL	startMem                ; Get memory
	ADRVS	r0,ErrorBlock_SSound_InitMem
	BLVS	msgLookupErrorGlobal
	BVS	initError               ; Turns out there wasn't any
d69 2
a70 2
	; r10 = private word
	; ws = memory pointer [r10]
d72 1
a72 1
	BL	initWorkspace           ; Initialise workspace
d75 3
a77 3
	ADR	r0,msgResArea
	SWI     XResourceFS_RegisterFiles
	BVS	initError
d79 5
a83 5
	ADD	r0,ws,#work_msgStruct
	ADR	r1,msgFileName
	MOV	r2,#0                   ; Buffer in RMA
	SWI	XMessageTrans_OpenFile
	BVS	initDeReg
d86 1
a86 1
	BL	InstallCBAI
d89 1
a89 1
	BL	installDefaultDriver   ; Preferably Sound_LinearHandler or ChannelHandler
d91 8
a98 8
	; notify TaskManager that the acknowledgements have changed
	LDR	r1,Service_TaskManagerAcknowledgementsVal
	MOV	r2,#0		; MUST be zero to notify of change
	SWI	XOS_ServiceCall ; ignore if it failed

	ADR	R0,send_service_sound_start
	MOV	R1,#0
	SWI	XOS_AddCallBack
d100 2
a101 2
	CLRV				; Clear V
	LDMIA	sp!,{r7-r11,ws,pc}
d105 5
a109 5
	MOV	r7,r0
	ADR	r0,msgResArea
	SWI     XResourceFS_DeregisterFiles
	MOV	r0,r7
	SETV
d112 1
a112 1
	LDMIA	sp!,{r7-r11,ws,pc}
d115 5
a119 5
	STMFD	r13!,{r0-r8,r14}
	MOV	r1,#Service_Sound			; Service_Sound
	MOV	r0,#Service_Sound_SharedSoundAlive	; SharedSound starting
	SWI	XOS_ServiceCall				; Ignore any errors
	LDMFD	r13!,{r0-r8,PC}
d125 2
a126 2
	ResourceFile $MergedMsgs, Resources.SSound.Messages
	DCD	0
d129 3
a131 3
	DCB	"Resources:$.Resources.SSound.Messages", 0
	ALIGN
	      
d133 3
a135 3
        STMDB	sp!,{r1-r7,lr}
	MOV	r1, #0                  ; For errors before the messages are open
	B	%FT10
d137 3
a139 3
	; _kernel_oserror *msgLookupError(_kernel_oserror *err)
        STMDB	sp!,{r1-r7,lr}
        ADD	r1,ws,#work_msgStruct
d141 8
a148 8
        MOV	r2,#0
        ADRL	r4,title
        MOV	r5,#0
        MOV	r6,#0
        MOV	r7,#0
        SWI	XMessageTrans_ErrorLookup
	LDMIA	sp!,{r1-r7,pc}          ; 26 bit case preserves flags (except V!)
	                                ; since nothing prior to the SWI corrupted them
d151 12
a162 12
	; void msgLookupToken(size_t buffersize, const char *token, char *buffer)
	STMDB	sp!,{r0-r7,lr}
	MOV	r3,r0
	ADD	r0,ws,#work_msgStruct
	MOV	r4,#0
	MOV	r5,#0
	MOV	r6,#0
	MOV	r7,#0
	SWI	XMessageTrans_Lookup
	MOVVS	r0,#0
	STRVSB	r0,[r2,#0]
	LDMIA	sp!,{r0-r7,pc}
d167 1
a167 1
	STMDB	sp!,{r0-r11,ws,lr}
d169 1
a169 1
	LDR	ws,[ws]          ; Get work area
d171 3
a173 3
	MOV	r1,#Service_Sound			; Service_Sound
	MOV	r0,#Service_Sound_SharedSoundDying	; SharedSound dying
	SWI	XOS_ServiceCall	 			; Ignore any errors
d175 3
a177 3
	ADR	r0,send_service_sound_start
	MOV	r1,#0
	SWI	XOS_RemoveCallBack
d181 1
a181 1
	BL	RemoveCBAI
d183 1
a183 1
	BL	releaseDriver
d185 12
a196 12
	; notify TaskManager that the acknowledgements have changed
	LDR	r1,Service_TaskManagerAcknowledgementsVal
	MOV	r2,#0 ; MUST be zero to notify of change
	SWI	XOS_ServiceCall ; ignore if it failed

	ADR     r0,serviceCode_Sound_DelayedCallback
	MOV     r1,r12
	SWI     XOS_RemoveTickerEvent

	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,r12
	SWI     XOS_RemoveCallBack
d199 3
a201 3
	ADRL	r0,rateChangeCallBack
	LDR	r1,[ws,#work_privateWord]
	SWI     XOS_RemoveCallBack
d204 3
a206 3
	ADRL	r0,doHandlerCallBack
	LDR	r1,[ws,#work_privateWord]
	SWI     XOS_RemoveCallBack
d208 2
a209 2
	ADD	r0,ws,#work_msgStruct
	SWI	XMessageTrans_CloseFile
d211 2
a212 2
	ADRL	r0,msgResArea
	SWI	XResourceFS_DeregisterFiles
d214 2
a215 2
	CLRV				; Clear V
	LDMIA	sp!,{r0-r11,ws,pc}
d219 4
a222 4
	; Service numbers, incorporating Ursula service numbers
	ASSERT  Service_Sound < Service_ResourceFSStarting
	ASSERT  Service_ResourceFSStarting < Service_TaskManagerAcknowledgements
	ASSERT  Service_TaskManagerAcknowledgements < Service_SoundDriver
d224 2
a225 2
	DCD	0 ; flags
	DCD	serviceCode_UrsulaEntry - MODULE_START	; the entry point
d227 1
a227 1
	DCD	Service_Sound
d229 1
a229 1
	DCD     Service_ResourceFSStarting
d232 1
a232 1
	DCD	Service_TaskManagerAcknowledgements
d234 3
a236 3
	DCD	Service_SoundDriver
	DCD	0 ; table terminator
	DCD	UrsulaService 		- MODULE_START	; the table anchor
d239 1
a239 1
	MOV     r0, r0
d243 2
a244 2
	TEQ	R1,#Service_Sound
	BEQ	serviceCode_Sound
d247 2
a248 2
	TEQ     R1,#Service_ResourceFSStarting
	BEQ	serviceCode_ResourceFSStarting
d250 7
a256 7
	LDR	lr,Service_SoundDriverVal
	TEQ	r1,lr
	BEQ	serviceCode_SoundDriver

	LDR	lr,Service_TaskManagerAcknowledgementsVal
	TEQ	r1,lr
	BEQ	serviceCode_TaskManagerAcknowledgements
d263 5
a267 5
	STMFD	R13!,{R0,LR}
	ADRL	R0, msgResArea
	MOV	lr,pc
	MOV	pc,R2
	LDMFD	R13!,{R0,PC}
d273 3
a275 3
	STMFD   R13!,{R0-R3}
	LDR     ws,[ws]
	LDR     R14,[ws,# work_currentDriver]
d280 9
a288 9
	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
	TEQEQ   R0,#Service_Sound_Level0Dying
	BEQ     serviceCode_Sound_Shutdown

	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
	TEQ     R0,#Service_Sound_Level0Alive
	BEQ     serviceCode_Sound_Reinit
d292 2
a293 2
	TEQ     R0,#Service_Sound_Level1Dying
	TEQEQ   R14,#1 ; log handler
d296 2
a297 2
	TEQ     R0,#Service_Sound_Level1Alive
	TEQEQ   R14,#1 ; log handler
d299 1
a299 1
	LDMNEFD R13!,{R0-R3,PC}
d310 3
a312 3
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter
d314 1
a314 1
	LDMFD   R13!,{R0-R3,PC}
d317 3
a319 3
	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,ws
	SWI     XOS_AddCallBack
d321 1
a321 1
	LDMFD   R13!,{R0-R3,PC}
d327 1
a327 1
	LDMFD   R13!,{R0-R3,PC}
d330 1
a330 1
	STMFD   R13!,{R0-R3,R14}
d332 1
a332 1
	BL      installDefaultDriver
d336 2
a337 2
	LDR     R14,[ws,# work_currentDriver]
	TEQ     R14,#1 ; log driver ?
d350 3
a352 3
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter
d355 1
a355 1
	LDMFD   R13!,{R0-R3,PC}
d358 1
a358 1
	STMFD   R13!,{R0-R3,R14}
d362 3
a364 3
	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,ws
	SWI     XOS_AddCallBack
d366 1
a366 1
	LDMFD   R13!,{R0-R3,PC}
d371 12
a382 12
	STMDB	sp!,{r0-r3}
	TEQ	r2,#0
	LDMEQIA	sp!,{r0-r3,pc}
	MOV	r3,r2
	MOV	r0,#&1000;TaskManager_AckGroup_System ; &1000

	ADRL	r1,title

	ADR	r2,acknowledgement
	MOV	lr,pc
	MOV	pc,r3
	LDMIA sp!,{r0-r3,pc}
d387 2
a388 2
	= ackS,0
	ALIGN
d391 1
a391 1
	STMDB	sp!,{r0-r11,ws}      ; lr already stacked
d393 1
a393 1
	LDR	ws,[ws]          ; Get work area
d395 2
a396 2
	CMP	r0,#Service_SoundDriver_Start
	BEQ	serviceCode_SoundDriverStart
d398 2
a399 2
	CMP	r0,#Service_SoundDriver_End
	BEQ	serviceCode_SoundDriverEnd
d401 1
a401 1
	LDMIA	sp!,{r0-r11,ws,pc}
d404 1
a404 1
	; install into Sound Driver
d406 2
a407 2
	ADRL	r0,SoundDriverStart
	MOV	r1,ws
d409 4
a412 4
	; Change here from RJW; we may well be in IRQ mode here, so
	; can't call SWIs directly. Instead jump to SVC mode and
	; protect SVC_R14 first.
	STMFD	R13!,{R8,R9}
d415 7
a421 7
	TEQ	PC,PC
	MRSEQ	R9,CPSR		; If in 32-bit mode, R9 = CPSR
	MOVNE	R9,PC		; If in 26-bit mode, R9 = PC+PSR
	ORR	R8,R9,#3	; Preserves 32-bitness
	MSREQ	CPSR_c,R8
	TEQNEP	R8,#0
	MOV	R0,R0
d428 1
a428 1
	Push    "R14"
d430 1
a430 1
	SWI	XOS_AddCallBack
d434 4
a437 4
	TEQ	PC,PC
	MSREQ	CPSR_c,R9
	TEQNEP	R9,#0
	MOV	R0,R0
d442 1
a442 1
	LDMFD	R13!,{R8,R9}
d444 1
a444 1
	LDMIA	sp!,{r0-r11,ws,pc}
d449 1
a449 1
	;  Remove from Sound Driver
d451 1
a451 1
	BL	SoundDriverRemove
d453 1
a453 1
	LDMIA sp!,{r0-r11,ws,pc}
d459 16
a474 16
	= swiNameS,0
	= "InstallHandler",0
	= "RemoveHandler",0
	= "HandlerInfo",0
	= "HandlerVolume",0
	= "HandlerSampleType",0
	= "HandlerPause",0
	= "SampleRate",0
	= "InstallDriver",0
	= "RemoveDriver",0
	= "DriverInfo",0
	= "DriverVolume",0
	= "DriverMixer",0
	= "CheckDriver",0
	= "ControlWord",0
	= "HandlerType",0
d476 2
a477 2
	= "Test",0
	= "Info",0
d479 2
a480 2
	DCB 0
	ALIGN
d483 5
a487 5
	MOV	r10,ws
	LDR	ws,[ws]    ; ws = pointer to RMA data block
	CMP	r11,#(EndOfJumpTable - jumpTable)/4
	ADDCC	pc,pc,r11,LSL #2
	B	UnknownSWIerror
d489 15
a503 15
	B	swiInstallHandler          ;  OK
	B	swiRemoveHandler           ;  OK
	B	swiHandlerInfo             ;  OK
	B	swiHandlerVolume           ;  OK
	B	swiHandlerSampleType       ;  not in this version
	B	swiHandlerPause            ;  not in this version
	B	swiSampleRate              ;  OK
	B	swiInstallDriver           ;  OK
	B	swiRemoveDriver            ;  OK
	B	swiDriverInfo              ;  OK
	B	swiDriverVolume            ;  OK
	B	swiDriverMixer             ;  OK
	B	driverCheck                ;
	B	swiControlWord             ;
	B	swiHandlerType             ;
d505 2
a506 2
	B	swiTest                    ;  For debugging only
	B	swiInfo                    ;  For debugging only
d512 2
a513 2
	ADR	r0,ErrorBlock_ModuleBadSWI
	B	msgLookupError
d515 1
a515 1
	MakeInternatErrorBlock ModuleBadSWI,,"BadSWI"
d517 1
a517 1
	END
@


1.9
log
@Internationalised
Errors are now looked up via MessageTrans.
The driver names (registered via InstallDriver or to SoundDriver_Install) are now also looked up.
Note, the SharedSound_DriverInfo SWI used to return r2 as the pointer to a pointer to the name, the documentation seems vague as to what the intent was, but it seems more likely that a pointer to the name was what was intended. The name string is buffered (because it needs looking up for internationalisation anyway).

Tested briefly, inspecting the workspace for name lookups and sending a fake Service_SoundDriver service call. Two errors deliberatly triggered to check error text.

Version 1.15. Tagged as 'SharedSnd-1_15'
@
text
@d54 3
d58 1
@


1.8
log
@Signed pointer comparison fix
In SWI InstallDriver reason codes > 2 are interpreted to mean a pointer to an install driver block, but this used a signed comparison so registering blocks in the top half of memory would fail.
SWIS.s:
 Comparison changed to process 0/1/2 and > 2 correctly
SoundDrv.s & Handler.s:
 Eliminated ADR range function by just using ADRL
Module.s:
 Zero length command table replaced by a 0 in the command entry of the module header
Memory.s:
 Signed loop exit changed for unsigned one (not relevant since the workspace is < 2G)
Drivers.s:
 SWI name moved inside doDMI switch

Version 1.14. Tagged as 'SharedSnd-1_14'
@
text
@d56 1
d58 1
a58 1
	STMDB	sp!,{r0-r11,ws,lr}
d60 4
a63 2
	BL	startMem               ; Get memory
	BVS	initMemError
d68 12
a79 1
	BL    initWorkspace          ; Initialise workspace
d82 1
a82 1
	BL    InstallCBAI
d97 1
a97 1
	LDMIA	sp!,{r0-r11,ws,pc}
d99 10
a108 11
initMemError
	LDMIA	sp!,{r0-r11,ws,lr}
	ADR	r0,initMemErrMesg
	CMP	R0,#&80000000
	CMNVC	R0,#&80000000		; Set V
	MOV	PC,R14
initMemErrMesg

	DCD errn_InitMem
	= "Not enough memory for ",titleS,0
	ALIGN
d119 43
d204 6
d216 2
a217 1
	ASSERT  Service_Sound < Service_TaskManagerAcknowledgements
d224 3
a234 2
	; Sound driver call recognised
	; TaskManager acknowledgements recognised
d242 4
d256 10
d508 2
a509 5
	ADR	r0,errMesg
	CMP	R0,#&80000000
	CMNVC	R0,#&80000000		; Set V
	MOV	PC,R14
errMesg
d511 1
a511 3
	DCD	&1E6
	= "Unknown SharedSound SWI",0
	ALIGN
@


1.7
log
@Changed to use NdrDebug instead of local debug functions
Changed GET of filenames to use <name>.<extension> form.
Built, but not tested.

Version 1.13. Tagged as 'SharedSnd-1_13'
@
text
@a25 4
; JRF: these are defined in global headers
; XOS_AddCallBack		*	&20054
; XOS_RemoveCallBack	*	&2005F
; XOS_ServiceCall		*	&20030
d35 1
a35 1
	DCD	commandTable	- MODULE_START
d324 1
a324 2
	BL	get_SoundDriverStart_R0
	;ADR   r0,SoundDriverStart
a372 6
	; -----------------  * Comands

commandTable

	DCD 0   ; No more commands

@


1.6
log
@Fix for zombie callback loop after killing SharedSound
When the sound system is reinitialised, but SoundChannels not yet started, SharedSound books a callback 40cs in the future to retry.
When used with an 8 bit sound system this occurs repeatedly (in the hope that a 16 bit linear handler will become available) but on RMKILL the callback was not cancelled - so although the module is dead a pair of zombie callbacks keep booking & trying, booking & trying.
* Finalise handler now cancels the 40cs ticker event
* Played safe and changed the CMP of the handler addresses (clearing V) to CLRV
* Added some asserts to the service table
* Removed some unnecessary NOP's after MOV lr, pc operations.

Tested in IOMD ROM.

Version 1.12. Tagged as 'SharedSnd-1_12'
@
text
@d58 1
a58 1
        DCD     1       ; 32-bit compatible
d246 1
a246 5
   [ debug
	SWI     XOS_WriteS
	= "shutdown: releaseDriver",0
	SWI     XOS_NewLine
   ]
d248 1
a248 5
   [ debug
	SWI     XOS_WriteS
	= "shutdown: returning",0
	SWI     XOS_NewLine
   ]
d253 1
a253 6
   [ debug
	SWI     XOS_WriteS
	= "callback: installDefaultDriver",0
	ALIGN
	SWI     XOS_NewLine
   ]
d255 1
a255 6
   [ debug
	SWI     XOS_WriteS
	= "callback: done",0
	ALIGN
	SWI     XOS_NewLine
   ]
d281 3
a283 6
   [ debug
	SWI     XOS_WriteS
	= "delayedcallback: set callback",0
	ALIGN
	SWI     XOS_NewLine
   ]
d404 1
a404 1
 [ debug1
d433 1
a433 1
 [ debug1
@


1.5
log
@  No longer uses non-X SWIs in module code
Detail:
  A few of these were careless typos, others were already X SWIs but the
  symbol names didn't reflect the fact, and in other cases there was no code
  path to deal with error cases. All now fixed. Also fixed all the assembly
  time warnings (at least for 32-bit ROM builds).
Admin:
  No longer prevents the Raspberry Pi ROM init from completing.

Version 1.11. Tagged as 'SharedSnd-1_11'
@
text
@d86 1
a86 1
	CMP	R0,#0			 ; Clear V
d134 4
d152 1
a152 1
	CMP	R0,#0			; Clear V
d157 3
a159 1
 ; Service numbers, incorporating Ursula service numbers
d170 1
a170 1
	DCD	UrsulaService 		- MODULE_START	; the entry point
d175 1
a175 1
	NOP
a324 1
	NOP
@


1.4
log
@Fix to work properly when built into ROM images
Detail:
  Makefile - Rewritten to use assembler makefile fragments instead of C ones. The component is listed as assembler in ModuleDB, so using the C fragments was causing an object file to be linked into the ROM instead of a module.
  MkRam,fd7 - Made to work with new makefile
  s/FillCode, s/Handler, s/Memory, s/Module, s/Vars - Removed dependency on relocation code. It looks like it was only the pointers in FILLCODE_table_start that were being relocated. The fillcode table is now stored in the workspace instead of within the module.
Admin:
  Tested in OMAP3 & Tungsten ROMs.
  Some of the disabled switches may still rely on the removed relocation code.


Version 1.07. Tagged as 'SharedSnd-1_07'
@
text
@d171 1
a171 1
	STMDB sp!,{lr}
d184 1
a184 1
	LDMIA	sp!,{pc}
d353 1
d361 7
a367 1
	STMFD	R13!,{R14}
d371 2
a372 1
	LDMFD	R13!,{R14}
d377 4
@


1.3
log
@  Selective merge of ESP's version 1.06 (14 May 2002) of SharedSound.
Detail:
  Changelog not provided by ESP. I have made an additional change to use
  the value of SoundSystemNIL from Hdr:Sound to test if SoundChannels is not
  installed - this constant changed in RISC OS 5 for 32-bitting reasons.
Admin:
  Builds, and briefly tested. Coincidentally, this is also our version 1.06.

Version 1.06. Tagged as 'SharedSnd-1_06'
@
text
@a30 2
	IMPORT	|__RelocCode|

a62 2
	BL	__RelocCode

@


1.2
log
@  Module scrutinised for problems, and many found and fixed.
Detail:
  * Module flags word and header entry reinstated.
  * Many exits from SWIs had lost their 32-bit compatibility.
  * Unconditional TEQP made conditional, and an MSR replaced with an MRS.
  * A few unnecessary mode checks and alternate returns simplified because
    transient callbacks and 8-bit fill code have never needed to preserve
    processor flags.
  * Driver mixer calling bug fixed again.
  * Spelling and grammatical errors in comments and error messages re-fixed.
  * Other insignificant stuff.
Admin:
  Still untested, but worth trying in a 32-bit build now.

Version 1.01. Tagged as 'SharedSnd-1_01'
@
text
@d26 4
a29 3
XOS_AddCallBack		*	&20054
XOS_RemoveCallBack	*	&2005F
XOS_ServiceCall		*	&20030
d101 1
a101 1
	DCD  &1E6
d194 2
a195 2
	LDR     R12,[R12]
	LDR     R14,[R12,# work_currentDriver]
d197 10
a206 1
	; linear handler goes through level 1
a207 1
	TEQEQ   R14,#2 ; linear handler
d210 8
a217 3
	; log handler goes through level 2 (I *assume*)
	;TEQ     R0,#Service_Sound_Level1Alive
	;TEQEQ   R14,#1 ; log handler
d222 15
d238 1
a238 1
	MOV     r1,r12
d243 15
a257 1
serviceCode_Sound_Callback
d259 6
d266 41
d316 1
a316 1
	MOV	r0,#&2000
d318 1
a318 2
	ADR	r1,title+&100
	SUB	r1,r1,#&100    ; Long ADR ;-(
@


1.2.2.1
log
@Import of latest sources from ESP.
This represents ESP's version 1.06 (14 May 2002). The files are exactly as
received, but they are not expected to build as they are against the public
headers.
@
text
@d26 3
a28 4
; JRF: these are defined in global headers
; XOS_AddCallBack		*	&20054
; XOS_RemoveCallBack	*	&2005F
; XOS_ServiceCall		*	&20030
d55 1
a55 1
	= "Shared Sound",9,Module_FullVersionAndDate,variantS,0
d100 1
a100 1
	DCD errn_InitMem
d193 2
a194 2
	LDR     ws,[ws]
	LDR     R14,[ws,# work_currentDriver]
d196 1
a196 10
; linear handler goes through level 0
; if it dies, we shutdown the current handler (for lin or log handlers)
; it it starts up, we start the current handler (for lin or log handlers)
	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
	TEQEQ   R0,#Service_Sound_Level0Dying
	BEQ     serviceCode_Sound_Shutdown

	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
d198 1
d201 3
a203 8
; log handler goes through level 1, but only after SoundChannels has
; registered itself
	TEQ     R0,#Service_Sound_Level1Dying
	TEQEQ   R14,#1 ; log handler
        BEQ     serviceCode_Sound_Shutdown

	TEQ     R0,#Service_Sound_Level1Alive
	TEQEQ   R14,#1 ; log handler
a207 15
        TEQ     r14,#1 ; log handler
        BNE     %FT10  ; linear handler can go

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter

	LDMFD   R13!,{R0-R3,PC}

10
d209 1
a209 1
	MOV     r1,ws
d214 1
a214 15
serviceCode_Sound_Shutdown
   [ debug
	SWI     XOS_WriteS
	= "shutdown: releaseDriver",0
	SWI     XOS_NewLine
   ]
        BL      releaseDriver
   [ debug
	SWI     XOS_WriteS
	= "shutdown: returning",0
	SWI     XOS_NewLine
   ]
	LDMFD   R13!,{R0-R3,PC}

serviceCode_Sound_Callback ROUT
a215 6
   [ debug
	SWI     XOS_WriteS
	= "callback: installDefaultDriver",0
	ALIGN
	SWI     XOS_NewLine
   ]
a216 39
   [ debug
	SWI     XOS_WriteS
	= "callback: done",0
	ALIGN
	SWI     XOS_NewLine
   ]

; check the install type
	LDR     R14,[ws,# work_currentDriver]
	TEQ     R14,#1 ; log driver ?
        BNE     %FT90
        LDR     R14,[ws,# work_Log_InitedFully]
        TEQ     R14,#1
        BEQ     %FT90

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter

90
	LDMFD   R13!,{R0-R3,PC}

serviceCode_Sound_DelayedCallback
	STMFD   R13!,{R0-R3,R14}
   [ debug
	SWI     XOS_WriteS
	= "delayedcallback: set callback",0
	ALIGN
	SWI     XOS_NewLine
   ]
	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,ws
	SWI     XOS_AddCallBack

d226 1
a226 1
	MOV	r0,#&1000;TaskManager_AckGroup_System ; &1000
d228 2
a229 1
	ADRL	r1,title
d272 1
a272 1
	MSREQ	CPSR_ctl,R8
d281 1
a281 1
	MSREQ	CPSR_ctl,R9
@


1.1
log
@  Import of version 1.00 of SharedSound from WSS - this is a merge of
  RISC OS Ltd, ESP and Pace sources. I've added the Makefile, Mk* and
  VersionNum files.

Detail (courtesy of WSS):
  * Incorporates fixes made to 0.58c to fix the callbacks on sound
    rate changes.

  * Incorporates RISC OS Ltd changes to response to
    TaskManager_Acknowledgements service.

  * Includes 8 bit Log and PowerWave drivers.

  * Now built with Objasm, not BASIC assembler.

  * SharedSound_HandlerInfo SWI fixed to conform to spec. Also
    extended to accept r0 = 0 on entry, in which case r0 = number of
    first registered handler (or 0 for none) on exit; R1-R5 corrupted.

    Therefore the following code enumerates handlers:

    REM Get first handler number.
    SYS "SharedSound_HandlerInfo",0 TO next% ; flags%
    REM While no errors, and not finished
    WHILE (next% <> 0) AND ((flags% AND 1) = 0)
     SYS"SharedSound_HandlerInfo",next% TO next%,a%,b%,c%,d%,e%
    ENDWHILE

  * Sends Service_Sound (&54) with reason code 6 (SharedSound Starting)
    on (callback after) initialisation.

  * Sends Service_Sound (&54) with reason code 7 (SharedSound Dying)
    on finalisation.

  * Some small optimisations

  * Version bumped to 1.00 (to allow RISC OS Ltd space to make changes
    to their versions).

  * Table of helpful fill code routines now passed to handlers in R8.

  * SharedSound reinitialises correctly on lower layers reinitialising.

  * More care taken to remove outstanding callbacks on finalise.

  * Dual 26/32 bit version.

Admin:
  * Not tested by us.

  * 8-bit sound system code is known not to be ROM safe. However, it is
    currently switched out (see the doLog option in s.Gets).

  * This version *will not work* on a 32-bit system. There are at least two
    issues with it that I've spotted with a quick glance through the code -
    the lack of the module flags word, and an unconditional TEQP instruction.
    This version has been checked in nevertheless as a record of what WSS
    delivered to us.

Version 1.00. Tagged as 'SharedSnd-1_00'
@
text
@d46 2
d58 3
d109 1
a109 3
	TEQ	PC,PC
	LDMEQFD	r13!,{r0-r8,PC}
	LDMFD	r13!,{r0-r8,PC}^
@


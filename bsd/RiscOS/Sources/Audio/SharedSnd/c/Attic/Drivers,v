head	1.6;
access;
symbols
	SharedSnd-0_49:1.5
	bavison_SharedSnd-0_48:1.3
	SharedSnd-0_48:1.2
	Spin_merge:1.1.2.2
	afrost_NC2_Generic:1.1.2.2
	afrost_Funai01-33:1.1.2.2
	smiddle_0_43:1.1.2.1
	Spinner:1.1.0.2;
locks; strict;
comment	@# @;


1.6
date	2001.06.28.18.11.56;	author bavison;	state dead;
branches;
next	1.5;

1.5
date	2001.01.16.17.31.06;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.16.15.28.02;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.14.04.16;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.16.36.08;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.11.06.14.18.02;	author smiddle;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.11.06.14.18.02;	author smiddle;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.11.06.14.44.04;	author smiddle;	state Exp;
branches;
next	;


desc
@Files for new SharedSound build
@


1.6
log
@  Import of version 1.00 of SharedSound from WSS - this is a merge of
  RISC OS Ltd, ESP and Pace sources. I've added the Makefile, Mk* and
  VersionNum files.

Detail (courtesy of WSS):
  * Incorporates fixes made to 0.58c to fix the callbacks on sound
    rate changes.

  * Incorporates RISC OS Ltd changes to response to
    TaskManager_Acknowledgements service.

  * Includes 8 bit Log and PowerWave drivers.

  * Now built with Objasm, not BASIC assembler.

  * SharedSound_HandlerInfo SWI fixed to conform to spec. Also
    extended to accept r0 = 0 on entry, in which case r0 = number of
    first registered handler (or 0 for none) on exit; R1-R5 corrupted.

    Therefore the following code enumerates handlers:

    REM Get first handler number.
    SYS "SharedSound_HandlerInfo",0 TO next% ; flags%
    REM While no errors, and not finished
    WHILE (next% <> 0) AND ((flags% AND 1) = 0)
     SYS"SharedSound_HandlerInfo",next% TO next%,a%,b%,c%,d%,e%
    ENDWHILE

  * Sends Service_Sound (&54) with reason code 6 (SharedSound Starting)
    on (callback after) initialisation.

  * Sends Service_Sound (&54) with reason code 7 (SharedSound Dying)
    on finalisation.

  * Some small optimisations

  * Version bumped to 1.00 (to allow RISC OS Ltd space to make changes
    to their versions).

  * Table of helpful fill code routines now passed to handlers in R8.

  * SharedSound reinitialises correctly on lower layers reinitialising.

  * More care taken to remove outstanding callbacks on finalise.

  * Dual 26/32 bit version.

Admin:
  * Not tested by us.

  * 8-bit sound system code is known not to be ROM safe. However, it is
    currently switched out (see the doLog option in s.Gets).

  * This version *will not work* on a 32-bit system. There are at least two
    issues with it that I've spotted with a quick glance through the code -
    the lack of the module flags word, and an unconditional TEQP instruction.
    This version has been checked in nevertheless as a record of what WSS
    delivered to us.

Version 1.00. Tagged as 'SharedSnd-1_00'
@
text
@/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

The driver will typically be the 16 bit DMA handler with all parameters
set as required, or the log driver for 8 bit support.
If it is the 8 bit driver then there is some conversion required to set the
parameters correctly.
This is indicated by passing a call address in the driver block which would
otherwise be 0.

DEFPROCDrivers
LOCAL er$,debug%
er$="Drivers"
debug%=FALSE
PRINT "PROCDrivers"
[OPT I%

\ -------------------------------- Driver routines ---------------------------

.installDefaultDriver%   \  The default driver will either be (in order of preference)
                         \      Sound_LinearHandler
                         \   or Sound_ChannelHandler

                         \  This routine looks to see what is available and installs
                         \  the appropriate driver.

    STMDB R13!,{R14}

    \ First see if Sound_LinearHandler exists

    \ This relies on the fact that the old SoundDMA module will respond to all
    \ SWI's outside its range with a 0
    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on

    MOV   R0,#0
    SWI   Sound_Mode%    \  Check configured for 16 Bit support

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Sound mode = "+CHR$(0):ALIGN
    MOV  R10,R0
    BL   printR10
]
ENDIF
[OPT I%

    CMP   R0,#0          \ R0 = 1 If 16 bit support is on

    MOVEQ R1,#1  \ Log
    MOVNE R1,#2  \ Linear

    STR   R1,[R12,#work_currentDriver%]

]
IF doLog% THEN
[OPT I%

    BNE   installDefaultDriverNotLog%
    BLEQ  installLogDriver%
    B     installDefaultDriverExit%
.installDefaultDriverNotLog%
]
ENDIF
[OPT I%

    BLNE  installLinearDriver%

.installDefaultDriverExit%
    LDMIA R13!,{PC}

\ -----------

.installDriver%     \ Install driver
                    \ R0 = Pointer to driver table
                    \ R1 = parameter to pass driver in R12 when called
                    \ R2 = flags
                    \ R3 = Driver name

    STMDB R13!,{R0-R6,R14}

    BL    releaseDriver%     \ release the currently active driver

    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table

    STR   R0,[R6,#driver_Address%]   \ Table address
    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
    STR   R2,[R6,#driver_Flags%]
    STR   R3,[R6,#driver_Name%]

    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
    STR   R0,[R6,#driver_Volume%]

    BL    driverInitialise% \ Initialise this driver

    LDR   R0,[R6,#driver_Volume%]
    MOV   R1,R6             \ Driver table
    BL    driverVolume%     \ Initialise driver volume

    LDMIA R13!,{R0-R6,PC}
\


\ -----------

.driverInitialise%    \ Initialise a new driver
                      \ R0 = driver table slot
                      \ Return with R0 = 0 if failed

    STMDB R13!,{R1-R12,R14}

    ADD   R6,R12,#work_driverTable%    \ driver Table slot

    LDR   R0,[R6,#driver_Address%]
    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address

    BL    clearCallBackBuffer%

    BL    getFillR0%
    \ ADR   R0,fill%   \ Main fill call address

    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
    STMDB R13!,{R12}                    \ Stack R12
    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
    STMDB R13!,{PC}                     \ Put return address on the stack
    MOV   PC,R2                         \ And call driver install entry
    MOV   R0,R0
    LDMIA R13!,{R12}                    \ Retrieve R12

    CMP   R0,#0  \ = 0 if install failed

    MOVNE R0,#0
    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions

    BL    startSound%                   \ Make sure that sound is active

    LDMIA R13!,{R1-R12,PC}

\ ------------

.driverCheck%   \ Call initialise to make sure that the current driver is still active

    STMDB R13!,{R0-R12,R14}

    ADD   R6,R12,#work_driverTable%    \ driver Table slot
    LDR   R0,[R6,#driver_Address%]

    CMP   R0,#0                          \ Is there a driver installed?
    BEQ   driverCheckExit%

    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address

    BL    getFillR0%
    \ ADR   R0,fill%                    \ R0 = Handler address
    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
    STMDB R13!,{R12}                    \ Stack R12
    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
    STMDB R13!,{PC}                     \ Put return address on the stack
    MOV   PC,R2                         \ And call driver install entry
    MOV   R0,R0
    LDMIA R13!,{R12}                    \ Retrieve R12

    MOV   R0,#0
    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag

.driverCheckExit%

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0-R12,PC}            \ 32-bit SWI exit; NZC corrupted, V clear
    LDMIA R13!,{R0-R12,PC}^             \ 26-bit SWI exit; NZC preserved, V clear


\-------------

.releaseDriver%

    STMDB R13!,{R0-R12,R14}

    BL    stopSound%

    ADD   R0,R12,#work_driverTable%    \ driver Table slot
    LDR   R1,[R0,#driver_Address%]

    CMP   R1,#0
    BEQ   releaseDriverExit%

    LDR   R1,[R1,#driverEntry_Remove%]
    STMDB R13!,{R12}                     \ Stack R12
    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
    STMDB R13!,{PC}                      \ Stack return address
    MOV   PC,R1                          \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                     \ Retrieve R12

.releaseDriverExit%

    LDMIA R13!,{R0-R12,PC}

\ ----------------

.driverSampleRate%  \ Call driver sample rate entry
                    \ On entry:
                    \ R0 = 0 to read
                    \    > 0 for sample frequency required
                    \ On exit:
                    \ R0 = current frequency

    STMDB R13!,{R14}

    \ Get or set current frequency

    ADD   R1,R12,#work_driverTable%    \ driver Table slot
    LDR   R2,[R1,#driver_Address%]

    CMP   R2,#0                 \ Return 0 for failed
    MOVEQ R0,#0
    BEQ   driverSampleRateExit%

    LDR   R2,[R1,#driver_Address%]
    LDR   R2,[R2,#driverEntry_SampleRate%]
    STMDB R13!,{R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R2                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                       \ Retrieve R12

    \  R0 = current frequency

.driverSampleRateExit%

    LDMIA R13!,{PC}


\ ----------

.driverVolume%  \ Set the new volume for a driver
                \ On entry:
                \   R0 = new LR volume
                \   R1 = driver table
                \ On exit:
                \   R0 = volume scaling required by handler to achieve this volume
                \   So if driver cannot scale volume then R0 = entry value and handler
                \   will have to do all the work
                \   If driver can scale then typically it will return &FFFFFFFF to
                \   tell handler not to scale volume at all

    STMDB R13!,{R1-R12,R14}

    \ Get or set current volume

    ADD   R1,R12,#work_driverTable%    \ driver Table slot
    LDR   R2,[R1,#driver_Address%]

    CMP   R2,#0
    BEQ   driverVolumeExit%

    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
    CMP   R2,#0
    STR   R0,[R1,#driver_Volume%]          \ Store it
    BEQ   driverVolumeStore%               \ Return with R0 as set

    STMDB R13!,{R1,R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R2                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R1,R12}                       \ Retrieve R12

.driverVolumeStore%

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
    MOV R10,R0
    BL  printR10
]
ENDIF
[OPT I%

    \  R0 = actual volume

    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers

.driverVolumeExit%

    LDMIA R13!,{R1-R12,PC}


\ -----------

.driverMixer%  \ Call driver's mixer entry
               \ On entry:
               \    R0 = Function code,  0 = read,  1 = set
               \    R1 = mixer number
               \    R2 = value if to set
               \    R3 = driver pointer
               \ On exit:
               \    R1 = number of mixers
               \    R2 = current value
               \    R3 = mixer name

    STMDB R13!,{R4-R12,R14}

    CMP   R3,#0
    BEQ   driverMixerExit%

    LDR   R4,[R3,#driver_Address%]
    LDR   R4,[R4,#driverEntry_Mixer%]      \ There may not be an entry
    CMP   R4,#0
    BEQ   driverMixerExit%                 \ No mixer entry

    STMDB R13!,{R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R4                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                       \ Retrieve R12

.driverMixerExit%

    LDMIA R13!,{R4-R12,PC}

]
ENDPROC
@


1.5
log
@Oops, I meant CMP, not TEQ. Retagged as 'SharedSnd-0_49'.
@
text
@@


1.4
log
@  See Detail.
Detail:
  * 32-bit compatible
  * srccommitted (and gets version number from VersionNum, even though it's
    written in BASIC)
  * added install rule and MkInstall file to install module in correct place
    within an ARMovie installation
Admin:
  Not tested.

Version 0.49. Tagged as 'SharedSnd-0_49'
@
text
@d192 1
a192 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
@


1.3
log
@Changed things so that the detokenised BASIC source (in the c directory) has
no line numbers present (LISTO 8). The detokenised source's raison d'etre is
to allow easier CVS diffs, but line numbers would defeat this purpose whenever
the change involves inserting more than a handful of line numbers.

No other changes - this version is committed and tagged purely as a reference
point for future updates. Tag used is 'bavison_SharedSnd-0_48'.
@
text
@d54 2
a55 2
    \ This rely's on the fact that the old SoundDMA module will respond to all
    \ SWI's outside it's range with a 0
d83 1
d85 2
d93 2
a94 1
    LDMIA R13!,{PC}^
a126 11
.installDriverError%
   LDMIA R13!,{R0-R5,R14}
   ADR   R0,installDriverErrMesg%
   ORRS  PC,R14,#Overflow_Flag
\
.installDriverErrMesg%
    EQUD  &1E6
    EQUS  "Cannot install driver"
    EQUB  0
    ALIGN
\
d192 3
a194 1
    LDMIA R13!,{R0-R12,PC}^
d335 1
a335 1
    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
@


1.2
log
@Spinner branch merged
@
text
@d26 331
a356 331
   10
   20The driver will typically be the 16 bit DMA handler with all parameters
   30set as required, or the log driver for 8 bit support.
   40If it is the 8 bit driver then there is some conversion required to set the
   50parameters correctly.
   60This is indicated by passing a call address in the driver block which would
   70otherwise be 0.
   80
   90DEFPROCDrivers
  100LOCAL er$,debug%
  110er$="Drivers"
  120debug%=FALSE
  130PRINT "PROCDrivers"
  140[OPT I%
  150
  160\ -------------------------------- Driver routines ---------------------------
  170
  180.installDefaultDriver%   \  The default driver will either be (in order of preference)
  190                         \      Sound_LinearHandler
  200                         \   or Sound_ChannelHandler
  210
  220                         \  This routine looks to see what is available and installs
  230                         \  the appropriate driver.
  240
  250    STMDB R13!,{R14}
  260
  270    \ First see if Sound_LinearHandler exists
  280
  290    \ This rely's on the fact that the old SoundDMA module will respond to all
  300    \ SWI's outside it's range with a 0
  310    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on
  320
  330    MOV   R0,#0
  340    SWI   Sound_Mode%    \  Check configured for 16 Bit support
  350
  360]
  370IF debug% THEN
  380[OPT I%
  390    SWI "XOS_WriteS"
  400    EQUS "Sound mode = "+CHR$(0):ALIGN
  410    MOV  R10,R0
  420    BL   printR10
  430]
  440ENDIF
  450[OPT I%
  460
  470    CMP   R0,#0          \ R0 = 1 If 16 bit support is on
  480
  490    MOVEQ R1,#1  \ Log
  500    MOVNE R1,#2  \ Linear
  510
  520    STR   R1,[R12,#work_currentDriver%]
  530
  540]
  550IF doLog% THEN
  560[OPT I%
  570
  580    BLEQ  installLogDriver%
  590]
  600ENDIF
  610[OPT I%
  620
  630    BLNE  installLinearDriver%
  640
  650    LDMIA R13!,{PC}^
  660
  670\ -----------
  680
  690.installDriver%     \ Install driver
  700                    \ R0 = Pointer to driver table
  710                    \ R1 = parameter to pass driver in R12 when called
  720                    \ R2 = flags
  730                    \ R3 = Driver name
  740
  750    STMDB R13!,{R0-R6,R14}
  760
  770    BL    releaseDriver%     \ release the currently active driver
  780
  790    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table
  800
  810    STR   R0,[R6,#driver_Address%]   \ Table address
  820    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
  830    STR   R2,[R6,#driver_Flags%]
  840    STR   R3,[R6,#driver_Name%]
  850
  860    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
  870    STR   R0,[R6,#driver_Volume%]
  880
  890    BL    driverInitialise% \ Initialise this driver
  900
  910    LDR   R0,[R6,#driver_Volume%]
  920    MOV   R1,R6             \ Driver table
  930    BL    driverVolume%     \ Initialise driver volume
  940
  950    LDMIA R13!,{R0-R6,PC}
  960\
  970
  980.installDriverError%
  990   LDMIA R13!,{R0-R5,R14}
 1000   ADR   R0,installDriverErrMesg%
 1010   ORRS  PC,R14,#Overflow_Flag
 1020\
 1030.installDriverErrMesg%
 1040    EQUD  &1E6
 1050    EQUS  "Cannot install driver"
 1060    EQUB  0
 1070    ALIGN
 1080\
 1090
 1100\ -----------
 1110
 1120.driverInitialise%    \ Initialise a new driver
 1130                      \ R0 = driver table slot
 1140                      \ Return with R0 = 0 if failed
 1150
 1160    STMDB R13!,{R1-R12,R14}
 1170
 1180    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1190
 1200    LDR   R0,[R6,#driver_Address%]
 1210    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1220
 1230    BL    clearCallBackBuffer%
 1240
 1250    BL    getFillR0%
 1260    \ ADR   R0,fill%   \ Main fill call address
 1270
 1280    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1290    STMDB R13!,{R12}                    \ Stack R12
 1300    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1310    STMDB R13!,{PC}                     \ Put return address on the stack
 1320    MOV   PC,R2                         \ And call driver install entry
 1330    MOV   R0,R0
 1340    LDMIA R13!,{R12}                    \ Retrieve R12
 1350
 1360    CMP   R0,#0  \ = 0 if install failed
 1370
 1380    MOVNE R0,#0
 1390    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions
 1400
 1410    BL    startSound%                   \ Make sure that sound is active
 1420
 1430    LDMIA R13!,{R1-R12,PC}
 1440
 1450\ ------------
 1460
 1470.driverCheck%   \ Call initialise to make sure that the current driver is still active
 1480
 1490    STMDB R13!,{R0-R12,R14}
 1500
 1510    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1520    LDR   R0,[R6,#driver_Address%]
 1530
 1540    CMP   R0,#0                          \ Is there a driver installed?
 1550    BEQ   driverCheckExit%
 1560
 1570    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1580
 1590    BL    getFillR0%
 1600    \ ADR   R0,fill%                    \ R0 = Handler address
 1610    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1620    STMDB R13!,{R12}                    \ Stack R12
 1630    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1640    STMDB R13!,{PC}                     \ Put return address on the stack
 1650    MOV   PC,R2                         \ And call driver install entry
 1660    MOV   R0,R0
 1670    LDMIA R13!,{R12}                    \ Retrieve R12
 1680
 1690    MOV   R0,#0
 1700    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
 1710
 1720.driverCheckExit%
 1730
 1740    LDMIA R13!,{R0-R12,PC}^
 1750
 1760
 1770\-------------
 1780
 1790.releaseDriver%
 1800
 1810    STMDB R13!,{R0-R12,R14}
 1820
 1830    BL    stopSound%
 1840
 1850    ADD   R0,R12,#work_driverTable%    \ driver Table slot
 1860    LDR   R1,[R0,#driver_Address%]
 1870
 1880    CMP   R1,#0
 1890    BEQ   releaseDriverExit%
 1900
 1910    LDR   R1,[R1,#driverEntry_Remove%]
 1920    STMDB R13!,{R12}                     \ Stack R12
 1930    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
 1940    STMDB R13!,{PC}                      \ Stack return address
 1950    MOV   PC,R1                          \ Call driver, no other parameters
 1960    MOV   R0,R0
 1970    LDMIA R13!,{R12}                     \ Retrieve R12
 1980
 1990.releaseDriverExit%
 2000
 2010    LDMIA R13!,{R0-R12,PC}
 2020
 2030\ ----------------
 2040
 2050.driverSampleRate%  \ Call driver sample rate entry
 2060                    \ On entry:
 2070                    \ R0 = 0 to read
 2080                    \    > 0 for sample frequency required
 2090                    \ On exit:
 2100                    \ R0 = current frequency
 2110
 2120    STMDB R13!,{R14}
 2130
 2140    \ Get or set current frequency
 2150
 2160    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2170    LDR   R2,[R1,#driver_Address%]
 2180
 2190    CMP   R2,#0                 \ Return 0 for failed
 2200    MOVEQ R0,#0
 2210    BEQ   driverSampleRateExit%
 2220
 2230    LDR   R2,[R1,#driver_Address%]
 2240    LDR   R2,[R2,#driverEntry_SampleRate%]
 2250    STMDB R13!,{R12}                       \ Stack R12
 2260    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2270    STMDB R13!,{PC}                        \ Stack return address
 2280    MOV   PC,R2                            \ Call driver, no other parameters
 2290    MOV   R0,R0
 2300    LDMIA R13!,{R12}                       \ Retrieve R12
 2310
 2320    \  R0 = current frequency
 2330
 2340.driverSampleRateExit%
 2350
 2360    LDMIA R13!,{PC}
 2370
 2380
 2390\ ----------
 2400
 2410.driverVolume%  \ Set the new volume for a driver
 2420                \ On entry:
 2430                \   R0 = new LR volume
 2440                \   R1 = driver table
 2450                \ On exit:
 2460                \   R0 = volume scaling required by handler to achieve this volume
 2470                \   So if driver cannot scale volume then R0 = entry value and handler
 2480                \   will have to do all the work
 2490                \   If driver can scale then typically it will return &FFFFFFFF to
 2500                \   tell handler not to scale volume at all
 2510
 2520    STMDB R13!,{R1-R12,R14}
 2530
 2540    \ Get or set current volume
 2550
 2560    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2570    LDR   R2,[R1,#driver_Address%]
 2580
 2590    CMP   R2,#0
 2600    BEQ   driverVolumeExit%
 2610
 2620    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
 2630    CMP   R2,#0
 2640    STR   R0,[R1,#driver_Volume%]          \ Store it
 2650    BEQ   driverVolumeStore%               \ Return with R0 as set
 2660
 2670    STMDB R13!,{R1,R12}                       \ Stack R12
 2680    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2690    STMDB R13!,{PC}                        \ Stack return address
 2700    MOV   PC,R2                            \ Call driver, no other parameters
 2710    MOV   R0,R0
 2720    LDMIA R13!,{R1,R12}                       \ Retrieve R12
 2730
 2740.driverVolumeStore%
 2750
 2760]
 2770IF debug% THEN
 2780[OPT I%
 2790    SWI "XOS_WriteS"
 2800    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
 2810    MOV R10,R0
 2820    BL  printR10
 2830]
 2840ENDIF
 2850[OPT I%
 2860
 2870    \  R0 = actual volume
 2880
 2890    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers
 2900
 2910.driverVolumeExit%
 2920
 2930    LDMIA R13!,{R1-R12,PC}
 2940
 2950
 2960\ -----------
 2970
 2980.driverMixer%  \ Call driver's mixer entry
 2990               \ On entry:
 3000               \    R0 = Function code,  0 = read,  1 = set
 3010               \    R1 = mixer number
 3020               \    R2 = value if to set
 3030               \    R3 = driver pointer
 3040               \ On exit:
 3050               \    R1 = number of mixers
 3060               \    R2 = current value
 3070               \    R3 = mixer name
 3080
 3090    STMDB R13!,{R4-R12,R14}
 3100
 3110    CMP   R3,#0
 3120    BEQ   driverMixerExit%
 3130
 3140    LDR   R4,[R3,#driver_Address%]
 3150    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
 3160    CMP   R4,#0
 3170    BEQ   driverMixerExit%                 \ No mixer entry
 3180
 3190    STMDB R13!,{R12}                       \ Stack R12
 3200    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 3210    STMDB R13!,{PC}                        \ Stack return address
 3220    MOV   PC,R4                            \ Call driver, no other parameters
 3230    MOV   R0,R0
 3240    LDMIA R13!,{R12}                       \ Retrieve R12
 3250
 3260.driverMixerExit%
 3270
 3280    LDMIA R13!,{R4-R12,PC}
 3290
 3300]
 3310ENDPROC
@


1.1
log
@file Drivers was initially added on branch Spinner.
@
text
@d1 356
@


1.1.2.1
log
@New layout SharedSound with text files rather than BASIC files.
@
text
@a0 255
/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
   20The driver will typically be the 16 bit DMA handler with all parameters
   30set as required, or the log driver for 8 bit support.
   40If it is the 8 bit driver then there is some conversion required to set the
   50parameters correctly.
   60This is indicated by passing a call address in the driver block which would
   70otherwise be 0.
   90DEFPROCDrivers
  100LOCAL er$,debug%
  110er$="Drivers"
  120debug%=FALSE
  130PRINT "PROCDrivers"
  140[OPT I%
  160\ -------------------------------- Driver routines ---------------------------
  180.installDefaultDriver%   \  The default driver will either be (in order of preference)
  190                         \      Sound_LinearHandler
  200                         \   or Sound_ChannelHandler
  220                         \  This routine looks to see what is available and installs
  230                         \  the appropriate driver.
  250    STMDB R13!,{R14}
  270    \ First see if Sound_LinearHandler exists
  290    \ This rely's on the fact that the old SoundDMA module will respond to all
  300    \ SWI's outside it's range with a 0
  310    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on
  330    MOV   R0,#0
  340    SWI   Sound_Mode%    \  Check configured for 16 Bit support
  360]
  370IF debug% THEN
  380[OPT I%
  390    SWI "XOS_WriteS"
  400    EQUS "Sound mode = "+CHR$(0):ALIGN
  410    MOV  R10,R0
  420    BL   printR10
  430]
  440ENDIF
  450[OPT I%
  470    CMP   R0,#0          \ R0 = 1 If 16 bit support is on
  490    MOVEQ R1,#1  \ Log
  500    MOVNE R1,#2  \ Linear
  520    STR   R1,[R12,#work_currentDriver%]
  540    \ BLEQ  installLogDriver%
  550    BLNE  installLinearDriver%
  570    LDMIA R13!,{PC}^
  590\ -----------
  610.installDriver%     \ Install driver
  620                    \ R0 = Pointer to driver table
  630                    \ R1 = parameter to pass driver in R12 when called
  640                    \ R2 = flags
  650                    \ R3 = Driver name
  670    STMDB R13!,{R0-R6,R14}
  690    BL    releaseDriver%     \ release the currently active driver
  710    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table
  730    STR   R0,[R6,#driver_Address%]   \ Table address
  740    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
  750    STR   R2,[R6,#driver_Flags%]
  760    STR   R3,[R6,#driver_Name%]
  780    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
  790    STR   R0,[R6,#driver_Volume%]
  810    BL    driverInitialise% \ Initialise this driver
  830    LDR   R0,[R6,#driver_Volume%]
  840    MOV   R1,R6             \ Driver table
  850    BL    driverVolume%     \ Initialise driver volume
  870    LDMIA R13!,{R0-R6,PC}
  880\
  900.installDriverError%
  910   LDMIA R13!,{R0-R5,R14}
  920   ADR   R0,installDriverErrMesg%
  930   ORRS  PC,R14,#Overflow_Flag
  940\
  950.installDriverErrMesg%
  960    EQUD  &1E6
  970    EQUS  "Cannot install driver"
  980    EQUB  0
  990    ALIGN
 1000\
 1020\ -----------
 1040.driverInitialise%    \ Initialise a new driver
 1050                      \ R0 = driver table slot
 1060                      \ Return with R0 = 0 if failed
 1080    STMDB R13!,{R1-R12,R14}
 1100    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1120    LDR   R0,[R6,#driver_Address%]
 1130    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1150    BL    clearCallBackBuffer%
 1170    BL    getFillR0%
 1180    \ ADR   R0,fill%   \ Main fill call address
 1200    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1210    STMDB R13!,{R12}                    \ Stack R12
 1220    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1230    STMDB R13!,{PC}                     \ Put return address on the stack
 1240    MOV   PC,R2                         \ And call driver install entry
 1250    MOV   R0,R0
 1260    LDMIA R13!,{R12}                    \ Retrieve R12
 1280    CMP   R0,#0  \ = 0 if install failed
 1300    MOVNE R0,#0
 1310    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions
 1330    BL    startSound%                   \ Make sure that sound is active
 1350    LDMIA R13!,{R1-R12,PC}
 1370\ ------------
 1390.driverCheck%   \ Call initialise to make sure that the current driver is still active
 1410    STMDB R13!,{R0-R12,R14}
 1430    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1440    LDR   R0,[R6,#driver_Address%]
 1460    CMP   R0,#0                          \ Is there a driver installed?
 1470    BEQ   driverCheckExit%
 1490    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1510    BL    getFillR0%
 1520    \ ADR   R0,fill%                    \ R0 = Handler address
 1530    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1540    STMDB R13!,{R12}                    \ Stack R12
 1550    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1560    STMDB R13!,{PC}                     \ Put return address on the stack
 1570    MOV   PC,R2                         \ And call driver install entry
 1580    MOV   R0,R0
 1590    LDMIA R13!,{R12}                    \ Retrieve R12
 1610    MOV   R0,#0
 1620    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
 1640.driverCheckExit%
 1660    LDMIA R13!,{R0-R12,PC}^
 1690\-------------
 1710.releaseDriver%
 1730    STMDB R13!,{R0-R12,R14}
 1750    BL    stopSound%
 1770    ADD   R0,R12,#work_driverTable%    \ driver Table slot
 1780    LDR   R1,[R0,#driver_Address%]
 1800    CMP   R1,#0
 1810    BEQ   releaseDriverExit%
 1830    LDR   R1,[R1,#driverEntry_Remove%]
 1840    STMDB R13!,{R12}                     \ Stack R12
 1850    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
 1860    STMDB R13!,{PC}                      \ Stack return address
 1870    MOV   PC,R1                          \ Call driver, no other parameters
 1880    MOV   R0,R0
 1890    LDMIA R13!,{R12}                     \ Retrieve R12
 1910.releaseDriverExit%
 1930    LDMIA R13!,{R0-R12,PC}
 1950\ ----------------
 1970.driverSampleRate%  \ Call driver sample rate entry
 1980                    \ On entry:
 1990                    \ R0 = 0 to read
 2000                    \    > 0 for sample frequency required
 2010                    \ On exit:
 2020                    \ R0 = current frequency
 2040    STMDB R13!,{R14}
 2060    \ Get or set current frequency
 2080    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2090    LDR   R2,[R1,#driver_Address%]
 2110    CMP   R2,#0                 \ Return 0 for failed
 2120    MOVEQ R0,#0
 2130    BEQ   driverSampleRateExit%
 2150    LDR   R2,[R1,#driver_Address%]
 2160    LDR   R2,[R2,#driverEntry_SampleRate%]
 2170    STMDB R13!,{R12}                       \ Stack R12
 2180    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2190    STMDB R13!,{PC}                        \ Stack return address
 2200    MOV   PC,R2                            \ Call driver, no other parameters
 2210    MOV   R0,R0
 2220    LDMIA R13!,{R12}                       \ Retrieve R12
 2240    \  R0 = current frequency
 2260.driverSampleRateExit%
 2280    LDMIA R13!,{PC}
 2310\ ----------
 2330.driverVolume%  \ Set the new volume for a driver
 2340                \ On entry:
 2350                \   R0 = new LR volume
 2360                \   R1 = driver table
 2370                \ On exit:
 2380                \   R0 = volume scaling required by handler to achieve this volume
 2390                \   So if driver cannot scale volume then R0 = entry value and handler
 2400                \   will have to do all the work
 2410                \   If driver can scale then typically it will return &FFFFFFFF to
 2420                \   tell handler not to scale volume at all
 2440    STMDB R13!,{R1-R12,R14}
 2460    \ Get or set current volume
 2480    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2490    LDR   R2,[R1,#driver_Address%]
 2510    CMP   R2,#0
 2520    BEQ   driverVolumeExit%
 2540    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
 2550    CMP   R2,#0
 2560    STR   R0,[R1,#driver_Volume%]          \ Store it
 2570    BEQ   driverVolumeStore%               \ Return with R0 as set
 2590    STMDB R13!,{R1,R12}                       \ Stack R12
 2600    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2610    STMDB R13!,{PC}                        \ Stack return address
 2620    MOV   PC,R2                            \ Call driver, no other parameters
 2630    MOV   R0,R0
 2640    LDMIA R13!,{R1,R12}                       \ Retrieve R12
 2660.driverVolumeStore%
 2680]
 2690IF debug% THEN
 2700[OPT I%
 2710    SWI "XOS_WriteS"
 2720    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
 2730    MOV R10,R0
 2740    BL  printR10
 2750]
 2760ENDIF
 2770[OPT I%
 2790    \  R0 = actual volume
 2810    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers
 2830.driverVolumeExit%
 2850    LDMIA R13!,{R1-R12,PC}
 2880\ -----------
 2900.driverMixer%  \ Call driver's mixer entry
 2910               \ On entry:
 2920               \    R0 = Function code,  0 = read,  1 = set
 2930               \    R1 = mixer number
 2940               \    R2 = value if to set
 2950               \    R3 = driver pointer
 2960               \ On exit:
 2970               \    R1 = number of mixers
 2980               \    R2 = current value
 2990               \    R3 = mixer name
 3010    STMDB R13!,{R4-R12,R14}
 3030    CMP   R3,#0
 3040    BEQ   driverMixerExit%
 3060    LDR   R4,[R3,#driver_Address%]
 3070    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
 3080    CMP   R4,#0
 3090    BEQ   driverMixerExit%                 \ No mixer entry
 3110    STMDB R13!,{R12}                       \ Stack R12
 3120    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 3130    STMDB R13!,{PC}                        \ Stack return address
 3140    MOV   PC,R4                            \ Call driver, no other parameters
 3150    MOV   R0,R0
 3160    LDMIA R13!,{R12}                       \ Retrieve R12
 3180.driverMixerExit%
 3200    LDMIA R13!,{R4-R12,PC}
 3220]
 3230ENDPROC
@


1.1.2.2
log
@New version: useful changes are bug fixed in removing callback
handlers (affects turning off the MIDI synth), and maintains number of
channels configured when callback buffers not supplied (stops volume
of RealAudio playback from fluctuating when MIDI Synth can't make its
mind up whether to created buffers or not.
Other changes adds CBAI and 8bit log output support (disabled) and
debugging code.
@
text
@a0 26
/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
   10
a31 1
   80
a37 1
  150
a38 1
  170
a41 1
  210
a43 1
  240
a44 1
  260
a45 1
  280
a48 1
  320
a50 1
  350
a60 1
  460
a61 1
  480
a63 1
  510
d65 191
a255 279
  530
  540]
  550IF doLog% THEN
  560[OPT I%
  570
  580    BLEQ  installLogDriver%
  590]
  600ENDIF
  610[OPT I%
  620
  630    BLNE  installLinearDriver%
  640
  650    LDMIA R13!,{PC}^
  660
  670\ -----------
  680
  690.installDriver%     \ Install driver
  700                    \ R0 = Pointer to driver table
  710                    \ R1 = parameter to pass driver in R12 when called
  720                    \ R2 = flags
  730                    \ R3 = Driver name
  740
  750    STMDB R13!,{R0-R6,R14}
  760
  770    BL    releaseDriver%     \ release the currently active driver
  780
  790    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table
  800
  810    STR   R0,[R6,#driver_Address%]   \ Table address
  820    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
  830    STR   R2,[R6,#driver_Flags%]
  840    STR   R3,[R6,#driver_Name%]
  850
  860    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
  870    STR   R0,[R6,#driver_Volume%]
  880
  890    BL    driverInitialise% \ Initialise this driver
  900
  910    LDR   R0,[R6,#driver_Volume%]
  920    MOV   R1,R6             \ Driver table
  930    BL    driverVolume%     \ Initialise driver volume
  940
  950    LDMIA R13!,{R0-R6,PC}
  960\
  970
  980.installDriverError%
  990   LDMIA R13!,{R0-R5,R14}
 1000   ADR   R0,installDriverErrMesg%
 1010   ORRS  PC,R14,#Overflow_Flag
 1020\
 1030.installDriverErrMesg%
 1040    EQUD  &1E6
 1050    EQUS  "Cannot install driver"
 1060    EQUB  0
 1070    ALIGN
 1080\
 1090
 1100\ -----------
 1110
 1120.driverInitialise%    \ Initialise a new driver
 1130                      \ R0 = driver table slot
 1140                      \ Return with R0 = 0 if failed
 1150
 1160    STMDB R13!,{R1-R12,R14}
 1170
 1180    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1190
 1200    LDR   R0,[R6,#driver_Address%]
 1210    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1220
 1230    BL    clearCallBackBuffer%
 1240
 1250    BL    getFillR0%
 1260    \ ADR   R0,fill%   \ Main fill call address
 1270
 1280    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1290    STMDB R13!,{R12}                    \ Stack R12
 1300    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1310    STMDB R13!,{PC}                     \ Put return address on the stack
 1320    MOV   PC,R2                         \ And call driver install entry
 1330    MOV   R0,R0
 1340    LDMIA R13!,{R12}                    \ Retrieve R12
 1350
 1360    CMP   R0,#0  \ = 0 if install failed
 1370
 1380    MOVNE R0,#0
 1390    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions
 1400
 1410    BL    startSound%                   \ Make sure that sound is active
 1420
 1430    LDMIA R13!,{R1-R12,PC}
 1440
 1450\ ------------
 1460
 1470.driverCheck%   \ Call initialise to make sure that the current driver is still active
 1480
 1490    STMDB R13!,{R0-R12,R14}
 1500
 1510    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1520    LDR   R0,[R6,#driver_Address%]
 1530
 1540    CMP   R0,#0                          \ Is there a driver installed?
 1550    BEQ   driverCheckExit%
 1560
 1570    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1580
 1590    BL    getFillR0%
 1600    \ ADR   R0,fill%                    \ R0 = Handler address
 1610    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1620    STMDB R13!,{R12}                    \ Stack R12
 1630    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1640    STMDB R13!,{PC}                     \ Put return address on the stack
 1650    MOV   PC,R2                         \ And call driver install entry
 1660    MOV   R0,R0
 1670    LDMIA R13!,{R12}                    \ Retrieve R12
 1680
 1690    MOV   R0,#0
 1700    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
 1710
 1720.driverCheckExit%
 1730
 1740    LDMIA R13!,{R0-R12,PC}^
 1750
 1760
 1770\-------------
 1780
 1790.releaseDriver%
 1800
 1810    STMDB R13!,{R0-R12,R14}
 1820
 1830    BL    stopSound%
 1840
 1850    ADD   R0,R12,#work_driverTable%    \ driver Table slot
 1860    LDR   R1,[R0,#driver_Address%]
 1870
 1880    CMP   R1,#0
 1890    BEQ   releaseDriverExit%
 1900
 1910    LDR   R1,[R1,#driverEntry_Remove%]
 1920    STMDB R13!,{R12}                     \ Stack R12
 1930    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
 1940    STMDB R13!,{PC}                      \ Stack return address
 1950    MOV   PC,R1                          \ Call driver, no other parameters
 1960    MOV   R0,R0
 1970    LDMIA R13!,{R12}                     \ Retrieve R12
 1980
 1990.releaseDriverExit%
 2000
 2010    LDMIA R13!,{R0-R12,PC}
 2020
 2030\ ----------------
 2040
 2050.driverSampleRate%  \ Call driver sample rate entry
 2060                    \ On entry:
 2070                    \ R0 = 0 to read
 2080                    \    > 0 for sample frequency required
 2090                    \ On exit:
 2100                    \ R0 = current frequency
 2110
 2120    STMDB R13!,{R14}
 2130
 2140    \ Get or set current frequency
 2150
 2160    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2170    LDR   R2,[R1,#driver_Address%]
 2180
 2190    CMP   R2,#0                 \ Return 0 for failed
 2200    MOVEQ R0,#0
 2210    BEQ   driverSampleRateExit%
 2220
 2230    LDR   R2,[R1,#driver_Address%]
 2240    LDR   R2,[R2,#driverEntry_SampleRate%]
 2250    STMDB R13!,{R12}                       \ Stack R12
 2260    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2270    STMDB R13!,{PC}                        \ Stack return address
 2280    MOV   PC,R2                            \ Call driver, no other parameters
 2290    MOV   R0,R0
 2300    LDMIA R13!,{R12}                       \ Retrieve R12
 2310
 2320    \  R0 = current frequency
 2330
 2340.driverSampleRateExit%
 2350
 2360    LDMIA R13!,{PC}
 2370
 2380
 2390\ ----------
 2400
 2410.driverVolume%  \ Set the new volume for a driver
 2420                \ On entry:
 2430                \   R0 = new LR volume
 2440                \   R1 = driver table
 2450                \ On exit:
 2460                \   R0 = volume scaling required by handler to achieve this volume
 2470                \   So if driver cannot scale volume then R0 = entry value and handler
 2480                \   will have to do all the work
 2490                \   If driver can scale then typically it will return &FFFFFFFF to
 2500                \   tell handler not to scale volume at all
 2510
 2520    STMDB R13!,{R1-R12,R14}
 2530
 2540    \ Get or set current volume
 2550
 2560    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2570    LDR   R2,[R1,#driver_Address%]
 2580
 2590    CMP   R2,#0
 2600    BEQ   driverVolumeExit%
 2610
 2620    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
 2630    CMP   R2,#0
 2640    STR   R0,[R1,#driver_Volume%]          \ Store it
 2650    BEQ   driverVolumeStore%               \ Return with R0 as set
 2660
 2670    STMDB R13!,{R1,R12}                       \ Stack R12
 2680    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2690    STMDB R13!,{PC}                        \ Stack return address
 2700    MOV   PC,R2                            \ Call driver, no other parameters
 2710    MOV   R0,R0
 2720    LDMIA R13!,{R1,R12}                       \ Retrieve R12
 2730
 2740.driverVolumeStore%
 2750
 2760]
 2770IF debug% THEN
 2780[OPT I%
 2790    SWI "XOS_WriteS"
 2800    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
 2810    MOV R10,R0
 2820    BL  printR10
 2830]
 2840ENDIF
 2850[OPT I%
 2860
 2870    \  R0 = actual volume
 2880
 2890    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers
 2900
 2910.driverVolumeExit%
 2920
 2930    LDMIA R13!,{R1-R12,PC}
 2940
 2950
 2960\ -----------
 2970
 2980.driverMixer%  \ Call driver's mixer entry
 2990               \ On entry:
 3000               \    R0 = Function code,  0 = read,  1 = set
 3010               \    R1 = mixer number
 3020               \    R2 = value if to set
 3030               \    R3 = driver pointer
 3040               \ On exit:
 3050               \    R1 = number of mixers
 3060               \    R2 = current value
 3070               \    R3 = mixer name
 3080
 3090    STMDB R13!,{R4-R12,R14}
 3100
 3110    CMP   R3,#0
 3120    BEQ   driverMixerExit%
 3130
 3140    LDR   R4,[R3,#driver_Address%]
 3150    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
 3160    CMP   R4,#0
 3170    BEQ   driverMixerExit%                 \ No mixer entry
 3180
 3190    STMDB R13!,{R12}                       \ Stack R12
 3200    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 3210    STMDB R13!,{PC}                        \ Stack return address
 3220    MOV   PC,R4                            \ Call driver, no other parameters
 3230    MOV   R0,R0
 3240    LDMIA R13!,{R12}                       \ Retrieve R12
 3250
 3260.driverMixerExit%
 3270
 3280    LDMIA R13!,{R4-R12,PC}
 3290
 3300]
 3310ENDPROC
@

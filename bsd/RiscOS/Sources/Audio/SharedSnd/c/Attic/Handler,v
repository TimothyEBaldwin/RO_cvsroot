head	1.5;
access;
symbols
	SharedSnd-0_49:1.4
	bavison_SharedSnd-0_48:1.3
	SharedSnd-0_48:1.2
	Spin_merge:1.1.2.2
	afrost_NC2_Generic:1.1.2.2
	afrost_Funai01-33:1.1.2.2
	smiddle_0_43:1.1.2.1
	Spinner:1.1.0.2;
locks; strict;
comment	@# @;


1.5
date	2001.06.28.18.11.57;	author bavison;	state dead;
branches;
next	1.4;

1.4
date	2001.01.16.15.28.02;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.14.04.16;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.16.36.10;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.11.06.14.18.03;	author smiddle;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.11.06.14.18.04;	author smiddle;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.11.06.14.44.05;	author smiddle;	state Exp;
branches;
next	;


desc
@Files for new SharedSound build
@


1.5
log
@  Import of version 1.00 of SharedSound from WSS - this is a merge of
  RISC OS Ltd, ESP and Pace sources. I've added the Makefile, Mk* and
  VersionNum files.

Detail (courtesy of WSS):
  * Incorporates fixes made to 0.58c to fix the callbacks on sound
    rate changes.

  * Incorporates RISC OS Ltd changes to response to
    TaskManager_Acknowledgements service.

  * Includes 8 bit Log and PowerWave drivers.

  * Now built with Objasm, not BASIC assembler.

  * SharedSound_HandlerInfo SWI fixed to conform to spec. Also
    extended to accept r0 = 0 on entry, in which case r0 = number of
    first registered handler (or 0 for none) on exit; R1-R5 corrupted.

    Therefore the following code enumerates handlers:

    REM Get first handler number.
    SYS "SharedSound_HandlerInfo",0 TO next% ; flags%
    REM While no errors, and not finished
    WHILE (next% <> 0) AND ((flags% AND 1) = 0)
     SYS"SharedSound_HandlerInfo",next% TO next%,a%,b%,c%,d%,e%
    ENDWHILE

  * Sends Service_Sound (&54) with reason code 6 (SharedSound Starting)
    on (callback after) initialisation.

  * Sends Service_Sound (&54) with reason code 7 (SharedSound Dying)
    on finalisation.

  * Some small optimisations

  * Version bumped to 1.00 (to allow RISC OS Ltd space to make changes
    to their versions).

  * Table of helpful fill code routines now passed to handlers in R8.

  * SharedSound reinitialises correctly on lower layers reinitialising.

  * More care taken to remove outstanding callbacks on finalise.

  * Dual 26/32 bit version.

Admin:
  * Not tested by us.

  * 8-bit sound system code is known not to be ROM safe. However, it is
    currently switched out (see the doLog option in s.Gets).

  * This version *will not work* on a 32-bit system. There are at least two
    issues with it that I've spotted with a quick glance through the code -
    the lack of the module flags word, and an unconditional TEQP instruction.
    This version has been checked in nevertheless as a record of what WSS
    delivered to us.

Version 1.00. Tagged as 'SharedSnd-1_00'
@
text
@/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

The process involves receiving a 'fill this buffer' instruction
from a driver.
The fill code then fills and mixes any available data from
any immediate handlers whith each handler doing it's own mixing.
Then any call back streams are called to give any available data
with the fill code mixing it.
Finally, call back streams are called to make sure that the call
back buffer is full.
At the end of each call back call process handlers can be called.
The same handler code for each stage can be used with flags to
indicate which type of handler is being processed ans with the
data pointers set appropriately.


DEFPROCHandler
LOCAL er$,debug%
er$="Handler"
debug%=FALSE
PRINT "PROCHandler"
CBAIDisableInt%=TRUE
[OPT I%


\-------------------------- Sound Handler Code ------------------------

.stopSound% \ Make sure nothing is happening

   STMDB R13!,{R0,R14}

   MOV   R0,#1
   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine

   \ Now wait until no sound is happening

.stopSoundLoop%

   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
   CMP   R0,#0
   BNE   stopSoundLoop%

   LDMIA R13!,{R0,PC}

\ -----------

.startSound% \ Set handler going again

  STMDB R13!,{R0,R14}

  MOV   R0,#0
  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag

  \ Should check that there is a current driver and that it is active...

  LDMIA R13!,{R0,PC}

\ -------------------------------

.getFillR0%

  ADR   R0,fill%
  MOV   PC,R14

\ ----

.fill%   \ Main fill call for output driver
         \ Can be called by a 16 or 8 bit driver
         \ It needs to collect and mix data into the final buffer
         \ converting the data if necessary.
         \ On entry:
         \    R0 = parameter, this should be the SharedSound R12 value
         \    R1 = base of buffer
         \    R2 = end of buffer
         \    R3 = flags
         \    R4 = sample frequency or period
         \ Added:
         \    R5 = sample period

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R0]

   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
   CMP   R0,#1
   BEQ   fillExit%

   MOV   R0,#1
   STR   R0,[R12,#work_SoundActive%]    \ Flag active

   \ If there is data in the buffer then this is shown in R3

   MOV   R5,R4
   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
   CMP   R4,R5

   BLNE  rateChange%                             \ Set a call back to change values

   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now

   \ First call any immediate handlers

   LDR   R6,[R12,#work_ImmediateHandlers%]
   CMP   R6,#0
   MOVNE R6,#handlerType_Immediate%
   BLNE  handler%

   \ Now get any callBack buffers and mix in

   LDR   R6,[R12,#work_CallBackHandlers%]
   CMP   R6,#0
   BEQ   fillExit%

   BL    addCallBackBuffer%

   \ Finally initiate any callbacks required

   BL    callBackHandlerProcess%


.fillExit%

   MOV   R0,#0
   STR   R0,[R12,#work_SoundActive%]    \ Flag finished

   LDMIA R13!,{R0-R12,PC}

\ ------------------

.rateChange%     \ Issue a call back to change the rate values

   STMDB R13!,{R0,R1,R14}

]
IF doCallBack% THEN
[OPT I%

   ADR   R0,rateChangeCallBack%
   LDR   R1,[R12,#work_privateWord%]

   SWI   "OS_AddCallBack"

   LDMIA R13!,{R0,R1,PC}


]
ELSE
[OPT I%

   MOV   R0,R5   \ New frequency
   BL    newRate%

   LDMIA R13!,{R0,R1,PC}

]
ENDIF
[OPT I%


\ ---------


]
IF doCallBack% THEN
[OPT I%


.rateChangeCallBack%

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R12]         \ Get workspace pointer

   \     First get current sample frequency and sample period
   \     This is provided by the SampleRate routine

   MOV   R0,#0          \ Function code read

   BL    newSampleRate%

   LDMIA R13!,{R0-R12,PC}

]
ENDIF
[OPT I%


\ ---------------- Handler stuff ---------------

.handler% \ Dummy fill code
          \ Used to pass on control to chain of handlers
          \ The flags indicate which handlers to call
          \ There are three types - immediate, callback and process
          \ On entry:
          \    R0 = parameter, this should be the SharedSound R12 value
          \    R1 = base of buffer
          \    R2 = end of buffer
          \    R3 = flags
          \    R4 = sample frequency
          \    R5 = sample period
          \    R6 = Handler type

          \ Added by SharedSound before calling handlers

          \    R6 = fraction step
          \    R7 = LR Volume

   STMDB R13!,{R0-R2,R4-R12,R14}

   \ Now call each handler in turn, if they match the flag type

   MOV   R11,R6 \ Handler type

   ADD   R8,R12,#work_handlerTable%       \ Address of table
   MOV   R9,#handlerMax%                  \ Handler count

.handlerLoop%

   LDR   R10,[R8,#handler_Type%]
   CMP   R10,R11
   BNE   handlerNext%

   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
   CMP   R10,#0
   BEQ   handlerNext%

   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved

   LDR   R0,[R8,#handler_Parameter%]
   LDR   R6,[R8,#handler_Fraction%]
   LDR   R7,[R8,#handler_VolumeScaled%]

   MOV   R14,PC
   MOV   PC,R10                            \ Jump to address
\   MOVNV R0,R0

.handlerReturn%

   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved

.handlerNext%

   ADD   R8,R8,#handlerTableLen%
   SUBS  R9,R9,#1
   BNE   handlerLoop%


.handlerExit%

   LDMIA R13!,{R0-R2,R4-R12,PC}

\ ------------------- Call Back Handler routines

.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%

\ ----

.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
                     \ On entry:
                     \    R1 = base of buffer
                     \    R2 = end of buffer
                     \    R3 = flags
                     \    R4 = sample frequency
                     \    R5 = sample period
                     \ On exit:
                     \    call back data mixed in if there is some

   STMDB R13!,{R0-R12,R14}

   SUB   R6,R2,R1
   LDR   R7,[R12,#work_CallBack_BufferSize%]

   CMP   R6,R7

   \ If the buffer size has changed then need to make changes...

   STR   R6,[R12,#work_CallBack_BufferSize%]

   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
   CMP   R5,#0
   BGT   addCallBackBuffer_OK%

   \ Need to flag an overrun

   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
   CMP   R5,#1

   \ If there are no full buffers and the call back is active then we have overrun

   LDREQ R7,[R12,#work_callBack_Count%]   \ If so then increment count and return
   ADDEQ R7,R7,#1
   STREQ R7,[R12,#work_callBack_Count%]

   \ Need to do a volume shift on the buffer to effectivly mix an empty buffer
   \ into the existing data
   \ This avoids volume fluctuations

   \ R1 = Start of SoundDMA buffer
   \ R2 = End of SoundDMA buffer
   \ R6 = Length

.addCallBackBuffer_VolumeShiftLoop%

   LDMIA R1,{R3-R6}

   \ Shift volumes

]
work1%=11:work2%=12
FOR getReg%=3 TO 6
[OPT I%

  MOV   work1%,getReg%,LSL #16          \ Put right into work1
  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg

  MOV   work1%,work1%,ASR #1     \ DIV 2

  MOV   getReg%,getReg%,ASR #1   \ DIV 2

  TST   getReg%,#1<<15           \ Remove any low bit
  EORNE getReg%,getReg%,#1<<15

  ADD   getReg%,getReg%,work1%,LSR #16

]
NEXT
[OPT I%

   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBuffer_VolumeShiftLoop%

   B     addCallBackBuffer_Exit%   \ No data available

.addCallBackBuffer_OK%  \ There are buffers available so use one of these

   \ R1 = Start of SoundDMA buffer
   \ R2 = End of SoundDMA buffer
   \ R6 = Length

   LDR   R5,work_CallBack_BufferVal%
   ADD   R5,R5,R12
   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
   MLA   R0,R6,R7,R5                                    \ Buffer position

   \ R0 = Source buffer
   \ R1 = DMA buffer
   \ R2 = DMA buffer end
   \ R3 = Fill flags

   \ Copy across (mixing??)

   TST  R3,#1
   BNE  addCallBackBuffer_Mix%

   \ No mixing

.addCallBackBuffer_Loop%

   LDMIA R0!,{R3-R6}
   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBuffer_Loop%

   B    addCallBackBuffer_Final%


.addCallBackBuffer_Mix%

   STMDB R13!,{R12}

.addCallBackBufferMix_Loop%

   LDMIA R0!,{R3-R6}
   LDMIA R1,{R7-R10}

]
work1%=11:work2%=12
FOR getReg%=3 TO 6
mixReg%=getReg%+4
[OPT I%

  MOV   work1%,getReg%,LSL #16          \ Put right into work1
  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg

  MOV   work1%,work1%,ASR #1     \ DIV 2

  MOV   getReg%,getReg%,ASR #1   \ DIV 2

  TST   getReg%,#1<<15           \ Remove any low bit
  EORNE getReg%,getReg%,#1<<15

  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg

  MOV   work2%,work2%,ASR #1     \ DIV 2

  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2

  TST   mixReg%,#1<<15           \ Remove any low bit
  EORNE mixReg%,mixReg%,#1<<15

  \ Now mix

  ADD   getReg%,getReg%,mixReg%
  ADD   work1%,work1%,work2%

  ADD   getReg%,getReg%,work1%,LSR #16



]
NEXT
[OPT I%

   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBufferMix_Loop%

   LDMIA R13!,{R12}

.addCallBackBuffer_Final%

   \ Increment current SoundDMA buffer

   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
   ADD   R7,R7,#1
   CMP   R7,R8
   MOVGE R7,#0
   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]

   \ Decrement full count

   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
   SUBS  R8,R8,#1
   MOVLT R8,#0
   STR   R8,[R12,#work_CallBack_BufferFullCount%]

.addCallBackBuffer_Exit%

   LDMIA R13!,{R0-R12,PC}

\ -------------------------------

.callBackHandlerProcess%
          \ On entry:
          \    R1 = base of buffer
          \    R2 = end of buffer
          \    R3 = flags
          \    R4 = sample frequency
          \    R5 = sample period

   STMDB R13!,{R0-R12,R14}

   SUB   R6,R2,R1
   STR   R6,[R12,#work_CallBack_BufferSize%]
   STR   R3,[R12,#work_CallBack_Flags%]
   STR   R4,[R12,#work_CallBack_SampleFrequency%]
   STR   R5,[R12,#work_CallBack_SamplePeriod%]

   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
   CMP   R5,#1
   BEQ   callBackHandlerProcess_Exit%

   MOV   R5,#1
   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag

   \ Set up new call back

]
IF doCBAI% THEN
[OPT I%

   \ Either by CBAI

   LDR   R0,[R12,#work_CBAIActive%]
   CMP   R0,#1

   ADREQ R0,CBAIRoutine%
   STREQ R0,[R12,#work_PollWord%]
   BEQ   callBackHandlerProcess_Exit%

   \ Or by old style Call backs

]
ENDIF
[OPT I%

   ADR   R0,doHandlerCallBack%
   LDR   R1,[R12,#work_privateWord%]

TEQ   PC,PC
MRSEQ R9,CPSR          \ if in 32-bit mode, R9 = CPSR
MOVNE R9,PC            \ if in 26-bit mode, R9 = PC+PSR
ORR   R8,R9,#SVC_Mode% \ preserves 32-bitness
MSREQ CPSR_c,R8
TEQNEP R8,#0
MOV   R0,R0
STMFD R13!,{R14}

   SWI   "XOS_AddCallBack"

LDMFD R13!,{R14}
TEQ   PC,PC
MSREQ CPSR_c,R9
TEQNEP R9,#0
MOV   R0,R0

.callBackHandlerProcess_Exit%

   LDMIA R13!,{R0-R12,PC}

\ -------



\ ---------------

.doHandlerCallBack%  \ Called by call back system
                     \ Needs to call the handler with the right parameters

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R12]

]
IF debug% THEN
[OPT I%
\ If you uncomment this, uncomment the switch to SVC mode in CBAIRoutine% too
\    SWI "XOS_WriteS"
\    EQUS "Handler call back"+CHR$(0):ALIGN
\    SWI  "XOS_NewLine"
]
ENDIF
[OPT I%

   \ From the start and end get the length and offset into the buffer
   \ by the current OutBuffer value

   LDR   R10,[R12,#work_CallBack_BufferSize%]
   LDR   R0,[R12,#work_privateWord%]
   LDR   R3,[R12,#work_CallBack_Flags%]
   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
   LDR   R5,[R12,#work_CallBack_SamplePeriod%]

.doHandlerCallBack_Loop%

   \ R10 = Buffer length

   LDR   R2,work_CallBack_BufferVal%
   ADD   R2,R2,R12
   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
   MLA   R1,R10,R7,R2                              \ Buffer address

   ADD   R2,R1,R10

   MOV   R3,#0                           \ Buffer invalid

   LDR   R8,[R12,#work_CallBackHandlers%]
   CMP   R8,#0
   MOVNE R6,#handlerType_CallBack%
   BLNE  handler%

   LDR   R8,[R12,#work_ProcessHandlers%]
   CMP   R8,#0
   MOVNE R6,#handlerType_Process%
   BLNE  handler%

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; disable interrupts
   TEQ   PC,PC
   MRSEQ R8,CPSR
   MOVNE R8,PC
   ORREQ R9,R8,#I32flag%
   ORRNE R9,R8,#Iflag%
   MSREQ CPSR_c,R9
   TEQNEP R9,#0
]
ENDIF
[OPT I%

   \ increment full count
   \ Increment out buffer

   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
   ADD   R7,R7,#1
   CMP   R7,R9
   MOVGE R7,#0
   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]

   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
   ADD   R7,R7,#1
   CMP   R7,R9
   MOVGT R7,R9
   STR   R7,[R12,#work_CallBack_BufferFullCount%]

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; restore interrupt state
   TEQ   PC,PC
   MSREQ CPSR_c,R8
   TEQNEP R8,#0
]
ENDIF
[OPT I%

   \ Check for full count = max
   \ Loop round if not

   CMP   R7,R9
   BLT   doHandlerCallBack_Loop%

   \ Otherwise we have filled all the buffers and can return

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; disable interrupts
   TEQ   PC,PC
   MRSEQ R8,CPSR
   MOVNE R8,PC
   ORREQ R9,R8,#I32flag%
   ORRNE R9,R8,#Iflag%
   MSREQ CPSR_c,R9
   TEQNEP R9,#0
]
ENDIF
[OPT I%

   MOV   R5,#0
   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; restore interrupt state
   TEQ   PC,PC
   MSREQ CPSR_c,R8
   TEQNEP R8,#0
]
ENDIF
[OPT I%

   LDMIA R13!,{R0-R12,PC}


\ ---------------

.clearCallBackBuffer%  \ Initialise the call back buffer to 0


     STMDB R13!,{R0-R12,R14}

     MOV   R0,#0
     MOV   R1,#0
     MOV   R2,#0
     MOV   R3,#0

     LDR   R4,work_CallBack_BufferVal%
     ADD   R4,R4,R12
     ADD   R5,R4,#callBackBufferLen%

.clearCallBackBuffer_Loop%

     STMIA R4!,{R0-R3}
     CMP   R4,R5
     BLT   clearCallBackBuffer_Loop%

     LDMIA R13!,{R0-R12,PC}


\ ---------------

.setHandlerType%  \ Set the corresponding bit for this handler's number & type
                  \ On entry:
                  \    R0 = Handler number
                  \    R4 = Type

    STMDB R13!,{R0-R4,R14}

    MOV   R1,#1
    MOV   R0,R1,LSL R0          \ As a bit

    CMP   R4,#handlerType_Immediate%
    LDREQ R1,[R12,#work_ImmediateHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_ImmediateHandlers%]

    CMP   R4,#handlerType_CallBack%
    LDREQ R1,[R12,#work_CallBackHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_CallBackHandlers%]

    CMP   R4,#handlerType_Process%
    LDREQ R1,[R12,#work_ProcessHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_ProcessHandlers%]

    LDMIA R13!,{R0-R4,PC}

\ ---------

.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
                    \ On entry:
                    \    R0 = Handler number
                    \    R4 = Type

    STMDB R13!,{R0-R4,R14}

    MOV   R1,#1
    MOV   R0,R1,LSL R0          \ As a bit

    CMP   R4,#handlerType_Immediate%
    LDREQ R1,[R12,#work_ImmediateHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_ImmediateHandlers%]

    CMP   R4,#handlerType_CallBack%
    LDREQ R1,[R12,#work_CallBackHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_CallBackHandlers%]

    CMP   R4,#handlerType_Process%
    LDREQ R1,[R12,#work_ProcessHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_ProcessHandlers%]

    LDMIA R13!,{R0-R4,PC}


\ -------------------- CBAI -----------------

]
IF doCBAI% THEN
[OPT I%

.InstallCBAI%  \ Install the CBAI stuff if module exists

     STMDB R13!,{R0-R12,R14}

     MOV   R0,#0
     STR   R0,[R12,#work_PollWord%]

     MOV   R0,#0
     ADR   R1,CBAIString%
     SWI   "XOS_SWINumberFromString"

     MOVVC R0,#1
     MOVVS R0,#0
     STR   R0,[R12,#work_CBAIActive%]

     ADDVC R0,R12,#work_PollWord%
     MOVVC R1,#&100000       \ Scheduling class
     LDRVC R2,[R12,#work_privateWord%]
     SWIVC "XCBAI_RegisterPollWord"

     LDMIA R13!,{R0-R12,PC}

\ -----------------

.CBAIString% EQUS "CBAI_RegisterPollWord"
             EQUB 0
             ALIGN

\ -----------------

.RemoveCBAI% \ De-register the CBAI pollword

     STMDB R13!,{R0-R12,R14}

     LDR   R0,[R12,#work_CBAIActive%]
     CMP   R0,#1

     ADDEQ R0,R12,#work_PollWord%
     SWIEQ "XCBAI_DeregisterPollWord"

     MOV   R0,#0
     STR   R0,[R12,#work_CBAIActive%]

     LDMIA R13!,{R0-R12,PC}

\ -----------------

.CBAIRoutine%  \ Call back routine to call call back addresses

     STMDB R13!,{R0-R12}

\     TEQ   PC,PC
\     MRSEQ R9,CPSR
\     MOVNE R9,PC
\     ORR   R8,R9,#SVC_mode%
\     MSREQ CPSR_c,R8
\     TEQNEP R8,#0
\     MOV   R0,R0
\     STMFD R13!,{R14}

]:IF CBAIDisableInt% THEN
[OPT I%

     ; disable interrupts
     TEQ   PC,PC
     MRSEQ R8,CPSR
     MOVNE R8,PC
     ORREQ R9,R8,#I32flag%
     ORRNE R9,R8,#Iflag%
     MSREQ CPSR_c,R9
     TEQNEP R9,#0
]
ENDIF
[OPT I%

     BL    doHandlerCallBack%

]:IF CBAIDisableInt% THEN
[OPT I%

     ; restore interrupt state
     TEQ   PC,PC
     MSREQ CPSR_c,R8
     TEQNEP R8,#0
]
ENDIF
[OPT I%

\     LDMFD R13!,{R14}
\     TEQ   PC,PC
\     MSREQ CPSR_c,R9
\     TEQNEP R9,#0
\     MOV   R0,R0

     LDMIA R13!,{R0-R12,PC}

\ -----------------
]
ENDIF
[OPT I%

]
ENDPROC

@


1.4
log
@  See Detail.
Detail:
  * 32-bit compatible
  * srccommitted (and gets version number from VersionNum, even though it's
    written in BASIC)
  * added install rule and MkInstall file to install module in correct place
    within an ARMovie installation
Admin:
  Not tested.

Version 0.49. Tagged as 'SharedSnd-0_49'
@
text
@@


1.3
log
@Changed things so that the detokenised BASIC source (in the c directory) has
no line numbers present (LISTO 8). The detokenised source's raison d'etre is
to allow easier CVS diffs, but line numbers would defeat this purpose whenever
the change involves inserting more than a handful of line numbers.

No other changes - this version is committed and tagged purely as a reference
point for future updates. Tag used is 'bavison_SharedSnd-0_48'.
@
text
@d167 1
a167 1
   LDMIA R13!,{R0,R1,PC}^
d177 1
a177 1
   LDMIA R13!,{R0,R1,PC}^
d205 1
a205 1
   LDMIA R13!,{R0-R12,PC}^
d520 6
a525 3
MOV   R9,PC
ORR   R8,R9,#SVC_Mode%
TEQP  R8,#0
d532 3
a534 1
TEQP  R9,#0
d557 4
a560 3
    SWI "XOS_WriteS"
    EQUS "Handler call back"+CHR$(0):ALIGN
    SWI  "XOS_NewLine"
d600 8
a607 3
   MOV  R8,PC
   ORR  R9,R8,#Iflag%
   TEQP R9,#0                  ; interrupts -> disabled
d631 4
a634 1
   TEQP R8,#0                  ; Interrupts reenabled
d650 8
a657 3
   MOV  R8,PC
   ORR  R9,R8,#Iflag%
   TEQP R9,#0                 ; interrupts -> disabled
d668 4
a671 1
   TEQP R8,#0                  ; Interrupts reenabled
d807 1
a807 1
     SWIEQ "CBAI_DeregisterPollWord"
d820 6
a825 3
\     MOV   R9,PC
\     ORR   R8,R9,#SVC_Mode%
\     TEQP  R8,#0
d832 8
a839 3
   MOV  R8,PC
   ORR  R9,R8,#Iflag%
   TEQP R9,#0                  ; interrupts -> disabled
d849 4
a852 1
   TEQP R8,#0                  ; Interrupts reenabled
d858 3
a860 1
\     TEQP  R9,#0
@


1.2
log
@Spinner branch merged
@
text
@d26 812
a837 812
   10
   20The process involves receiving a 'fill this buffer' instruction
   30from a driver.
   40The fill code then fills and mixes any available data from
   50any immediate handlers whith each handler doing it's own mixing.
   60Then any call back streams are called to give any available data
   70with the fill code mixing it.
   80Finally, call back streams are called to make sure that the call
   90back buffer is full.
  100At the end of each call back call process handlers can be called.
  110The same handler code for each stage can be used with flags to
  120indicate which type of handler is being processed ans with the
  130data pointers set appropriately.
  140
  150
  160DEFPROCHandler
  170LOCAL er$,debug%
  180er$="Handler"
  190debug%=FALSE
  200PRINT "PROCHandler"
  210CBAIDisableInt%=TRUE
  220[OPT I%
  230
  240
  250\-------------------------- Sound Handler Code ------------------------
  260
  270.stopSound% \ Make sure nothing is happening
  280
  290   STMDB R13!,{R0,R14}
  300
  310   MOV   R0,#1
  320   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine
  330
  340   \ Now wait until no sound is happening
  350
  360.stopSoundLoop%
  370
  380   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
  390   CMP   R0,#0
  400   BNE   stopSoundLoop%
  410
  420   LDMIA R13!,{R0,PC}
  430
  440\ -----------
  450
  460.startSound% \ Set handler going again
  470
  480  STMDB R13!,{R0,R14}
  490
  500  MOV   R0,#0
  510  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
  520
  530  \ Should check that there is a current driver and that it is active...
  540
  550  LDMIA R13!,{R0,PC}
  560
  570\ -------------------------------
  580
  590.getFillR0%
  600
  610  ADR   R0,fill%
  620  MOV   PC,R14
  630
  640\ ----
  650
  660.fill%   \ Main fill call for output driver
  670         \ Can be called by a 16 or 8 bit driver
  680         \ It needs to collect and mix data into the final buffer
  690         \ converting the data if necessary.
  700         \ On entry:
  710         \    R0 = parameter, this should be the SharedSound R12 value
  720         \    R1 = base of buffer
  730         \    R2 = end of buffer
  740         \    R3 = flags
  750         \    R4 = sample frequency or period
  760         \ Added:
  770         \    R5 = sample period
  780
  790   STMDB R13!,{R0-R12,R14}
  800
  810   LDR   R12,[R0]
  820
  830   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
  840   CMP   R0,#1
  850   BEQ   fillExit%
  860
  870   MOV   R0,#1
  880   STR   R0,[R12,#work_SoundActive%]    \ Flag active
  890
  900   \ If there is data in the buffer then this is shown in R3
  910
  920   MOV   R5,R4
  930   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
  940   CMP   R4,R5
  950
  960   BLNE  rateChange%                             \ Set a call back to change values
  970
  980   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now
  990
 1000   \ First call any immediate handlers
 1010
 1020   LDR   R6,[R12,#work_ImmediateHandlers%]
 1030   CMP   R6,#0
 1040   MOVNE R6,#handlerType_Immediate%
 1050   BLNE  handler%
 1060
 1070   \ Now get any callBack buffers and mix in
 1080
 1090   LDR   R6,[R12,#work_CallBackHandlers%]
 1100   CMP   R6,#0
 1110   BEQ   fillExit%
 1120
 1130   BL    addCallBackBuffer%
 1140
 1150   \ Finally initiate any callbacks required
 1160
 1170   BL    callBackHandlerProcess%
 1180
 1190
 1200.fillExit%
 1210
 1220   MOV   R0,#0
 1230   STR   R0,[R12,#work_SoundActive%]    \ Flag finished
 1240
 1250   LDMIA R13!,{R0-R12,PC}
 1260
 1270\ ------------------
 1280
 1290.rateChange%     \ Issue a call back to change the rate values
 1300
 1310   STMDB R13!,{R0,R1,R14}
 1320
 1330]
 1340IF doCallBack% THEN
 1350[OPT I%
 1360
 1370   ADR   R0,rateChangeCallBack%
 1380   LDR   R1,[R12,#work_privateWord%]
 1390
 1400   SWI   "OS_AddCallBack"
 1410
 1420   LDMIA R13!,{R0,R1,PC}^
 1430
 1440
 1450]
 1460ELSE
 1470[OPT I%
 1480
 1490   MOV   R0,R5   \ New frequency
 1500   BL    newRate%
 1510
 1520   LDMIA R13!,{R0,R1,PC}^
 1530
 1540]
 1550ENDIF
 1560[OPT I%
 1570
 1580
 1590\ ---------
 1600
 1610
 1620]
 1630IF doCallBack% THEN
 1640[OPT I%
 1650
 1660
 1670.rateChangeCallBack%
 1680
 1690   STMDB R13!,{R0-R12,R14}
 1700
 1710   LDR   R12,[R12]         \ Get workspace pointer
 1720
 1730   \     First get current sample frequency and sample period
 1740   \     This is provided by the SampleRate routine
 1750
 1760   MOV   R0,#0          \ Function code read
 1770
 1780   BL    newSampleRate%
 1790
 1800   LDMIA R13!,{R0-R12,PC}^
 1810
 1820]
 1830ENDIF
 1840[OPT I%
 1850
 1860
 1870\ ---------------- Handler stuff ---------------
 1880
 1890.handler% \ Dummy fill code
 1900          \ Used to pass on control to chain of handlers
 1910          \ The flags indicate which handlers to call
 1920          \ There are three types - immediate, callback and process
 1930          \ On entry:
 1940          \    R0 = parameter, this should be the SharedSound R12 value
 1950          \    R1 = base of buffer
 1960          \    R2 = end of buffer
 1970          \    R3 = flags
 1980          \    R4 = sample frequency
 1990          \    R5 = sample period
 2000          \    R6 = Handler type
 2010
 2020          \ Added by SharedSound before calling handlers
 2030
 2040          \    R6 = fraction step
 2050          \    R7 = LR Volume
 2060
 2070   STMDB R13!,{R0-R2,R4-R12,R14}
 2080
 2090   \ Now call each handler in turn, if they match the flag type
 2100
 2110   MOV   R11,R6 \ Handler type
 2120
 2130   ADD   R8,R12,#work_handlerTable%       \ Address of table
 2140   MOV   R9,#handlerMax%                  \ Handler count
 2150
 2160.handlerLoop%
 2170
 2180   LDR   R10,[R8,#handler_Type%]
 2190   CMP   R10,R11
 2200   BNE   handlerNext%
 2210
 2220   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
 2230   CMP   R10,#0
 2240   BEQ   handlerNext%
 2250
 2260   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2270
 2280   LDR   R0,[R8,#handler_Parameter%]
 2290   LDR   R6,[R8,#handler_Fraction%]
 2300   LDR   R7,[R8,#handler_VolumeScaled%]
 2310
 2320   MOV   R14,PC
 2330   MOV   PC,R10                            \ Jump to address
 2340\   MOVNV R0,R0
 2350
 2360.handlerReturn%
 2370
 2380   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2390
 2400.handlerNext%
 2410
 2420   ADD   R8,R8,#handlerTableLen%
 2430   SUBS  R9,R9,#1
 2440   BNE   handlerLoop%
 2450
 2460
 2470.handlerExit%
 2480
 2490   LDMIA R13!,{R0-R2,R4-R12,PC}
 2500
 2510\ ------------------- Call Back Handler routines
 2520
 2530.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%
 2540
 2550\ ----
 2560
 2570.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
 2580                     \ On entry:
 2590                     \    R1 = base of buffer
 2600                     \    R2 = end of buffer
 2610                     \    R3 = flags
 2620                     \    R4 = sample frequency
 2630                     \    R5 = sample period
 2640                     \ On exit:
 2650                     \    call back data mixed in if there is some
 2660
 2670   STMDB R13!,{R0-R12,R14}
 2680
 2690   SUB   R6,R2,R1
 2700   LDR   R7,[R12,#work_CallBack_BufferSize%]
 2710
 2720   CMP   R6,R7
 2730
 2740   \ If the buffer size has changed then need to make changes...
 2750
 2760   STR   R6,[R12,#work_CallBack_BufferSize%]
 2770
 2780   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
 2790   CMP   R5,#0
 2800   BGT   addCallBackBuffer_OK%
 2810
 2820   \ Need to flag an overrun
 2830
 2840   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
 2850   CMP   R5,#1
 2860
 2870   \ If there are no full buffers and the call back is active then we have overrun
 2880
 2890   LDREQ R7,[R12,#work_callBack_Count%]   \ If so then increment count and return
 2900   ADDEQ R7,R7,#1
 2910   STREQ R7,[R12,#work_callBack_Count%]
 2920
 2930   \ Need to do a volume shift on the buffer to effectivly mix an empty buffer
 2940   \ into the existing data
 2950   \ This avoids volume fluctuations
 2960
 2970   \ R1 = Start of SoundDMA buffer
 2980   \ R2 = End of SoundDMA buffer
 2990   \ R6 = Length
 3000
 3010.addCallBackBuffer_VolumeShiftLoop%
 3020
 3030   LDMIA R1,{R3-R6}
 3040
 3050   \ Shift volumes
 3060
 3070]
 3080work1%=11:work2%=12
 3090FOR getReg%=3 TO 6
 3100[OPT I%
 3110
 3120  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3130  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3140
 3150  MOV   work1%,work1%,ASR #1     \ DIV 2
 3160
 3170  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3180
 3190  TST   getReg%,#1<<15           \ Remove any low bit
 3200  EORNE getReg%,getReg%,#1<<15
 3210
 3220  ADD   getReg%,getReg%,work1%,LSR #16
 3230
 3240]
 3250NEXT
 3260[OPT I%
 3270
 3280   STMIA R1!,{R3-R6}
 3290
 3300   CMP   R1,R2
 3310   BLT   addCallBackBuffer_VolumeShiftLoop%
 3320
 3330   B     addCallBackBuffer_Exit%   \ No data available
 3340
 3350.addCallBackBuffer_OK%  \ There are buffers available so use one of these
 3360
 3370   \ R1 = Start of SoundDMA buffer
 3380   \ R2 = End of SoundDMA buffer
 3390   \ R6 = Length
 3400
 3410   LDR   R5,work_CallBack_BufferVal%
 3420   ADD   R5,R5,R12
 3430   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3440   MLA   R0,R6,R7,R5                                    \ Buffer position
 3450
 3460   \ R0 = Source buffer
 3470   \ R1 = DMA buffer
 3480   \ R2 = DMA buffer end
 3490   \ R3 = Fill flags
 3500
 3510   \ Copy across (mixing??)
 3520
 3530   TST  R3,#1
 3540   BNE  addCallBackBuffer_Mix%
 3550
 3560   \ No mixing
 3570
 3580.addCallBackBuffer_Loop%
 3590
 3600   LDMIA R0!,{R3-R6}
 3610   STMIA R1!,{R3-R6}
 3620
 3630   CMP   R1,R2
 3640   BLT   addCallBackBuffer_Loop%
 3650
 3660   B    addCallBackBuffer_Final%
 3670
 3680
 3690.addCallBackBuffer_Mix%
 3700
 3710   STMDB R13!,{R12}
 3720
 3730.addCallBackBufferMix_Loop%
 3740
 3750   LDMIA R0!,{R3-R6}
 3760   LDMIA R1,{R7-R10}
 3770
 3780]
 3790work1%=11:work2%=12
 3800FOR getReg%=3 TO 6
 3810mixReg%=getReg%+4
 3820[OPT I%
 3830
 3840  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3850  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3860
 3870  MOV   work1%,work1%,ASR #1     \ DIV 2
 3880
 3890  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3900
 3910  TST   getReg%,#1<<15           \ Remove any low bit
 3920  EORNE getReg%,getReg%,#1<<15
 3930
 3940  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
 3950  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg
 3960
 3970  MOV   work2%,work2%,ASR #1     \ DIV 2
 3980
 3990  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2
 4000
 4010  TST   mixReg%,#1<<15           \ Remove any low bit
 4020  EORNE mixReg%,mixReg%,#1<<15
 4030
 4040  \ Now mix
 4050
 4060  ADD   getReg%,getReg%,mixReg%
 4070  ADD   work1%,work1%,work2%
 4080
 4090  ADD   getReg%,getReg%,work1%,LSR #16
 4100
 4110
 4120
 4130]
 4140NEXT
 4150[OPT I%
 4160
 4170   STMIA R1!,{R3-R6}
 4180
 4190   CMP   R1,R2
 4200   BLT   addCallBackBufferMix_Loop%
 4210
 4220   LDMIA R13!,{R12}
 4230
 4240.addCallBackBuffer_Final%
 4250
 4260   \ Increment current SoundDMA buffer
 4270
 4280   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4290   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
 4300   ADD   R7,R7,#1
 4310   CMP   R7,R8
 4320   MOVGE R7,#0
 4330   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4340
 4350   \ Decrement full count
 4360
 4370   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
 4380   SUBS  R8,R8,#1
 4390   MOVLT R8,#0
 4400   STR   R8,[R12,#work_CallBack_BufferFullCount%]
 4410
 4420.addCallBackBuffer_Exit%
 4430
 4440   LDMIA R13!,{R0-R12,PC}
 4450
 4460\ -------------------------------
 4470
 4480.callBackHandlerProcess%
 4490          \ On entry:
 4500          \    R1 = base of buffer
 4510          \    R2 = end of buffer
 4520          \    R3 = flags
 4530          \    R4 = sample frequency
 4540          \    R5 = sample period
 4550
 4560   STMDB R13!,{R0-R12,R14}
 4570
 4580   SUB   R6,R2,R1
 4590   STR   R6,[R12,#work_CallBack_BufferSize%]
 4600   STR   R3,[R12,#work_CallBack_Flags%]
 4610   STR   R4,[R12,#work_CallBack_SampleFrequency%]
 4620   STR   R5,[R12,#work_CallBack_SamplePeriod%]
 4630
 4640   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4650   CMP   R5,#1
 4660   BEQ   callBackHandlerProcess_Exit%
 4670
 4680   MOV   R5,#1
 4690   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4700
 4710   \ Set up new call back
 4720
 4730]
 4740IF doCBAI% THEN
 4750[OPT I%
 4760
 4770   \ Either by CBAI
 4780
 4790   LDR   R0,[R12,#work_CBAIActive%]
 4800   CMP   R0,#1
 4810
 4820   ADREQ R0,CBAIRoutine%
 4830   STREQ R0,[R12,#work_PollWord%]
 4840   BEQ   callBackHandlerProcess_Exit%
 4850
 4860   \ Or by old style Call backs
 4870
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920   ADR   R0,doHandlerCallBack%
 4930   LDR   R1,[R12,#work_privateWord%]
 4940
 4950MOV   R9,PC
 4960ORR   R8,R9,#SVC_Mode%
 4970TEQP  R8,#0
 4980MOV   R0,R0
 4990STMFD R13!,{R14}
 5000
 5010   SWI   "XOS_AddCallBack"
 5020
 5030LDMFD R13!,{R14}
 5040TEQP  R9,#0
 5050MOV   R0,R0
 5060
 5070.callBackHandlerProcess_Exit%
 5080
 5090   LDMIA R13!,{R0-R12,PC}
 5100
 5110\ -------
 5120
 5130
 5140
 5150\ ---------------
 5160
 5170.doHandlerCallBack%  \ Called by call back system
 5180                     \ Needs to call the handler with the right parameters
 5190
 5200   STMDB R13!,{R0-R12,R14}
 5210
 5220   LDR   R12,[R12]
 5230
 5240]
 5250IF debug% THEN
 5260[OPT I%
 5270    SWI "XOS_WriteS"
 5280    EQUS "Handler call back"+CHR$(0):ALIGN
 5290    SWI  "XOS_NewLine"
 5300]
 5310ENDIF
 5320[OPT I%
 5330
 5340   \ From the start and end get the length and offset into the buffer
 5350   \ by the current OutBuffer value
 5360
 5370   LDR   R10,[R12,#work_CallBack_BufferSize%]
 5380   LDR   R0,[R12,#work_privateWord%]
 5390   LDR   R3,[R12,#work_CallBack_Flags%]
 5400   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
 5410   LDR   R5,[R12,#work_CallBack_SamplePeriod%]
 5420
 5430.doHandlerCallBack_Loop%
 5440
 5450   \ R10 = Buffer length
 5460
 5470   LDR   R2,work_CallBack_BufferVal%
 5480   ADD   R2,R2,R12
 5490   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5500   MLA   R1,R10,R7,R2                              \ Buffer address
 5510
 5520   ADD   R2,R1,R10
 5530
 5540   MOV   R3,#0                           \ Buffer invalid
 5550
 5560   LDR   R8,[R12,#work_CallBackHandlers%]
 5570   CMP   R8,#0
 5580   MOVNE R6,#handlerType_CallBack%
 5590   BLNE  handler%
 5600
 5610   LDR   R8,[R12,#work_ProcessHandlers%]
 5620   CMP   R8,#0
 5630   MOVNE R6,#handlerType_Process%
 5640   BLNE  handler%
 5650
 5660]:IF NOT CBAIDisableInt% THEN
 5670[OPT I%
 5680
 5690   MOV  R8,PC
 5700   ORR  R9,R8,#Iflag%
 5710   TEQP R9,#0                  ; interrupts -> disabled
 5720]
 5730ENDIF
 5740[OPT I%
 5750
 5760   \ increment full count
 5770   \ Increment out buffer
 5780
 5790   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5800   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
 5810   ADD   R7,R7,#1
 5820   CMP   R7,R9
 5830   MOVGE R7,#0
 5840   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5850
 5860   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
 5870   ADD   R7,R7,#1
 5880   CMP   R7,R9
 5890   MOVGT R7,R9
 5900   STR   R7,[R12,#work_CallBack_BufferFullCount%]
 5910
 5920]:IF NOT CBAIDisableInt% THEN
 5930[OPT I%
 5940
 5950   TEQP R8,#0                  ; Interrupts reenabled
 5960]
 5970ENDIF
 5980[OPT I%
 5990
 6000   \ Check for full count = max
 6010   \ Loop round if not
 6020
 6030   CMP   R7,R9
 6040   BLT   doHandlerCallBack_Loop%
 6050
 6060   \ Otherwise we have filled all the buffers and can return
 6070
 6080]:IF NOT CBAIDisableInt% THEN
 6090[OPT I%
 6100
 6110   MOV  R8,PC
 6120   ORR  R9,R8,#Iflag%
 6130   TEQP R9,#0                 ; interrupts -> disabled
 6140]
 6150ENDIF
 6160[OPT I%
 6170
 6180   MOV   R5,#0
 6190   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed
 6200
 6210]:IF NOT CBAIDisableInt% THEN
 6220[OPT I%
 6230
 6240   TEQP R8,#0                  ; Interrupts reenabled
 6250]
 6260ENDIF
 6270[OPT I%
 6280
 6290   LDMIA R13!,{R0-R12,PC}
 6300
 6310
 6320\ ---------------
 6330
 6340.clearCallBackBuffer%  \ Initialise the call back buffer to 0
 6350
 6360
 6370     STMDB R13!,{R0-R12,R14}
 6380
 6390     MOV   R0,#0
 6400     MOV   R1,#0
 6410     MOV   R2,#0
 6420     MOV   R3,#0
 6430
 6440     LDR   R4,work_CallBack_BufferVal%
 6450     ADD   R4,R4,R12
 6460     ADD   R5,R4,#callBackBufferLen%
 6470
 6480.clearCallBackBuffer_Loop%
 6490
 6500     STMIA R4!,{R0-R3}
 6510     CMP   R4,R5
 6520     BLT   clearCallBackBuffer_Loop%
 6530
 6540     LDMIA R13!,{R0-R12,PC}
 6550
 6560
 6570\ ---------------
 6580
 6590.setHandlerType%  \ Set the corresponding bit for this handler's number & type
 6600                  \ On entry:
 6610                  \    R0 = Handler number
 6620                  \    R4 = Type
 6630
 6640    STMDB R13!,{R0-R4,R14}
 6650
 6660    MOV   R1,#1
 6670    MOV   R0,R1,LSL R0          \ As a bit
 6680
 6690    CMP   R4,#handlerType_Immediate%
 6700    LDREQ R1,[R12,#work_ImmediateHandlers%]
 6710    ORREQ R1,R1,R0
 6720    STREQ R1,[R12,#work_ImmediateHandlers%]
 6730
 6740    CMP   R4,#handlerType_CallBack%
 6750    LDREQ R1,[R12,#work_CallBackHandlers%]
 6760    ORREQ R1,R1,R0
 6770    STREQ R1,[R12,#work_CallBackHandlers%]
 6780
 6790    CMP   R4,#handlerType_Process%
 6800    LDREQ R1,[R12,#work_ProcessHandlers%]
 6810    ORREQ R1,R1,R0
 6820    STREQ R1,[R12,#work_ProcessHandlers%]
 6830
 6840    LDMIA R13!,{R0-R4,PC}
 6850
 6860\ ---------
 6870
 6880.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
 6890                    \ On entry:
 6900                    \    R0 = Handler number
 6910                    \    R4 = Type
 6920
 6930    STMDB R13!,{R0-R4,R14}
 6940
 6950    MOV   R1,#1
 6960    MOV   R0,R1,LSL R0          \ As a bit
 6970
 6980    CMP   R4,#handlerType_Immediate%
 6990    LDREQ R1,[R12,#work_ImmediateHandlers%]
 7000    BICEQ R1,R1,R0
 7010    STREQ R1,[R12,#work_ImmediateHandlers%]
 7020
 7030    CMP   R4,#handlerType_CallBack%
 7040    LDREQ R1,[R12,#work_CallBackHandlers%]
 7050    BICEQ R1,R1,R0
 7060    STREQ R1,[R12,#work_CallBackHandlers%]
 7070
 7080    CMP   R4,#handlerType_Process%
 7090    LDREQ R1,[R12,#work_ProcessHandlers%]
 7100    BICEQ R1,R1,R0
 7110    STREQ R1,[R12,#work_ProcessHandlers%]
 7120
 7130    LDMIA R13!,{R0-R4,PC}
 7140
 7150
 7160\ -------------------- CBAI -----------------
 7170
 7180]
 7190IF doCBAI% THEN
 7200[OPT I%
 7210
 7220.InstallCBAI%  \ Install the CBAI stuff if module exists
 7230
 7240     STMDB R13!,{R0-R12,R14}
 7250
 7260     MOV   R0,#0
 7270     STR   R0,[R12,#work_PollWord%]
 7280
 7290     MOV   R0,#0
 7300     ADR   R1,CBAIString%
 7310     SWI   "XOS_SWINumberFromString"
 7320
 7330     MOVVC R0,#1
 7340     MOVVS R0,#0
 7350     STR   R0,[R12,#work_CBAIActive%]
 7360
 7370     ADDVC R0,R12,#work_PollWord%
 7380     MOVVC R1,#&100000       \ Scheduling class
 7390     LDRVC R2,[R12,#work_privateWord%]
 7400     SWIVC "XCBAI_RegisterPollWord"
 7410
 7420     LDMIA R13!,{R0-R12,PC}
 7430
 7440\ -----------------
 7450
 7460.CBAIString% EQUS "CBAI_RegisterPollWord"
 7470             EQUB 0
 7480             ALIGN
 7490
 7500\ -----------------
 7510
 7520.RemoveCBAI% \ De-register the CBAI pollword
 7530
 7540     STMDB R13!,{R0-R12,R14}
 7550
 7560     LDR   R0,[R12,#work_CBAIActive%]
 7570     CMP   R0,#1
 7580
 7590     ADDEQ R0,R12,#work_PollWord%
 7600     SWIEQ "CBAI_DeregisterPollWord"
 7610
 7620     MOV   R0,#0
 7630     STR   R0,[R12,#work_CBAIActive%]
 7640
 7650     LDMIA R13!,{R0-R12,PC}
 7660
 7670\ -----------------
 7680
 7690.CBAIRoutine%  \ Call back routine to call call back addresses
 7700
 7710     STMDB R13!,{R0-R12}
 7720
 7730\     MOV   R9,PC
 7740\     ORR   R8,R9,#SVC_Mode%
 7750\     TEQP  R8,#0
 7760\     MOV   R0,R0
 7770\     STMFD R13!,{R14}
 7780
 7790]:IF CBAIDisableInt% THEN
 7800[OPT I%
 7810
 7820   MOV  R8,PC
 7830   ORR  R9,R8,#Iflag%
 7840   TEQP R9,#0                  ; interrupts -> disabled
 7850]
 7860ENDIF
 7870[OPT I%
 7880
 7890     BL    doHandlerCallBack%
 7900
 7910]:IF CBAIDisableInt% THEN
 7920[OPT I%
 7930
 7940   TEQP R8,#0                  ; Interrupts reenabled
 7950]
 7960ENDIF
 7970[OPT I%
 7980
 7990\     LDMFD R13!,{R14}
 8000\     TEQP  R9,#0
 8010\     MOV   R0,R0
 8020
 8030     LDMIA R13!,{R0-R12,PC}
 8040
 8050\ -----------------
 8060]
 8070ENDIF
 8080[OPT I%
 8090
 8100]
 8110ENDPROC
 8120
@


1.1
log
@file Handler was initially added on branch Spinner.
@
text
@d1 837
@


1.1.2.1
log
@New layout SharedSound with text files rather than BASIC files.
@
text
@a0 405
/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
   20The process involves receiving a 'fill this buffer' instruction
   30from a driver.
   40The fill code then fills and mixes any available data from
   50any immediate handlers whith each handler doing it's own mixing.
   60Then any call back streams are called to give any available data
   70with the fill code mixing it.
   80Finally, call back streams are called to make sure that the call
   90back buffer is full.
  100At the end of each call back call process handlers can be called.
  110The same handler code for each stage can be used with flags to
  120indicate which type of handler is being processed ans with the
  130data pointers set appropriately.
  160DEFPROCHandler
  170LOCAL er$
  180er$="Handler"
  190PRINT "PROCHandler"
  200[OPT I%
  230\-------------------------- Sound Handler Code ------------------------
  250.stopSound% \ Make sure nothing is happening
  270   STMDB R13!,{R0,R14}
  290   MOV   R0,#1
  300   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine
  320   \ Now wait until no sound is happening
  340.stopSoundLoop%
  360   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
  370   CMP   R0,#0
  380   BNE   stopSoundLoop%
  400   LDMIA R13!,{R0,PC}
  420\ -----------
  440.startSound% \ Set handler going again
  460  STMDB R13!,{R0,R14}
  480  MOV   R0,#0
  490  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
  510  \ Should check that there is a current driver and that it is active...
  530  LDMIA R13!,{R0,PC}
  550\ -------------------------------
  570.getFillR0%
  590  ADR   R0,fill%
  600  MOV   PC,R14
  620\ ----
  640.fill%   \ Main fill call for output driver
  650         \ Can be called by a 16 or 8 bit driver
  660         \ It needs to collect and mix data into the final buffer
  670         \ converting the data if necessary.
  680         \ On entry:
  690         \    R0 = parameter, this should be the SharedSound R12 value
  700         \    R1 = base of buffer
  710         \    R2 = end of buffer
  720         \    R3 = flags
  730         \    R4 = sample frequency or period
  740         \ Added:
  750         \    R5 = sample period
  770   STMDB R13!,{R0-R12,R14}
  790   LDR   R12,[R0]
  810   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
  820   CMP   R0,#1
  830   BEQ   fillExit%
  850   MOV   R0,#1
  860   STR   R0,[R12,#work_SoundActive%]    \ Flag active
  880   \ If there is data in the buffer then this is shown in R3
  900   MOV   R5,R4
  910   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
  920   CMP   R4,R5
  940   BLNE  rateChange%                             \ Set a call back to change values
  960   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now
  980   \ First call any immediate handlers
 1000   LDR   R6,[R12,#work_ImmediateHandlers%]
 1010   CMP   R6,#0
 1020   MOVNE R6,#handlerType_Immediate%
 1030   BLNE  handler%
 1050   \ Now get any callBack buffers and mix in
 1070   LDR   R6,[R12,#work_CallBackHandlers%]
 1080   CMP   R6,#0
 1090   BEQ   fillExit%
 1110   BL    addCallBackBuffer%
 1130   \ Finally initiate any callbacks required
 1150   BL    callBackHandlerProcess%
 1180.fillExit%
 1200   MOV   R0,#0
 1210   STR   R0,[R12,#work_SoundActive%]    \ Flag finished
 1230   LDMIA R13!,{R0-R12,PC}
 1250\ ------------------
 1270.rateChange%     \ Issue a call back to change the rate values
 1290   STMDB R13!,{R0,R1,R14}
 1310   MOV   R0,R5   \ New frequency
 1320   BL    newRate%
 1340   LDMIA R13!,{R0,R1,PC}^
 1370\ ---------------- Handler stuff ---------------
 1390.handler% \ Dummy fill code
 1400          \ Used to pass on control to chain of handlers
 1410          \ The flags indicate which handlers to call
 1420          \ There are three types - immediate, callback and process
 1430          \ On entry:
 1440          \    R0 = parameter, this should be the SharedSound R12 value
 1450          \    R1 = base of buffer
 1460          \    R2 = end of buffer
 1470          \    R3 = flags
 1480          \    R4 = sample frequency
 1490          \    R5 = sample period
 1500          \    R6 = Handler type
 1520          \ Added by SharedSound before calling handlers
 1540          \    R6 = fraction step
 1550          \    R7 = LR Volume
 1570   STMDB R13!,{R0-R2,R4-R12,R14}
 1590   \ Now call each handler in turn, if they match the flag type
 1610   MOV   R11,R6 \ Handler type
 1630   ADD   R8,R12,#work_handlerTable%       \ Address of table
 1640   MOV   R9,#handlerMax%                  \ Handler count
 1660.handlerLoop%
 1680   LDR   R10,[R8,#handler_Type%]
 1690   CMP   R10,R11
 1700   BNE   handlerNext%
 1720   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
 1730   CMP   R10,#0
 1740   BEQ   handlerNext%
 1760   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 1780   LDR   R0,[R8,#handler_Parameter%]
 1790   LDR   R6,[R8,#handler_Fraction%]
 1800   LDR   R7,[R8,#handler_VolumeScaled%]
 1820   MOV   R14,PC
 1830   MOV   PC,R10                            \ Jump to address
 1840\   MOVNV R0,R0
 1860.handlerReturn%
 1880   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 1900.handlerNext%
 1920   ADD   R8,R8,#handlerTableLen%
 1930   SUBS  R9,R9,#1
 1940   BNE   handlerLoop%
 1970.handlerExit%
 1990   LDMIA R13!,{R0-R2,R4-R12,PC}
 2010\ ------------------- Call Back Handler routines
 2030.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%
 2050\ ----
 2070.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
 2080                     \ On entry:
 2090                     \    R1 = base of buffer
 2100                     \    R2 = end of buffer
 2110                     \    R3 = flags
 2120                     \    R4 = sample frequency
 2130                     \    R5 = sample period
 2140                     \ On exit:
 2150                     \    call back data mixed in if there is some
 2170   STMDB R13!,{R0-R12,R14}
 2190   SUB   R6,R2,R1
 2200   LDR   R7,[R12,#work_CallBack_BufferSize%]
 2220   CMP   R6,R7
 2240   \ If the buffer size has changed then need to make changes...
 2260   STR   R6,[R12,#work_CallBack_BufferSize%]
 2280   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
 2290   CMP   R5,#0
 2300   BGT   addCallBackBuffer_OK%
 2320   \ Need to flag an overrun
 2340   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
 2350   CMP   R5,#1
 2370   \ If there are no full buffers and the call back is active then we have overrun
 2390   LDREQ R6,[R12,#work_callBack_Count%]   \ If so then increment count and return
 2400   ADDEQ R6,R6,#1
 2410   STREQ R6,[R12,#work_callBack_Count%]
 2430   B     addCallBackBuffer_Exit%   \ No data available
 2450.addCallBackBuffer_OK%  \ There are buffers available so use one of these
 2470   \ R1 = Start of SoundDMA buffer
 2480   \ R2 = End of SoundDMA buffer
 2490   \ R6 = Length
 2510   LDR   R5,work_CallBack_BufferVal%
 2520   ADD   R5,R5,R12
 2530   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 2540   MLA   R0,R6,R7,R5                                    \ Buffer position
 2560   \ R0 = Source buffer
 2570   \ R1 = DMA buffer
 2580   \ R2 = DMA buffer end
 2590   \ R3 = Fill flags
 2610   \ Copy across (mixing??)
 2630   TST  R3,#1
 2640   BNE  addCallBackBuffer_Mix%
 2660   \ No mixing
 2680.addCallBackBuffer_Loop%
 2700   LDMIA R0!,{R3-R6}
 2710   STMIA R1!,{R3-R6}
 2730   CMP   R1,R2
 2740   BLT   addCallBackBuffer_Loop%
 2760   B    addCallBackBuffer_Final%
 2790.addCallBackBuffer_Mix%
 2810   STMDB R13!,{R12}
 2830.addCallBackBufferMix_Loop%
 2850   LDMIA R0!,{R3-R6}
 2860   LDMIA R1,{R7-R10}
 2880]
 2890work1%=11:work2%=12
 2900FOR getReg%=3 TO 6
 2910mixReg%=getReg%+4
 2920[OPT I%
 2940  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 2950  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 2970  MOV   work1%,work1%,ASR #1     \ DIV 2
 2990  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3010  TST   getReg%,#1<<15           \ Remove any low bit
 3020  EORNE getReg%,getReg%,#1<<15
 3040  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
 3050  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg
 3070  MOV   work2%,work2%,ASR #1     \ DIV 2
 3090  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2
 3110  TST   mixReg%,#1<<15           \ Remove any low bit
 3120  EORNE mixReg%,mixReg%,#1<<15
 3140  \ Now mix
 3160  ADD   getReg%,getReg%,mixReg%
 3170  ADD   work1%,work1%,work2%
 3190  ADD   getReg%,getReg%,work1%,LSR #16
 3230]
 3240NEXT
 3250[OPT I%
 3270   STMIA R1!,{R3-R6}
 3290   CMP   R1,R2
 3300   BLT   addCallBackBufferMix_Loop%
 3320   LDMIA R13!,{R12}
 3340.addCallBackBuffer_Final%
 3360   \ Increment current SoundDMA buffer
 3380   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3390   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
 3400   ADD   R7,R7,#1
 3410   CMP   R7,R8
 3420   MOVGE R7,#0
 3430   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3450   \ Decrement full count
 3470   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
 3480   SUBS  R8,R8,#1
 3490   MOVLT R8,#0
 3500   STR   R8,[R12,#work_CallBack_BufferFullCount%]
 3520.addCallBackBuffer_Exit%
 3540   LDMIA R13!,{R0-R12,PC}
 3560\ -------------------------------
 3580.callBackHandlerProcess%
 3590          \ On entry:
 3600          \    R1 = base of buffer
 3610          \    R2 = end of buffer
 3620          \    R3 = flags
 3630          \    R4 = sample frequency
 3640          \    R5 = sample period
 3660   STMDB R13!,{R0-R12,R14}
 3680   SUB   R6,R2,R1
 3690   STR   R6,[R12,#work_CallBack_BufferSize%]
 3700   STR   R3,[R12,#work_CallBack_Flags%]
 3710   STR   R4,[R12,#work_CallBack_SampleFrequency%]
 3720   STR   R5,[R12,#work_CallBack_SamplePeriod%]
 3740   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 3750   CMP   R5,#1
 3760   BEQ   callBackHandlerProcess_Exit%
 3780   MOV   R5,#1
 3790   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 3810   \ Set up new call back
 3830   ADR   R0,doHandlerCallBack%
 3840   LDR   R1,[R12,#work_privateWord%]
 3860MOV   R9,PC
 3870ORR   R8,R9,#SVC_Mode%
 3880TEQP  R8,#0
 3890MOV   R0,R0
 3900STMFD R13!,{R14}
 3920   SWI   "XOS_AddCallBack"
 3940LDMFD R13!,{R14}
 3950TEQP  R9,#0
 3960MOV   R0,R0
 3980.callBackHandlerProcess_Exit%
 4000   LDMIA R13!,{R0-R12,PC}
 4020\ -------
 4060\ ---------------
 4080.doHandlerCallBack%  \ Called by call back system
 4090                     \ Needs to call the handler with the right parameters
 4110   STMDB R13!,{R0-R12,R14}
 4130   LDR   R12,[R12]
 4150   \ From the start and end get the length and offset into the buffer
 4160   \ by the current OutBuffer value
 4180   LDR   R10,[R12,#work_CallBack_BufferSize%]
 4190   LDR   R0,[R12,#work_privateWord%]
 4200   LDR   R3,[R12,#work_CallBack_Flags%]
 4210   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
 4220   LDR   R5,[R12,#work_CallBack_SamplePeriod%]
 4240.doHandlerCallBack_Loop%
 4260   \ R10 = Buffer length
 4280   LDR   R2,work_CallBack_BufferVal%
 4290   ADD   R2,R2,R12
 4300   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4310   MLA   R1,R10,R7,R2                              \ Buffer address
 4330   ADD   R2,R1,R10
 4350   MOV   R3,#0                           \ Buffer invalid
 4370   LDR   R8,[R12,#work_CallBackHandlers%]
 4380   CMP   R8,#0
 4390   MOVNE R6,#handlerType_CallBack%
 4400   BLNE  handler%
 4420   LDR   R8,[R12,#work_ProcessHandlers%]
 4430   CMP   R8,#0
 4440   MOVNE R6,#handlerType_Process%
 4450   BLNE  handler%
 4470   MOV  R8,PC
 4480   ORR  R9,R8,#Iflag%
 4490   TEQP R9,#0                  ; interrupts -> disabled
 4510   \ increment full count
 4520   \ Increment out buffer
 4540   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4550   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
 4560   ADD   R7,R7,#1
 4570   CMP   R7,R9
 4580   MOVGE R7,#0
 4590   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4610   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
 4620   ADD   R7,R7,#1
 4630   CMP   R7,R9
 4640   MOVGT R7,R9
 4650   STR   R7,[R12,#work_CallBack_BufferFullCount%]
 4670   TEQP R8,#0                  ; Interrupts reenabled
 4690   \ Check for full count = max
 4700   \ Loop round if not
 4720   CMP   R7,R9
 4730   BLT   doHandlerCallBack_Loop%
 4750   \ Otherwise we have filled all the buffers and can return
 4770   MOV  R8,PC
 4780   ORR  R9,R8,#Iflag%
 4790   TEQP R9,#0                 ; interrupts -> disabled
 4810   MOV   R5,#0
 4820   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed
 4840   TEQP R8,#0                  ; Interrupts reenabled
 4860   LDMIA R13!,{R0-R12,PC}
 4890\ ---------------
 4910.clearCallBackBuffer%  \ Initialise the call back buffer to 0
 4940     STMDB R13!,{R0-R12,R14}
 4960     MOV   R0,#0
 4970     MOV   R1,#0
 4980     MOV   R2,#0
 4990     MOV   R3,#0
 5010     LDR   R4,work_CallBack_BufferVal%
 5020     ADD   R4,R4,R12
 5030     ADD   R5,R4,#callBackBufferLen%
 5050.clearCallBackBuffer_Loop%
 5070     STMIA R4!,{R0-R3}
 5080     CMP   R4,R5
 5090     BLT   clearCallBackBuffer_Loop%
 5110     LDMIA R13!,{R0-R12,PC}
 5140\ ---------------
 5160.setHandlerType%  \ Set the corresponding bit for this handler's number & type
 5170                  \ On entry:
 5180                  \    R0 = Handler number
 5190                  \    R4 = Type
 5210    STMDB R13!,{R0-R4,R14}
 5230    MOV   R1,#1
 5240    MOV   R0,R1,LSL R0          \ As a bit
 5260    CMP   R4,#handlerType_Immediate%
 5270    LDREQ R1,[R12,#work_ImmediateHandlers%]
 5280    ORREQ R1,R1,R0
 5290    STREQ R1,[R12,#work_ImmediateHandlers%]
 5310    CMP   R4,#handlerType_CallBack%
 5320    LDREQ R1,[R12,#work_CallBackHandlers%]
 5330    ORREQ R1,R1,R0
 5340    STREQ R1,[R12,#work_CallBackHandlers%]
 5360    CMP   R4,#handlerType_Process%
 5370    LDREQ R1,[R12,#work_ProcessHandlers%]
 5380    ORREQ R1,R1,R0
 5390    STREQ R1,[R12,#work_ProcessHandlers%]
 5410    LDMIA R13!,{R0-R4,PC}
 5430\ ---------
 5450.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
 5460                    \ On entry:
 5470                    \    R0 = Handler number
 5480                    \    R4 = Type
 5500    STMDB R13!,{R0-R4,R14}
 5520    MOV   R1,#1
 5530    MOV   R0,R1,LSL R0          \ As a bit
 5550    CMP   R4,#handlerType_Immediate%
 5560    LDREQ R1,[R12,#work_ImmediateHandlers%]
 5570    BICEQ R1,R1,R0
 5580    STREQ R1,[R12,#work_ImmediateHandlers%]
 5600    CMP   R4,#handlerType_CallBack%
 5610    LDREQ R1,[R12,#work_CallBackHandlers%]
 5620    BICEQ R1,R1,R0
 5630    STREQ R1,[R12,#work_CallBackHandlers%]
 5650    CMP   R4,#handlerType_Process%
 5660    LDREQ R1,[R12,#work_ProcessHandlers%]
 5670    BICEQ R1,R1,R0
 5680    STREQ R1,[R12,#work_ProcessHandlers%]
 5700    LDMIA R13!,{R0-R4,PC}
 5730\ --------
 5740]
 5750ENDPROC
@


1.1.2.2
log
@New version: useful changes are bug fixed in removing callback
handlers (affects turning off the MIDI synth), and maintains number of
channels configured when callback buffers not supplied (stops volume
of RealAudio playback from fluctuating when MIDI Synth can't make its
mind up whether to created buffers or not.
Other changes adds CBAI and 8bit log output support (disabled) and
debugging code.
@
text
@a0 26
/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
   10
a37 2
  140
  150
d39 1
a39 1
  170LOCAL er$,debug%
d41 365
a405 794
  190debug%=FALSE
  200PRINT "PROCHandler"
  210CBAIDisableInt%=TRUE
  220[OPT I%
  230
  240
  250\-------------------------- Sound Handler Code ------------------------
  260
  270.stopSound% \ Make sure nothing is happening
  280
  290   STMDB R13!,{R0,R14}
  300
  310   MOV   R0,#1
  320   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine
  330
  340   \ Now wait until no sound is happening
  350
  360.stopSoundLoop%
  370
  380   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
  390   CMP   R0,#0
  400   BNE   stopSoundLoop%
  410
  420   LDMIA R13!,{R0,PC}
  430
  440\ -----------
  450
  460.startSound% \ Set handler going again
  470
  480  STMDB R13!,{R0,R14}
  490
  500  MOV   R0,#0
  510  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
  520
  530  \ Should check that there is a current driver and that it is active...
  540
  550  LDMIA R13!,{R0,PC}
  560
  570\ -------------------------------
  580
  590.getFillR0%
  600
  610  ADR   R0,fill%
  620  MOV   PC,R14
  630
  640\ ----
  650
  660.fill%   \ Main fill call for output driver
  670         \ Can be called by a 16 or 8 bit driver
  680         \ It needs to collect and mix data into the final buffer
  690         \ converting the data if necessary.
  700         \ On entry:
  710         \    R0 = parameter, this should be the SharedSound R12 value
  720         \    R1 = base of buffer
  730         \    R2 = end of buffer
  740         \    R3 = flags
  750         \    R4 = sample frequency or period
  760         \ Added:
  770         \    R5 = sample period
  780
  790   STMDB R13!,{R0-R12,R14}
  800
  810   LDR   R12,[R0]
  820
  830   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
  840   CMP   R0,#1
  850   BEQ   fillExit%
  860
  870   MOV   R0,#1
  880   STR   R0,[R12,#work_SoundActive%]    \ Flag active
  890
  900   \ If there is data in the buffer then this is shown in R3
  910
  920   MOV   R5,R4
  930   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
  940   CMP   R4,R5
  950
  960   BLNE  rateChange%                             \ Set a call back to change values
  970
  980   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now
  990
 1000   \ First call any immediate handlers
 1010
 1020   LDR   R6,[R12,#work_ImmediateHandlers%]
 1030   CMP   R6,#0
 1040   MOVNE R6,#handlerType_Immediate%
 1050   BLNE  handler%
 1060
 1070   \ Now get any callBack buffers and mix in
 1080
 1090   LDR   R6,[R12,#work_CallBackHandlers%]
 1100   CMP   R6,#0
 1110   BEQ   fillExit%
 1120
 1130   BL    addCallBackBuffer%
 1140
 1150   \ Finally initiate any callbacks required
 1160
 1170   BL    callBackHandlerProcess%
 1180
 1190
 1200.fillExit%
 1210
 1220   MOV   R0,#0
 1230   STR   R0,[R12,#work_SoundActive%]    \ Flag finished
 1240
 1250   LDMIA R13!,{R0-R12,PC}
 1260
 1270\ ------------------
 1280
 1290.rateChange%     \ Issue a call back to change the rate values
 1300
 1310   STMDB R13!,{R0,R1,R14}
 1320
 1330]
 1340IF doCallBack% THEN
 1350[OPT I%
 1360
 1370   ADR   R0,rateChangeCallBack%
 1380   LDR   R1,[R12,#work_privateWord%]
 1390
 1400   SWI   "OS_AddCallBack"
 1410
 1420   LDMIA R13!,{R0,R1,PC}^
 1430
 1440
 1450]
 1460ELSE
 1470[OPT I%
 1480
 1490   MOV   R0,R5   \ New frequency
 1500   BL    newRate%
 1510
 1520   LDMIA R13!,{R0,R1,PC}^
 1530
 1540]
 1550ENDIF
 1560[OPT I%
 1570
 1580
 1590\ ---------
 1600
 1610
 1620]
 1630IF doCallBack% THEN
 1640[OPT I%
 1650
 1660
 1670.rateChangeCallBack%
 1680
 1690   STMDB R13!,{R0-R12,R14}
 1700
 1710   LDR   R12,[R12]         \ Get workspace pointer
 1720
 1730   \     First get current sample frequency and sample period
 1740   \     This is provided by the SampleRate routine
 1750
 1760   MOV   R0,#0          \ Function code read
 1770
 1780   BL    newSampleRate%
 1790
 1800   LDMIA R13!,{R0-R12,PC}^
 1810
 1820]
 1830ENDIF
 1840[OPT I%
 1850
 1860
 1870\ ---------------- Handler stuff ---------------
 1880
 1890.handler% \ Dummy fill code
 1900          \ Used to pass on control to chain of handlers
 1910          \ The flags indicate which handlers to call
 1920          \ There are three types - immediate, callback and process
 1930          \ On entry:
 1940          \    R0 = parameter, this should be the SharedSound R12 value
 1950          \    R1 = base of buffer
 1960          \    R2 = end of buffer
 1970          \    R3 = flags
 1980          \    R4 = sample frequency
 1990          \    R5 = sample period
 2000          \    R6 = Handler type
 2010
 2020          \ Added by SharedSound before calling handlers
 2030
 2040          \    R6 = fraction step
 2050          \    R7 = LR Volume
 2060
 2070   STMDB R13!,{R0-R2,R4-R12,R14}
 2080
 2090   \ Now call each handler in turn, if they match the flag type
 2100
 2110   MOV   R11,R6 \ Handler type
 2120
 2130   ADD   R8,R12,#work_handlerTable%       \ Address of table
 2140   MOV   R9,#handlerMax%                  \ Handler count
 2150
 2160.handlerLoop%
 2170
 2180   LDR   R10,[R8,#handler_Type%]
 2190   CMP   R10,R11
 2200   BNE   handlerNext%
 2210
 2220   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
 2230   CMP   R10,#0
 2240   BEQ   handlerNext%
 2250
 2260   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2270
 2280   LDR   R0,[R8,#handler_Parameter%]
 2290   LDR   R6,[R8,#handler_Fraction%]
 2300   LDR   R7,[R8,#handler_VolumeScaled%]
 2310
 2320   MOV   R14,PC
 2330   MOV   PC,R10                            \ Jump to address
 2340\   MOVNV R0,R0
 2350
 2360.handlerReturn%
 2370
 2380   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2390
 2400.handlerNext%
 2410
 2420   ADD   R8,R8,#handlerTableLen%
 2430   SUBS  R9,R9,#1
 2440   BNE   handlerLoop%
 2450
 2460
 2470.handlerExit%
 2480
 2490   LDMIA R13!,{R0-R2,R4-R12,PC}
 2500
 2510\ ------------------- Call Back Handler routines
 2520
 2530.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%
 2540
 2550\ ----
 2560
 2570.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
 2580                     \ On entry:
 2590                     \    R1 = base of buffer
 2600                     \    R2 = end of buffer
 2610                     \    R3 = flags
 2620                     \    R4 = sample frequency
 2630                     \    R5 = sample period
 2640                     \ On exit:
 2650                     \    call back data mixed in if there is some
 2660
 2670   STMDB R13!,{R0-R12,R14}
 2680
 2690   SUB   R6,R2,R1
 2700   LDR   R7,[R12,#work_CallBack_BufferSize%]
 2710
 2720   CMP   R6,R7
 2730
 2740   \ If the buffer size has changed then need to make changes...
 2750
 2760   STR   R6,[R12,#work_CallBack_BufferSize%]
 2770
 2780   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
 2790   CMP   R5,#0
 2800   BGT   addCallBackBuffer_OK%
 2810
 2820   \ Need to flag an overrun
 2830
 2840   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
 2850   CMP   R5,#1
 2860
 2870   \ If there are no full buffers and the call back is active then we have overrun
 2880
 2890   LDREQ R7,[R12,#work_callBack_Count%]   \ If so then increment count and return
 2900   ADDEQ R7,R7,#1
 2910   STREQ R7,[R12,#work_callBack_Count%]
 2920
 2930   \ Need to do a volume shift on the buffer to effectivly mix an empty buffer
 2940   \ into the existing data
 2950   \ This avoids volume fluctuations
 2960
 2970   \ R1 = Start of SoundDMA buffer
 2980   \ R2 = End of SoundDMA buffer
 2990   \ R6 = Length
 3000
 3010.addCallBackBuffer_VolumeShiftLoop%
 3020
 3030   LDMIA R1,{R3-R6}
 3040
 3050   \ Shift volumes
 3060
 3070]
 3080work1%=11:work2%=12
 3090FOR getReg%=3 TO 6
 3100[OPT I%
 3110
 3120  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3130  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3140
 3150  MOV   work1%,work1%,ASR #1     \ DIV 2
 3160
 3170  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3180
 3190  TST   getReg%,#1<<15           \ Remove any low bit
 3200  EORNE getReg%,getReg%,#1<<15
 3210
 3220  ADD   getReg%,getReg%,work1%,LSR #16
 3230
 3240]
 3250NEXT
 3260[OPT I%
 3270
 3280   STMIA R1!,{R3-R6}
 3290
 3300   CMP   R1,R2
 3310   BLT   addCallBackBuffer_VolumeShiftLoop%
 3320
 3330   B     addCallBackBuffer_Exit%   \ No data available
 3340
 3350.addCallBackBuffer_OK%  \ There are buffers available so use one of these
 3360
 3370   \ R1 = Start of SoundDMA buffer
 3380   \ R2 = End of SoundDMA buffer
 3390   \ R6 = Length
 3400
 3410   LDR   R5,work_CallBack_BufferVal%
 3420   ADD   R5,R5,R12
 3430   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3440   MLA   R0,R6,R7,R5                                    \ Buffer position
 3450
 3460   \ R0 = Source buffer
 3470   \ R1 = DMA buffer
 3480   \ R2 = DMA buffer end
 3490   \ R3 = Fill flags
 3500
 3510   \ Copy across (mixing??)
 3520
 3530   TST  R3,#1
 3540   BNE  addCallBackBuffer_Mix%
 3550
 3560   \ No mixing
 3570
 3580.addCallBackBuffer_Loop%
 3590
 3600   LDMIA R0!,{R3-R6}
 3610   STMIA R1!,{R3-R6}
 3620
 3630   CMP   R1,R2
 3640   BLT   addCallBackBuffer_Loop%
 3650
 3660   B    addCallBackBuffer_Final%
 3670
 3680
 3690.addCallBackBuffer_Mix%
 3700
 3710   STMDB R13!,{R12}
 3720
 3730.addCallBackBufferMix_Loop%
 3740
 3750   LDMIA R0!,{R3-R6}
 3760   LDMIA R1,{R7-R10}
 3770
 3780]
 3790work1%=11:work2%=12
 3800FOR getReg%=3 TO 6
 3810mixReg%=getReg%+4
 3820[OPT I%
 3830
 3840  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3850  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3860
 3870  MOV   work1%,work1%,ASR #1     \ DIV 2
 3880
 3890  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3900
 3910  TST   getReg%,#1<<15           \ Remove any low bit
 3920  EORNE getReg%,getReg%,#1<<15
 3930
 3940  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
 3950  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg
 3960
 3970  MOV   work2%,work2%,ASR #1     \ DIV 2
 3980
 3990  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2
 4000
 4010  TST   mixReg%,#1<<15           \ Remove any low bit
 4020  EORNE mixReg%,mixReg%,#1<<15
 4030
 4040  \ Now mix
 4050
 4060  ADD   getReg%,getReg%,mixReg%
 4070  ADD   work1%,work1%,work2%
 4080
 4090  ADD   getReg%,getReg%,work1%,LSR #16
 4100
 4110
 4120
 4130]
 4140NEXT
 4150[OPT I%
 4160
 4170   STMIA R1!,{R3-R6}
 4180
 4190   CMP   R1,R2
 4200   BLT   addCallBackBufferMix_Loop%
 4210
 4220   LDMIA R13!,{R12}
 4230
 4240.addCallBackBuffer_Final%
 4250
 4260   \ Increment current SoundDMA buffer
 4270
 4280   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4290   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
 4300   ADD   R7,R7,#1
 4310   CMP   R7,R8
 4320   MOVGE R7,#0
 4330   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4340
 4350   \ Decrement full count
 4360
 4370   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
 4380   SUBS  R8,R8,#1
 4390   MOVLT R8,#0
 4400   STR   R8,[R12,#work_CallBack_BufferFullCount%]
 4410
 4420.addCallBackBuffer_Exit%
 4430
 4440   LDMIA R13!,{R0-R12,PC}
 4450
 4460\ -------------------------------
 4470
 4480.callBackHandlerProcess%
 4490          \ On entry:
 4500          \    R1 = base of buffer
 4510          \    R2 = end of buffer
 4520          \    R3 = flags
 4530          \    R4 = sample frequency
 4540          \    R5 = sample period
 4550
 4560   STMDB R13!,{R0-R12,R14}
 4570
 4580   SUB   R6,R2,R1
 4590   STR   R6,[R12,#work_CallBack_BufferSize%]
 4600   STR   R3,[R12,#work_CallBack_Flags%]
 4610   STR   R4,[R12,#work_CallBack_SampleFrequency%]
 4620   STR   R5,[R12,#work_CallBack_SamplePeriod%]
 4630
 4640   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4650   CMP   R5,#1
 4660   BEQ   callBackHandlerProcess_Exit%
 4670
 4680   MOV   R5,#1
 4690   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4700
 4710   \ Set up new call back
 4720
 4730]
 4740IF doCBAI% THEN
 4750[OPT I%
 4760
 4770   \ Either by CBAI
 4780
 4790   LDR   R0,[R12,#work_CBAIActive%]
 4800   CMP   R0,#1
 4810
 4820   ADREQ R0,CBAIRoutine%
 4830   STREQ R0,[R12,#work_PollWord%]
 4840   BEQ   callBackHandlerProcess_Exit%
 4850
 4860   \ Or by old style Call backs
 4870
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920   ADR   R0,doHandlerCallBack%
 4930   LDR   R1,[R12,#work_privateWord%]
 4940
 4950MOV   R9,PC
 4960ORR   R8,R9,#SVC_Mode%
 4970TEQP  R8,#0
 4980MOV   R0,R0
 4990STMFD R13!,{R14}
 5000
 5010   SWI   "XOS_AddCallBack"
 5020
 5030LDMFD R13!,{R14}
 5040TEQP  R9,#0
 5050MOV   R0,R0
 5060
 5070.callBackHandlerProcess_Exit%
 5080
 5090   LDMIA R13!,{R0-R12,PC}
 5100
 5110\ -------
 5120
 5130
 5140
 5150\ ---------------
 5160
 5170.doHandlerCallBack%  \ Called by call back system
 5180                     \ Needs to call the handler with the right parameters
 5190
 5200   STMDB R13!,{R0-R12,R14}
 5210
 5220   LDR   R12,[R12]
 5230
 5240]
 5250IF debug% THEN
 5260[OPT I%
 5270    SWI "XOS_WriteS"
 5280    EQUS "Handler call back"+CHR$(0):ALIGN
 5290    SWI  "XOS_NewLine"
 5300]
 5310ENDIF
 5320[OPT I%
 5330
 5340   \ From the start and end get the length and offset into the buffer
 5350   \ by the current OutBuffer value
 5360
 5370   LDR   R10,[R12,#work_CallBack_BufferSize%]
 5380   LDR   R0,[R12,#work_privateWord%]
 5390   LDR   R3,[R12,#work_CallBack_Flags%]
 5400   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
 5410   LDR   R5,[R12,#work_CallBack_SamplePeriod%]
 5420
 5430.doHandlerCallBack_Loop%
 5440
 5450   \ R10 = Buffer length
 5460
 5470   LDR   R2,work_CallBack_BufferVal%
 5480   ADD   R2,R2,R12
 5490   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5500   MLA   R1,R10,R7,R2                              \ Buffer address
 5510
 5520   ADD   R2,R1,R10
 5530
 5540   MOV   R3,#0                           \ Buffer invalid
 5550
 5560   LDR   R8,[R12,#work_CallBackHandlers%]
 5570   CMP   R8,#0
 5580   MOVNE R6,#handlerType_CallBack%
 5590   BLNE  handler%
 5600
 5610   LDR   R8,[R12,#work_ProcessHandlers%]
 5620   CMP   R8,#0
 5630   MOVNE R6,#handlerType_Process%
 5640   BLNE  handler%
 5650
 5660]:IF NOT CBAIDisableInt% THEN
 5670[OPT I%
 5680
 5690   MOV  R8,PC
 5700   ORR  R9,R8,#Iflag%
 5710   TEQP R9,#0                  ; interrupts -> disabled
 5720]
 5730ENDIF
 5740[OPT I%
 5750
 5760   \ increment full count
 5770   \ Increment out buffer
 5780
 5790   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5800   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
 5810   ADD   R7,R7,#1
 5820   CMP   R7,R9
 5830   MOVGE R7,#0
 5840   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5850
 5860   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
 5870   ADD   R7,R7,#1
 5880   CMP   R7,R9
 5890   MOVGT R7,R9
 5900   STR   R7,[R12,#work_CallBack_BufferFullCount%]
 5910
 5920]:IF NOT CBAIDisableInt% THEN
 5930[OPT I%
 5940
 5950   TEQP R8,#0                  ; Interrupts reenabled
 5960]
 5970ENDIF
 5980[OPT I%
 5990
 6000   \ Check for full count = max
 6010   \ Loop round if not
 6020
 6030   CMP   R7,R9
 6040   BLT   doHandlerCallBack_Loop%
 6050
 6060   \ Otherwise we have filled all the buffers and can return
 6070
 6080]:IF NOT CBAIDisableInt% THEN
 6090[OPT I%
 6100
 6110   MOV  R8,PC
 6120   ORR  R9,R8,#Iflag%
 6130   TEQP R9,#0                 ; interrupts -> disabled
 6140]
 6150ENDIF
 6160[OPT I%
 6170
 6180   MOV   R5,#0
 6190   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed
 6200
 6210]:IF NOT CBAIDisableInt% THEN
 6220[OPT I%
 6230
 6240   TEQP R8,#0                  ; Interrupts reenabled
 6250]
 6260ENDIF
 6270[OPT I%
 6280
 6290   LDMIA R13!,{R0-R12,PC}
 6300
 6310
 6320\ ---------------
 6330
 6340.clearCallBackBuffer%  \ Initialise the call back buffer to 0
 6350
 6360
 6370     STMDB R13!,{R0-R12,R14}
 6380
 6390     MOV   R0,#0
 6400     MOV   R1,#0
 6410     MOV   R2,#0
 6420     MOV   R3,#0
 6430
 6440     LDR   R4,work_CallBack_BufferVal%
 6450     ADD   R4,R4,R12
 6460     ADD   R5,R4,#callBackBufferLen%
 6470
 6480.clearCallBackBuffer_Loop%
 6490
 6500     STMIA R4!,{R0-R3}
 6510     CMP   R4,R5
 6520     BLT   clearCallBackBuffer_Loop%
 6530
 6540     LDMIA R13!,{R0-R12,PC}
 6550
 6560
 6570\ ---------------
 6580
 6590.setHandlerType%  \ Set the corresponding bit for this handler's number & type
 6600                  \ On entry:
 6610                  \    R0 = Handler number
 6620                  \    R4 = Type
 6630
 6640    STMDB R13!,{R0-R4,R14}
 6650
 6660    MOV   R1,#1
 6670    MOV   R0,R1,LSL R0          \ As a bit
 6680
 6690    CMP   R4,#handlerType_Immediate%
 6700    LDREQ R1,[R12,#work_ImmediateHandlers%]
 6710    ORREQ R1,R1,R0
 6720    STREQ R1,[R12,#work_ImmediateHandlers%]
 6730
 6740    CMP   R4,#handlerType_CallBack%
 6750    LDREQ R1,[R12,#work_CallBackHandlers%]
 6760    ORREQ R1,R1,R0
 6770    STREQ R1,[R12,#work_CallBackHandlers%]
 6780
 6790    CMP   R4,#handlerType_Process%
 6800    LDREQ R1,[R12,#work_ProcessHandlers%]
 6810    ORREQ R1,R1,R0
 6820    STREQ R1,[R12,#work_ProcessHandlers%]
 6830
 6840    LDMIA R13!,{R0-R4,PC}
 6850
 6860\ ---------
 6870
 6880.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
 6890                    \ On entry:
 6900                    \    R0 = Handler number
 6910                    \    R4 = Type
 6920
 6930    STMDB R13!,{R0-R4,R14}
 6940
 6950    MOV   R1,#1
 6960    MOV   R0,R1,LSL R0          \ As a bit
 6970
 6980    CMP   R4,#handlerType_Immediate%
 6990    LDREQ R1,[R12,#work_ImmediateHandlers%]
 7000    BICEQ R1,R1,R0
 7010    STREQ R1,[R12,#work_ImmediateHandlers%]
 7020
 7030    CMP   R4,#handlerType_CallBack%
 7040    LDREQ R1,[R12,#work_CallBackHandlers%]
 7050    BICEQ R1,R1,R0
 7060    STREQ R1,[R12,#work_CallBackHandlers%]
 7070
 7080    CMP   R4,#handlerType_Process%
 7090    LDREQ R1,[R12,#work_ProcessHandlers%]
 7100    BICEQ R1,R1,R0
 7110    STREQ R1,[R12,#work_ProcessHandlers%]
 7120
 7130    LDMIA R13!,{R0-R4,PC}
 7140
 7150
 7160\ -------------------- CBAI -----------------
 7170
 7180]
 7190IF doCBAI% THEN
 7200[OPT I%
 7210
 7220.InstallCBAI%  \ Install the CBAI stuff if module exists
 7230
 7240     STMDB R13!,{R0-R12,R14}
 7250
 7260     MOV   R0,#0
 7270     STR   R0,[R12,#work_PollWord%]
 7280
 7290     MOV   R0,#0
 7300     ADR   R1,CBAIString%
 7310     SWI   "XOS_SWINumberFromString"
 7320
 7330     MOVVC R0,#1
 7340     MOVVS R0,#0
 7350     STR   R0,[R12,#work_CBAIActive%]
 7360
 7370     ADDVC R0,R12,#work_PollWord%
 7380     MOVVC R1,#&100000       \ Scheduling class
 7390     LDRVC R2,[R12,#work_privateWord%]
 7400     SWIVC "XCBAI_RegisterPollWord"
 7410
 7420     LDMIA R13!,{R0-R12,PC}
 7430
 7440\ -----------------
 7450
 7460.CBAIString% EQUS "CBAI_RegisterPollWord"
 7470             EQUB 0
 7480             ALIGN
 7490
 7500\ -----------------
 7510
 7520.RemoveCBAI% \ De-register the CBAI pollword
 7530
 7540     STMDB R13!,{R0-R12,R14}
 7550
 7560     LDR   R0,[R12,#work_CBAIActive%]
 7570     CMP   R0,#1
 7580
 7590     ADDEQ R0,R12,#work_PollWord%
 7600     SWIEQ "CBAI_DeregisterPollWord"
 7610
 7620     MOV   R0,#0
 7630     STR   R0,[R12,#work_CBAIActive%]
 7640
 7650     LDMIA R13!,{R0-R12,PC}
 7660
 7670\ -----------------
 7680
 7690.CBAIRoutine%  \ Call back routine to call call back addresses
 7700
 7710     STMDB R13!,{R0-R12}
 7720
 7730\     MOV   R9,PC
 7740\     ORR   R8,R9,#SVC_Mode%
 7750\     TEQP  R8,#0
 7760\     MOV   R0,R0
 7770\     STMFD R13!,{R14}
 7780
 7790]:IF CBAIDisableInt% THEN
 7800[OPT I%
 7810
 7820   MOV  R8,PC
 7830   ORR  R9,R8,#Iflag%
 7840   TEQP R9,#0                  ; interrupts -> disabled
 7850]
 7860ENDIF
 7870[OPT I%
 7880
 7890     BL    doHandlerCallBack%
 7900
 7910]:IF CBAIDisableInt% THEN
 7920[OPT I%
 7930
 7940   TEQP R8,#0                  ; Interrupts reenabled
 7950]
 7960ENDIF
 7970[OPT I%
 7980
 7990\     LDMFD R13!,{R14}
 8000\     TEQP  R9,#0
 8010\     MOV   R0,R0
 8020
 8030     LDMIA R13!,{R0-R12,PC}
 8040
 8050\ -----------------
 8060]
 8070ENDIF
 8080[OPT I%
 8090
 8100]
 8110ENDPROC
 8120
@

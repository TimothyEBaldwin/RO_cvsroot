head	1.6;
access;
symbols
	SharedSnd-0_49:1.5
	bavison_SharedSnd-0_48:1.3
	SharedSnd-0_48:1.2
	Spin_merge:1.1.2.2
	afrost_NC2_Generic:1.1.2.2
	afrost_Funai01-33:1.1.2.2
	smiddle_0_43:1.1.2.1
	Spinner:1.1.0.2;
locks; strict;
comment	@# @;


1.6
date	2001.06.28.18.11.57;	author bavison;	state dead;
branches;
next	1.5;

1.5
date	2001.01.16.17.31.06;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.16.15.28.02;	author bavison;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.14.04.16;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.16.36.14;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.11.06.14.18.09;	author smiddle;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.11.06.14.18.09;	author smiddle;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.11.06.14.44.09;	author smiddle;	state Exp;
branches;
next	;


desc
@Files for new SharedSound build
@


1.6
log
@  Import of version 1.00 of SharedSound from WSS - this is a merge of
  RISC OS Ltd, ESP and Pace sources. I've added the Makefile, Mk* and
  VersionNum files.

Detail (courtesy of WSS):
  * Incorporates fixes made to 0.58c to fix the callbacks on sound
    rate changes.

  * Incorporates RISC OS Ltd changes to response to
    TaskManager_Acknowledgements service.

  * Includes 8 bit Log and PowerWave drivers.

  * Now built with Objasm, not BASIC assembler.

  * SharedSound_HandlerInfo SWI fixed to conform to spec. Also
    extended to accept r0 = 0 on entry, in which case r0 = number of
    first registered handler (or 0 for none) on exit; R1-R5 corrupted.

    Therefore the following code enumerates handlers:

    REM Get first handler number.
    SYS "SharedSound_HandlerInfo",0 TO next% ; flags%
    REM While no errors, and not finished
    WHILE (next% <> 0) AND ((flags% AND 1) = 0)
     SYS"SharedSound_HandlerInfo",next% TO next%,a%,b%,c%,d%,e%
    ENDWHILE

  * Sends Service_Sound (&54) with reason code 6 (SharedSound Starting)
    on (callback after) initialisation.

  * Sends Service_Sound (&54) with reason code 7 (SharedSound Dying)
    on finalisation.

  * Some small optimisations

  * Version bumped to 1.00 (to allow RISC OS Ltd space to make changes
    to their versions).

  * Table of helpful fill code routines now passed to handlers in R8.

  * SharedSound reinitialises correctly on lower layers reinitialising.

  * More care taken to remove outstanding callbacks on finalise.

  * Dual 26/32 bit version.

Admin:
  * Not tested by us.

  * 8-bit sound system code is known not to be ROM safe. However, it is
    currently switched out (see the doLog option in s.Gets).

  * This version *will not work* on a 32-bit system. There are at least two
    issues with it that I've spotted with a quick glance through the code -
    the lack of the module flags word, and an unconditional TEQP instruction.
    This version has been checked in nevertheless as a record of what WSS
    delivered to us.

Version 1.00. Tagged as 'SharedSnd-1_00'
@
text
@/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
DEFPROCSWIS
LOCAL er$
er$="SWIS"
PRINT "PROCSWIS"
[OPT I%


\ ------------------- SWI Code --------------

.swiControlWord%    \ Provides the address of a control word
                    \ used by Replay for 1 if n playback
                    \ On entry:
                    \    none
                    \ On exit:
                    \    R0 = control word address

    ADD   R0,R12,#work_ControlWord%
    MOV   PC,R14


\ -------------

]
IF debug1% THEN
[OPT I%

.swiTest% \ Test stuff

    STMDB R13!,{R14}


    LDMIA R13!,{PC}

\----------

.swiInfo% \ Get info

    STMDB R13!,{R14}

    LDR   R0,[R12,#work_SampleFrequency%]
    LDR   R1,[R12,#work_SamplePeriod%]

    LDMIA R13!,{PC}


\ ---------

]
ENDIF
[OPT I%

.swiInstallHandler%            \ Install a linear handler
                               \ On entry:
                               \  R0 = Handler address
                               \  R1 = parameter to pass
                               \  R2 = flags
                               \  R3 = name of handler
                               \  R4 = Type if bit 0 of flags = 1
                               \ On exit:
                               \  R0 = Handler number
    STMDB R13!,{R1-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Install handler"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    CMP   R0,#0                     \ Check handler address non-zero
    BEQ   swiInstallHandlerExitExit%

    ADD   R8,R12,#work_handlerTable% \ Get address of table
    MOV   R6,#handlerMax%            \ Maximum number available

    \ Look first for handler already exists

.swiInstallHandlerCheckSlot%

    LDR   R5,[R8,#handler_Address%]
    CMP   R5,R0                         \ Check address
    BNE   swiInstallHandlerCheckNext%   \ Not equal

    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
    CMP   R7,R1
    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry

.swiInstallHandlerCheckNext%

    ADD   R8,R8,#handlerTableLen%   \ Try next slot
    SUBS  R6,R6,#1
    BNE   swiInstallHandlerCheckSlot%

    \ OK so doesn't already exist
    \ Now look for an empty slot

    ADD   R8,R12,#work_handlerTable% \ Get address of table
    MOV   R6,#handlerMax%            \ Maximum number available

.swiInstallHandlerFindSlot%

    LDR   R5,[R8,#handler_Address%]
    CMP   R5,#0
    BEQ   swiInstallHandlerGo%       \ Free slot

    ADD   R8,R8,#handlerTableLen%   \ Try next slot
    SUBS  R6,R6,#1
    BNE   swiInstallHandlerFindSlot%

    \ No more slots available

    B     installMaxError%

.swiInstallHandlerGo%                \ OK So enter new handler
                                     \ R8 = slot pointer
    BL     stopSound%                \ Make sure nothing happening

    STR    R0,[R8,#handler_Address%]
    STR    R1,[R8,#handler_Parameter%]
    STR    R2,[R8,#handler_Flags%]

    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
    MOVEQ  R4,#handlerType_Default%
    STR    R4,[R8,#handler_Type%]     \ Type

    \ Set handler type variables

    RSB   R0,R6,#handlerMax%    \ Handler number

    BL    setHandlerType%

    \ Name

    ADD    R5,R8,#handler_Name%       \ Position of name
    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
    SUB    R2,R2,#1

.swiInstallHandlerNameLoop%

    LDRB   R7,[R3],#1
    STRB   R7,[R5],#1
    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
    MOVEQ  R7,#0
    STREQB R7,[R5]

    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached

    BNE    swiInstallHandlerNameLoop%  \ Carry on with name


    \ And initialise the other parameters in the table

    MOV    R0,#0                       \ Volume LR
    SUB    R0,R0,#1                    \ = &FFFF FFFF
    STR    R0,[R8,#handler_Volume%]

    MOV    R0,R8                       \ Set up scaled volume
    BL     scaleHandlerVolume%


    MOV    R0,#0
    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined

    MOV    R0,#1<<24
    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1


.swiInstallHandlerExit%

    BL    startSound%                   \ Set sound going again and provoke a driver check

    RSB   R0,R6,#handlerMax%            \ Return handler number
    ADD   R0,R0,#1                      \ In the range 1 - handlerMax


.swiInstallHandlerExitExit%
    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R1-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R1-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\

.installMaxError%
    LDMIA R13!,{R1-R12,R14}
    ADR   R0,installMaxMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.installMaxMesg%
    EQUD  &1E6
    EQUS  "Maximum number of handlers reached"
    EQUB  0
    ALIGN
\


\ -----------

.swiRemoveHandler%           \ Remove a particular handler
                             \ Slot number in R0, 1 - 10
    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Remove handler"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    BLT   swiHandlerNumError%

    CMP   R0,#handlerMax%            \ If > max then error
    BGE   swiHandlerNumError%

    MOV   R3,#handlerTableLen%
    MLA   R2,R3,R0,R1

    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    BEQ   swiHandlerExistError%       \ If not then exit

    \ R0 = Handler number (0-n)

    LDR   R4,[R2,#handler_Type%]
    BL    clearHandlerType%

    BL    stopSound%         \ Stop sound and wait for end of buffer fill

    MOV   R0,#0                       \ Remove involves simply setting Address to 0
    STR   R0,[R2,#handler_Address%]

    BL    startSound%


    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R0-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\
.swiHandlerNumError%
    LDMIA R13!,{R0-R12,R14}
.swiHandlerNumError1%
    ADR   R0,HandlerNumMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.HandlerNumMesg%
    EQUD  &1E6
    EQUS  "Handler number out of range"
    EQUB  0
    ALIGN
\

.swiHandlerExistError%
    LDMIA R13!,{R0-R12,R14}
.swiHandlerExistError1%
    ADR   R0,HandlerExistMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.HandlerExistMesg%
    EQUD  &1E6
    EQUS  "Handler not installed"
    EQUB  0
    ALIGN
\


\ -----------

.swiHandlerType% \ Set the type of the handler
                 \ On entry:
                 \    R0 = handler number
                 \    R1 = Type
                 \ On exit:

    STMDB R13!,{R6-R12,R14}

    MOV   R7,R1   \ Type into R7

    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R6-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R6-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R1

    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    LDMEQIA R13!,{R6-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \ R0 = Handler number (0-n)

    LDR   R4,[R6,#handler_Type%]
    BL    clearHandlerType%

    STR   R7,[R6,#handler_Type%]
    MOV   R4,R7
    BL    setHandlerType%

    LDMIA R13!,{R6-R12,PC}


\ -----------

.swiHandlerInfo%   \ R0 = handler number
                   \ On exit:
                   \ R0 = number of next available handler or 0 for none
                   \ R1 = flags
                   \ R2 = name
                   \ R3 = Sample frequency
                   \ R4 = Sample type
                   \ R5 = Volume

    STMDB R13!,{R6-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler info"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R6-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R6-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R1

    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    LDMEQIA R13!,{R6-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \ Get handler values

    LDR   R1,[R6,#handler_Flags%]
    ADD   R2,R6,#handler_Name%
    LDR   R3,[R6,#handler_SampleFrequency%]
    LDR   R4,[R6,#handler_Type%]
    LDR   R5,[R6,#handler_Volume%]

    \ Now find next handler

.swiHandlerInfoLoop%

    ADD   R0,R0,#1
    CMP   R0,#handlerMax%
    MOVEQ R0,#0
    BEQ   swiHandlerInfoExit%

    ADD   R6,R6,#handlerTableLen%    \ Try next one
    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
    CMP   R7,#0
    BEQ   swiHandlerInfoLoop%        \ No, then try next one

.swiHandlerInfoExit%

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R6-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R6-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiSampleRate%          \ Either set the current driver rate
                         \ or set the rate for a particular handler
                         \ On entry:
                         \ R0 = 0 for set driver rate
                         \    > 0 for handler number
                         \ R1 = sample frequency required
                         \      if 0 then use current rate
                         \ On exit:
                         \ R1 = actual sample rate
                         \ R2 = sample period
                         \ R3 = fractional step used get the required rate

    STMDB R13!,{R4-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Sample rate"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    CMP   R0,#0
    BNE   swiSampleRateDo%

    \     Set driver rate

    MOV   R0,R1              \ Move rate into R0
    BL    newSampleRate%     \ Sets new rate across all handlers
                             \ all registers preserved

    LDR   R0,[R12,#work_SampleFrequency%]

    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
                              \ return fraction in R0


    B     swiSampleRateExit%


.swiSampleRateDo%

    \ Find handler

    ADD   R2,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R4-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R4-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R2

    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R2,#0
    LDMEQIA R13!,{R4-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \   Get fraction

    CMP   R1,#0
    LDREQ R0,[R12,#work_SampleFrequency%]
    MOVNE R0,R1
    BL    sampleRateFraction%          \ Return fraction in R0

    \  Store values in handler table

    CMP   R1,#0
    LDREQ R1,[R12,#work_SampleFrequency%]
    STR   R1,[R6,#handler_SampleFrequency%]
    STR   R0,[R6,#handler_Fraction%]

.swiSampleRateExit%

    MOV   R3,R0                         \ Set up return values
    LDR   R1,[R12,#work_SampleFrequency%]
    LDR   R2,[R12,#work_SamplePeriod%]

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R4-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R4-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiHandlerVolume%           \ Set a handler's volume
                             \ On entry:
                             \ R0 = handler number
                             \ R1 = LR volume to set
                             \ On exit:
                             \ R1 = current volume

    STMDB R13!,{R0,R2-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler Volume"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    \ Find handler

    ADD   R4,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R0,R1,R3-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R0,R1,R3-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R0,R1,R3-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    STR   R1,[R6,#handler_Volume%]     \ Set volume
    MOV   R0,R6
    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr

    LDR   R1,[R6,#handler_Volume%]     \ Read result

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0,R2-R12,PC}         \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R0,R2-R12,PC}^          \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiHandlerSampleType%        \ Not in this version

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler sample type"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    LDMIA R13!,{R0-R12,PC}

\ -----------

.swiHandlerPause%             \ Not in this version

    STMDB R13!,{R0-R12,R14}
]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler pause"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    LDMIA R13!,{R0-R12,PC}

\ -----------

.swiInstallDriver%  \ Install or make active a driver
                    \ R0 = Pointer to driver table address
                    \      or 1 = Linear
                    \      or 2 = Log
                    \ R1 = parameter to pass driver in R12 when called
                    \ R2 = flags
                    \ R3 = Volume

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Install driver"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    \ If R0 = 1 or 2 then Linear or Log
    \ Otherwise regard this as a new driver

    CMP   R0,#2
    BGT   swiInstallDriverTable%

    CMP   R0,#1
    BNE   swiInstallDriverLog%

    BL    installLinearDriver%

    B     swiInstallDriverExit%

.swiInstallDriverLog%

]
IF doLog% THEN
[OPT I%

    CMP   R0,#2
    BLEQ  installLogDriver%

]
ENDIF
[OPT I%

    B     swiInstallDriverExit%


.swiInstallDriverTable%

    BL    installDriver%               \ Simply pass on to this routine


.swiInstallDriverExit%

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R0-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiDriverNumError%
    LDMIA R13!,{R0-R12,R14}
.swiDriverNumError1%
    ADR   R0,DriverNumMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.DriverNumMesg%
    EQUD  &1E6
    EQUS  "Driver number out of range"
    EQUB  0
    ALIGN
\

.swiDriverExistError%
    LDMIA R13!,{R0-R12,R14}
.swiDriverExistError1%
    ADR   R0,DriverExistMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.DriverExistMesg%
    EQUD  &1E6
    EQUS  "Driver not installed"
    EQUB  0
    ALIGN
\

.swiRemoveDriverError%
    LDMIA R13!,{R0-R12,R14}
    ADR   R0,swiRemoveDriverMesg%
    TEQ   PC,PC
    ORRNES PC,R14,#Overflow_Flag        \ 26-bit exit; NZC preserved, V set
    MSR   CPSR_f,#Overflow_Flag
    MOV   PC,R14                        \ 32-bit exit; NZC corrupted, V set
.swiRemoveDriverMesg%
    EQUD  &1E6
    EQUS  "Cannot remove the default driver"
    EQUB  0
    ALIGN
\

\ -----------

.swiRemoveDriver%      \ Remove a driver from the driver table
                       \ On entry:
                       \   R0 = driver number
                       \        cannot remove driver 1 as this is the default driver

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Remove Driver"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    \ First check parameter

    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    BLT   swiDriverNumError%

    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver

    CMP   R0,#driverMax%             \ >= max
    BGE   swiDriverNumError%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    BEQ   swiDriverExistError%         \ If not then exit

    \ is driver current

    SUB   R4,R6,R12
    LDR   R0,[R12,#work_currentDriver%]
    CMP   R4,R0
    BNE   swiRemoveDriverNext%

    \ if it is then release it first

    BL    releaseDriver%

    \ and make sure at least the default driver is installed instead

    MOV   R0,#1              \ Default driver
    BL    swiInstallDriver%

.swiRemoveDriverNext%

    \ Now remove the driver entry

    MOV   R0,#0
    STR   R0,[R6,#driver_Address%]

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R0-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiDriverInfo%   \ R0 = driver number
                  \ On exit:
                  \ R0 = number of next available driver or 0 for none
                  \ R1 = flags
                  \ R2 = name
                  \ R3 = Volume
                  \ R4 = Overrun count

    STMDB R13!,{R5-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver info"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R5-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R5-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R5-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    \ Get driver values

\    LDR   R1,[R6,#driver_Flags%]
    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
    ADD   R4,R4,R12
    CMP   R4,R6
    MOVEQ R1,#1        \ 1 if current
    MOVNE R1,#0        \ 0 if not

    ADD   R2,R6,#driver_Name%
    LDR   R3,[R6,#driver_Volume%]

    \ Now find next driver, if it exists

.swiDriverInfoLoop%

    ADD   R0,R0,#1
    CMP   R0,#driverMax%
    MOVEQ R0,#0
    BEQ   swiDriverInfoExit%

    ADD   R6,R6,#driverTableLen%    \ Try next one
    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
    CMP   R7,#0
    BEQ   swiDriverInfoLoop%        \ No, then try next one

.swiDriverInfoExit%

    LDR   R4,[R12,#work_callBack_Count%]

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R5-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R5-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ -----------

.swiDriverVolume%            \ Set the volume for a driver
                             \ On entry:
                             \    R0 = driver number
                             \    R1 = new volume
                             \ On exit:
                             \    R0 = current volume
    STMDB R13!,{R1-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver volume"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R1-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R1-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R1-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    MOV   R0,R1      \ Volume
    MOV   R1,R6      \ Table address
    BL    driverVolume%                 \ Set driver volume to R0

    \ Note that when the driver's volume changes, all handler scaled
    \ volumes may need to be reset

    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
    ADD   R0,R0,R12
    CMP   R0,R6

    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes

    LDR   R0,[R6,#driver_Volume%]       \ Return volume

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R1-R12,PC}            \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R1-R12,PC}^             \ 26-bit exit; NZC preserved, V clear

\ ----------------

.swiDriverMixer%             \ Set or read the mixer for a driver
                             \ On entry:
                             \    R0 = driver number
                             \    R1 = function   0 = read, 1 = set
                             \    R2 = mixer number
                             \    R3 = value if set
                             \ On exit:
                             \    R0 preserved
                             \    R1 = no of mixers
                             \    R2 = value
                             \    R3 = name

    STMDB R13!,{R0,R4-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver mixer"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R0,R4-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R0,R4-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R1-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    MOV   R0,R1         \ Function code
    MOV   R1,R2         \ Mixer number
    MOV   R2,R3         \ Value
    MOV   R3,R6         \ Driver table pointer

    BL    driverMixer%


    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0,R4-R12,PC}         \ 32-bit exit; NZC corrupted, V clear
    LDMIA R13!,{R0,R4-R12,PC}^          \ 26-bit exit; NZC preserved, V clear
]
ENDPROC
@


1.5
log
@Oops, I meant CMP, not TEQ. Retagged as 'SharedSnd-0_49'.
@
text
@@


1.4
log
@  See Detail.
Detail:
  * 32-bit compatible
  * srccommitted (and gets version number from VersionNum, even though it's
    written in BASIC)
  * added install rule and MkInstall file to install module in correct place
    within an ARMovie installation
Admin:
  Not tested.

Version 0.49. Tagged as 'SharedSnd-0_49'
@
text
@d205 1
a205 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d271 1
a271 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d418 1
a418 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d510 1
a510 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d564 1
a564 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d665 1
a665 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d780 1
a780 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d859 1
a859 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d920 1
a920 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
d981 1
a981 1
    TEQ   PC,PC                         \ also clears V in 32-bit mode
@


1.3
log
@Changed things so that the detokenised BASIC source (in the c directory) has
no line numbers present (LISTO 8). The detokenised source's raison d'etre is
to allow easier CVS diffs, but line numbers would defeat this purpose whenever
the change involves inserting more than a handful of line numbers.

No other changes - this version is committed and tagged purely as a reference
point for future updates. Tag used is 'bavison_SharedSnd-0_48'.
@
text
@d99 1
a99 1
    LDMEQIA R13!,{R1-R12,PC}^
d204 4
a207 1
    LDMIA R13!,{R1-R12,PC}^
d214 4
a217 1
    ORRS  PC,R14,#Overflow_Flag
d220 1
a220 1
    EQUS  "Maximum nunber of handlers reached"
d271 3
a273 1
    LDMIA R13!,{R0-R12,PC}^
d280 4
a283 1
    ORRS  PC,R14,#Overflow_Flag
d295 4
a298 1
    ORRS  PC,R14,#Overflow_Flag
d418 3
a420 1
    LDMIA R13!,{R6-R12,PC}^
d510 3
a512 1
    LDMIA R13!,{R4-R12,PC}^
d564 3
a566 1
    LDMIA R13!,{R0,R2-R12,PC}^
d586 1
a586 1
    LDMIA R13!,{R0-R12,PC}^
d605 1
a605 1
    LDMIA R13!,{R0-R12,PC}^
d665 3
a667 1
    LDMIA R13!,{R0-R12,PC}^
d675 4
a678 1
    ORRS  PC,R14,#Overflow_Flag
d690 4
a693 1
    ORRS  PC,R14,#Overflow_Flag
d704 4
a707 1
    ORRS  PC,R14,#Overflow_Flag
d780 3
a782 1
    LDMIA R13!,{R0-R12,PC}^
d859 3
a861 1
    LDMIA R13!,{R5-R12,PC}^
d920 3
a922 1
    LDMIA R13!,{R1-R12,PC}^
d981 3
a983 1
    LDMIA R13!,{R0,R4-R12,PC}^
@


1.2
log
@Spinner branch merged
@
text
@d26 921
a946 921
   10DEFPROCSWIS
   20LOCAL er$
   30er$="SWIS"
   40PRINT "PROCSWIS"
   50[OPT I%
   60
   70
   80\ ------------------- SWI Code --------------
   90
  100.swiControlWord%    \ Provides the address of a control word
  110                    \ used by Replay for 1 if n playback
  120                    \ On entry:
  130                    \    none
  140                    \ On exit:
  150                    \    R0 = control word address
  160
  170    ADD   R0,R12,#work_ControlWord%
  180    MOV   PC,R14
  190
  200
  210\ -------------
  220
  230]
  240IF debug1% THEN
  250[OPT I%
  260
  270.swiTest% \ Test stuff
  280
  290    STMDB R13!,{R14}
  300
  310
  320    LDMIA R13!,{PC}
  330
  340\----------
  350
  360.swiInfo% \ Get info
  370
  380    STMDB R13!,{R14}
  390
  400    LDR   R0,[R12,#work_SampleFrequency%]
  410    LDR   R1,[R12,#work_SamplePeriod%]
  420
  430    LDMIA R13!,{PC}
  440
  450
  460\ ---------
  470
  480]
  490ENDIF
  500[OPT I%
  510
  520.swiInstallHandler%            \ Install a linear handler
  530                               \ On entry:
  540                               \  R0 = Handler address
  550                               \  R1 = parameter to pass
  560                               \  R2 = flags
  570                               \  R3 = name of handler
  580                               \  R4 = Type if bit 0 of flags = 1
  590                               \ On exit:
  600                               \  R0 = Handler number
  610    STMDB R13!,{R1-R12,R14}
  620
  630]
  640IF debug% THEN
  650[OPT I%
  660    SWI "XOS_WriteS"
  670    EQUS "Install handler"+CHR$(0):ALIGN
  680    SWI "XOS_NewLine"
  690]
  700ENDIF
  710[OPT I%
  720
  730    CMP   R0,#0                     \ Check handler address non-zero
  740    LDMEQIA R13!,{R1-R12,PC}^
  750
  760    ADD   R8,R12,#work_handlerTable% \ Get address of table
  770    MOV   R6,#handlerMax%            \ Maximum number available
  780
  790    \ Look first for handler already exists
  800
  810.swiInstallHandlerCheckSlot%
  820
  830    LDR   R5,[R8,#handler_Address%]
  840    CMP   R5,R0                         \ Check address
  850    BNE   swiInstallHandlerCheckNext%   \ Not equal
  860
  870    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
  880    CMP   R7,R1
  890    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry
  900
  910.swiInstallHandlerCheckNext%
  920
  930    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  940    SUBS  R6,R6,#1
  950    BNE   swiInstallHandlerCheckSlot%
  960
  970    \ OK so doesn't already exist
  980    \ Now look for an empty slot
  990
 1000    ADD   R8,R12,#work_handlerTable% \ Get address of table
 1010    MOV   R6,#handlerMax%            \ Maximum number available
 1020
 1030.swiInstallHandlerFindSlot%
 1040
 1050    LDR   R5,[R8,#handler_Address%]
 1060    CMP   R5,#0
 1070    BEQ   swiInstallHandlerGo%       \ Free slot
 1080
 1090    ADD   R8,R8,#handlerTableLen%   \ Try next slot
 1100    SUBS  R6,R6,#1
 1110    BNE   swiInstallHandlerFindSlot%
 1120
 1130    \ No more slots available
 1140
 1150    B     installMaxError%
 1160
 1170.swiInstallHandlerGo%                \ OK So enter new handler
 1180                                     \ R8 = slot pointer
 1190    BL     stopSound%                \ Make sure nothing happening
 1200
 1210    STR    R0,[R8,#handler_Address%]
 1220    STR    R1,[R8,#handler_Parameter%]
 1230    STR    R2,[R8,#handler_Flags%]
 1240
 1250    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
 1260    MOVEQ  R4,#handlerType_Default%
 1270    STR    R4,[R8,#handler_Type%]     \ Type
 1280
 1290    \ Set handler type variables
 1300
 1310    RSB   R0,R6,#handlerMax%    \ Handler number
 1320
 1330    BL    setHandlerType%
 1340
 1350    \ Name
 1360
 1370    ADD    R5,R8,#handler_Name%       \ Position of name
 1380    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
 1390    SUB    R2,R2,#1
 1400
 1410.swiInstallHandlerNameLoop%
 1420
 1430    LDRB   R7,[R3],#1
 1440    STRB   R7,[R5],#1
 1450    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
 1460    MOVEQ  R7,#0
 1470    STREQB R7,[R5]
 1480
 1490    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached
 1500
 1510    BNE    swiInstallHandlerNameLoop%  \ Carry on with name
 1520
 1530
 1540    \ And initialise the other parameters in the table
 1550
 1560    MOV    R0,#0                       \ Volume LR
 1570    SUB    R0,R0,#1                    \ = &FFFF FFFF
 1580    STR    R0,[R8,#handler_Volume%]
 1590
 1600    MOV    R0,R8                       \ Set up scaled volume
 1610    BL     scaleHandlerVolume%
 1620
 1630
 1640    MOV    R0,#0
 1650    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined
 1660
 1670    MOV    R0,#1<<24
 1680    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1
 1690
 1700
 1710.swiInstallHandlerExit%
 1720
 1730    BL    startSound%                   \ Set sound going again and provoke a driver check
 1740
 1750    RSB   R0,R6,#handlerMax%            \ Return handler number
 1760    ADD   R0,R0,#1                      \ In the range 1 - handlerMax
 1770
 1780
 1790    LDMIA R13!,{R1-R12,PC}^
 1800
 1810\
 1820
 1830.installMaxError%
 1840    LDMIA R13!,{R1-R12,R14}
 1850    ADR   R0,installMaxMesg%
 1860    ORRS  PC,R14,#Overflow_Flag
 1870.installMaxMesg%
 1880    EQUD  &1E6
 1890    EQUS  "Maximum nunber of handlers reached"
 1900    EQUB  0
 1910    ALIGN
 1920\
 1930
 1940
 1950\ -----------
 1960
 1970.swiRemoveHandler%           \ Remove a particular handler
 1980                             \ Slot number in R0, 1 - 10
 1990    STMDB R13!,{R0-R12,R14}
 2000
 2010]
 2020IF debug% THEN
 2030[OPT I%
 2040    SWI "XOS_WriteS"
 2050    EQUS "Remove handler"+CHR$(0):ALIGN
 2060    SWI "XOS_NewLine"
 2070]
 2080ENDIF
 2090[OPT I%
 2100
 2110    ADD   R1,R12,#work_handlerTable%
 2120    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2130
 2140    CMP   R0,#0                      \ If <0 then error
 2150    BLT   swiHandlerNumError%
 2160
 2170    CMP   R0,#handlerMax%            \ If > max then error
 2180    BGE   swiHandlerNumError%
 2190
 2200    MOV   R3,#handlerTableLen%
 2210    MLA   R2,R3,R0,R1
 2220
 2230    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
 2240    CMP   R1,#0
 2250    BEQ   swiHandlerExistError%       \ If not then exit
 2260
 2270    \ R0 = Handler number (0-n)
 2280
 2290    LDR   R4,[R2,#handler_Type%]
 2300    BL    clearHandlerType%
 2310
 2320    BL    stopSound%         \ Stop sound and wait for end of buffer fill
 2330
 2340    MOV   R0,#0                       \ Remove involves simply setting Address to 0
 2350    STR   R0,[R2,#handler_Address%]
 2360
 2370    BL    startSound%
 2380
 2390
 2400    LDMIA R13!,{R0-R12,PC}^
 2410
 2420\
 2430.swiHandlerNumError%
 2440    LDMIA R13!,{R0-R12,R14}
 2450.swiHandlerNumError1%
 2460    ADR   R0,HandlerNumMesg%
 2470    ORRS  PC,R14,#Overflow_Flag
 2480.HandlerNumMesg%
 2490    EQUD  &1E6
 2500    EQUS  "Handler number out of range"
 2510    EQUB  0
 2520    ALIGN
 2530\
 2540
 2550.swiHandlerExistError%
 2560    LDMIA R13!,{R0-R12,R14}
 2570.swiHandlerExistError1%
 2580    ADR   R0,HandlerExistMesg%
 2590    ORRS  PC,R14,#Overflow_Flag
 2600.HandlerExistMesg%
 2610    EQUD  &1E6
 2620    EQUS  "Handler not installed"
 2630    EQUB  0
 2640    ALIGN
 2650\
 2660
 2670
 2680\ -----------
 2690
 2700.swiHandlerType% \ Set the type of the handler
 2710                 \ On entry:
 2720                 \    R0 = handler number
 2730                 \    R1 = Type
 2740                 \ On exit:
 2750
 2760    STMDB R13!,{R6-R12,R14}
 2770
 2780    MOV   R7,R1   \ Type into R7
 2790
 2800    ADD   R1,R12,#work_handlerTable%
 2810    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2820
 2830    CMP   R0,#0                      \ If <0 then error
 2840    LDMLTIA R13!,{R6-R12,R14}
 2850    BLT   swiHandlerNumError1%
 2860
 2870    CMP   R0,#handlerMax%            \ If > max then error
 2880    LDMGEIA R13!,{R6-R12,R14}
 2890    BGE   swiHandlerNumError1%
 2900
 2910    MOV   R3,#handlerTableLen%
 2920    MLA   R6,R3,R0,R1
 2930
 2940    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2950    CMP   R1,#0
 2960    LDMEQIA R13!,{R6-R12,R14}
 2970    BEQ   swiHandlerExistError1%       \ If not then exit
 2980
 2990    \ R0 = Handler number (0-n)
 3000
 3010    LDR   R4,[R6,#handler_Type%]
 3020    BL    clearHandlerType%
 3030
 3040    STR   R7,[R6,#handler_Type%]
 3050    MOV   R4,R7
 3060    BL    setHandlerType%
 3070
 3080    LDMIA R13!,{R6-R12,PC}
 3090
 3100
 3110\ -----------
 3120
 3130.swiHandlerInfo%   \ R0 = handler number
 3140                   \ On exit:
 3150                   \ R0 = number of next available handler or 0 for none
 3160                   \ R1 = flags
 3170                   \ R2 = name
 3180                   \ R3 = Sample frequency
 3190                   \ R4 = Sample type
 3200                   \ R5 = Volume
 3210
 3220    STMDB R13!,{R6-R12,R14}
 3230
 3240]
 3250IF debug% THEN
 3260[OPT I%
 3270    SWI "XOS_WriteS"
 3280    EQUS "Handler info"+CHR$(0):ALIGN
 3290    SWI "XOS_NewLine"
 3300]
 3310ENDIF
 3320[OPT I%
 3330
 3340
 3350
 3360    ADD   R1,R12,#work_handlerTable%
 3370    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 3380
 3390    CMP   R0,#0                      \ If <0 then error
 3400    LDMLTIA R13!,{R6-R12,R14}
 3410    BLT   swiHandlerNumError1%
 3420
 3430    CMP   R0,#handlerMax%            \ If > max then error
 3440    LDMGEIA R13!,{R6-R12,R14}
 3450    BGE   swiHandlerNumError1%
 3460
 3470    MOV   R3,#handlerTableLen%
 3480    MLA   R6,R3,R0,R1
 3490
 3500    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 3510    CMP   R1,#0
 3520    LDMEQIA R13!,{R6-R12,R14}
 3530    BEQ   swiHandlerExistError1%       \ If not then exit
 3540
 3550    \ Get handler values
 3560
 3570    LDR   R1,[R6,#handler_Flags%]
 3580    ADD   R2,R6,#handler_Name%
 3590    LDR   R3,[R6,#handler_SampleFrequency%]
 3600    LDR   R4,[R6,#handler_Type%]
 3610    LDR   R5,[R6,#handler_Volume%]
 3620
 3630    \ Now find next handler
 3640
 3650.swiHandlerInfoLoop%
 3660
 3670    ADD   R0,R0,#1
 3680    CMP   R0,#handlerMax%
 3690    MOVEQ R0,#0
 3700    BEQ   swiHandlerInfoExit%
 3710
 3720    ADD   R6,R6,#handlerTableLen%    \ Try next one
 3730    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
 3740    CMP   R7,#0
 3750    BEQ   swiHandlerInfoLoop%        \ No, then try next one
 3760
 3770.swiHandlerInfoExit%
 3780
 3790    LDMIA R13!,{R6-R12,PC}^
 3800
 3810\ -----------
 3820
 3830.swiSampleRate%          \ Either set the current driver rate
 3840                         \ or set the rate for a particular handler
 3850                         \ On entry:
 3860                         \ R0 = 0 for set driver rate
 3870                         \    > 0 for handler number
 3880                         \ R1 = sample frequency required
 3890                         \      if 0 then use current rate
 3900                         \ On exit:
 3910                         \ R1 = actual sample rate
 3920                         \ R2 = sample period
 3930                         \ R3 = fractional step used get the required rate
 3940
 3950    STMDB R13!,{R4-R12,R14}
 3960
 3970]
 3980IF debug% THEN
 3990[OPT I%
 4000    SWI "XOS_WriteS"
 4010    EQUS "Sample rate"+CHR$(0):ALIGN
 4020    SWI "XOS_NewLine"
 4030]
 4040ENDIF
 4050[OPT I%
 4060
 4070
 4080    CMP   R0,#0
 4090    BNE   swiSampleRateDo%
 4100
 4110    \     Set driver rate
 4120
 4130    MOV   R0,R1              \ Move rate into R0
 4140    BL    newSampleRate%     \ Sets new rate across all handlers
 4150                             \ all registers preserved
 4160
 4170    LDR   R0,[R12,#work_SampleFrequency%]
 4180
 4190    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
 4200                              \ return fraction in R0
 4210
 4220
 4230    B     swiSampleRateExit%
 4240
 4250
 4260.swiSampleRateDo%
 4270
 4280    \ Find handler
 4290
 4300    ADD   R2,R12,#work_handlerTable%
 4310    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4320
 4330    CMP   R0,#0                      \ If <0 then error
 4340    LDMLTIA R13!,{R4-R12,R14}
 4350    BLT   swiHandlerNumError1%
 4360
 4370    CMP   R0,#handlerMax%            \ If > max then error
 4380    LDMGEIA R13!,{R4-R12,R14}
 4390    BGE   swiHandlerNumError1%
 4400
 4410    MOV   R3,#handlerTableLen%
 4420    MLA   R6,R3,R0,R2
 4430
 4440    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
 4450    CMP   R2,#0
 4460    LDMEQIA R13!,{R4-R12,R14}
 4470    BEQ   swiHandlerExistError1%       \ If not then exit
 4480
 4490    \   Get fraction
 4500
 4510    CMP   R1,#0
 4520    LDREQ R0,[R12,#work_SampleFrequency%]
 4530    MOVNE R0,R1
 4540    BL    sampleRateFraction%          \ Return fraction in R0
 4550
 4560    \  Store values in handler table
 4570
 4580    CMP   R1,#0
 4590    LDREQ R1,[R12,#work_SampleFrequency%]
 4600    STR   R1,[R6,#handler_SampleFrequency%]
 4610    STR   R0,[R6,#handler_Fraction%]
 4620
 4630.swiSampleRateExit%
 4640
 4650    MOV   R3,R0                         \ Set up return values
 4660    LDR   R1,[R12,#work_SampleFrequency%]
 4670    LDR   R2,[R12,#work_SamplePeriod%]
 4680
 4690    LDMIA R13!,{R4-R12,PC}^
 4700
 4710\ -----------
 4720
 4730.swiHandlerVolume%           \ Set a handler's volume
 4740                             \ On entry:
 4750                             \ R0 = handler number
 4760                             \ R1 = LR volume to set
 4770                             \ On exit:
 4780                             \ R1 = current volume
 4790
 4800    STMDB R13!,{R0,R2-R12,R14}
 4810
 4820]
 4830IF debug% THEN
 4840[OPT I%
 4850    SWI "XOS_WriteS"
 4860    EQUS "Handler Volume"+CHR$(0):ALIGN
 4870    SWI "XOS_NewLine"
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920
 4930
 4940    \ Find handler
 4950
 4960    ADD   R4,R12,#work_handlerTable%
 4970    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4980
 4990    CMP   R0,#0                      \ If <0 then error
 5000    LDMLTIA R13!,{R0,R1,R3-R12,R14}
 5010    BLT   swiHandlerNumError1%
 5020
 5030    CMP   R0,#handlerMax%            \ If > max then error
 5040    LDMGEIA R13!,{R0,R1,R3-R12,R14}
 5050    BGE   swiHandlerNumError1%
 5060
 5070    MOV   R3,#handlerTableLen%
 5080    MLA   R6,R3,R0,R4
 5090
 5100    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
 5110    CMP   R4,#0
 5120    LDMEQIA R13!,{R0,R1,R3-R12,R14}
 5130    BEQ   swiHandlerExistError1%       \ If not then exit
 5140
 5150    STR   R1,[R6,#handler_Volume%]     \ Set volume
 5160    MOV   R0,R6
 5170    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr
 5180
 5190    LDR   R1,[R6,#handler_Volume%]     \ Read result
 5200
 5210    LDMIA R13!,{R0,R2-R12,PC}^
 5220
 5230\ -----------
 5240
 5250.swiHandlerSampleType%        \ Not in this version
 5260
 5270    STMDB R13!,{R0-R12,R14}
 5280
 5290]
 5300IF debug% THEN
 5310[OPT I%
 5320    SWI "XOS_WriteS"
 5330    EQUS "Handler sample type"+CHR$(0):ALIGN
 5340    SWI "XOS_NewLine"
 5350]
 5360ENDIF
 5370[OPT I%
 5380
 5390
 5400
 5410    LDMIA R13!,{R0-R12,PC}^
 5420
 5430\ -----------
 5440
 5450.swiHandlerPause%             \ Not in this version
 5460
 5470    STMDB R13!,{R0-R12,R14}
 5480]
 5490IF debug% THEN
 5500[OPT I%
 5510    SWI "XOS_WriteS"
 5520    EQUS "Handler pause"+CHR$(0):ALIGN
 5530    SWI "XOS_NewLine"
 5540]
 5550ENDIF
 5560[OPT I%
 5570
 5580
 5590
 5600    LDMIA R13!,{R0-R12,PC}^
 5610
 5620\ -----------
 5630
 5640.swiInstallDriver%  \ Install or make active a driver
 5650                    \ R0 = Pointer to driver table address
 5660                    \      or 1 = Linear
 5670                    \      or 2 = Log
 5680                    \ R1 = parameter to pass driver in R12 when called
 5690                    \ R2 = flags
 5700                    \ R3 = Volume
 5710
 5720    STMDB R13!,{R0-R12,R14}
 5730
 5740]
 5750IF debug% THEN
 5760[OPT I%
 5770    SWI "XOS_WriteS"
 5780    EQUS "Install driver"+CHR$(0):ALIGN
 5790    SWI "XOS_NewLine"
 5800]
 5810ENDIF
 5820[OPT I%
 5830
 5840    \ If R0 = 1 or 2 then Linear or Log
 5850    \ Otherwise regard this as a new driver
 5860
 5870    CMP   R0,#2
 5880    BGT   swiInstallDriverTable%
 5890
 5900    CMP   R0,#1
 5910    BNE   swiInstallDriverLog%
 5920
 5930    BL    installLinearDriver%
 5940
 5950    B     swiInstallDriverExit%
 5960
 5970.swiInstallDriverLog%
 5980
 5990]
 6000IF doLog% THEN
 6010[OPT I%
 6020
 6030    CMP   R0,#2
 6040    BLEQ  installLogDriver%
 6050
 6060]
 6070ENDIF
 6080[OPT I%
 6090
 6100    B     swiInstallDriverExit%
 6110
 6120
 6130.swiInstallDriverTable%
 6140
 6150    BL    installDriver%               \ Simply pass on to this routine
 6160
 6170
 6180.swiInstallDriverExit%
 6190
 6200    LDMIA R13!,{R0-R12,PC}^
 6210
 6220\ -----------
 6230
 6240.swiDriverNumError%
 6250    LDMIA R13!,{R0-R12,R14}
 6260.swiDriverNumError1%
 6270    ADR   R0,DriverNumMesg%
 6280    ORRS  PC,R14,#Overflow_Flag
 6290.DriverNumMesg%
 6300    EQUD  &1E6
 6310    EQUS  "Driver number out of range"
 6320    EQUB  0
 6330    ALIGN
 6340\
 6350
 6360.swiDriverExistError%
 6370    LDMIA R13!,{R0-R12,R14}
 6380.swiDriverExistError1%
 6390    ADR   R0,DriverExistMesg%
 6400    ORRS  PC,R14,#Overflow_Flag
 6410.DriverExistMesg%
 6420    EQUD  &1E6
 6430    EQUS  "Driver not installed"
 6440    EQUB  0
 6450    ALIGN
 6460\
 6470
 6480.swiRemoveDriverError%
 6490    LDMIA R13!,{R0-R12,R14}
 6500    ADR   R0,swiRemoveDriverMesg%
 6510    ORRS  PC,R14,#Overflow_Flag
 6520.swiRemoveDriverMesg%
 6530    EQUD  &1E6
 6540    EQUS  "Cannot remove the default driver"
 6550    EQUB  0
 6560    ALIGN
 6570\
 6580
 6590\ -----------
 6600
 6610.swiRemoveDriver%      \ Remove a driver from the driver table
 6620                       \ On entry:
 6630                       \   R0 = driver number
 6640                       \        cannot remove driver 1 as this is the default driver
 6650
 6660    STMDB R13!,{R0-R12,R14}
 6670
 6680]
 6690IF debug% THEN
 6700[OPT I%
 6710    SWI "XOS_WriteS"
 6720    EQUS "Remove Driver"+CHR$(0):ALIGN
 6730    SWI "XOS_NewLine"
 6740]
 6750ENDIF
 6760[OPT I%
 6770
 6780
 6790    \ First check parameter
 6800
 6810    ADD   R4,R12,#work_driverTable%
 6820    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6830
 6840    CMP   R0,#0                      \ < 0
 6850    BLT   swiDriverNumError%
 6860
 6870    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver
 6880
 6890    CMP   R0,#driverMax%             \ >= max
 6900    BGE   swiDriverNumError%
 6910
 6920    \ Does the driver exist?
 6930
 6940    MOV   R3,#driverTableLen%
 6950    MLA   R6,R3,R0,R4
 6960
 6970    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6980    CMP   R4,#0
 6990    BEQ   swiDriverExistError%         \ If not then exit
 7000
 7010    \ is driver current
 7020
 7030    SUB   R4,R6,R12
 7040    LDR   R0,[R12,#work_currentDriver%]
 7050    CMP   R4,R0
 7060    BNE   swiRemoveDriverNext%
 7070
 7080    \ if it is then release it first
 7090
 7100    BL    releaseDriver%
 7110
 7120    \ and make sure at least the default driver is installed instead
 7130
 7140    MOV   R0,#1              \ Default driver
 7150    BL    swiInstallDriver%
 7160
 7170.swiRemoveDriverNext%
 7180
 7190    \ Now remove the driver entry
 7200
 7210    MOV   R0,#0
 7220    STR   R0,[R6,#driver_Address%]
 7230
 7240    LDMIA R13!,{R0-R12,PC}^
 7250
 7260\ -----------
 7270
 7280.swiDriverInfo%   \ R0 = driver number
 7290                  \ On exit:
 7300                  \ R0 = number of next available driver or 0 for none
 7310                  \ R1 = flags
 7320                  \ R2 = name
 7330                  \ R3 = Volume
 7340                  \ R4 = Overrun count
 7350
 7360    STMDB R13!,{R5-R12,R14}
 7370
 7380]
 7390IF debug% THEN
 7400[OPT I%
 7410    SWI "XOS_WriteS"
 7420    EQUS "Driver info"+CHR$(0):ALIGN
 7430    SWI "XOS_NewLine"
 7440]
 7450ENDIF
 7460[OPT I%
 7470
 7480
 7490
 7500    ADD   R4,R12,#work_driverTable%
 7510    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 7520
 7530    CMP   R0,#0                      \ < 0
 7540    LDMLTIA R13!,{R5-R12,R14}
 7550    BLT   swiDriverNumError1%
 7560
 7570    CMP   R0,#driverMax%             \ >= max
 7580    LDMGEIA R13!,{R5-R12,R14}
 7590    BGE   swiDriverNumError1%
 7600
 7610    \ Does the driver exist?
 7620
 7630    MOV   R3,#driverTableLen%
 7640    MLA   R6,R3,R0,R4
 7650
 7660    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 7670    CMP   R4,#0
 7680    LDMEQIA R13!,{R5-R12,R14}
 7690    BEQ   swiDriverExistError1%         \ If not then exit
 7700
 7710    \ Get driver values
 7720
 7730\    LDR   R1,[R6,#driver_Flags%]
 7740    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
 7750    ADD   R4,R4,R12
 7760    CMP   R4,R6
 7770    MOVEQ R1,#1        \ 1 if current
 7780    MOVNE R1,#0        \ 0 if not
 7790
 7800    ADD   R2,R6,#driver_Name%
 7810    LDR   R3,[R6,#driver_Volume%]
 7820
 7830    \ Now find next driver, if it exists
 7840
 7850.swiDriverInfoLoop%
 7860
 7870    ADD   R0,R0,#1
 7880    CMP   R0,#driverMax%
 7890    MOVEQ R0,#0
 7900    BEQ   swiDriverInfoExit%
 7910
 7920    ADD   R6,R6,#driverTableLen%    \ Try next one
 7930    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
 7940    CMP   R7,#0
 7950    BEQ   swiDriverInfoLoop%        \ No, then try next one
 7960
 7970.swiDriverInfoExit%
 7980
 7990    LDR   R4,[R12,#work_callBack_Count%]
 8000
 8010    LDMIA R13!,{R5-R12,PC}^
 8020
 8030\ -----------
 8040
 8050.swiDriverVolume%            \ Set the volume for a driver
 8060                             \ On entry:
 8070                             \    R0 = driver number
 8080                             \    R1 = new volume
 8090                             \ On exit:
 8100                             \    R0 = current volume
 8110    STMDB R13!,{R1-R12,R14}
 8120
 8130]
 8140IF debug% THEN
 8150[OPT I%
 8160    SWI "XOS_WriteS"
 8170    EQUS "Driver volume"+CHR$(0):ALIGN
 8180    SWI "XOS_NewLine"
 8190]
 8200ENDIF
 8210[OPT I%
 8220
 8230
 8240    ADD   R4,R12,#work_driverTable%
 8250    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8260
 8270    CMP   R0,#0                      \ < 0
 8280    LDMLTIA R13!,{R1-R12,R14}
 8290    BLT   swiDriverNumError1%
 8300
 8310    CMP   R0,#driverMax%             \ >= max
 8320    LDMGEIA R13!,{R1-R12,R14}
 8330    BGE   swiDriverNumError1%
 8340
 8350    \ Does the driver exist?
 8360
 8370    MOV   R3,#driverTableLen%
 8380    MLA   R6,R3,R0,R4
 8390
 8400    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 8410    CMP   R4,#0
 8420    LDMEQIA R13!,{R1-R12,R14}
 8430    BEQ   swiDriverExistError1%         \ If not then exit
 8440
 8450    MOV   R0,R1      \ Volume
 8460    MOV   R1,R6      \ Table address
 8470    BL    driverVolume%                 \ Set driver volume to R0
 8480
 8490    \ Note that when the driver's volume changes, all handler scaled
 8500    \ volumes may need to be reset
 8510
 8520    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
 8530    ADD   R0,R0,R12
 8540    CMP   R0,R6
 8550
 8560    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes
 8570
 8580    LDR   R0,[R6,#driver_Volume%]       \ Return volume
 8590
 8600    LDMIA R13!,{R1-R12,PC}^
 8610
 8620\ ----------------
 8630
 8640.swiDriverMixer%             \ Set or read the mixer for a driver
 8650                             \ On entry:
 8660                             \    R0 = driver number
 8670                             \    R1 = function   0 = read, 1 = set
 8680                             \    R2 = mixer number
 8690                             \    R3 = value if set
 8700                             \ On exit:
 8710                             \    R0 preserved
 8720                             \    R1 = no of mixers
 8730                             \    R2 = value
 8740                             \    R3 = name
 8750
 8760    STMDB R13!,{R0,R4-R12,R14}
 8770
 8780]
 8790IF debug% THEN
 8800[OPT I%
 8810    SWI "XOS_WriteS"
 8820    EQUS "Driver mixer"+CHR$(0):ALIGN
 8830    SWI "XOS_NewLine"
 8840]
 8850ENDIF
 8860[OPT I%
 8870
 8880
 8890
 8900    ADD   R4,R12,#work_driverTable%
 8910    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8920
 8930    CMP   R0,#0                      \ < 0
 8940    LDMLTIA R13!,{R0,R4-R12,R14}
 8950    BLT   swiDriverNumError1%
 8960
 8970    CMP   R0,#driverMax%             \ >= max
 8980    LDMGEIA R13!,{R0,R4-R12,R14}
 8990    BGE   swiDriverNumError1%
 9000
 9010    \ Does the driver exist?
 9020
 9030    MOV   R3,#driverTableLen%
 9040    MLA   R6,R3,R0,R4
 9050
 9060    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 9070    CMP   R4,#0
 9080    LDMEQIA R13!,{R1-R12,R14}
 9090    BEQ   swiDriverExistError1%         \ If not then exit
 9100
 9110    MOV   R0,R1         \ Function code
 9120    MOV   R1,R2         \ Mixer number
 9130    MOV   R2,R3         \ Value
 9140    MOV   R3,R6         \ Driver table pointer
 9150
 9160    BL    driverMixer%
 9170
 9180
 9190    LDMIA R13!,{R0,R4-R12,PC}^
 9200]
 9210ENDPROC
@


1.1
log
@file SWIS was initially added on branch Spinner.
@
text
@d1 946
@


1.1.2.1
log
@New layout SharedSound with text files rather than BASIC files.
@
text
@a0 542
/* Copyright (c) 1995, Expressive Software Projects
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Expressive Software Projects nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
   10DEFPROCSWIS
   20LOCAL er$
   30er$="SWIS"
   40PRINT "PROCSWIS"
   50[OPT I%
   80\ ------------------- SWI Code --------------
  100.swiControlWord%    \ Provides the address of a control word
  110                    \ used by Replay for 1 if n playback
  120                    \ On entry:
  130                    \    none
  140                    \ On exit:
  150                    \    R0 = control word address
  170    ADD   R0,R12,#work_ControlWord%
  180    MOV   PC,R14
  210\ -------------
  240.swiInstallHandler%            \ Install a linear handler
  250                               \ On entry:
  260                               \  R0 = Handler address
  270                               \  R1 = parameter to pass
  280                               \  R2 = flags
  290                               \  R3 = name of handler
  300                               \  R4 = Type if bit 0 of flags = 1
  310                               \ On exit:
  320                               \  R0 = Handler number
  330    STMDB R13!,{R1-R12,R14}
  350    CMP   R0,#0                     \ Check handler address non-zero
  360    LDMEQIA R13!,{R1-R12,PC}^
  380    ADD   R8,R12,#work_handlerTable% \ Get address of table
  390    MOV   R6,#handlerMax%            \ Maximum number available
  410    \ Look first for handler already exists
  430.swiInstallHandlerCheckSlot%
  450    LDR   R5,[R8,#handler_Address%]
  460    CMP   R5,R0                         \ Check address
  470    BNE   swiInstallHandlerCheckNext%   \ Not equal
  490    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
  500    CMP   R7,R1
  510    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry
  530.swiInstallHandlerCheckNext%
  550    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  560    SUBS  R6,R6,#1
  570    BNE   swiInstallHandlerCheckSlot%
  590    \ OK so doesn't already exist
  600    \ Now look for an empty slot
  620    ADD   R8,R12,#work_handlerTable% \ Get address of table
  630    MOV   R6,#handlerMax%            \ Maximum number available
  650.swiInstallHandlerFindSlot%
  670    LDR   R5,[R8,#handler_Address%]
  680    CMP   R5,#0
  690    BEQ   swiInstallHandlerGo%       \ Free slot
  710    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  720    SUBS  R6,R6,#1
  730    BNE   swiInstallHandlerFindSlot%
  750    \ No more slots available
  770    B     installMaxError%
  790.swiInstallHandlerGo%                \ OK So enter new handler
  800                                     \ R8 = slot pointer
  810    BL     stopSound%                \ Make sure nothing happening
  830    STR    R0,[R8,#handler_Address%]
  840    STR    R1,[R8,#handler_Parameter%]
  850    STR    R2,[R8,#handler_Flags%]
  870    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
  880    MOVEQ  R4,#handlerType_Default%
  890    STR    R4,[R8,#handler_Type%]     \ Type
  910    \ Set handler type variables
  930    RSB   R0,R6,#handlerMax%    \ Handler number
  950    BL    setHandlerType%
  970    \ Name
  990    ADD    R5,R8,#handler_Name%       \ Position of name
 1000    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
 1010    SUB    R2,R2,#1
 1030.swiInstallHandlerNameLoop%
 1050    LDRB   R7,[R3],#1
 1060    STRB   R7,[R5],#1
 1070    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
 1080    MOVEQ  R7,#0
 1090    STREQB R7,[R5]
 1110    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached
 1130    BNE    swiInstallHandlerNameLoop%  \ Carry on with name
 1160    \ And initialise the other parameters in the table
 1180    MOV    R0,#0                       \ Volume LR
 1190    SUB    R0,R0,#1                    \ = &FFFF FFFF
 1200    STR    R0,[R8,#handler_Volume%]
 1220    MOV    R0,R8                       \ Set up scaled volume
 1230    BL     scaleHandlerVolume%
 1260    MOV    R0,#0
 1270    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined
 1290    MOV    R0,#1<<24
 1300    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1
 1330.swiInstallHandlerExit%
 1350    BL    startSound%                   \ Set sound going again and provoke a driver check
 1370    RSB   R0,R6,#handlerMax%            \ Return handler number
 1380    ADD   R0,R0,#1                      \ In the range 1 - handlerMax
 1410    LDMIA R13!,{R1-R12,PC}^
 1430\
 1450.installMaxError%
 1460    LDMIA R13!,{R1-R12,R14}
 1470    ADR   R0,installMaxMesg%
 1480    ORRS  PC,R14,#Overflow_Flag
 1490.installMaxMesg%
 1500    EQUD  &1E6
 1510    EQUS  "Maximum nunber of handlers reached"
 1520    EQUB  0
 1530    ALIGN
 1540\
 1570\ -----------
 1590.swiRemoveHandler%           \ Remove a particular handler
 1600                             \ Slot number in R0, 1 - 10
 1610    STMDB R13!,{R0-R12,R14}
 1640    ADD   R1,R12,#work_handlerTable%
 1650    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 1670    CMP   R0,#0                      \ If <0 then error
 1680    BLT   swiHandlerNumError%
 1700    CMP   R0,#handlerMax%            \ If > max then error
 1710    BGE   swiHandlerNumError%
 1730    MOV   R3,#handlerTableLen%
 1740    MLA   R2,R3,R0,R1
 1760    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
 1770    CMP   R1,#0
 1780    BEQ   swiHandlerExistError%       \ If not then exit
 1800    BL    stopSound%         \ Stop sound and wait for end of buffer fill
 1820    MOV   R0,#0                       \ Remove involves simply setting Address to 0
 1830    STR   R0,[R2,#handler_Address%]
 1850    BL    startSound%
 1880    LDMIA R13!,{R0-R12,PC}^
 1900\
 1910.swiHandlerNumError%
 1920    LDMIA R13!,{R0-R12,R14}
 1930.swiHandlerNumError1%
 1940    ADR   R0,HandlerNumMesg%
 1950    ORRS  PC,R14,#Overflow_Flag
 1960.HandlerNumMesg%
 1970    EQUD  &1E6
 1980    EQUS  "Handler number out of range"
 1990    EQUB  0
 2000    ALIGN
 2010\
 2030.swiHandlerExistError%
 2040    LDMIA R13!,{R0-R12,R14}
 2050.swiHandlerExistError1%
 2060    ADR   R0,HandlerExistMesg%
 2070    ORRS  PC,R14,#Overflow_Flag
 2080.HandlerExistMesg%
 2090    EQUD  &1E6
 2100    EQUS  "Handler not installed"
 2110    EQUB  0
 2120    ALIGN
 2130\
 2160\ -----------
 2180.swiHandlerType% \ Set the type of the handler
 2190                 \ On entry:
 2200                 \    R0 = handler number
 2210                 \    R1 = Type
 2220                 \ On exit:
 2240    STMDB R13!,{R6-R12,R14}
 2260    MOV   R7,R1   \ Type into R7
 2280    ADD   R1,R12,#work_handlerTable%
 2290    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2310    CMP   R0,#0                      \ If <0 then error
 2320    LDMLTIA R13!,{R6-R12,R14}
 2330    BLT   swiHandlerNumError1%
 2350    CMP   R0,#handlerMax%            \ If > max then error
 2360    LDMGEIA R13!,{R6-R12,R14}
 2370    BGE   swiHandlerNumError1%
 2390    MOV   R3,#handlerTableLen%
 2400    MLA   R6,R3,R0,R1
 2420    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2430    CMP   R1,#0
 2440    LDMEQIA R13!,{R6-R12,R14}
 2450    BEQ   swiHandlerExistError1%       \ If not then exit
 2470    \ R0 = Handler number (0-n)
 2490    LDR   R4,[R6,#handler_Type%]
 2500    BL    clearHandlerType%
 2520    STR   R7,[R6,#handler_Type%]
 2530    MOV   R4,R7
 2540    BL    setHandlerType%
 2560    LDMIA R13!,{R6-R12,PC}
 2590\ -----------
 2610.swiHandlerInfo%   \ R0 = handler number
 2620                   \ On exit:
 2630                   \ R0 = number of next available handler or 0 for none
 2640                   \ R1 = flags
 2650                   \ R2 = name
 2660                   \ R3 = Sample frequency
 2670                   \ R4 = Sample type
 2680                   \ R5 = Volume
 2700    STMDB R13!,{R6-R12,R14}
 2720    ADD   R1,R12,#work_handlerTable%
 2730    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2750    CMP   R0,#0                      \ If <0 then error
 2760    LDMLTIA R13!,{R6-R12,R14}
 2770    BLT   swiHandlerNumError1%
 2790    CMP   R0,#handlerMax%            \ If > max then error
 2800    LDMGEIA R13!,{R6-R12,R14}
 2810    BGE   swiHandlerNumError1%
 2830    MOV   R3,#handlerTableLen%
 2840    MLA   R6,R3,R0,R1
 2860    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2870    CMP   R1,#0
 2880    LDMEQIA R13!,{R6-R12,R14}
 2890    BEQ   swiHandlerExistError1%       \ If not then exit
 2910    \ Get handler values
 2930    LDR   R1,[R6,#handler_Flags%]
 2940    ADD   R2,R6,#handler_Name%
 2950    LDR   R3,[R6,#handler_SampleFrequency%]
 2960    LDR   R4,[R6,#handler_Type%]
 2970    LDR   R5,[R6,#handler_Volume%]
 2990    \ Now find next handler
 3010.swiHandlerInfoLoop%
 3030    ADD   R0,R0,#1
 3040    CMP   R0,#handlerMax%
 3050    MOVEQ R0,#0
 3060    BEQ   swiHandlerInfoExit%
 3080    ADD   R6,R6,#handlerTableLen%    \ Try next one
 3090    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
 3100    CMP   R7,#0
 3110    BEQ   swiHandlerInfoLoop%        \ No, then try next one
 3130.swiHandlerInfoExit%
 3150    LDMIA R13!,{R6-R12,PC}^
 3170\ -----------
 3190.swiSampleRate%          \ Either set the current driver rate
 3200                         \ or set the rate for a particular handler
 3210                         \ On entry:
 3220                         \ R0 = 0 for set driver rate
 3230                         \    > 0 for handler number
 3240                         \ R1 = sample frequency required
 3250                         \      if 0 then use current rate
 3260                         \ On exit:
 3270                         \ R1 = actual sample rate
 3280                         \ R2 = sample period
 3290                         \ R3 = fractional step used get the required rate
 3310    STMDB R13!,{R4-R12,R14}
 3340    CMP   R0,#0
 3350    BNE   swiSampleRateDo%
 3370    \     Set driver rate
 3390    MOV   R0,R1              \ Move rate into R0
 3400    BL    newSampleRate%     \ Sets new rate across all handlers
 3410                             \ all registers preserved
 3430    LDR   R0,[R12,#work_SampleFrequency%]
 3450    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
 3460                              \ return fraction in R0
 3490    B     swiSampleRateExit%
 3520.swiSampleRateDo%
 3540    \ Find handler
 3560    ADD   R2,R12,#work_handlerTable%
 3570    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 3590    CMP   R0,#0                      \ If <0 then error
 3600    LDMLTIA R13!,{R4-R12,R14}
 3610    BLT   swiHandlerNumError1%
 3630    CMP   R0,#handlerMax%            \ If > max then error
 3640    LDMGEIA R13!,{R4-R12,R14}
 3650    BGE   swiHandlerNumError1%
 3670    MOV   R3,#handlerTableLen%
 3680    MLA   R6,R3,R0,R2
 3700    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
 3710    CMP   R2,#0
 3720    LDMEQIA R13!,{R4-R12,R14}
 3730    BEQ   swiHandlerExistError1%       \ If not then exit
 3750    \   Get fraction
 3770    CMP   R1,#0
 3780    LDREQ R0,[R12,#work_SampleFrequency%]
 3790    MOVNE R0,R1
 3800    BL    sampleRateFraction%          \ Return fraction in R0
 3820    \  Store values in handler table
 3840    CMP   R1,#0
 3850    LDREQ R1,[R12,#work_SampleFrequency%]
 3860    STR   R1,[R6,#handler_SampleFrequency%]
 3870    STR   R0,[R6,#handler_Fraction%]
 3890.swiSampleRateExit%
 3910    MOV   R3,R0                         \ Set up return values
 3920    LDR   R1,[R12,#work_SampleFrequency%]
 3930    LDR   R2,[R12,#work_SamplePeriod%]
 3950    LDMIA R13!,{R4-R12,PC}^
 3970\ -----------
 3990.swiHandlerVolume%           \ Set a handler's volume
 4000                             \ On entry:
 4010                             \ R0 = handler number
 4020                             \ R1 = LR volume to set
 4030                             \ On exit:
 4040                             \ R1 = current volume
 4060    STMDB R13!,{R0,R2-R12,R14}
 4080    \ Find handler
 4100    ADD   R4,R12,#work_handlerTable%
 4110    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4130    CMP   R0,#0                      \ If <0 then error
 4140    LDMLTIA R13!,{R0,R1,R3-R12,R14}
 4150    BLT   swiHandlerNumError1%
 4170    CMP   R0,#handlerMax%            \ If > max then error
 4180    LDMGEIA R13!,{R0,R1,R3-R12,R14}
 4190    BGE   swiHandlerNumError1%
 4210    MOV   R3,#handlerTableLen%
 4220    MLA   R6,R3,R0,R4
 4240    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
 4250    CMP   R4,#0
 4260    LDMEQIA R13!,{R0,R1,R3-R12,R14}
 4270    BEQ   swiHandlerExistError1%       \ If not then exit
 4290    STR   R1,[R6,#handler_Volume%]     \ Set volume
 4300    MOV   R0,R6
 4310    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr
 4330    LDR   R1,[R6,#handler_Volume%]     \ Read result
 4350    LDMIA R13!,{R0,R2-R12,PC}^
 4370\ -----------
 4390.swiHandlerSampleType%        \ Not in this version
 4410    STMDB R13!,{R0-R12,R14}
 4440    LDMIA R13!,{R0-R12,PC}^
 4460\ -----------
 4480.swiHandlerPause%             \ Not in this version
 4500    STMDB R13!,{R0-R12,R14}
 4530    LDMIA R13!,{R0-R12,PC}^
 4550\ -----------
 4570.swiInstallDriver%  \ Install or make active a driver
 4580                    \ R0 = Pointer to driver table address
 4590                    \      or 1 = Linear
 4600                    \      or 2 = Log
 4610                    \ R1 = parameter to pass driver in R12 when called
 4620                    \ R2 = flags
 4630                    \ R3 = Volume
 4650    STMDB R13!,{R0-R12,R14}
 4670    \ If R0 = 1 or 2 then Linear or Log
 4680    \ Otherwise regard this as a new driver
 4700    CMP   R0,#2
 4710    BGT   swiInstallDriverTable%
 4730    CMP   R0,#1
 4740    BNE   swiInstallDriverLog%
 4760    BL    installLinearDriver%
 4780    B     swiInstallDriverExit%
 4800.swiInstallDriverLog%
 4820\    CMP   R0,#2
 4830\    BLEQ  installLogDriver%
 4850    B     swiInstallDriverExit%
 4880.swiInstallDriverTable%
 4900    BL    installDriver%               \ Simply pass on to this routine
 4930.swiInstallDriverExit%
 4950    LDMIA R13!,{R0-R12,PC}^
 4970\ -----------
 4990.swiDriverNumError%
 5000    LDMIA R13!,{R0-R12,R14}
 5010.swiDriverNumError1%
 5020    ADR   R0,DriverNumMesg%
 5030    ORRS  PC,R14,#Overflow_Flag
 5040.DriverNumMesg%
 5050    EQUD  &1E6
 5060    EQUS  "Driver number out of range"
 5070    EQUB  0
 5080    ALIGN
 5090\
 5110.swiDriverExistError%
 5120    LDMIA R13!,{R0-R12,R14}
 5130.swiDriverExistError1%
 5140    ADR   R0,DriverExistMesg%
 5150    ORRS  PC,R14,#Overflow_Flag
 5160.DriverExistMesg%
 5170    EQUD  &1E6
 5180    EQUS  "Driver not installed"
 5190    EQUB  0
 5200    ALIGN
 5210\
 5230.swiRemoveDriverError%
 5240    LDMIA R13!,{R0-R12,R14}
 5250    ADR   R0,swiRemoveDriverMesg%
 5260    ORRS  PC,R14,#Overflow_Flag
 5270.swiRemoveDriverMesg%
 5280    EQUD  &1E6
 5290    EQUS  "Cannot remove the default driver"
 5300    EQUB  0
 5310    ALIGN
 5320\
 5340\ -----------
 5360.swiRemoveDriver%      \ Remove a driver from the driver table
 5370                       \ On entry:
 5380                       \   R0 = driver number
 5390                       \        cannot remove driver 1 as this is the default driver
 5410    STMDB R13!,{R0-R12,R14}
 5430    \ First check parameter
 5450    ADD   R4,R12,#work_driverTable%
 5460    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 5480    CMP   R0,#0                      \ < 0
 5490    BLT   swiDriverNumError%
 5510    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver
 5530    CMP   R0,#driverMax%             \ >= max
 5540    BGE   swiDriverNumError%
 5560    \ Does the driver exist?
 5580    MOV   R3,#driverTableLen%
 5590    MLA   R6,R3,R0,R4
 5610    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 5620    CMP   R4,#0
 5630    BEQ   swiDriverExistError%         \ If not then exit
 5650    \ is driver current
 5670    SUB   R4,R6,R12
 5680    LDR   R0,[R12,#work_currentDriver%]
 5690    CMP   R4,R0
 5700    BNE   swiRemoveDriverNext%
 5720    \ if it is then release it first
 5740    BL    releaseDriver%
 5760    \ and make sure at least the default driver is installed instead
 5780    MOV   R0,#1              \ Default driver
 5790    BL    swiInstallDriver%
 5810.swiRemoveDriverNext%
 5830    \ Now remove the driver entry
 5850    MOV   R0,#0
 5860    STR   R0,[R6,#driver_Address%]
 5880    LDMIA R13!,{R0-R12,PC}^
 5900\ -----------
 5920.swiDriverInfo%   \ R0 = driver number
 5930                  \ On exit:
 5940                  \ R0 = number of next available driver or 0 for none
 5950                  \ R1 = flags
 5960                  \ R2 = name
 5970                  \ R3 = Volume
 5980                  \ R4 = Overrun count
 6000    STMDB R13!,{R5-R12,R14}
 6020    ADD   R4,R12,#work_driverTable%
 6030    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6050    CMP   R0,#0                      \ < 0
 6060    LDMLTIA R13!,{R5-R12,R14}
 6070    BLT   swiDriverNumError1%
 6090    CMP   R0,#driverMax%             \ >= max
 6100    LDMGEIA R13!,{R5-R12,R14}
 6110    BGE   swiDriverNumError1%
 6130    \ Does the driver exist?
 6150    MOV   R3,#driverTableLen%
 6160    MLA   R6,R3,R0,R4
 6180    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6190    CMP   R4,#0
 6200    LDMEQIA R13!,{R5-R12,R14}
 6210    BEQ   swiDriverExistError1%         \ If not then exit
 6230    \ Get driver values
 6250\    LDR   R1,[R6,#driver_Flags%]
 6260    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
 6270    ADD   R4,R4,R12
 6280    CMP   R4,R6
 6290    MOVEQ R1,#1        \ 1 if current
 6300    MOVNE R1,#0        \ 0 if not
 6320    ADD   R2,R6,#driver_Name%
 6330    LDR   R3,[R6,#driver_Volume%]
 6350    \ Now find next driver, if it exists
 6370.swiDriverInfoLoop%
 6390    ADD   R0,R0,#1
 6400    CMP   R0,#driverMax%
 6410    MOVEQ R0,#0
 6420    BEQ   swiDriverInfoExit%
 6440    ADD   R6,R6,#driverTableLen%    \ Try next one
 6450    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
 6460    CMP   R7,#0
 6470    BEQ   swiDriverInfoLoop%        \ No, then try next one
 6490.swiDriverInfoExit%
 6510    LDR   R4,[R12,#work_callBack_Count%]
 6530    LDMIA R13!,{R5-R12,PC}^
 6550\ -----------
 6570.swiDriverVolume%            \ Set the volume for a driver
 6580                             \ On entry:
 6590                             \    R0 = driver number
 6600                             \    R1 = new volume
 6610                             \ On exit:
 6620                             \    R0 = current volume
 6630    STMDB R13!,{R1-R12,R14}
 6650    ADD   R4,R12,#work_driverTable%
 6660    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6680    CMP   R0,#0                      \ < 0
 6690    LDMLTIA R13!,{R1-R12,R14}
 6700    BLT   swiDriverNumError1%
 6720    CMP   R0,#driverMax%             \ >= max
 6730    LDMGEIA R13!,{R1-R12,R14}
 6740    BGE   swiDriverNumError1%
 6760    \ Does the driver exist?
 6780    MOV   R3,#driverTableLen%
 6790    MLA   R6,R3,R0,R4
 6810    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6820    CMP   R4,#0
 6830    LDMEQIA R13!,{R1-R12,R14}
 6840    BEQ   swiDriverExistError1%         \ If not then exit
 6860    MOV   R0,R1      \ Volume
 6870    MOV   R1,R6      \ Table address
 6880    BL    driverVolume%                 \ Set driver volume to R0
 6900    \ Note that when the driver's volume changes, all handler scaled
 6910    \ volumes may need to be reset
 6930    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
 6940    ADD   R0,R0,R12
 6950    CMP   R0,R6
 6970    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes
 6990    LDR   R0,[R6,#driver_Volume%]       \ Return volume
 7010    LDMIA R13!,{R1-R12,PC}^
 7030\ ----------------
 7050.swiDriverMixer%             \ Set or read the mixer for a driver
 7060                             \ On entry:
 7070                             \    R0 = driver number
 7080                             \    R1 = function   0 = read, 1 = set
 7090                             \    R2 = mixer number
 7100                             \    R3 = value if set
 7110                             \ On exit:
 7120                             \    R0 preserved
 7130                             \    R1 = no of mixers
 7140                             \    R2 = value
 7150                             \    R3 = name
 7170    STMDB R13!,{R0,R4-R12,R14}
 7190    ADD   R4,R12,#work_driverTable%
 7200    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 7220    CMP   R0,#0                      \ < 0
 7230    LDMLTIA R13!,{R0,R4-R12,R14}
 7240    BLT   swiDriverNumError1%
 7260    CMP   R0,#driverMax%             \ >= max
 7270    LDMGEIA R13!,{R0,R4-R12,R14}
 7280    BGE   swiDriverNumError1%
 7300    \ Does the driver exist?
 7320    MOV   R3,#driverTableLen%
 7330    MLA   R6,R3,R0,R4
 7350    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 7360    CMP   R4,#0
 7370    LDMEQIA R13!,{R1-R12,R14}
 7380    BEQ   swiDriverExistError1%         \ If not then exit
 7400    MOV   R0,R1         \ Function code
 7410    MOV   R1,R2         \ Mixer number
 7420    MOV   R2,R3         \ Value
 7430    MOV   R3,R6         \ Driver table pointer
 7450    BL    driverMixer%
 7480    LDMIA R13!,{R0,R4-R12,PC}^
 7490]
 7500ENDPROC
@


1.1.2.2
log
@New version: useful changes are bug fixed in removing callback
handlers (affects turning off the MIDI synth), and maintains number of
channels configured when callback buffers not supplied (stops volume
of RealAudio playback from fluctuating when MIDI Synth can't make its
mind up whether to created buffers or not.
Other changes adds CBAI and 8bit log output support (disabled) and
debugging code.
@
text
@a30 2
   60
   70
a31 1
   90
a37 1
  160
a39 2
  190
  200
d41 502
a542 900
  220
  230]
  240IF debug1% THEN
  250[OPT I%
  260
  270.swiTest% \ Test stuff
  280
  290    STMDB R13!,{R14}
  300
  310
  320    LDMIA R13!,{PC}
  330
  340\----------
  350
  360.swiInfo% \ Get info
  370
  380    STMDB R13!,{R14}
  390
  400    LDR   R0,[R12,#work_SampleFrequency%]
  410    LDR   R1,[R12,#work_SamplePeriod%]
  420
  430    LDMIA R13!,{PC}
  440
  450
  460\ ---------
  470
  480]
  490ENDIF
  500[OPT I%
  510
  520.swiInstallHandler%            \ Install a linear handler
  530                               \ On entry:
  540                               \  R0 = Handler address
  550                               \  R1 = parameter to pass
  560                               \  R2 = flags
  570                               \  R3 = name of handler
  580                               \  R4 = Type if bit 0 of flags = 1
  590                               \ On exit:
  600                               \  R0 = Handler number
  610    STMDB R13!,{R1-R12,R14}
  620
  630]
  640IF debug% THEN
  650[OPT I%
  660    SWI "XOS_WriteS"
  670    EQUS "Install handler"+CHR$(0):ALIGN
  680    SWI "XOS_NewLine"
  690]
  700ENDIF
  710[OPT I%
  720
  730    CMP   R0,#0                     \ Check handler address non-zero
  740    LDMEQIA R13!,{R1-R12,PC}^
  750
  760    ADD   R8,R12,#work_handlerTable% \ Get address of table
  770    MOV   R6,#handlerMax%            \ Maximum number available
  780
  790    \ Look first for handler already exists
  800
  810.swiInstallHandlerCheckSlot%
  820
  830    LDR   R5,[R8,#handler_Address%]
  840    CMP   R5,R0                         \ Check address
  850    BNE   swiInstallHandlerCheckNext%   \ Not equal
  860
  870    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
  880    CMP   R7,R1
  890    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry
  900
  910.swiInstallHandlerCheckNext%
  920
  930    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  940    SUBS  R6,R6,#1
  950    BNE   swiInstallHandlerCheckSlot%
  960
  970    \ OK so doesn't already exist
  980    \ Now look for an empty slot
  990
 1000    ADD   R8,R12,#work_handlerTable% \ Get address of table
 1010    MOV   R6,#handlerMax%            \ Maximum number available
 1020
 1030.swiInstallHandlerFindSlot%
 1040
 1050    LDR   R5,[R8,#handler_Address%]
 1060    CMP   R5,#0
 1070    BEQ   swiInstallHandlerGo%       \ Free slot
 1080
 1090    ADD   R8,R8,#handlerTableLen%   \ Try next slot
 1100    SUBS  R6,R6,#1
 1110    BNE   swiInstallHandlerFindSlot%
 1120
 1130    \ No more slots available
 1140
 1150    B     installMaxError%
 1160
 1170.swiInstallHandlerGo%                \ OK So enter new handler
 1180                                     \ R8 = slot pointer
 1190    BL     stopSound%                \ Make sure nothing happening
 1200
 1210    STR    R0,[R8,#handler_Address%]
 1220    STR    R1,[R8,#handler_Parameter%]
 1230    STR    R2,[R8,#handler_Flags%]
 1240
 1250    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
 1260    MOVEQ  R4,#handlerType_Default%
 1270    STR    R4,[R8,#handler_Type%]     \ Type
 1280
 1290    \ Set handler type variables
 1300
 1310    RSB   R0,R6,#handlerMax%    \ Handler number
 1320
 1330    BL    setHandlerType%
 1340
 1350    \ Name
 1360
 1370    ADD    R5,R8,#handler_Name%       \ Position of name
 1380    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
 1390    SUB    R2,R2,#1
 1400
 1410.swiInstallHandlerNameLoop%
 1420
 1430    LDRB   R7,[R3],#1
 1440    STRB   R7,[R5],#1
 1450    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
 1460    MOVEQ  R7,#0
 1470    STREQB R7,[R5]
 1480
 1490    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached
 1500
 1510    BNE    swiInstallHandlerNameLoop%  \ Carry on with name
 1520
 1530
 1540    \ And initialise the other parameters in the table
 1550
 1560    MOV    R0,#0                       \ Volume LR
 1570    SUB    R0,R0,#1                    \ = &FFFF FFFF
 1580    STR    R0,[R8,#handler_Volume%]
 1590
 1600    MOV    R0,R8                       \ Set up scaled volume
 1610    BL     scaleHandlerVolume%
 1620
 1630
 1640    MOV    R0,#0
 1650    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined
 1660
 1670    MOV    R0,#1<<24
 1680    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1
 1690
 1700
 1710.swiInstallHandlerExit%
 1720
 1730    BL    startSound%                   \ Set sound going again and provoke a driver check
 1740
 1750    RSB   R0,R6,#handlerMax%            \ Return handler number
 1760    ADD   R0,R0,#1                      \ In the range 1 - handlerMax
 1770
 1780
 1790    LDMIA R13!,{R1-R12,PC}^
 1800
 1810\
 1820
 1830.installMaxError%
 1840    LDMIA R13!,{R1-R12,R14}
 1850    ADR   R0,installMaxMesg%
 1860    ORRS  PC,R14,#Overflow_Flag
 1870.installMaxMesg%
 1880    EQUD  &1E6
 1890    EQUS  "Maximum nunber of handlers reached"
 1900    EQUB  0
 1910    ALIGN
 1920\
 1930
 1940
 1950\ -----------
 1960
 1970.swiRemoveHandler%           \ Remove a particular handler
 1980                             \ Slot number in R0, 1 - 10
 1990    STMDB R13!,{R0-R12,R14}
 2000
 2010]
 2020IF debug% THEN
 2030[OPT I%
 2040    SWI "XOS_WriteS"
 2050    EQUS "Remove handler"+CHR$(0):ALIGN
 2060    SWI "XOS_NewLine"
 2070]
 2080ENDIF
 2090[OPT I%
 2100
 2110    ADD   R1,R12,#work_handlerTable%
 2120    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2130
 2140    CMP   R0,#0                      \ If <0 then error
 2150    BLT   swiHandlerNumError%
 2160
 2170    CMP   R0,#handlerMax%            \ If > max then error
 2180    BGE   swiHandlerNumError%
 2190
 2200    MOV   R3,#handlerTableLen%
 2210    MLA   R2,R3,R0,R1
 2220
 2230    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
 2240    CMP   R1,#0
 2250    BEQ   swiHandlerExistError%       \ If not then exit
 2260
 2270    \ R0 = Handler number (0-n)
 2280
 2290    LDR   R4,[R2,#handler_Type%]
 2300    BL    clearHandlerType%
 2310
 2320    BL    stopSound%         \ Stop sound and wait for end of buffer fill
 2330
 2340    MOV   R0,#0                       \ Remove involves simply setting Address to 0
 2350    STR   R0,[R2,#handler_Address%]
 2360
 2370    BL    startSound%
 2380
 2390
 2400    LDMIA R13!,{R0-R12,PC}^
 2410
 2420\
 2430.swiHandlerNumError%
 2440    LDMIA R13!,{R0-R12,R14}
 2450.swiHandlerNumError1%
 2460    ADR   R0,HandlerNumMesg%
 2470    ORRS  PC,R14,#Overflow_Flag
 2480.HandlerNumMesg%
 2490    EQUD  &1E6
 2500    EQUS  "Handler number out of range"
 2510    EQUB  0
 2520    ALIGN
 2530\
 2540
 2550.swiHandlerExistError%
 2560    LDMIA R13!,{R0-R12,R14}
 2570.swiHandlerExistError1%
 2580    ADR   R0,HandlerExistMesg%
 2590    ORRS  PC,R14,#Overflow_Flag
 2600.HandlerExistMesg%
 2610    EQUD  &1E6
 2620    EQUS  "Handler not installed"
 2630    EQUB  0
 2640    ALIGN
 2650\
 2660
 2670
 2680\ -----------
 2690
 2700.swiHandlerType% \ Set the type of the handler
 2710                 \ On entry:
 2720                 \    R0 = handler number
 2730                 \    R1 = Type
 2740                 \ On exit:
 2750
 2760    STMDB R13!,{R6-R12,R14}
 2770
 2780    MOV   R7,R1   \ Type into R7
 2790
 2800    ADD   R1,R12,#work_handlerTable%
 2810    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2820
 2830    CMP   R0,#0                      \ If <0 then error
 2840    LDMLTIA R13!,{R6-R12,R14}
 2850    BLT   swiHandlerNumError1%
 2860
 2870    CMP   R0,#handlerMax%            \ If > max then error
 2880    LDMGEIA R13!,{R6-R12,R14}
 2890    BGE   swiHandlerNumError1%
 2900
 2910    MOV   R3,#handlerTableLen%
 2920    MLA   R6,R3,R0,R1
 2930
 2940    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2950    CMP   R1,#0
 2960    LDMEQIA R13!,{R6-R12,R14}
 2970    BEQ   swiHandlerExistError1%       \ If not then exit
 2980
 2990    \ R0 = Handler number (0-n)
 3000
 3010    LDR   R4,[R6,#handler_Type%]
 3020    BL    clearHandlerType%
 3030
 3040    STR   R7,[R6,#handler_Type%]
 3050    MOV   R4,R7
 3060    BL    setHandlerType%
 3070
 3080    LDMIA R13!,{R6-R12,PC}
 3090
 3100
 3110\ -----------
 3120
 3130.swiHandlerInfo%   \ R0 = handler number
 3140                   \ On exit:
 3150                   \ R0 = number of next available handler or 0 for none
 3160                   \ R1 = flags
 3170                   \ R2 = name
 3180                   \ R3 = Sample frequency
 3190                   \ R4 = Sample type
 3200                   \ R5 = Volume
 3210
 3220    STMDB R13!,{R6-R12,R14}
 3230
 3240]
 3250IF debug% THEN
 3260[OPT I%
 3270    SWI "XOS_WriteS"
 3280    EQUS "Handler info"+CHR$(0):ALIGN
 3290    SWI "XOS_NewLine"
 3300]
 3310ENDIF
 3320[OPT I%
 3330
 3340
 3350
 3360    ADD   R1,R12,#work_handlerTable%
 3370    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 3380
 3390    CMP   R0,#0                      \ If <0 then error
 3400    LDMLTIA R13!,{R6-R12,R14}
 3410    BLT   swiHandlerNumError1%
 3420
 3430    CMP   R0,#handlerMax%            \ If > max then error
 3440    LDMGEIA R13!,{R6-R12,R14}
 3450    BGE   swiHandlerNumError1%
 3460
 3470    MOV   R3,#handlerTableLen%
 3480    MLA   R6,R3,R0,R1
 3490
 3500    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 3510    CMP   R1,#0
 3520    LDMEQIA R13!,{R6-R12,R14}
 3530    BEQ   swiHandlerExistError1%       \ If not then exit
 3540
 3550    \ Get handler values
 3560
 3570    LDR   R1,[R6,#handler_Flags%]
 3580    ADD   R2,R6,#handler_Name%
 3590    LDR   R3,[R6,#handler_SampleFrequency%]
 3600    LDR   R4,[R6,#handler_Type%]
 3610    LDR   R5,[R6,#handler_Volume%]
 3620
 3630    \ Now find next handler
 3640
 3650.swiHandlerInfoLoop%
 3660
 3670    ADD   R0,R0,#1
 3680    CMP   R0,#handlerMax%
 3690    MOVEQ R0,#0
 3700    BEQ   swiHandlerInfoExit%
 3710
 3720    ADD   R6,R6,#handlerTableLen%    \ Try next one
 3730    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
 3740    CMP   R7,#0
 3750    BEQ   swiHandlerInfoLoop%        \ No, then try next one
 3760
 3770.swiHandlerInfoExit%
 3780
 3790    LDMIA R13!,{R6-R12,PC}^
 3800
 3810\ -----------
 3820
 3830.swiSampleRate%          \ Either set the current driver rate
 3840                         \ or set the rate for a particular handler
 3850                         \ On entry:
 3860                         \ R0 = 0 for set driver rate
 3870                         \    > 0 for handler number
 3880                         \ R1 = sample frequency required
 3890                         \      if 0 then use current rate
 3900                         \ On exit:
 3910                         \ R1 = actual sample rate
 3920                         \ R2 = sample period
 3930                         \ R3 = fractional step used get the required rate
 3940
 3950    STMDB R13!,{R4-R12,R14}
 3960
 3970]
 3980IF debug% THEN
 3990[OPT I%
 4000    SWI "XOS_WriteS"
 4010    EQUS "Sample rate"+CHR$(0):ALIGN
 4020    SWI "XOS_NewLine"
 4030]
 4040ENDIF
 4050[OPT I%
 4060
 4070
 4080    CMP   R0,#0
 4090    BNE   swiSampleRateDo%
 4100
 4110    \     Set driver rate
 4120
 4130    MOV   R0,R1              \ Move rate into R0
 4140    BL    newSampleRate%     \ Sets new rate across all handlers
 4150                             \ all registers preserved
 4160
 4170    LDR   R0,[R12,#work_SampleFrequency%]
 4180
 4190    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
 4200                              \ return fraction in R0
 4210
 4220
 4230    B     swiSampleRateExit%
 4240
 4250
 4260.swiSampleRateDo%
 4270
 4280    \ Find handler
 4290
 4300    ADD   R2,R12,#work_handlerTable%
 4310    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4320
 4330    CMP   R0,#0                      \ If <0 then error
 4340    LDMLTIA R13!,{R4-R12,R14}
 4350    BLT   swiHandlerNumError1%
 4360
 4370    CMP   R0,#handlerMax%            \ If > max then error
 4380    LDMGEIA R13!,{R4-R12,R14}
 4390    BGE   swiHandlerNumError1%
 4400
 4410    MOV   R3,#handlerTableLen%
 4420    MLA   R6,R3,R0,R2
 4430
 4440    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
 4450    CMP   R2,#0
 4460    LDMEQIA R13!,{R4-R12,R14}
 4470    BEQ   swiHandlerExistError1%       \ If not then exit
 4480
 4490    \   Get fraction
 4500
 4510    CMP   R1,#0
 4520    LDREQ R0,[R12,#work_SampleFrequency%]
 4530    MOVNE R0,R1
 4540    BL    sampleRateFraction%          \ Return fraction in R0
 4550
 4560    \  Store values in handler table
 4570
 4580    CMP   R1,#0
 4590    LDREQ R1,[R12,#work_SampleFrequency%]
 4600    STR   R1,[R6,#handler_SampleFrequency%]
 4610    STR   R0,[R6,#handler_Fraction%]
 4620
 4630.swiSampleRateExit%
 4640
 4650    MOV   R3,R0                         \ Set up return values
 4660    LDR   R1,[R12,#work_SampleFrequency%]
 4670    LDR   R2,[R12,#work_SamplePeriod%]
 4680
 4690    LDMIA R13!,{R4-R12,PC}^
 4700
 4710\ -----------
 4720
 4730.swiHandlerVolume%           \ Set a handler's volume
 4740                             \ On entry:
 4750                             \ R0 = handler number
 4760                             \ R1 = LR volume to set
 4770                             \ On exit:
 4780                             \ R1 = current volume
 4790
 4800    STMDB R13!,{R0,R2-R12,R14}
 4810
 4820]
 4830IF debug% THEN
 4840[OPT I%
 4850    SWI "XOS_WriteS"
 4860    EQUS "Handler Volume"+CHR$(0):ALIGN
 4870    SWI "XOS_NewLine"
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920
 4930
 4940    \ Find handler
 4950
 4960    ADD   R4,R12,#work_handlerTable%
 4970    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4980
 4990    CMP   R0,#0                      \ If <0 then error
 5000    LDMLTIA R13!,{R0,R1,R3-R12,R14}
 5010    BLT   swiHandlerNumError1%
 5020
 5030    CMP   R0,#handlerMax%            \ If > max then error
 5040    LDMGEIA R13!,{R0,R1,R3-R12,R14}
 5050    BGE   swiHandlerNumError1%
 5060
 5070    MOV   R3,#handlerTableLen%
 5080    MLA   R6,R3,R0,R4
 5090
 5100    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
 5110    CMP   R4,#0
 5120    LDMEQIA R13!,{R0,R1,R3-R12,R14}
 5130    BEQ   swiHandlerExistError1%       \ If not then exit
 5140
 5150    STR   R1,[R6,#handler_Volume%]     \ Set volume
 5160    MOV   R0,R6
 5170    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr
 5180
 5190    LDR   R1,[R6,#handler_Volume%]     \ Read result
 5200
 5210    LDMIA R13!,{R0,R2-R12,PC}^
 5220
 5230\ -----------
 5240
 5250.swiHandlerSampleType%        \ Not in this version
 5260
 5270    STMDB R13!,{R0-R12,R14}
 5280
 5290]
 5300IF debug% THEN
 5310[OPT I%
 5320    SWI "XOS_WriteS"
 5330    EQUS "Handler sample type"+CHR$(0):ALIGN
 5340    SWI "XOS_NewLine"
 5350]
 5360ENDIF
 5370[OPT I%
 5380
 5390
 5400
 5410    LDMIA R13!,{R0-R12,PC}^
 5420
 5430\ -----------
 5440
 5450.swiHandlerPause%             \ Not in this version
 5460
 5470    STMDB R13!,{R0-R12,R14}
 5480]
 5490IF debug% THEN
 5500[OPT I%
 5510    SWI "XOS_WriteS"
 5520    EQUS "Handler pause"+CHR$(0):ALIGN
 5530    SWI "XOS_NewLine"
 5540]
 5550ENDIF
 5560[OPT I%
 5570
 5580
 5590
 5600    LDMIA R13!,{R0-R12,PC}^
 5610
 5620\ -----------
 5630
 5640.swiInstallDriver%  \ Install or make active a driver
 5650                    \ R0 = Pointer to driver table address
 5660                    \      or 1 = Linear
 5670                    \      or 2 = Log
 5680                    \ R1 = parameter to pass driver in R12 when called
 5690                    \ R2 = flags
 5700                    \ R3 = Volume
 5710
 5720    STMDB R13!,{R0-R12,R14}
 5730
 5740]
 5750IF debug% THEN
 5760[OPT I%
 5770    SWI "XOS_WriteS"
 5780    EQUS "Install driver"+CHR$(0):ALIGN
 5790    SWI "XOS_NewLine"
 5800]
 5810ENDIF
 5820[OPT I%
 5830
 5840    \ If R0 = 1 or 2 then Linear or Log
 5850    \ Otherwise regard this as a new driver
 5860
 5870    CMP   R0,#2
 5880    BGT   swiInstallDriverTable%
 5890
 5900    CMP   R0,#1
 5910    BNE   swiInstallDriverLog%
 5920
 5930    BL    installLinearDriver%
 5940
 5950    B     swiInstallDriverExit%
 5960
 5970.swiInstallDriverLog%
 5980
 5990]
 6000IF doLog% THEN
 6010[OPT I%
 6020
 6030    CMP   R0,#2
 6040    BLEQ  installLogDriver%
 6050
 6060]
 6070ENDIF
 6080[OPT I%
 6090
 6100    B     swiInstallDriverExit%
 6110
 6120
 6130.swiInstallDriverTable%
 6140
 6150    BL    installDriver%               \ Simply pass on to this routine
 6160
 6170
 6180.swiInstallDriverExit%
 6190
 6200    LDMIA R13!,{R0-R12,PC}^
 6210
 6220\ -----------
 6230
 6240.swiDriverNumError%
 6250    LDMIA R13!,{R0-R12,R14}
 6260.swiDriverNumError1%
 6270    ADR   R0,DriverNumMesg%
 6280    ORRS  PC,R14,#Overflow_Flag
 6290.DriverNumMesg%
 6300    EQUD  &1E6
 6310    EQUS  "Driver number out of range"
 6320    EQUB  0
 6330    ALIGN
 6340\
 6350
 6360.swiDriverExistError%
 6370    LDMIA R13!,{R0-R12,R14}
 6380.swiDriverExistError1%
 6390    ADR   R0,DriverExistMesg%
 6400    ORRS  PC,R14,#Overflow_Flag
 6410.DriverExistMesg%
 6420    EQUD  &1E6
 6430    EQUS  "Driver not installed"
 6440    EQUB  0
 6450    ALIGN
 6460\
 6470
 6480.swiRemoveDriverError%
 6490    LDMIA R13!,{R0-R12,R14}
 6500    ADR   R0,swiRemoveDriverMesg%
 6510    ORRS  PC,R14,#Overflow_Flag
 6520.swiRemoveDriverMesg%
 6530    EQUD  &1E6
 6540    EQUS  "Cannot remove the default driver"
 6550    EQUB  0
 6560    ALIGN
 6570\
 6580
 6590\ -----------
 6600
 6610.swiRemoveDriver%      \ Remove a driver from the driver table
 6620                       \ On entry:
 6630                       \   R0 = driver number
 6640                       \        cannot remove driver 1 as this is the default driver
 6650
 6660    STMDB R13!,{R0-R12,R14}
 6670
 6680]
 6690IF debug% THEN
 6700[OPT I%
 6710    SWI "XOS_WriteS"
 6720    EQUS "Remove Driver"+CHR$(0):ALIGN
 6730    SWI "XOS_NewLine"
 6740]
 6750ENDIF
 6760[OPT I%
 6770
 6780
 6790    \ First check parameter
 6800
 6810    ADD   R4,R12,#work_driverTable%
 6820    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6830
 6840    CMP   R0,#0                      \ < 0
 6850    BLT   swiDriverNumError%
 6860
 6870    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver
 6880
 6890    CMP   R0,#driverMax%             \ >= max
 6900    BGE   swiDriverNumError%
 6910
 6920    \ Does the driver exist?
 6930
 6940    MOV   R3,#driverTableLen%
 6950    MLA   R6,R3,R0,R4
 6960
 6970    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6980    CMP   R4,#0
 6990    BEQ   swiDriverExistError%         \ If not then exit
 7000
 7010    \ is driver current
 7020
 7030    SUB   R4,R6,R12
 7040    LDR   R0,[R12,#work_currentDriver%]
 7050    CMP   R4,R0
 7060    BNE   swiRemoveDriverNext%
 7070
 7080    \ if it is then release it first
 7090
 7100    BL    releaseDriver%
 7110
 7120    \ and make sure at least the default driver is installed instead
 7130
 7140    MOV   R0,#1              \ Default driver
 7150    BL    swiInstallDriver%
 7160
 7170.swiRemoveDriverNext%
 7180
 7190    \ Now remove the driver entry
 7200
 7210    MOV   R0,#0
 7220    STR   R0,[R6,#driver_Address%]
 7230
 7240    LDMIA R13!,{R0-R12,PC}^
 7250
 7260\ -----------
 7270
 7280.swiDriverInfo%   \ R0 = driver number
 7290                  \ On exit:
 7300                  \ R0 = number of next available driver or 0 for none
 7310                  \ R1 = flags
 7320                  \ R2 = name
 7330                  \ R3 = Volume
 7340                  \ R4 = Overrun count
 7350
 7360    STMDB R13!,{R5-R12,R14}
 7370
 7380]
 7390IF debug% THEN
 7400[OPT I%
 7410    SWI "XOS_WriteS"
 7420    EQUS "Driver info"+CHR$(0):ALIGN
 7430    SWI "XOS_NewLine"
 7440]
 7450ENDIF
 7460[OPT I%
 7470
 7480
 7490
 7500    ADD   R4,R12,#work_driverTable%
 7510    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 7520
 7530    CMP   R0,#0                      \ < 0
 7540    LDMLTIA R13!,{R5-R12,R14}
 7550    BLT   swiDriverNumError1%
 7560
 7570    CMP   R0,#driverMax%             \ >= max
 7580    LDMGEIA R13!,{R5-R12,R14}
 7590    BGE   swiDriverNumError1%
 7600
 7610    \ Does the driver exist?
 7620
 7630    MOV   R3,#driverTableLen%
 7640    MLA   R6,R3,R0,R4
 7650
 7660    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 7670    CMP   R4,#0
 7680    LDMEQIA R13!,{R5-R12,R14}
 7690    BEQ   swiDriverExistError1%         \ If not then exit
 7700
 7710    \ Get driver values
 7720
 7730\    LDR   R1,[R6,#driver_Flags%]
 7740    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
 7750    ADD   R4,R4,R12
 7760    CMP   R4,R6
 7770    MOVEQ R1,#1        \ 1 if current
 7780    MOVNE R1,#0        \ 0 if not
 7790
 7800    ADD   R2,R6,#driver_Name%
 7810    LDR   R3,[R6,#driver_Volume%]
 7820
 7830    \ Now find next driver, if it exists
 7840
 7850.swiDriverInfoLoop%
 7860
 7870    ADD   R0,R0,#1
 7880    CMP   R0,#driverMax%
 7890    MOVEQ R0,#0
 7900    BEQ   swiDriverInfoExit%
 7910
 7920    ADD   R6,R6,#driverTableLen%    \ Try next one
 7930    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
 7940    CMP   R7,#0
 7950    BEQ   swiDriverInfoLoop%        \ No, then try next one
 7960
 7970.swiDriverInfoExit%
 7980
 7990    LDR   R4,[R12,#work_callBack_Count%]
 8000
 8010    LDMIA R13!,{R5-R12,PC}^
 8020
 8030\ -----------
 8040
 8050.swiDriverVolume%            \ Set the volume for a driver
 8060                             \ On entry:
 8070                             \    R0 = driver number
 8080                             \    R1 = new volume
 8090                             \ On exit:
 8100                             \    R0 = current volume
 8110    STMDB R13!,{R1-R12,R14}
 8120
 8130]
 8140IF debug% THEN
 8150[OPT I%
 8160    SWI "XOS_WriteS"
 8170    EQUS "Driver volume"+CHR$(0):ALIGN
 8180    SWI "XOS_NewLine"
 8190]
 8200ENDIF
 8210[OPT I%
 8220
 8230
 8240    ADD   R4,R12,#work_driverTable%
 8250    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8260
 8270    CMP   R0,#0                      \ < 0
 8280    LDMLTIA R13!,{R1-R12,R14}
 8290    BLT   swiDriverNumError1%
 8300
 8310    CMP   R0,#driverMax%             \ >= max
 8320    LDMGEIA R13!,{R1-R12,R14}
 8330    BGE   swiDriverNumError1%
 8340
 8350    \ Does the driver exist?
 8360
 8370    MOV   R3,#driverTableLen%
 8380    MLA   R6,R3,R0,R4
 8390
 8400    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 8410    CMP   R4,#0
 8420    LDMEQIA R13!,{R1-R12,R14}
 8430    BEQ   swiDriverExistError1%         \ If not then exit
 8440
 8450    MOV   R0,R1      \ Volume
 8460    MOV   R1,R6      \ Table address
 8470    BL    driverVolume%                 \ Set driver volume to R0
 8480
 8490    \ Note that when the driver's volume changes, all handler scaled
 8500    \ volumes may need to be reset
 8510
 8520    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
 8530    ADD   R0,R0,R12
 8540    CMP   R0,R6
 8550
 8560    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes
 8570
 8580    LDR   R0,[R6,#driver_Volume%]       \ Return volume
 8590
 8600    LDMIA R13!,{R1-R12,PC}^
 8610
 8620\ ----------------
 8630
 8640.swiDriverMixer%             \ Set or read the mixer for a driver
 8650                             \ On entry:
 8660                             \    R0 = driver number
 8670                             \    R1 = function   0 = read, 1 = set
 8680                             \    R2 = mixer number
 8690                             \    R3 = value if set
 8700                             \ On exit:
 8710                             \    R0 preserved
 8720                             \    R1 = no of mixers
 8730                             \    R2 = value
 8740                             \    R3 = name
 8750
 8760    STMDB R13!,{R0,R4-R12,R14}
 8770
 8780]
 8790IF debug% THEN
 8800[OPT I%
 8810    SWI "XOS_WriteS"
 8820    EQUS "Driver mixer"+CHR$(0):ALIGN
 8830    SWI "XOS_NewLine"
 8840]
 8850ENDIF
 8860[OPT I%
 8870
 8880
 8890
 8900    ADD   R4,R12,#work_driverTable%
 8910    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8920
 8930    CMP   R0,#0                      \ < 0
 8940    LDMLTIA R13!,{R0,R4-R12,R14}
 8950    BLT   swiDriverNumError1%
 8960
 8970    CMP   R0,#driverMax%             \ >= max
 8980    LDMGEIA R13!,{R0,R4-R12,R14}
 8990    BGE   swiDriverNumError1%
 9000
 9010    \ Does the driver exist?
 9020
 9030    MOV   R3,#driverTableLen%
 9040    MLA   R6,R3,R0,R4
 9050
 9060    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 9070    CMP   R4,#0
 9080    LDMEQIA R13!,{R1-R12,R14}
 9090    BEQ   swiDriverExistError1%         \ If not then exit
 9100
 9110    MOV   R0,R1         \ Function code
 9120    MOV   R1,R2         \ Mixer number
 9130    MOV   R2,R3         \ Value
 9140    MOV   R3,R6         \ Driver table pointer
 9150
 9160    BL    driverMixer%
 9170
 9180
 9190    LDMIA R13!,{R0,R4-R12,PC}^
 9200]
 9210ENDPROC
@
